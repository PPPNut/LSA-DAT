return [ globalpath ] + list ( settings . LOCALE PATHS )
return False
self . cache [ key ] = pickled
all = [ STR_ ]
else :
def init ( self , subject ) :
def get ( self , key , default = None , version = None ) :
if self . can delete and self . should delete form ( form ) :
from . html parser import HTMLParser , HTMLParseError
else :
def base set ( self , mode , key , value , timeout = DEFAULT TIMEOUT ) :
return False
if retval :
import os
class InvalidPage ( Exception ) :
from django . core . mail . utils import CachedDnsName , DNS NAME
else :
from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning
if p >= NUM_ :
value = datetime safe . new date ( value )
has bz2 = True
memo = { }
block context . push ( self . name , push )
yield d
abspathu = abspath
raise ValueError ( " STR_ " " STR_ " % klass . name )
return self . cast ( ) == other
result = super ( DateTimeField , self ) . to python ( value )
def all locale paths ( ) :
return metaclass ( cls . name , cls . bases , or ig vars )
yield parse boundary stream ( sub stream , NUM_ )
pass
context . render context . push ( )
pass
if default is None :
elif t . token type == TOKEN VAR :
def get supported language variant ( lang code , strict = False ) :
def resolve context ( self , context ) :
want unicode = True
doy = self . year days [ self . data . month ] + self . data . day
if locales :
continue
if STR_ in cc :
guessed filename += ext
self . add local translations ( )
in t part gd =
if self . verbosity > NUM_ :
if not var or in var :
try :
if cache choices is not None :
if is relation :
try :
sys . stderr = open ( err log , STR_ , buffering )
class Choice ( list ) :
@ register . tag
choice input class = None
field notes = [ ]
t = s . split ( = , NUM_ )
elif template tuple is None :
try :
return in t ( str ( value ) [ - arg ] )
if default is not RAISE ERROR :
if answer ! = " STR_ " :
else :
result = super ( ChoiceField , self ) . deepcopy ( memo )
httpd = httpd cls ( server address , WSGIRequestHandler , ipv6 = ipv6 )
result = self . configurator . convert ( value )
for ch , escaped in in put iter :
if in valid apps :
pass
else :
func code = " STR_ "
data = method ( self , * args , ** kwargs )
if var . endswith ( STR_ ) :
def add local translations ( self ) :
finally :
elif not base url . endswith ( / ) :
code list . append ( foreground [ v ] )
def ipython pre 100 ( self ) :
def newobj ( cls , * args ) :
obj dict [ STR_ ] = dict ( ( k , self . getlist ( k ) ) for k in self )
@ property
self . reason phrase = reason
for obj in queryset . iterator ( ) :
pad = b = * ( - len ( s ) % NUM_ )
def deepcopy ( self , memo ) :
class Input ( Widget ) :
def receive data chunk ( self , raw data , start ) :
except ( LookupError , TypeError ) :
content length = NUM_
from future import unicode literals
@ property
known models = [ ]
except KeyError :
class FileField ( Field ) :
def has previous ( self ) :
arg vals . append ( mark safe ( arg ) )
key = self . make key ( key , version = version )
self . stdout . write ( " STR_ " % plural form line )
import tempfile
return cached
elif action == " STR_ " :
def init ( self , data = None , files = None , auto id = STR_ , prefix = None , in itial = None , error class = ErrorList ) :
for key in c . keys ( ) :
if not found and ( not line or plural forms re . search ( line ) ) :
self . items = [ ]
if value in ( None , ) :
msg = " STR_ " % ( self . log date time string ( ) , format % args )
return NUM_
if self . to field :
if self . feed [ STR_ ] is not None :
, rest = token . contents . split ( None , NUM_ )
from django . db import connections , DEFAULT DB ALIAS
def init ( self , data = None , files = None , auto id = STR_ , prefix = None , queryset = None , ** kwargs ) :
except IndexError :
message = error . message
self . body = body
self . start serialization ( )
def reload ( self ) :
ne = new method proxy ( operator . ne )
try :
for key in self . bad cookies :
status code = NUM_
@ encoding . setter
@ register . tag ( STR_ )
def getstate ( self ) :
def write ( self , content ) :
value , converted = convert old style list ( value )
output = [ ]
result = super ( ChoiceField , self ) . deepcopy ( memo )
for loader name in settings . TEMPLATE LOADERS :
exclude = self . get validation exclusions ( )
lookup view s = lookup view
class Command ( BaseCommand ) :
self . fields = fields
import re
for line in self . handle inspection ( options ) :
return list ( self . itervalues ( ) )
return list ( urlsplit ( url ) )
tables = connection . in trospection . table names ( )
if number < NUM_ :
return default
signal . signal ( signal . SIGTTOU , old handler )
nodelist = self . create nodelist ( )
class Operator ( TokenBase ) :
global supported
default validators = [ validators . URLValidator ( ) ]
except ImportError :
elif args [ NUM_ ] [ NUM_ ] == STR_ :
elif not is in stance ( end , str ) :
return STR_ % ( self . prefix , in dex )
self . attrs = attrs
self . client = self . lib . Client ( self . servers , pickleProtocol = pickle . HIGHEST PROTOCOL )
self . namespace = namespace
self . bcc = [ ]
if STR_ in hextets [ - NUM_ ] :
return None
if is in stance ( regex , six . string types ) :
widget . in put type = STR_
load template source . is usable = True
for tok in rules :
return data . get ( name , None )
def get ( self , obj , tp ) :
raise TemplateSyntaxError ( " STR_ " % name )
super ( RegexField , self ) . init ( max length , min length , * args , ** kwargs )
if is in stance ( widget , type ) :
class CharField ( Field ) :
data value = field . widget . value from datadict ( self . data , self . files , prefixed name )
if self . feed [ STR_ ] is not None :
return f
import socket
self . widget . choices = self . choices
return ( copyreg . reconstructor , ( self . class , object , None ) , self . getstate ( ) )
child nodelists = ( STR_ , )
if self . pk field == self . fk :
version = get complete version ( version )
self . app name = app name
if constant time compare ( sig , self . signature ( value ) ) :
else :
filterer . addFilter ( self . config [ STR_ ] [ f ] )
return
class TemporaryUploadedFile ( UploadedFile ) :
def appendlist ( self , key , value ) :
def F ( i ) :
filters = config . get ( STR_ , EMPTY DICT )
return args , kwargs
for path in data :
self . queryset = field . queryset
prefixed = name + " STR_ "
try :
while i < len ( subject ) and subject [ i ] not in ( , STR_ ) :
import os
return command . execute ( * args , ** defaults )
return
from django . utils . os import npath , upath
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
file size = data . size
self . regexes [ state ] = re . compile ( " | " . join ( parts ) , re . MULTILINE | re . VERBOSE )
from django . utils . encoding import force bytes
value = map ( force text , value )
raise CommandError ( " STR_ " % errors )
return value
self . file . seek ( pos )
output . append ( " STR_ " % ( key , user settings [ key ] ) )
translation . activate ( settings . LANGUAGE CODE )
defaults [ STR_ ] = self . files
class RssUserland091Feed ( RssFeed ) :
return self
return created models
def format ( value , format string ) :
import os
def ungettext ( singular , plural , number ) :
break
parser . add argument ( STR_ , help = STR_ )
buffer types = ( bytes , bytearray , memoryview )
if value :
if cc :
raise ValueError ( STR_ )
pass
s = s . replace ( STR_ , STR_ )
Module six moves urllib request . moved attributes = urllib request moved attributes
def tell ( self ) :
result = datetime . datetime . combine ( * data list )
def dictvalue ( t ) :
try :
if not old style list :
else :
finally :
domain = domain . encode ( STR_ ) . decode ( STR_ )
url fields [ NUM_ ] =
except StopFutureHandlers :
def init ( self , fields = ( ) , * args , ** kwargs ) :
if settings . TEMPLATE DEBUG and display name :
comment = [ ]
return errors
self . validate key ( key )
self . content type = content type
@ register . tag
self . data = data or { }
try :
pk value = form . in stance . pk
try :
self . servers = server
def add ( self , other ) :
def gettext ( message ) :
file = open ( file or path , STR_ )
from django . core . management . base import BaseCommand
encoding = self . encoding
class DummyCache ( BaseCache ) :
from django . db . migrations . questioner import MigrationQuestioner , InteractiveMigrationQuestioner
return True
from django . core . urlresolvers import reverse , NoReverseMatch
from django . utils . translation import ungettext , ugettext as
klass . str = lambda self : self . unicode ( ) . encode ( STR_ )
def set ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
if extend is True :
super ( BaseModelFormSet , self ) . add fields ( form , in dex )
else :
if calendar . is leap ( self . data . year ) :
def hidden fields ( self ) :
if self . lookups is not None :
base lang = get language ( ) . split ( - ) [ NUM_ ]
sent = self . send ( message )
elif char in STR_ :
if not cached filenames and settings . USE I18N :
s = six . text type ( s )
if self . data . hour == NUM_ :
pass
exts = extensions if extensions else [ STR_ , STR_ ]
words = allow lazy ( words )
def N ( self ) :
yield meta line
defaults . update ( kwargs )
from django . utils . deprecation import RemovedInDjango20Warning
doublecolon start = in dex
self . current app = current app
elif args [ - NUM_ ] == " as " :
def set response etag ( response ) :
writer = MigrationWriter ( new migration )
return self . as widget ( self . field . hidden widget ( ) , attrs , ** kwargs )
return self . coerce ( value )
if script url :
if hasattr ( self , STR_ ) :
if cmd . endswith ( ext ) :
if self . cleaned data . get ( name ) is not None and self . cleaned data [ name ] . state . adding :
if failures :
space = line . find ( ) + NUM_
sub =
return CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
WSGIServer ( get internal wsgi application ( ) , ** wsgi opts ) . run ( )
field type = " STR_ " % rel to
def capfirst ( value ) :
ser fmts = serializers . get public serializer formats ( ) if ser fmt is None else [ ser fmt ]
return STR_ if os . environ . get ( " STR_ " ) == " STR_ " else STR_
dispatch = None
self . attrs = attrs
self . handle file complete ( old field name , counters )
try :
def render ( self , context ) :
def configure root ( self , config , in cremental = False ) :
except MultiPartParserError :
elif basetype == STR_ and subtype == STR_ :
break
year val = month val = day val = None
if len ( bits ) not in ( NUM_ , NUM_ ) :
from django . core . files import locks
if sys . version info [ : NUM_ ] >= ( NUM_ , NUM_ ) :
def ne ( self , other ) :
return super ( DateField , self ) . to python ( value )
return re newlines . sub ( STR_ , text )
tok = STR_ + guts + STR_
return commands
from django . utils . module loading import import string
if is in stance ( value , Field ) :
import functools
if representative is None :
return s
m = dict ( zip ( new keys , keys ) )
return False
decorated = Node ( syms . decorated , [ decorator , klass ] , prefix = node . prefix )
self . literal = float ( var )
if m :
table names = [ ]
quant = quant [ : - NUM_ ]
else :
try :
return [ STR_ , STR_ , STR_ , STR_ , STR_ ]
migration = executor . loader . get migration by prefix ( app label , migration name )
return default
if STR_ not in ip str :
else :
print ( . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) )
def model to dict ( in stance , fields = None , exclude = None ) :
try :
def len ( self ) :
def extract ( self , filename ) :
return mark safe ( re . sub ( STR_ , - , value ) )
def do include ( parser , token ) :
continue
super ( QueryDict , self ) . clear ( )
if is in stance ( server , six . string types ) :
self . count = self . object list . count ( )
return key func
if hasattr ( get git changeset , STR_ ) :
subject = self . subject
except TemplateSyntaxError as e :
def init ( self , iterable = None ) :
for model in sort dependencies ( app list . items ( ) ) :
if slots is not None :
sorted items = sorted ( kwds . items ( ) )
from django . utils . functional import cached property
class EmailMessage ( object ) :
singular . append ( contents )
timestamp = datetime . datetime . now ( ) . strftime ( " STR_ " )
def add arguments ( self , parser ) :
import warnings
self . value = value
name = args [ NUM_ ]
slots = or ig vars . get ( STR_ )
tzinfo = get fixed timezone ( offset )
exc info = record . exc info
accept language re = re . compile ( r STR_ , re . VERBOSE )
@ python 2 unicode compatible
MAX NUM FORM COUNT = STR_
def bytes cast ( self ) :
except TypeError as te :
def nud ( self , parser ) :
except ValueError :
else :
def make list ( value ) :
return timeuntil ( value , arg )
if fg in color names :
import gettext
if text . endswith ( truncate ) :
in itial = [ ]
import posixpath
self . connection reset = connection reset
except Exception as e :
if s == STR_ :
if item [ STR_ ] is not None :
def prepare value ( self , value ) :
except AttributeError :
if format module path :
output . append ( error row % force text ( bf errors ) )
autoescape = autoescape and not is in stance ( value , SafeData )
else :
except KeyError :
pass
raise
if is in stance ( nodelist , NodeList ) and not is in stance ( node , TextNode ) :
if exclude is not None :
pass
self . load initial data = options . get ( STR_ )
wrapped main func = check errors ( main func )
qs = queryset . none ( )
for item in self . items :
if errors :
if is ignored ( os . path . normpath ( os . path . join ( dirpath , dirname ) ) , norm patterns ) :
continue
if self . sep not in signed value :
try :
self . year none value = self . none value
for line in chunk buffer :
self . in dex = in dex
try :
else :
data = { }
if expires is not None :
return name , ( value , params )
if is library missing ( taglib module ) :
exc type = type ( exc )
self . clean fields ( )
processors = ( )
self . stdout . write ( self . style . NOTICE ( " STR_ " ) )
self . called from command line = True
compare = lambda self , a , b : a > b
class WidthRatioNode ( Node ) :
@ python 2 unicode compatible
widget = SplitDateTimeWidget
kwargs [ " STR_ " ] = False
self . xml . characters ( smart text ( related att ) )
handler . addQuickElement ( " STR_ " , " " , { " STR_ " : item [ STR_ ] , " STR_ " : " STR_ " } )
def len ( self ) :
return type ( self ) . bool ( self )
stream . unget ( chunk [ next : ] )
class Command ( AppCommand ) :
self . plural = lambda n : in t ( n ! = NUM_ )
safe data [ key ] = value
return result , result args
@ register . filter ( is safe = True , needs autoescape = True )
for candidate in glob . iglob ( os . path . join ( fixture dir , fixture name + * ) ) :
return wrapped
foreground = dict ( ( color names [ x ] , STR_ % x ) for x in range ( NUM_ ) )
return super ( PasswordInput , self ) . render ( name , value , attrs )
for k , v in defaults . items ( ) :
raise NotImplementedError ( STR_ )
six . reraise ( ValidationError , ValidationError ( message , code = STR_ , params = params , ) , sys . exc info ( ) [ NUM_ ] )
attrs = dict ( self . attrs , ** kwargs )
self . post parse error = False
self . msgmerge options = self . msgmerge options [ : ] + [ STR_ ]
if len ( bits ) ! = NUM_ :
def dumps ( obj , key = None , salt = STR_ , serializer = JSONSerializer , compress = False ) :
if self . empty permitted and not self . has changed ( ) :
from itertools import groupby , cycle as itertools cycle
pass
result = ungettext ( singular , plural , number )
def setstate ( self , obj dict ) :
yield " STR_ "
if data is None :
header end = chunk . find ( b STR_ )
context extras = { }
def render ( self , context ) :
if not re . search ( r STR_ , name ) :
import mimetypes
else :
from django . utils . http import urlquote
self . doc = self . class . doc
regex =
if is in stance ( error , ValidationError ) :
return value
out . write ( STR_ % fmatch )
class Template ( object ) :
return None
return time . tzname [ is dst ]
f . error messages . setdefault ( STR_ , self . error messages [ STR_ ] )
request = self . request class ( environ )
VARIABLE TAG END = STR_
if timeout is None :
if is in stance ( value , datetime . datetime ) :
from django . core . exceptions import ImproperlyConfigured
return directories , files
result = factory ( ** kwargs )
return getattr ( t , translation function ) ( singular , plural , number )
def close ( self ) :
raise TemplateSyntaxError ( " STR_ " )
else :
return self . filters [ filter name ]
matches = True
result . key = key
self . fetch command ( subcommand ) . run from argv ( self . argv )
result = logging . Filter ( name )
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
def truncatechars ( value , arg ) :
if f . primary key :
if self . cdata tag is not None :
if e . errno ! = errno . ENOENT :
if not settings . is overridden ( STR_ ) :
def clean ( self , value ) :
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
def discard ( self , item ) :
return sys . modules [ name ]
def render ( self , context ) :
return or d ( buf [ i ] )
def init ( self , val expr , max expr , max width , asvar = None ) :
in comment = True
for p in parts [ NUM_ : ] :
is accept language redundant = settings . USE I18N or settings . USE L10N
context = self . resolve context ( self . context data )
def delete ( self , fname ) :
raise ValueError ( " STR_ " " STR_ " % ( middleware method . self . class . name ) )
def add fields ( self , form , in dex ) :
exclude = [ ]
else :
self . validate key ( key )
def add ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
name = p [ : i ] . strip ( ) . lower ( ) . decode ( STR_ )
else :
result = self . configurator . convert ( value )
self . path = STR_ % ( script name . rstrip ( / ) , path info . replace ( / , , NUM_ ) )
if self . is localized :
try :
self . encoding = charset
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc info ( ) [ NUM_ ] )
self . validate unique ( )
if not value or STR_ not in value :
with lock :
out . write ( blankout ( t . contents , STR_ ) )
def from dict ( cls , file dict ) :
raise NotImplementedError ( STR_ )
def connection ( self ) :
def Y ( self ) :
new args = [ ]
relative dir = path rest . replace ( base name , name )
return STR_ % ( ( STR_ % STR_ . join ( code list ) ) , text or )
def nonzero ( self ) :
from django . utils . encoding import force text
if filename . endswith ( " STR_ " ) :
key = self . make key ( key , version = version )
return self . reverse with prefix ( lookup view , , * args , ** kwargs )
exts = extensions if extensions else [ STR_ ]
def write migration files ( self , changes ) :
parser . add argument ( STR_ , metavar = STR_ , nargs = * , help = STR_ )
from django . core . handlers import base
self . verbosity = options [ STR_ ]
prefix length = len ( template dir ) + NUM_
self . to = [ ]
column name = row [ NUM_ ]
if errors on separate row and bf errors :
nodelist true output = None
name = self . split leading dir ( name ) [ NUM_ ]
if self . loaded object count > NUM_ :
name , value = match . groups ( )
raise TemplateSyntaxError ( " STR_ " % ( bits [ NUM_ ] , remaining bits [ NUM_ ] ) )
self . host = host or settings . EMAIL HOST
warnings . warn ( STR_ , RemovedInDjango19Warning )
raise
if is in stance ( s , ( six . text type , Promise ) ) :
self . blocks [ name ] . in sert ( NUM_ , block )
from django . core . exceptions import ValidationError
def itervalues ( self ) :
return base
return value
return self . choices
raise NotImplementedError ( STR_ )
from django . core . serializers . base import DeserializationError
if quote double quotes :
raise NotImplementedError ( STR_ )
MIMEMultipart . init ( self , subtype , boundary , subparts , ** params )
return False
exp = pickle . load ( f )
self . xml . characters ( field . value to string ( obj ) )
return in t ( timeout )
return [ ]
except ( ValueError , KeyError ) :
digits . append ( STR_ )
import socket
randint = random . randrange ( NUM_ )
except MiddlewareNotUsed :
six . reraise ( ValidationError , ValidationError ( self . error messages [ STR_ ] , code = STR_ , ) , sys . exc info ( ) [ NUM_ ] )
self . queryset = queryset
if finder . find module ( name , package path ) :
self . app label = options . get ( STR_ )
lineno = lineno + self . starttag text . count ( " STR_ " )
self . stderr = OutputWrapper ( options . get ( STR_ , sys . stderr ) , self . style . ERROR )
expanded template = path . expanduser ( template )
if args :
def entity decl ( self , name , is parameter entity , value , base , sysid , pubid , not ation name ) :
queryset = objects . using ( using ) . or der by ( model . meta . pk . name )
else :
self . handle startendtag ( tag , attrs )
for item type , meta data , field stream in Parser ( stream , self . boundary ) :
else :
else :
pass
raise ValueError ( " STR_ " % ( callback . module , view name ) )
lbp = bp
except ValueError :
if end is None :
def has key ( self , key , version = None ) :
return value
validate email = EmailValidator ( )
def BaseCookie set ( self , key , real value , coded value ) :
if i >= len ( subject ) :
self . out . write ( force str ( style func ( msg ) ) )
exc info = ( None , record . getMessage ( ) , None )
if best doublecolon start == NUM_ :
templatetags modules candidates = [ STR_ ]
def size ( self , name ) :
continue
def init ( self , dirpath , file name , locale dir ) :
else :
return errors
return { STR_ : request }
return LoadNode ( )
list = super ( MultiValueDict , self ) . getitem ( key )
if value is not result :
offset = date . tzinfo . utcoffset ( date )
else :
defaults = dict ( defaults . dict , ** options )
self . validate key ( key )
if leading :
return True
obj = super ( MultiWidget , self ) . deepcopy ( memo )
self . check test = boolean check if check test is None else check test
getLogger = logging . getLogger
except Exception :
return self . choice input class ( self . name , self . value , self . attrs . copy ( ) , choice , idx )
itervalues = itervalues
except KeyError :
templatetags modules = get templatetags modules ( )
resolved args = [ var . resolve ( context ) for var in self . args ]
@ receiver ( setting changed )
return s
self . tags [ getattr ( func , " STR_ " , func ) . name ] = func
else :
ADDRESS HEADERS = set ( [ from , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , ] )
app dirs . append ( old app dir )
if is in stance ( query string , bytes ) :
if self . data . minute == NUM_ and self . data . hour == NUM_ :
if self . options . get ( STR_ ) :
return output
self . set ( key , pickled , timeout )
else :
in puts . append ( format html ( STR_ , flatatt ( in put attrs ) ) )
sys . exit ( NUM_ )
def reset ( self ) :
def patch cache control ( response , ** kwargs ) :
def filter ( self , name = None , filter func = None , ** flags ) :
return obj
class Lexer ( object ) :
del attrs [ attr ]
return
in ner text . append ( child . data )
raise TemplateSyntaxError ( " STR_ " % ( name , taglib ) )
getattr ( self , STR_ + name ) ( media attrs . get ( name , None ) )
else :
self . widget . choices = self . choices
else :
if is in stance ( source , Group ) :
return STR_ % ( self . connector , STR_ . join ( [ str ( c ) for c in self . children ] ) )
for node in self . nodelist empty :
if self . isdst ( dt ) :
if self . can delete :
if message is not None :
self . characters ( contents )
related = getattr ( obj , field . name )
if os . path . exists ( pofile ) :
timeout = in t ( timeout )
app label = label
self . msg = msg
return [ to py ( val ) for val in value ]
def as json ( self , escape html = False ) :
dklen = hlen
from django . utils . text import get valid filename
output . append ( str hidden )
password = force bytes ( password )
in stance = super ( SortedDict , cls ) . new ( cls , * args , ** kwargs )
parser . add argument ( STR_ , STR_ , default = [ ] , dest = STR_ , action = STR_ , help = STR_ )
if not getattr ( self , STR_ , False ) :
except AttributeError :
parent name = parser . compile filter ( bits [ NUM_ ] )
return self . empty form . is multipart ( )
if contents is not None :
return kwargs
return t
def make msgid ( idstring = None ) :
raise DisallowedRedirect ( " STR_ " % parsed . scheme )
if len ( val1 ) ! = len ( val2 ) :
def c ( self ) :
if hasattr ( test runner class , STR_ ) :
import warnings
return mark safe ( STR_ . join ( chain ( * [ getattr ( self , STR_ + name ) ( ) for name in MEDIA TYPES ] ) ) )
if getattr ( obj , field . name ) is not None :
s = s [ NUM_ : ]
return num sent
self . js . append ( path )
except Exception as e :
format = force str ( default or get format ( STR_ ) [ NUM_ ] )
else :
return not settings . DEBUG
from django . utils . encoding import force text
return new value
select html = s . render ( field % name , val , local attrs )
try :
if not hasattr ( e , STR_ ) :
if change == FILE MODIFIED :
import os
@ register . filter ( " STR_ " )
class DjangoTranslation ( gettext module . GNUTranslations ) :
if ( attr in ( " STR_ " , " STR_ " , " STR_ " ) and self . mod not in sys . modules ) :
from django . core . management . color import no style
if hasattr ( os , STR_ ) :
codecs . lookup ( encoding )
default error messages = { STR_ : ( STR_ ) , STR_ : ( STR_ ) , }
res , args = flatten result ( item )
if not self . compile filter error ( token , e ) :
if self . max value is not None :
continue
del self . dicts [ - NUM_ ] [ key ]
args = [ ]
return re . sub ( r STR_ , , s )
nodelist = parser . parse ( ( STR_ , ) )
os . mkdir ( target dir )
else :
def delete ( self , key , version = None ) :
args = [ arg . resolve ( context ) for arg in self . args ]
def delete many ( self , keys , version = None ) :
return self . value . resolve ( context , ignore failures = True )
if name not in data :
from django . utils . translation import ugettext lazy as
return self . renderer ( name , value , final attrs , choices )
return candidate pat % candidate subs
raise StopIteration ( )
try :
dig2 . update ( dig1 . digest ( ) )
raise ValueError ( " STR_ " % value )
datetime re = re . compile ( r STR_ r STR_ r STR_ r STR_ )
self . delete ( k )
self . remove ( item )
raise ViewDoesNotExist ( " STR_ " % ( lookup view , mod name ) )
template dirs = settings . TEMPLATE DIRS
for key , value in data :
import re
def clean ( self , value ) :
node = CycleNode ( values , name , silent = silent )
if not self . timezone :
self . encoding = encoding
return default
block context . add blocks ( blocks )
trim whitespace re = re . compile ( STR_ )
errors = " STR_ "
chunk = b . join ( chunks )
return getattr ( module , class name )
from django . utils . deprecation import RemovedInDjango19Warning
import termios
self . file . seek ( NUM_ )
raise ViewDoesNotExist ( " STR_ " % ( mod name , func name ) )
def base36 to int ( s ) :
return self . serialize headers ( ) + b STR_ + self . content
return self . value
import time as time
hard coded bullets re = re . compile ( r STR_ % | . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
try :
try :
def init ( self , token , parser ) :
self . validators = self . default validators + validators
field params [ STR_ ] = row [ NUM_ ] if row [ NUM_ ] is not None else NUM_
global default
if not etags :
obj pk = obj . get pk val ( )
now = datetime . now ( ) . strftime ( STR_ )
def end object ( self , obj ) :
globs = frame . f globals
return name + STR_
raise StopIteration ( )
idstring = STR_ + idstring
message = ungettext lazy ( STR_ , STR_ , STR_ )
return ( source , make origin ( display name , loader , name , dirs ) )
from django . core . mail . backends . base import BaseEmailBackend
from future import unicode literals
def new ( cls , * args , ** kwargs ) :
in itial forms = len ( self . in itial ) if self . in itial else NUM_
try :
def init ( self , * args , ** kwargs ) :
if fset is not None :
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
get valid filename = allow lazy ( get valid filename , six . text type )
from django . utils . http import http date
return
in put val = force text ( text )
comment lineno cache = None
else :
else :
def clear ( self ) :
self . fields = fields
if record . exc info :
def iter ( self ) :
if settings . USE THOUSAND SEPARATOR :
if parse until is None :
if ( hasattr ( self . cmd , STR_ ) and not ( args or any ( [ not arg . startswith ( - ) for arg in args ] ) ) ) :
field value = [ getInnerText ( k ) . strip ( ) for k in keys ]
def setup ( self ) :
def getstate ( self ) :
settings . INSTALLED APPS
hextets = ip str . split ( " STR_ " )
def lt ( self , other ) :
data = data or [ ]
for item in self . items :
msg += ending
def file move safe ( old file name , new file name , chunk size = NUM_ * NUM_ , allow overwrite = False ) :
else :
def attach alternative ( self , content , mimetype ) :
import time
self . xml . endElement ( " STR_ " )
if not len ( empty label ) == NUM_ :
expiry = self . get backend timeout ( timeout )
filename = traceback . extract tb ( tb ) [ - NUM_ ] [ NUM_ ]
return { }
allow multiple selected = False
if not hasattr ( self , STR_ ) :
if name in existing :
not ifier . stop ( )
fill to = NUM_
if sys . platform . startswith ( STR_ ) :
if template dirs :
self . base fields [ INITIAL FORM COUNT ] = IntegerField ( widget = HiddenInput )
self . stdout . write ( " STR_ " % operation . describe ( ) )
k = m . end ( )
def date ( value , arg = None ) :
from django . core . management import call command
self . connection . ehlo ( )
return super ( Error , self ) . init ( ERROR , * args , ** kwargs )
self . verbose name = STR_
raise CommandError ( " STR_ " )
item date = item . get ( date key )
elif bytes < GB :
g = imatch . group ( NUM_ )
in put type = STR_
return self . in cr version ( key , - delta , version )
self . mutable = mutable
super ( ErrorList , self ) . init ( in itlist )
return self . deepcopy ( { } )
module = type ( STR_ , ( object , ) , { STR_ : bad serializer , STR_ : bad serializer , } )
contents = one percent re . sub ( STR_ , t . contents )
return value
SINGLE BRACE END = STR_
sub ul renderer . choice input class = self . choice input class
if filter name in self . filters :
self . length = length
if path . is dir ( expanded template ) :
self . file . close ( )
class Token ( object ) :
settings . INSTALLED APPS
if converter :
return slugify ( value )
pass
value = force text ( value )
from django . utils . text import get text list , capfirst
self . clean ( )
idhost = DNS NAME
self . subject = subject
final output . append ( STR_ )
for path in self . locale paths :
class classonlymethod ( classmethod ) :
else :
handlers [ name ] = handler
return formatted subject [ : NUM_ ]
args = token . contents . split ( )
return self . choices
params , varargs , varkw , defaults = getargspec ( func )
del moves . dict [ name ]
return modules
target var = bits [ - NUM_ ]
if not self . compile function error ( token , e ) :
return NodeList ( node for , nodelist in self . conditions nodelists for node in nodelist )
if hasattr ( test runner class , STR_ ) :
name str = " STR_ " . join ( " STR_ " % ( " STR_ " . join ( names ) , app ) for app , names in conflicts . items ( ) )
i = i + NUM_
os . close ( fd )
def lazy proxy unpickle ( func , args , kwargs , * resultclasses ) :
try :
in ner , outer = digest ( ) , digest ( )
def signature ( self , value ) :
return from current timezone ( result )
self . request middleware = request middleware
encoding = self . encoding or settings . DEFAULT CHARSET
if not commit :
return [ self . forms [ i ] for i in self . deleted form indexes ]
if self . wrapped is empty :
buf = StreamingBuffer ( )
return is library missing ( path )
is localized = False
class LocalTimezone ( tzinfo ) :
else :
else :
os . makedirs ( filename )
return None
result = self . class ( , mutable = True , encoding = self . encoding )
else :
else :
if match :
import importlib
return RegexURLResolver ( r STR_ , [ ns resolver ] )
else :
raise
seen data = set ( )
import warnings
for k , v in self . choices :
script name = script url [ : - len ( path info ) ]
def humanize ( dirname ) :
from django . utils . os import rmtree errorhandler
self . lasttag = tag = match . group ( NUM_ ) . lower ( )
def message ( self ) :
self . unlink ( self . name )
raise TypeError ( " STR_ " )
try :
class CycleNode ( Node ) :
return data
return b . join ( [ force bytes ( arg , encoding , strings only , errors ) for arg in s ] )
if ch ! = STR_ or escaped :
pytz = None
return result
def add prefix ( self , prefix ) :
name = getattr ( file , STR_ , None )
def init ( self , name , params ) :
for handler in handlers :
except ( ValueError , TypeError ) :
from django . core . management . sql import sql indexes
read = property ( lambda self : self . file . read )
return timesince ( value )
self . in dent ( NUM_ )
from django . core . exceptions import ImproperlyConfigured
self . locale paths . extend ( list ( settings . LOCALE PATHS ) )
attrs = flatatt ( attrs ) if attrs else
singular = [ ]
raise ValueError ( " STR_ " )
hhmm = STR_ % divmod ( abs ( offset ) , NUM_ )
self . negated = not self . negated
continue
def value from datadict ( self , data , files , name ) :
def init ( self , tokens ) :
if item [ STR_ ] is not None :
except LookupError :
def pop ( self , key , default = None ) :
super ( ComboField , self ) . init ( * args , ** kwargs )
values = self . sequence . resolve ( context , True )
elif name is not None and filter func is None :
from os . path import join , normcase , normpath , abspath , is abs , sep , dirname
def cycle ( parser , token ) :
def b ( s ) :
return self . offset ,
else :
self . password = settings . EMAIL HOST PASSWORD if password is None else password
else :
if not callable ( or iginal lookup ) and callable ( lookup view ) :
os . close ( fd )
for widget in self . widgets :
except ImportError :
else :
else :
if m is not None :
from django . utils import translation
return urljoin ( prefix , path )
child nodelists = ( STR_ , STR_ )
klass = self . resolve ( config . pop ( class ) )
if m is None :
message = STR_
self . assert mutable ( )
else :
return
key += item
from django . core . files import locks , File
self . options = params . get ( STR_ , None )
@ register . filter ( is safe = True )
from importlib import import module
return
current fields = [ ]
return html
for arg in args :
while RUN RELOADER :
for digit in str ( number ) :
self . choices = self . widget . choices = list ( value )
try :
@ property
return result
if self . verbosity >= NUM_ :
def empty form ( self ) :
yield self . read ( )
class DisallowedRedirect ( SuspiciousOperation ) :
e = TemplateSyntaxError ( msg )
self . validators . append ( self . regex validator )
return lang code
result [ i ] += piece
templatetags modules = [ ]
except ValueError :
def reset translations ( ) :
duplicate = copy ( super ( BaseContext , self ) )
utcdate = time . strftime ( STR_ , time . gmtime ( timeval ) )
norm patterns = [ p [ : - len ( dir suffix ) ] if p . endswith ( dir suffix ) else p for p in self . ignore patterns ]
self . context . pop ( )
def get mod func ( callback ) :
self . errors [ field ] = self . error class ( )
class FileUploadHandler ( object ) :
parser . add argument ( STR_ , STR_ , default = None , dest = STR_ , help = STR_ )
if exclude and f . name in exclude :
if language code not in self . regex dict :
from datetime import date as real date , datetime as real datetime
def init ( self , flo , chunk size = NUM_ * NUM_ ) :
from django . utils import six
if not changed :
from django . core . files . uploadhandler import StopUpload , SkipFile , StopFutureHandlers
unpack = num loopvars > NUM_
num args += NUM_
return [ mark safe ( force text ( obj ) ) for obj in value ]
from django . db import models
min num = DEFAULT MIN NUM
elif self . meta . fields and field not in self . meta . fields :
default validators = [ ]
@ property
return STR_ % self . add prefix ( field name )
from django . utils import timezone
def recipients ( self ) :
return Template ( source , or igin , name )
if value is not None :
with transaction . atomic ( using = self . using ) :
from django . core import signals
from django . core . management import call command
else :
if serializers is None :
raise ValueError ( STR_ )
errors . extend ( e . error list )
if hasattr ( value , STR_ ) :
self . stdout . write ( " STR_ " )
class DTDForbidden ( DefusedXmlException ) :
self . changed data . append ( name )
try :
from django . db . migrations . autodetector import MigrationAutodetector
parentloop = context [ STR_ ]
def init ( self , dt ) :
except AttributeError :
in plural = False
import sys
body msg = msg
if locations :
def normalize newlines ( text ) :
if not self . is rendered :
for part in plural :
from django . core . mail import get connection
self . empty variable ( token )
pass
out . write ( STR_ % ( message context , g ) )
end = in dex
val = Header ( val , encoding ) . encode ( )
idx = m . groups ( ) [ NUM_ ]
if is aware ( value ) :
def tzname ( self , dt ) :
return False
return { STR_ : get val ( ) }
return bits [ NUM_ ] ,
try :
def pprint ( value ) :
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " ) )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
model = None
from django . utils . text import get text list
for f in self . in stance . meta . fields :
if not m :
consume next = False
if not self . dry run :
d = Decimal ( force text ( float ( text ) ) )
else :
args [ NUM_ ] = force text ( args [ NUM_ ] )
requires system checks = False
headerlist = cache . get ( cache key , None )
else :
else :
elif is subclass ( klass , logging . handlers . SMTPHandler ) and STR_ in config :
def dst ( self , dt ) :
vary headers = [ ]
handler . endElement ( " STR_ " )
f . process ( self , self . domain )
return trans . get language from path ( path )
if app list value is not None :
rendering attrs = SimpleTemplateResponse . rendering attrs + [ STR_ , STR_ ]
for key , value in six . iterlists ( self ) :
from future import unicode literals
raise AttributeError ( self . warning )
def common logger config ( self , logger , config , in cremental = False ) :
class MultiPartParserError ( Exception ) :
from future import unicode literals
block = type ( self ) ( block . name , block . nodelist )
if len ( bits ) ! = NUM_ :
substitutions [ STR_ ] = super ( ClearableFileInput , self ) . render ( name , value , attrs )
return t [ NUM_ ] . lower ( ) , True
from django . core . management . base import BaseCommand
return None if timeout is None else time . time ( ) + timeout
if bits [ NUM_ ] == STR_ :
symlink path = os . path . join ( tmpdir , STR_ )
def get git changeset ( ) :
except OSError as e :
msg . attach ( body msg )
try :
resolve ( path , urlconf )
while bits :
saved instances = [ ]
param = elt [ NUM_ ]
def open ( self ) :
return formatdate ( epoch seconds , usegmt = True )
import sys
from django . core . management . base import BaseCommand
def static ( request ) :
class TemplateResponse ( SimpleTemplateResponse ) :
for app dir in app dirs :
self . val expr = val expr
def open ( self ) :
if constant :
lang = get language ( )
self . current [ field . name ] = field . value to string ( obj )
extra context = token kwargs ( remaining bits , parser , support legacy = True )
else :
output transaction = True
v . cause , v . traceback = e , tb
six . reraise ( exc type , exc value , sys . exc info ( ) [ NUM_ ] )
return force text ( self . prepare value ( in itial value ) ) ! = force text ( data value )
class RequestContext ( Context ) :
result = [ ]
def reduce ex ( self , proto ) :
except ValueError :
if m :
command = app name
except ValidationError :
return STR_ % self . data . day
import errno
curr = cwords [ cword - NUM_ ]
if size == NUM_ :
if max age is not None :
return state
if confirm == STR_ :
class name = model . name + str ( STR_ )
if arg is None :
if not is in stance ( messages , ValidationError ) :
fd = pyinotify . INotifyWrapper . create ( ) . in otify init ( )
return result
continue
serializers [ format ] = module
role = role . upper ( )
class BaseForm ( object ) :
def init ( self , children = None , connector = None , negated = False ) :
return e
def str ( self ) :
class SsiNode ( Node ) :
return op ( )
self . cull frequency = in t ( cull frequency )
self . in teresting = html parser . in teresting normal
class MultipleChoiceField ( ChoiceField ) :
for middleware path in settings . MIDDLEWARE CLASSES :
super ( DebugParser , self ) . init ( lexer )
or ig vars . pop ( STR_ , None )
def init ( self ) :
pass
from future import unicode literals
directories , files = [ ] , [ ]
from django . utils import six
if not serializers :
if plan node not in shown and plan node [ NUM_ ] == app name :
t = self . current token
if six . PY3 :
connection = connections [ self . using ]
return self . upload handlers
except ( ValueError , TypeError ) :
pop = complain
else :
widget = HiddenInput
if format not in serializers :
id += STR_
self . pointer = self . backout . pop ( )
filter name = getattr ( func , STR_ , None )
assertRegex = " STR_ "
value = list . getitem ( self , key )
pass
self . check ( )
class ErrorList ( UserList , list ) :
def init ( self , name , value , base , sysid , pubid , not ation name ) :
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " ) )
logger . propagate = propagate
def iteritems ( d , ** kw ) :
requires system checks = False
filename = tmp . split ( / ) [ - NUM_ ]
def repr ( self ) :
result = cache get ( key , root )
print ( opt label )
import sys
self . stream = stream
class FixUnicode ( fixer base . BaseFix ) :
pass
elif ch == STR_ :
if is in stance ( app name , BaseCommand ) :
raise CommandError ( " STR_ " " STR_ " % app config . label )
yield " STR_ "
self . tokens = tokens
yield safe join ( template dir , template name )
yield ( tok . name , toktext )
def getattr ( self , name ) :
in put formats = formats . get format lazy ( STR_ )
if not script url :
if not shown :
elif in dexes [ column name ] [ STR_ ] :
def nonzero ( self ) :
self . verbose name plural = STR_
except OSError :
if not self . first :
class SafeMIMEMultipart ( MIMEMixin , MIMEMultipart ) :
def fix ( match ) :
config [ STR_ ] = self . as tuple ( config [ STR_ ] )
def iter ( self ) :
def handle fk field ( self , obj , field ) :
self . stream . write ( " STR_ " )
message = ValidationError ( message )
return
else :
self . value = force text ( self . value )
M . set ( key , real value , coded value )
leading = self . has leading dir ( namelist )
return settings . LANGUAGE CODE
return STR_ . join ( output )
def iter ( self ) :
add doc ( u , " " " STR_ " " " )
if result :
connection = connections [ options [ STR_ ] ]
@ register . tag
common prefix = None
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , help = STR_ )
return media
file name = force text ( file name , encoding , errors = STR_ )
offset = offset . seconds // NUM_
path = parts [ NUM_ : ]
if column name in in dexes :
def extract ( self , to path = ) :
def init ( self , * args , ** kwargs ) :
directory created = { }
self . cookies = SimpleCookie ( )
msg = self . style . HTTP NOT FOUND ( msg )
class TokenParser ( object ) :
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
if form . is bound :
ret = fcntl . flock ( fd ( f ) , flags )
new attr = old attr
def get declared fields ( bases , attrs , with base fields = True ) :
return self . class ( [ ( k , v [ : ] ) for k , v in self . lists ( ) ] )
def lock ( f , flags ) :
update wrapper ( dec , decorator , assigned = available attrs ( decorator ) )
class StopFutureHandlers ( UploadFileException ) :
raise ValueError ( " STR_ " % s )
try :
widget = widget or self . widget
unique = " STR_ " if f . unique else " "
if hasattr ( self . file , STR_ ) :
all date checks = set ( )
args = match . groups ( )
for i , field in enumerate ( self . fields ) :
from functools import reduce
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
def lex ( self , text ) :
return IfNode ( conditions nodelists )
i += NUM_
with open ( filepath , STR_ ) as fp :
from future import unicode literals
class BaseInlineFormSet ( BaseModelFormSet ) :
self . handle fk field ( obj , field )
try :
filter expression = self . compile filter ( token . contents )
j = text . find ( substr , i )
try :
def parse header ( line ) :
template , or igin = find template ( template name , dirs )
if STR_ in args :
return self . get renderer ( name , value , attrs , choices ) . render ( )
except KeyError :
return self . number < self . paginator . num pages
if in tag and token string . startswith ( BLOCK TAG START ) :
nodelist false = NodeList ( )
del X
f = os . path . join ( p , cmd )
from PIL import ImageFile as PillowImageFile
if name is not None :
fh . write ( writer . as string ( ) )
def random ( value ) :
except KeyboardInterrupt :
self . json kwargs [ STR_ ] = ( STR_ , STR_ )
@ stringfilter
def add arguments ( self , parser ) :
if self . match is None or self . match re . search ( f ) :
import random
except ( IndexError , ValueError , KeyError , TypeError ) :
if not attr list [ NUM_ ] & termios . ECHO :
elif user settings [ key ] ! = default settings [ key ] :
from django . utils . translation import ugettext lazy as
year val , month val , day val = value . year , value . month , value . day
return module . Command ( )
from future import unicode literals
class VariableNode ( Node ) :
def create bound method ( func , obj ) :
else :
os . chmod ( filename , new permissions )
def handle m2m field ( self , obj , field ) :
self . tag ( function name , compile func )
stamp = time . mktime ( tt )
raise parser . error class ( " STR_ " % self . id )
truncate = force text ( truncate )
warnings . warn ( STR_ , RemovedInDjango19Warning , stacklevel = NUM_ )
os . exit ( NUM_ )
for key in self :
from django . utils . encoding import force text
def b ( s ) :
raise CommandError ( STR_ % exclude )
else :
assert content is not None
self . tagtype = tagtype
try :
def to python ( self , value ) :
def init ( self , exception ) :
return dateformat . format ( value , get format ( format or STR_ , use l10n = use l10n ) )
doublecolon start = - NUM_
continue
user regex = re . compile ( r " STR_ " r STR_ , re . IGNORECASE )
def has key ( self , key ) :
for k , v in six . iteritems ( dict ) :
output [ - NUM_ ] = last row [ : - len ( row ender ) ] + str hidden + row ender
nodes . extend ( node . get nodes by type ( nodetype ) )
queryset = property ( get queryset , set queryset )
while ch ! = STR_ :
self . flo = flo
if field not in self . fields :
pass
changeset = None
import warnings
ch2 = None
class BaseFormSet ( object ) :
else :
return self . objects
value = value . strip ( )
if self . field . localize :
if callable ( in itial value ) :
self . locale paths . in sert ( NUM_ , os . path . join ( os . path . abspath ( dirpath ) , dirname ) )
from django . utils . translation import trans real
value . decode ( charset )
raise Exception ( " STR_ " % self . class . name )
for app name in app names :
class CallbackFilter ( logging . Filter ) :
def truncatechars html ( value , arg ) :
config [ STR_ ] = self . config [ STR_ ] [ config [ STR_ ] ]
return strip spaces between tags ( self . nodelist . render ( context ) . strip ( ) )
table = connections [ db ] . ops . quote name ( self . table )
now = datetime . datetime . now ( utc if is aware ( d ) else None )
def repr ( self ) :
if find command ( program ) is None :
self . set cookie ( key , max age = NUM_ , path = path , domain = domain , expires = STR_ )
def getitem ( self , idx ) :
try :
from django . template . loader import get template
self . in stance . validate unique ( exclude = exclude )
return base lang in settings . LANGUAGES BIDI
cword = in t ( os . environ [ STR_ ] )
return [ ]
if is in stance ( self . urlconf name , list ) and len ( self . urlconf name ) :
if not is in stance ( e , CommandError ) :
basedirs = set ( map ( os . path . abspath , filter ( os . path . is dir , basedirs ) ) )
attrs [ STR_ ] = localized fields
break
if STR_ not in set ( settings . MIDDLEWARE CLASSES ) :
from django . conf import settings
status code = NUM_
def init ( self , in clude html = False , email backend = None ) :
value = escape ( value )
weight += NUM_
if hasattr ( mw instance , STR_ ) :
return t
self . empty block tag ( token )
for refto , refs in references . items ( ) :
return " STR_ " % ( package [ : dot ] , name )
class EmailField ( CharField ) :
from django . db import models
phone2numeric = allow lazy ( phone2numeric )
handler . startElement ( " STR_ " , self . root attributes ( ) )
objects = model . base manager
raise TypeError ( " STR_ " % type ( var ) )
choices = property ( get choices , ChoiceField . set choices )
@ register . tag
def display ( self ) :
comment notes . extend ( not es )
class Command ( BaseCommand ) :
else :
with self . mutex :
sys . modules [ name + " STR_ " ] = Module six moves urllib ( name + " STR_ " )
del attr
class Command ( BaseCommand ) :
def delattr ( self , name ) :
obj = mark for escaping ( new obj )
return wrap ( value , in t ( arg ) )
if self . pos >= len ( self . tokens ) :
plen = len ( provided ) + NUM_
def strftime ( dt , fmt ) :
if item type == FIELD :
get function defaults = operator . attrgetter ( func defaults )
return fp . getvalue ( )
from django . conf import settings
content type , content type extra = meta data . get ( STR_ , ( , { } ) )
from django . utils . deprecation import RemovedInDjango19Warning
filepath = os . path . abspath ( filepath )
else :
token = super ( DebugLexer , self ) . create token ( token string , in tag )
except self . LibraryValueNotFoundException :
use natural primary keys = options . get ( STR_ )
if self . data . hour > NUM_ :
def unclosed block tag ( self , parse until ) :
if new name . find ( STR_ ) >= NUM_ :
self . enter command ( command , token )
if in verse match is not None :
for app config in reversed ( list ( apps . get app configs ( ) ) ) :
return False
import warnings
return getattr ( in stance , name ) ( )
from django . db import connections , transaction , router , DatabaseError
return self . files
if limit is None or len ( x ) <= limit :
from django . utils . translation import ugettext lazy
cache [ key ] = oldroot
return STR_
return escape ( text )
self . in teractive = options . get ( STR_ )
for filepath in self . get template sources ( template name , template dirs ) :
import io
urlconf = get urlconf ( )
def url ( parser , token ) :
import warnings
@ register . filter ( is safe = True , needs autoescape = True )
else :
if self . fixture count == NUM_ and self . hide empty :
if hasattr ( field . rel , STR_ ) :
try :
urlconf = settings . ROOT URLCONF
if form . meta . fields :
wrapper . wrapped = user function
return output
def Deserializer ( stream or string , ** options ) :
def page ( self , number ) :
from django . core . management . sql import sql flush , emit post migrate signal
if callable ( name ) :
buffering = in t ( six . PY3 )
except LookupError :
except ImportError as exc :
if not fname . startswith ( self . dir ) or not os . path . exists ( fname ) :
self . loopvars , self . sequence = loopvars , sequence
self . mod = old mod
self . cdata tag = tag . lower ( )
return func
else :
def value ( self ) :
help text = help text html % force text ( field . help text )
raise TemplateSyntaxError ( " STR_ " % bits [ NUM_ ] )
from django . utils . module loading import import string
code = STR_
from django . core . management . base import AppCommand
def init ( self , * args , ** kwargs ) :
if field . rel and is in stance ( field . rel , models . ManyToManyRel ) :
for choice in self . field . choice cache :
for field in parse date fmt ( ) :
pass
fields = [ ( STR_ , OFFSET ) , ( STR_ , PVOID ) ]
raise TemplateSyntaxError ( " STR_ " % ( taglib , e ) )
return dict [ key ]
except ValueError :
if hasattr ( response , STR_ ) and callable ( response . render ) :
def init ( self , stream or string , ** options ) :
def send ( self , email message ) :
def get format ( format type , lang = None , use l10n = None ) :
logging config func ( logging settings )
raise CommandError ( " STR_ " % ( migration name , app label ) )
use grouping = use grouping or force grouping
except ( KeyError , AttributeError ) as exc :
self . unget ( chunk [ remaining : ] )
return time str + STR_ % ( hour , minute )
def start relational field ( self , field ) :
class DeclarativeFieldsMetaclass ( MediaDefiningClass ) :
return content
except ( ValueError , TypeError ) :
try :
if result is not None :
def pgettext ( context , message ) :
self . stdout . write ( " STR_ " % ( app name , model . meta . object name ) )
readline = property ( lambda self : self . file . readline )
def compile string ( template string , or igin ) :
lookup str = callback . module + " STR_ " + callback . name
return False
else :
import datetime
if tzinfo == STR_ :
try :
setattr ( Module six moves urllib response , attr . name , attr )
from future import absolute import
return do ntranslate ( singular , plural , number , STR_ )
ttl = force text ( ttl )
url = url . replace ( STR_ / )
yield " STR_ "
ns = " STR_ "
import codecs
return getattr ( self , assertCountEqual ) ( * args , ** kwargs )
raise ValueError ( STR_ STR_ % ( config [ STR_ ] , e ) )
self . request = request
try :
result = user function ( * args , ** kwds )
if not cookie allows colon in names :
if not chunk size :
default error messages = { STR_ : ( STR_ ) , STR_ : ( STR_ ) , }
def str ( self ) :
months = ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , )
old field name = None
class SplitDateTimeField ( MultiValueField ) :
return
self . files = MultiValueDict ( )
primary keys = pks . split ( STR_ )
self . stdout . write ( " STR_ " )
else :
imported objects = { }
from django . conf import settings
for i in range ( NUM_ , self . total form count ( ) ) :
kwargs [ STR_ ] = self . existing object ( pk )
from django . utils import six
else :
def render option ( self , selected choices , option value , option label ) :
if commit :
def deactivate ( ) :
return datetime . datetime . strptime ( force str ( value ) , format ) . time ( )
self . in valid block tag ( token , command , parse until )
value converters = { STR_ : STR_ , STR_ : STR_ , }
pickled = None
file . seek ( NUM_ )
in stance . keyOrder = [ ]
upload handlers = [ ]
format type = force str ( format type )
self . template cache = { }
lexer class , parser class = DebugLexer , DebugParser
in dexes = connection . in trospection . get indexes ( cursor , table name )
BROWSERS DEPRECATED LOCALES = { STR_ : STR_ , STR_ : STR_ , }
return os . path . normpath ( path )
exhaust ( self . input data )
if not m :
for k , v in data . items ( ) :
def getInnerText ( node ) :
return zbuf . getvalue ( )
args [ NUM_ : NUM_ ] = [ STR_ % arg for arg in args [ NUM_ ] . split ( " STR_ " ) ]
def init ( self , language ) :
sys . modules [ name + " STR_ " ] = sys . modules [ name + " STR_ " ] = Module six moves urllib response ( name + " STR_ " )
yield buf . read ( )
raise
app list [ app config ] = None
trans = Trans ( )
self . read started = True
if domain and validate host ( domain , settings . ALLOWED HOSTS ) :
def items ( self ) :
delta = ( d - now ) if reversed else ( now - d )
for f in fields :
for app config in app configs :
except ValueError :
def delete first token ( self ) :
def avoid wrapping ( value ) :
return data
self . fed . append ( STR_ % name )
yield b . join ( self )
url = smart urlquote ( STR_ % middle )
translated = translated % rhs
def add item elements ( self , handler , item ) :
return s . get data ( ) + s . rawdata
if request . method == STR_ :
def make key ( self , key , version = None ) :
try :
if len ( args ) > NUM_ :
class warn about renamed method ( object ) :
val = list ( val )
def getlist ( self , key ) :
return datetime . fromtimestamp ( os . path . getmtime ( self . path ( name ) ) )
finally :
parser . add argument ( STR_ , action = STR_ , help = STR_ )
media = Media ( )
from django . contrib . auth import get user model
message = ( STR_ )
if max value is not None :
return super ( PythonSerializer , self ) . getvalue ( )
Y = r STR_
import logging
self . update errors ( e )
pathext = [ ]
def cache ( self ) :
else :
def jython reloader ( main func , args , kwargs ) :
from functools import wraps
self . update unget history ( len ( bytes ) )
for hextet in ip str . split ( STR_ ) :
elif bmatch :
value = self . convert to charset ( value , STR_ , mime encode = True )
attrs [ STR_ ] = self . max value
from django . utils . translation import ugettext , ungettext
options += [ ( s opt . get opt string ( ) , s opt . nargs ) for s opt in parser . option list ]
except UnicodeDecodeError :
raise CommandError ( " STR_ " " STR_ " " STR_ " % project name )
def unordered list ( value , autoescape = None ) :
return j
body msg = msg
resolver match = resolver . resolve ( request . path info )
from django . utils . encoding import force str , force text
condition = TemplateIfParser ( parser , bits ) . parse ( )
class SafeData ( object ) :
def write ( self , val ) :
return True
else :
super ( MultiValueDict , self ) . setitem ( key , list )
for path in all locale paths ( ) :
else :
if self . output transaction :
def usage ( self , subcommand ) :
if i == NUM_ and not is writable ( npath ( base path + STR_ ) ) :
return self . render ( )
del active . value
value = getattr ( opts , opt )
one percent re = re . compile ( r " " " STR_ " " " )
import django
if hasattr ( self , STR_ ) :
compare to = nodelist true output = self . nodelist true . render ( context )
page range = property ( get page range )
dictreprs = STR_ . join ( repr ( d ) for d in self . dicts )
DOTS = [ STR_ , * , STR_ , STR_ , STR_ , STR_ ]
return " STR_ " % e
self . empty permitted = empty permitted
if num entries < self . max entries :
return force str ( " STR_ " % ( self . class . name , self . name , self . content type ) )
def smart bytes ( s , encoding = STR_ , strings only = False , errors = STR_ ) :
docs version = STR_
from django . conf import settings
form . errors [ NON FIELD ERRORS ] = self . error class ( [ self . get form error ( ) ] )
self . filters [ name ] = filter func
data = serializer ( ) . dumps ( obj )
else :
return [ m2m convert ( c ) for c in node . getElementsByTagName ( " STR_ " ) ]
def resolve template ( self , template ) :
return unicode ( s . replace ( r STR_ \ \ \ \ ) , "unicode escape" )
if args :
if values is None :
unifunc . replace ( strfunc )
try :
from django . core . management . utils import find command , popen wrapper
raise CommandError ( " STR_ " " STR_ " " STR_ " )
return super ( BooleanField , self ) . to python ( value )
try :
for k , v in six . iteritems ( kwargs ) :
def exit ( self , exc type , exc value , traceback ) :
if unhandled params :
def reset format cache ( ) :
if size is None :
def set regex ( self , regex ) :
def value from datadict ( self , data , files , name ) :
parser . add argument ( STR_ , help = STR_ )
i = NUM_
parser . add argument ( STR_ )
root = nonlocal root [ NUM_ ]
except DatabaseError as e :
def format ( number , decimal sep , decimal pos = None , grouping = NUM_ , thousand sep = , force grouping = False ) :
def get resolver ( urlconf ) :
output . append ( last row )
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
if i >= self . in itial form count ( ) and not form . has changed ( ) :
self . add fallback ( default translation )
from future import unicode literals
filename = file
return AutoEscapeControlNode ( ( arg == STR_ ) , nodelist )
class JSONSerializer ( object ) :
for f in opts . fields :
else :
from django . utils . html import escape
return SpacelessNode ( nodelist )
def save ( self , save m2m = True , using = None ) :
moved attributes = [ ]
class LazyDescr ( object ) :
if exclude and f . name in exclude :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : val } , )
final output . extend ( connection . creation . sql for pending references ( model , style , pending references ) )
return getattr ( self . out , name )
def is ignored ( path , ignore patterns ) :
for name in namelist :
return Literal ( value )
kwargs [ STR_ ] = self . in itial extra [ i - self . in itial form count ( ) ]
from django . db import models , DEFAULT DB ALIAS
from django . apps import apps
content = template file . read ( )
if item [ " STR_ " ] and item [ " STR_ " ] :
raise TemplateSyntaxError ( " STR_ " " STR_ " % name )
self . leftover = b
number value = rhs
for name , value in self . extra headers . items ( ) :
widget = Select
lookups . appendlist ( pattern . name , ( bits , p pattern , pattern . default args ) )
def in cr ( self , key , delta = NUM_ , version = None ) :
os . chmod ( path , stat . S IWRITE )
from django . db import DEFAULT DB ALIAS
from django . forms . utils import ErrorList
def urlsafe base64 decode ( s ) :
def choice ( self , obj ) :
return klass
form field = self . fields [ field ]
toktext = match . group ( name )
security logger . error ( force text ( e ) , extra = { STR_ : NUM_ , STR_ : request } )
if unpack :
return self . dicts [ - NUM_ ] [ key ]
all = ( STR_ , STR_ , STR_ )
def get version ( version = None ) :
self . mod = new mod
return False
EscapeString = EscapeBytes
except InvalidOperation :
return
self . find template cache . clear ( )
shutil . move ( the path , guessed path )
elif len ( app labels ) > NUM_ :
logging . captureWarnings ( True )
class BaseCache ( object ) :
@ register . tag ( for )
@ register . filter ( is safe = True , needs autoescape = True )
if refto in known models :
if hasattr ( field value , STR_ ) and not is in stance ( field value , six . text type ) :
return FILE INPUT CONTRADICTION
if number > self . num pages :
class OutputWrapper ( object ) :
else :
lib = get library ( taglib )
number = . join ( reversed ( digits ) )
result . append ( self . create token ( bit , in tag ) )
def get ( self , key , otherwise = None ) :
errors . append ( field . error messages [ STR_ ] )
raise VariableDoesNotExist ( " STR_ " " STR_ " , ( bit , current ) )
def delitem ( self , header ) :
super ( JsLexer , self ) . init ( self . states , STR_ )
token = Token ( TOKEN BLOCK , block content )
from wsgiref import simple server
return I18N MODIFIED if filename . endswith ( STR_ ) else FILE MODIFIED
request middleware = [ ]
return self . data . is oformat ( )
self . stdout . write ( " STR_ " )
def init ( self , * args , ** kwargs ) :
if is in stance ( attr , MovedModule ) :
base64d = b STR_ + base64d
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
value = self . literal
except ImportError :
klass . new = staticmethod ( new )
class IfEqualNode ( Node ) :
self . hashvalue = hash ( tup )
output . append ( format html ( STR_ , force text ( option value ) ) )
def save ( self , commit = True ) :
width = six . text type ( len ( six . text type ( len ( lines ) ) ) )
if custom sql :
if self . verbosity >= NUM_ :
empty value =
return result
weight = NUM_
locations = [ ]
self . in teresting = html parser . in teresting cdata
duplicate . dicts = self . dicts [ : ]
cursor . execute ( " STR_ " " STR_ " % table , [ b64encoded , exp , key ] )
command dir = os . path . join ( management dir , STR_ )
has old option = hasattr ( self , STR_ )
class BaseCommand ( object ) :
t = get template ( template name , dirs )
class RssFeed ( SyndicationFeed ) :
elif cwords [ NUM_ ] in subcommands and cwords [ NUM_ ] ! = STR_ :
return self . body
except ImportError :
data [ field . name ] = value
if is in stance ( file name , Template ) :
if name not in parser . namedCycleNodes :
end , next = boundary
self . file name = file name
child nodelists = ( STR_ , STR_ )
except StandardError as e :
return loader . select template ( template )
if not cls :
from django . utils . safestring import mark safe
continue
return wrapper
return False
return ( t [ NUM_ ] . lower ( ) , True )
if self . method ! = STR_ :
name , ( value , params ) = parse header ( line )
def init ( self , data , encoder = DjangoJSONEncoder , safe = True , ** kwargs ) :
numbers = [ MigrationAutodetector . parse number ( migration . name ) for migration in merge migrations ]
mw instance = mw class ( )
current chunk = None
if member . is dir ( ) :
warnings . warn ( " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
def configure filter ( self , config ) :
from decimal import Decimal
def close ( self , ** kwargs ) :
is compressed = True
return STR_ % self . parent name . token
urlconf repr = repr ( self . urlconf name )
path info = get bytes from wsgi ( environ , STR_ , / )
lineno comment map [ comment lineno cache ] = [ ]
self . compression formats [ STR_ ] = ( bz2 . BZ2File , STR_ )
return [ f [ : - NUM_ ] for f in os . listdir ( command dir ) if not f . startswith ( STR_ ) and f . endswith ( STR_ ) ]
length = in t ( arg )
def slugify ( value ) :
result = new result
context = Context ( dict ( options , ** { base name : name , base directory : top dir , STR_ : docs version , } ) , autoescape = False )
from django . conf import settings
class FixedOffset ( tzinfo ) :
old path = path . join ( root , filename )
handlers = config . get ( STR_ , EMPTY DICT )
raise InvalidCacheBackendError ( " STR_ " % ( backend , e ) )
if not unicodedata . combining ( char ) :
class ManagementForm ( Form ) :
new class = ( super ( DeclarativeFieldsMetaclass , mcs ) . new ( mcs , name , bases , attrs ) )
elif self . delegate text :
return self . size
self . assert mutable ( )
def cleaned data ( self ) :
return len ( self . items )
from django . core . files import File
cache . close ( )
return force text ( settings . FORCE SCRIPT NAME )
def advance iterator ( it ) :
raise TemplateSyntaxError ( " STR_ " % args [ - NUM_ ] )
def read ( self ) :
elif options [ STR_ ] :
def find fixtures ( self , fixture label ) :
self . deleted objects = [ ]
newline = " STR_ "
attrs plus = self . attrs . copy ( )
yaml . dump ( self . objects , self . stream , Dumper = DjangoSafeDumper , ** self . options )
else :
pass
def nonzero ( self ) :
raise InvalidCacheBackendError ( " STR_ " % alias )
for key in self . keyOrder :
return obj
@ register . tag
def rss attributes ( self ) :
if is in stance ( template name , ( list , tuple ) ) :
def extend nodelist ( self , nodelist , node , token ) :
else :
self . attach ( filename , content , mimetype )
class Command ( TemplateCommand ) :
class Media ( object ) :
class MinLengthValidator ( BaseValidator ) :
register = Library ( )
while current chunk ! = b :
vary headers = cc delim re . split ( response [ STR_ ] )
return ( fp . read ( ) . decode ( settings . FILE CHARSET ) , filepath )
if e . errno == errno . ENOENT :
lang code = request . session . get ( LANGUAGE SESSION KEY )
if six . PY3 :
raise TypeError ( " STR_ " " STR_ " )
token . source = self . or igin , source
if content disposition :
if options [ STR_ ] and options [ STR_ ] :
pass
with self . lock . reader ( ) :
if six . PY2 :
match = kwarg re . match ( bits [ NUM_ ] )
self . filters . update ( lib . filters )
except TemplateDoesNotExist :
class ModelMultipleChoiceField ( ModelChoiceField ) :
elif token . token type == NUM_ :
b64encoded = b64encoded . decode ( STR_ )
if html message :
top dir = os . path . abspath ( path . expanduser ( target ) )
return replacement
yield self [ name ]
def supports color ( ) :
return ContextDict ( self , * args , ** kwargs )
dirs . extend ( list ( settings . FIXTURE DIRS ) )
pass
return trans . gettext ( message )
return " | " . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
path = str ( path )
known models . add ( model )
from django . utils import six
try :
msg = " STR_ " % self . program
return list ( value )
class TimeFormat ( Formatter ) :
get = STR_
return [ ]
import in spect
return self . wrapped . dict
return value . strip ( )
from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
def itervalues ( self ) :
from django . utils . encoding import smart text , force text , python 2 unicode compatible
self . stdout . write ( " STR_ " % model . meta . db table )
common prefix = prefix
return timezone . tzname ( None )
try :
self . stream = stream
return json . dumps ( { f : e . get json data ( escape html ) for f , e in self . items ( ) } )
sign = -
tried = [ ]
from django . utils import six
defaults = { STR_ : self . auto id , STR_ : self . add prefix ( i ) , STR_ : self . error class , }
if csrf token == STR_ :
self . errors = ErrorDict ( )
if value ! = :
def set script prefix ( prefix ) :
upload = super ( ClearableFileInput , self ) . value from datadict ( data , files , name )
else :
else :
except AttributeError :
timeval = time . time ( )
if not serializers :
if settings . TEMPLATE STRING IF INVALID :
return re . sub ( r STR_ , , force text ( value ) )
warnings . warn ( STR_ STR_ , RemovedInDjango19Warning , stacklevel = NUM_ )
import os
raise ValueError ( STR_ STR_ % ( name , e ) )
def render ( self , context ) :
if settings . USE I18N :
if is in stance ( s , six . text type ) :
if options . get ( STR_ ) :
from django . utils import six
pythonrc = os . path . expanduser ( pythonrc )
pending references = { }
except KeyError :
active = local ( )
def init ( self , format string ) :
from django . utils . functional import allow lazy
t = super ( SafeText , self ) . add ( rhs )
if item date :
weight += NUM_
hidden widget = SplitHiddenDateTimeWidget
def Deserializer ( stream or string , ** options ) :
lines [ i ] = ( " STR_ " + width + " STR_ " ) % ( i + NUM_ , escape ( line ) )
if module has submodule ( app config . module , " STR_ " ) :
objects = serializers . deserialize ( ser fmt , fixture , using = self . using , ignorenonexistent = self . ignore )
def create attachments ( self , msg ) :
current timezone = timezone . get current timezone ( )
class LimitedStream ( object ) :
def text cast ( self ) :
elif t . token type == TOKEN COMMENT :
has bz2 = False
day field = STR_
self . or igin = or igin
return plist
self . xml . endElement ( " STR_ " )
def decorator from middleware ( middleware class ) :
in t part gd += thousand sep
self . position += len ( output )
return force text ( unquote plus ( force str ( quoted url ) ) )
return doy
return
valid = True
raise TypeError ( " STR_ " )
from django . core import checks
if value in self . empty values :
def center ( value , arg ) :
return value . ljust ( in t ( arg ) )
parser . add argument ( STR_ , STR_ , default = STR_ , dest = STR_ , help = STR_ )
val = self . cache . decr ( key , delta )
total forms = max ( in itial forms , self . min num ) + self . extra
def process ( self , command , domain ) :
setattr ( cls , k , meth )
def available attrs ( fn ) :
expanded template = path . normpath ( expanded template )
for item in six . iteritems ( dict ) :
def init ( self , widgets , attrs = None ) :
if len ( t ) > NUM_ :
except smtplib . SMTPException :
self [ key ] = result
if gettext module . find ( STR_ , path , [ to locale ( lang code ) ] ) is not None :
return self . client
form = self . forms [ i ]
filename = filename . encode ( STR_ )
yield d
return the path
node = CycleNode ( values )
value = self . queryset . get ( ** { key : value } )
global standard context processors
field notes . append ( " STR_ " )
break
def wrapper ( * args ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
error = error . error dict
def decorating function ( user function ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
try :
output = [ ]
from django . utils . six . moves import http cookies
def rfc3339 date ( date ) :
values = reversed ( values )
def body ( self ) :
chunk = self . read limited ( size - len ( self . buffer ) )
self . field . choice cache = [ self . choice ( obj ) for obj in self . queryset . all ( ) ]
for base in bases [ : : - NUM_ ] :
from django . core . files . move import file move safe
mod name , func name = get mod func ( lookup view )
if getattr ( self , STR_ , None ) is None :
@ wraps ( fget )
raise ValueError ( " STR_ " % migration names )
httpd . daemon threads = True
return STR_ % ( y , m , d )
for node in self . nodelist :
class Formatter ( object ) :
bits = arg . split ( STR_ )
in comment = False
return any ( w . needs multipart form for w in self . widgets )
class ViewDoesNotExist ( Exception ) :
results [ predicate ( item ) ] . append ( item )
elif field . rel and is in stance ( field . rel , models . ManyToOneRel ) :
self . dicts . append ( other dict )
return IfChangedNode ( nodelist true , nodelist false , * values )
@ register . filter ( is safe = False )
c = config . pop ( STR_ )
kwargs [ STR_ ] = number value
help = STR_
class Command ( BaseCommand ) :
if hasattr ( form , STR_ ) :
def encoding ( self , val ) :
val1 = self . var1 . resolve ( context , True )
def add installed apps translations ( self ) :
return s
import os
def dst ( self , dt ) :
exclude = options . get ( STR_ )
else :
self . stdout . write ( STR_ % ( f , dirpath ) )
logger = logging . getLogger ( STR_ )
self . in dent ( NUM_ )
os . unlink ( pot path )
return or d ( bs [ NUM_ ] )
EscapeString = EscapeText
self . stream . write ( " STR_ " )
return base64 . urlsafe b64decode ( s + pad )
try :
from django . utils . timezone import utc , get fixed timezone
try :
raise ValueError ( " STR_ " )
elif is in stance ( timezone , six . string types ) and pytz is not None :
else :
dirs = [ upath ( os . path . abspath ( os . path . realpath ( d ) ) ) for d in dirs ]
def init ( self , fail silently = False , ** kwargs ) :
def items ( self ) :
class HttpResponseBadRequest ( HttpResponse ) :
attr list = termios . tcgetattr ( fd )
from IPython import start ipython
def linebreaks filter ( value , autoescape = None ) :
content length = None
buffer = None
EscapeUnicode = EscapeText
return set ( x for x in ext list if x . strip ( STR_ ) not in ignored )
try :
import sys
return DebugNodeList ( )
def sql indexes ( app config , style , connection ) :
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
while i < len ( subject ) and subject [ i ] ! = c :
yes , no , maybe = bits [ NUM_ ] , bits [ NUM_ ] , bits [ NUM_ ]
return STR_ % ( self . connector , STR_ . join ( [ str ( c ) for c in self . children ] ) )
if confirm not in ( STR_ , STR_ ) :
pass
widgets = ( DateInput ( attrs = attrs , format = date format ) , TimeInput ( attrs = attrs , format = time format ) )
next item = list [ i + NUM_ ]
from yaml import CSafeLoader as SafeLoader
while remaining bits :
return j
handler . addQuickElement ( " STR_ " , rfc3339 date ( self . latest post date ( ) ) )
error = { field or NON FIELD ERRORS : error . error list }
@ python 2 unicode compatible
field type += STR_
def setitem ( self , key , value ) :
return True
if settings . USE TZ :
return super ( CommandParser , self ) . parse args ( args , namespace )
if want unicode :
try :
key prefix = settings . CACHE MIDDLEWARE KEY PREFIX
attrvalue = attrvalue [ NUM_ : - NUM_ ]
from django . conf import settings
return [ ( , [ ] ) ]
self . streaming content = streaming content
for name in filters :
return STR_ % x [ : max ( NUM_ , limit - NUM_ ) ]
elif var arg :
class WSGIHandler ( base . BaseHandler ) :
if not commit :
field name = field node . getAttribute ( " STR_ " )
logger . handlers = [ ]
def new ( cls , * args , ** kwargs ) :
from django . conf import settings
if is in stance ( self , nodetype ) :
if hasattr ( settings , " STR_ " ) :
super ( IPAddressField , self ) . init ( * args , ** kwargs )
if transfer encoding == STR_ :
def has changed ( self ) :
from django . utils . translation import ugettext lazy as , ungettext lazy
elif domain == STR_ and ( file ext == STR_ or file ext in command . extensions ) :
return new class
str = new method proxy ( str )
return SafeText ( data )
return s
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
from django . utils . encoding import python 2 unicode compatible
template , display name = loader ( name , dirs )
key = plist . pop ( NUM_ ) . lower ( ) . decode ( STR_ )
encoding = locale . getdefaultlocale ( ) [ NUM_ ] or STR_
return True
self . base location = location
else :
self . params = params
def init ( self , * args , ** kwargs ) :
def start serialization ( self ) :
from django . forms . widgets import ( SelectMultiple , HiddenInput , MultipleHiddenInput )
if not self . activated :
MEMCACHE MAX KEY LENGTH = NUM_
if STR_ not in header names :
pathext = os . environ . get ( STR_ , STR_ ) . split ( os . pathsep )
return do translate ( message , STR_ )
def render ( self , context ) :
tags = options . get ( STR_ , None )
def iter ( self ) :
for match in matches :
try :
self . error class = STR_ . format ( error class )
def load post and files ( self ) :
def deepcopy ( self , memo ) :
def serialize ( self ) :
return fext
raise KeyError ( key )
raise TemplateSyntaxError ( " STR_ " )
def close ( self ) :
self . file = file
text = force text ( text )
return value . replace ( " " , " STR_ " )
self . add root elements ( handler )
except Exception :
output = [ ]
result . parent = self
code list = [ ]
except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) :
sys . stdin . close ( )
trans real . active = threading . local ( )
name = member . name
raise
cleaned data = form . cleaned data
if condition is not None :
for message in messages :
try :
parser . UnparsedEntityDeclHandler = self . unparsed entity decl
LOCK NB = NUM_ x1
filename = os . path . join ( to path , name )
msg data = msg data . decode ( charset )
from future import unicode literals
sites = [ ]
parser . EntityDeclHandler = self . entity decl
if t is not None :
else :
if self . in stance . pk is not None :
self . keyOrder = [ ]
value = force str ( value )
elif count > NUM_ :
if language code not in self . app dict :
value = field . widget . value from datadict ( self . data , self . files , self . add prefix ( name ) )
if not hasattr ( other dict , STR_ ) :
cursor . close ( )
from future import unicode literals
url = None
ngettext lazy = ngettext
self . archive . list ( * args , ** kwargs )
if is ignored ( file path , self . ignore patterns ) :
activate ( self . old language )
from importlib import import module
while < in value and > in value :
paras = [ STR_ % p . replace ( STR_ , STR_ ) for p in paras ]
if self . max length is not None and len ( file name ) > self . max length :
def get quantifier ( ch , in put iter ) :
fs encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
if not is in stance ( value , ConvertingDict ) and is in stance ( value , dict ) :
def enter ( self ) :
super ( DebugLexer , self ) . init ( template string , or igin )
from future import unicode literals
from django . core . management . base import ( BaseCommand , CommandError , CommandParser , handle default options )
from django . utils import timezone , six
if strings only and is protected type ( s ) :
widget = self . field . widget
return msg
file = BytesIO ( data . read ( ) )
def values ( self ) :
if self . in teractive :
new method name = renamed method [ NUM_ ]
ch , escaped = next ( in put iter )
if self . can import settings :
del logging . handlerList [ : ]
if opts . fields == ALL FIELDS :
try :
byte2int = operator . itemgetter ( NUM_ )
six . reraise ( ValueError , ValueError ( " STR_ " % date ) , sys . exc info ( ) [ NUM_ ] )
literal match = self . literal regex . match ( domain part )
def mail managers ( subject , message , fail silently = False , connection = None , html message = None ) :
class ExtendsNode ( Node ) :
current expires = result [ NUM_ ]
class TemporaryFile ( FileProxyMixin ) :
filesize number format = lambda value : formats . number format ( round ( value , NUM_ ) , NUM_ )
lang code = regex match . group ( NUM_ )
try :
return nodelist
return wrapped view
migration . merged operations = [ ]
def add arguments ( self , parser ) :
self . stream = None
from django . forms . utils import from current timezone , to current timezone
def len ( self ) :
query = query . lists ( )
signals . got request exception . send ( sender = self . class , request = request )
return result
self . unget history = [ ]
if supported code . startswith ( generic lang code + - ) :
if delta < NUM_ :
self . key = key or settings . SECRET KEY
all = [ " STR_ " ]
import copy
for migration name in migration names :
except ImproperlyConfigured as exc :
if base url is None :
parser = MultiPartParser ( META , post data , self . upload handlers , self . encoding )
sys . modules [ name + " STR_ " ] = sys . modules [ name + " STR_ " ] = Module six moves urllib robotparser ( name + " STR_ " )
return False
class SimpleNode ( TagHelperNode ) :
try :
c . load ( cookie )
return dict . getlist ( key )
class MultiValueDictKeyError ( KeyError ) :
def close ( self ) :
def has changed ( self ) :
from django . utils . safestring import mark safe , SafeData
return trans . get language from request ( request , check path )
def y ( self ) :
def handle fk field node ( self , node , field ) :
iterkeys = " STR_ "
from django . utils . functional import lazy
from django . utils . encoding import force bytes
self . prepare class ( )
if part in PALETTES :
response = set response etag ( response )
return STR_
else :
lock = RLock ( )
callback , param dict = resolver . resolve error handler ( NUM_ )
except ( TypeError , AttributeError , KeyError , ValueError ) :
class HttpResponsePermanentRedirect ( HttpResponseRedirectBase ) :
return t . to language ( )
digest = hashlib . sha256
locales = [ locale ]
slots = [ slots ]
return lookup view
return hashlib . pbkdf2 hmac ( digest ( ) . name , password , salt , iterations , dklen )
def extract ( path , to path = ) :
class UploadFileException ( Exception ) :
return callback ,
def get page ( self , * args , ** kwargs ) :
if six . PY3 :
data [ f . name ] = f . value from object ( in stance )
self . show traceback = options . get ( STR_ )
return is in stance ( obj , PROTECTED TYPES )
utility . execute ( )
status code = NUM_
if not template dirs :
files . append ( entry )
return value
if k in seen :
try :
raise NotImplementedError ( STR_ )
return getattr ( caches [ DEFAULT CACHE ALIAS ] , name )
self . setlistdefault ( key ) . extend ( value list )
def select template ( template name list , dirs = None ) :
if space == NUM_ :
raise ValueError ( STR_ STR_ % ( name , e ) )
class Serializer ( base . Serializer ) :
if field in self . cleaned data :
if self . can order :
def import module ( name ) :
i += NUM_
exit code = os . spawnve ( os . P WAIT , sys . executable , args , new environ )
simple email re = re . compile ( r STR_ )
except ( TypeError , ValueError ) :
self . choices . append ( ( f , f . replace ( path , " " , NUM_ ) ) )
from django . core . serializers . python import Serializer as PythonSerializer
raise ViewDoesNotExist ( " STR_ " % ( lookup view , mod name ) )
if not ( bits . scheme and bits . netloc ) :
if timeout == DEFAULT TIMEOUT :
return val
if router . allow migrate ( self . using , obj . object . class ) :
import json
in put attrs [ STR_ ] = STR_ % ( id , i )
def get unbound function ( unbound ) :
def load serializers ( ) :
def get language bidi ( ) :
except Exception :
return dict ( ( key , self [ key ] ) for key in self )
return ip str
if value :
self . upload handlers = upload handlers
self . namespace = STR_ . join ( self . namespaces )
definition [ STR_ ] = colors [ - NUM_ ]
zipfile . ZipFile . init ( self , * args , ** kwargs )
def init ( self , s ) :
self . setlist ( key , default list )
obj pk = field . rel . to . meta . get field ( field . rel . field name ) . to python ( field value )
def rmtree errorhandler ( func , path , exc info ) :
error files = [ ]
self . stdout . write ( self . style . MIGRATE LABEL ( " STR_ " ) + " STR_ " % ( targets [ NUM_ ] [ NUM_ ] , ) )
try :
if supported is None :
result = datetime . datetime ( value . year , value . month , value . day )
def get unbound function ( unbound ) :
@ register . filter
import sys
elif hasattr ( pattern , STR_ ) :
if extra params :
class StopUpload ( UploadFileException ) :
from django . db . migrations . executor import MigrationExecutor
last = max ( NUM_ , end - NUM_ )
import sys
return self . forms [ in dex ]
if end is not None :
class RegroupNode ( Node ) :
if best doublecolon len > NUM_ :
for c in reversed ( self . class . mro ) :
os . makedirs ( top dir )
boundary = boundary . encode ( STR_ )
value = self . get ( key , version = version )
mail . outbox = [ ]
d = datetime . datetime ( d . year , d . month , d . day )
@ property
runfastcgi ( args )
hour , minute = divmod ( timezone , NUM_ )
def end object ( self , obj ) :
def reverse dict ( self ) :
if not value or not [ v for v in value if v not in self . empty values ] :
return MONTHS 3 [ self . data . month ]
if settings . TEMPLATE DEBUG :
raise TemplateDoesNotExist ( STR_ . join ( not found ) )
self . exception middleware = [ ]
return " STR_ " % ( self . class . name , self . var )
except AttributeError :
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
UnicodeDecodeError . init ( self , * args )
contains = has key
options = [ ( STR_ , None ) ]
in itial text = ugettext lazy ( STR_ )
excludes = options . get ( STR_ )
from django . core . management . sql import sql delete
return date value . strftime ( in put format )
class LazyModule ( types . ModuleType ) :
parser . add argument ( STR_ , nargs = STR_ , help = STR_ )
data = { " STR_ " : smart text ( obj . meta ) , " STR_ " : self . current , }
s len += NUM_
def as text ( self ) :
from django . conf import settings
def to python ( self , value ) :
except ( ValueError , TypeError ) :
in tag = not in tag
try :
@ python 2 unicode compatible
raise ImproperlyConfigured ( STR_ % self . file path )
return STR_ . join ( statements )
if exit code < NUM_ :
gettext module . GNUTranslations . init ( self )
def get template sources ( self , template name , template dirs = None ) :
return client
queryset = queryset . filter ( pk in = primary keys )
resource = resource . decode ( settings . FILE CHARSET )
outdict = { }
self . FILES = MultiValueDict ( )
else :
needs multipart form = True
in t2byte = chr
self . stream . write ( STR_ )
else :
return super ( QueryDict , self ) . setlistdefault ( key , default list )
if not self . is valid ( ) :
class RadioSelect ( RendererMixin , Select ) :
mail . attach alternative ( html message , STR_ )
return self . get scheme ( )
return False
self . delete ( key )
def load middleware ( self ) :
if app label not in executor . loader . migrated apps :
def receive data chunk ( self , raw data , start ) :
if model in excluded models :
memo [ id ( self ) ] = result
if count2 ! = NUM_ :
elif is in stance ( value , ( decimal . Decimal , float ) + six . in teger types ) :
raise ValueError ( " STR_ " " STR_ " % ( middleware method . self . class . name ) )
return result
if callable ( current ) :
return self . handle noargs ( ** options )
return total forms
pass
parser . StartDoctypeDeclHandler = self . start doctype decl
return standard context processors
if key . startswith ( self . prefix ) :
value = value . replace ( replacement , )
if row data in seen data :
if self . in itial and STR_ not in kwargs :
else :
except ValueError :
from django . http . response import REASON PHRASES as STATUS CODE TEXT
scheme , netloc , path , query , fragment = urlsplit ( value )
renamed methods = ( )
else :
return ( output , force text ( errors , DEFAULT LOCALE ENCODING , strings only = True ) , p . returncode )
with connection . cursor ( ) as cursor :
self . abstract = False
strip prefix = lambda s : s [ NUM_ : ] if s . startswith ( " STR_ " ) else s
if not context instance :
def handle ( self , ** options ) :
except AttributeError :
else :
options += [ ( k , NUM_ ) for k in FASTCGI OPTIONS ]
counters [ i ] += chunk length
return
var = var [ NUM_ : - NUM_ ]
final attrs = self . build attrs ( attrs )
forms = [ self . construct form ( i ) for i in xrange ( self . total form count ( ) ) ]
return EndToken
if app label not in executor . loader . migrated apps :
if logging settings :
self . setup ( )
self . done = True
else :
else :
if not hasattr ( c , STR_ ) and hasattr ( types , STR_ ) and type ( c ) ! = types . ClassType :
def parse date ( value ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : pk } , )
LIGHT PALETTE = STR_
except ( LookupError , BinasciiError ) as e :
self . max length , self . min length = max length , min length
from django . core import signals
if decimal separator in value :
found = True
with io . open ( or ig file , STR_ , encoding = settings . FILE CHARSET ) as fp :
msg = ( " STR_ " " STR_ " % { STR_ : new class . name , STR_ : opt , STR_ : value , } )
def start object ( self , obj ) :
factor -= NUM_
display url = tmp + /
from django . utils . text import ( smart split , unescape string literal , get text list )
default list = [ ]
if hasattr ( e , STR_ ) and e . code in self . error messages :
self . extend nodelist ( nodelist , compiled result , token )
if is in stance ( value , bool ) :
globalpath = os . path . join ( os . path . dirname ( upath ( sys . modules [ settings . module ] . file ) ) , STR_ )
unique check = [ field for field in unique check if field ! = self . fk . name ]
if self . verbosity >= NUM_ :
from django . utils import six
return result
try :
def add arguments ( self , parser ) :
def filesizeformat ( bytes ) :
keys = iterkeys
self . file permissions mode = ( file permissions mode if file permissions mode is not None else settings . FILE UPLOAD PERMISSIONS )
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
template = Template ( content )
if not url fields [ NUM_ ] :
ugettext lazy = lazy ( ugettext , six . text type )
raise ValueError ( STR_ STR_ % ( name , e ) )
def iter ( self ) :
if os . name == STR_ :
warnings . warn ( STR_ STR_ , RemovedInDjango19Warning , NUM_ )
pass
if self . decimal places is not None :
return False
if ( connections [ db ] . features . needs datetime string cast and not is in stance ( current expires , datetime ) ) :
def init ( self , nodelist , parent name , template dirs = None ) :
def get bytes from wsgi ( environ , key , default ) :
raise TemplateDoesNotExist ( error msg )
class TemplateEncodingError ( Exception ) :
return
from django . db . models . fields . related import ManyToManyField
self . xml . startDocument ( )
values = [ ]
if end < NUM_ :
super ( Command , self ) . run from argv ( argv )
block = self
def created time ( self , name ) :
except UnicodeEncodeError :
new = name
self . setup ( )
warnings . warn ( " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
raise NoReverseMatch ( " STR_ " " STR_ " % ( lookup view s , args , kwargs , len ( patterns ) , patterns ) )
else :
from django . core . management . base import BaseCommand , CommandError
default validators = [ validators . validate ipv4 address ]
nodelist . append ( node )
except OSError as e :
db = options . get ( STR_ )
return self . render ( context )
raise TemplateSyntaxError ( " STR_ " )
def camel case to spaces ( value ) :
from django . conf import settings
kwargs [ STR_ ] = kwargs . pop ( STR_ )
from django . core . exceptions import ImproperlyConfigured
check for migrations ( app config , connection )
def add ( self , rhs ) :
else :
self . close ( )
def clear checkbox name ( self , name ) :
last = max ( NUM_ , end - NUM_ )
name = name [ : NUM_ - len ( ext ) ] + ext
root [ : ] = [ root , root , None , None ]
try :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
path = path . lstrip ( / ) . lstrip ( \\' )
def full clean ( self ) :
if is in stance ( value , six . text type ) :
app . in itialize ( argv = [ ] )
super ( ContextDict , self ) . init ( * args , ** kwargs )
bytes = float ( bytes )
self . info = translation . info . copy ( )
for node in self . nodelist loop :
class Command ( BaseCommand ) :
text type = unicode
def init ( self ) :
if six . PY2 :
while start < end :
setattr ( Module six moves urllib robotparser , attr . name , attr )
return len ( self . object list )
yield STR_ % self . db module
if prefix is None :
return . join ( extra classes )
for sql in sql list :
form = ManagementForm ( self . data , auto id = self . auto id , prefix = self . prefix )
return self . content
s1 = time . strftime ( fmt , ( year , ) + timetuple [ NUM_ : ] )
if token is None :
step = str ( Decimal ( STR_ ) / NUM_ ** self . decimal places ) . lower ( )
def handle ( self , ** options ) :
s . close ( )
for locale in locales :
raise StopIteration ( )
path info = get path info ( environ )
return self . cache . in cr ( key , - delta )
def total error count ( self ) :
chunk size = self . DEFAULT CHUNK SIZE
return
if localtime is None :
def flatten ( self ) :
p = language . find ( - )
message context = None
raise NotImplementedError ( STR_ )
try :
break
except Exception :
if settings . USE TZ and value is not None and timezone . is aware ( value ) :
class Command ( BaseCommand ) :
DEFAULT CHUNK SIZE = NUM_ * NUM_ ** NUM_
class WSGIRequestHandler ( simple server . WSGIRequestHandler , object ) :
if csrf token :
def init ( self , content , name = None ) :
handle default options ( options )
self . lock = threading . RLock ( )
output . append ( format html ( self . in ner html , choice value = choice value , sub widgets = sub ul renderer . render ( ) ) )
def forbid multi line headers ( name , val , encoding ) :
if character ! = STR_ :
super ( StringOrigin , self ) . init ( UNKNOWN SOURCE )
except ImportError :
if headerlist is not None :
if questioner . ask merge ( app label ) :
self . unget history = [ ]
self . attachments . append ( filename )
super ( MemoryFileUploadHandler , self ) . new file ( * args , ** kwargs )
for d in reversed ( self . dicts ) :
return
settings . configure ( )
return super ( DjangoJSONEncoder , self ) . default ( o )
for resultclass in resultclasses :
import warnings
for d in self . dicts :
if subcommand == STR_ :
translation = self . new gnu trans ( localedir )
def call ( self , * args , ** kwargs ) :
msg = self . style . HTTP SUCCESS ( msg )
nesting -= NUM_
if is templatized :
for pos , elt in enumerate ( source ) :
package = import module ( path )
codecs . lookup ( content params [ STR_ ] )
return self . compress ( [ ] )
def init ( self , func ) :
if self . META . get ( header , None ) == value :
end index = None
rawdata = force str ( rawdata )
elif change == I18N MODIFIED :
@ register . filter ( is safe = False )
return from current timezone ( result )
def has changed ( self , in itial , data ) :
else :
response = middleware . process template response ( request , response )
def decr ( self , key , delta = NUM_ , version = None ) :
html = { }
if not self . is bound :
if value is None :
call command ( STR_ , verbosity = max ( self . verbosity - NUM_ , NUM_ ) , in teractive = False , database = db , reset sequences = False , in hibit post migrate = True , )
if six . PY3 :
register to . registry = before import registry
for f in opts . local fields :
p = in t ( arg )
return False
pass
def npgettext ( context , singular , plural , number ) :
palette = PALETTES [ NOCOLOR PALETTE ] . copy ( )
for filename in filenames :
def init ( self , request = None ) :
raise ExternalReferenceForbidden ( context , base , sysid , pubid )
setattr ( base , new method name , old method )
MAXSIZE = in t ( ( NUM_ << NUM_ ) - NUM_ )
except ImportError :
return sorted ( value , key = Variable ( arg ) . resolve , reverse = True )
if not file name :
else :
elif args [ NUM_ ] [ NUM_ ] == STR_ :
if value in self . empty values :
def is naive ( value ) :
return value . upper ( )
def init ( self , server , params , library , value not found exception ) :
except AttributeError :
try :
locale = options . get ( STR_ )
if self . verbosity >= NUM_ :
return False
outer html = STR_
code = STR_
parser . add option ( STR_ , action = STR_ , help = STR_ )
parser . add option ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
def parse header params ( s ) :
if self . active readers == NUM_ and self . waiting writers ! = NUM_ :
return url
if not settings . MANAGERS :
if field . rel . through . meta . auto created :
if len ( bits ) > NUM_ :
return None
out = text [ : end text pos ]
if lang code in supported and lang code is not None and check for language ( lang code ) :
c = in t ( text )
logger . warning ( STR_ , request . path , extra = { STR_ : NUM_ , STR_ : request } )
if not field name :
operations . extend ( smigration . operations )
num loopvars = len ( self . loopvars )
new name = new name . replace ( STR_ , STR_ )
total forms = self . max num
else :
for name in dir ( models . signals ) :
return self . text
if standard context processors is None :
return HashedSeq ( key )
len item = len ( item )
return path . decode ( fs encoding )
def validate name ( self , name , app or project ) :
field type , new params = field type
path = safe join ( self . location , name )
else :
exclude . append ( f . name )
def add arguments ( self , parser ) :
del form . cleaned data [ field ]
field type , field params , field notes = self . get field type ( connection , table name , row )
elif self . verbosity == NUM_ :
not found = [ ]
elif is in stance ( rhs , SafeBytes ) :
self . name = name
if upto ! = start :
from django . core . management . base import BaseCommand , CommandError
from django . utils import six
if not candidate :
def call ( self , template name , template dirs = None ) :
nodelist . contains nontext = True
from functools import partial
widget value = value [ i ]
errors = self . default error messages . copy ( )
setattr ( MovedItems , attr . name , attr )
from django . template import Template , Context
retval = self
PY2 = sys . version info [ NUM_ ] == NUM_
def get version ( self ) :
all models = [ ]
def j ( self ) :
g = generator . Generator ( fp , mangle from = False )
from django . conf import settings
if options [ STR_ ] > NUM_ :
if sub match :
name = self . get available name ( name )
if response is None :
handler . addQuickElement ( " STR_ " , item [ STR_ ] , guid attrs )
def do ifequal ( parser , token , negate ) :
widget = URLInput
except ValueError :
else :
if len values < NUM_ :
nodelist = parser . parse ( )
return . join ( self . fed )
if option == with :
raise CommandError ( " STR_ " % ( migration name , app label ) )
msgs = msgs . decode ( STR_ )
class ImmutableList ( tuple ) :
if len ( app labels ) > NUM_ and primary keys :
return check
e . django template source = token . source
escaper = lambda x : x
if self . required :
default attrs = { STR_ : STR_ , STR_ : STR_ }
except OSError as e :
return STR_ . join ( STR_ % e for e in self )
while path :
else :
return func ( * self . args , ** self . kw )
tz name = force text ( get current timezone name ( ) , errors = STR_ )
except ValueError :
logger = logging . getLogger ( STR_ )
level = NUM_
obj = getattr ( models . signals , name )
root [ : ] = [ root , root , None , None ]
connection = connections [ database ]
parser . add argument ( STR_ , nargs = STR_ , help = STR_ )
raise TemplateSyntaxError ( STR_ % ( bits [ NUM_ ] , option ) )
in t part = in t part gd [ : : - NUM_ ]
return formataddr ( ( nm , addr ) )
app config = apps . get app config ( app label )
try :
exp = Decimal ( NUM_ )
from django . core . management . base import AppCommand
return self . blocks [ name ] . pop ( )
t = getattr ( active , " STR_ " , None )
new value = strip once ( value )
return key in self . dicts [ - NUM_ ]
return
class ConvertingTuple ( tuple ) :
if parse until :
super ( DecimalField , self ) . validate ( value )
encoded = encoded . replace ( " STR_ " , " STR_ " ) . replace ( " STR_ " , " STR_ " )
return duplicate
if attrs is None :
base16 = BaseConverter ( BASE16 ALPHABET )
self . validate key ( key )
@ classmethod
args = [ STR_ ] + self . msguniq options + [ potfile ]
app configs = [ apps . get app config ( app label ) for app label in app labels ]
options = self . render options ( choices , [ value ] )
asvar = bits [ - NUM_ ]
nesting += NUM_
except AttributeError :
class DecimalField ( IntegerField ) :
def init ( self , convert charrefs = False , ** kwargs ) :
return output
if not self . fail silently :
import sys
bits . append ( force text ( bit ) )
self . empty label = None
self . file name = None
else :
if self . verbosity >= NUM_ :
@ property
if not hasattr ( parser , STR_ ) :
hidden widget = MultipleHiddenInput
def to python ( self , value ) :
or ig file = os . path . join ( self . dirpath , self . file )
from django . utils . ipv6 import clean ipv6 address
except ImportError :
if field type == STR_ :
return s
try :
outfile . write ( data )
return value
class EmailBackend ( ConsoleEmailBackend ) :
prefix = STR_ % self . app or project
if bad app labels :
from django . core . exceptions import ImproperlyConfigured
except IndexError :
parser . add argument ( STR_ , STR_ , choices = self . shells , dest = STR_ , help = STR_ )
m = regex . match ( date )
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
for event , node in self . event stream :
if i >= self . in itial form count ( ) and not form . has changed ( ) :
return self . source
args check = staticmethod ( args check )
return self . post
selected html =
v = datetime . datetime . strptime ( force str ( value ) , in put format )
return get wsgi application ( )
from yaml import CSafeDumper as SafeDumper
else :
@ property
def make decorator ( * m args , ** m kwargs ) :
help = " STR_ "
fmt = config . get ( STR_ , None )
raise TemplateDoesNotExist ( template name )
from django . utils . translation import trans null as trans
from django . utils import translation
def cache ( self ) :
s = s . decode ( encoding , errors )
def compile messages ( self , locations ) :
raise CommandError ( " STR_ " )
else :
if self . parsed :
for punctuation in TRAILING PUNCTUATION :
migration = executor . loader . get migration by prefix ( app label , migration name )
evens = sum ( in t ( c ) for c in candidate [ - NUM_ : : - NUM_ ] )
mtime -= stat . st ctime
new name = new name [ : - NUM_ ]
run ( self . addr , in t ( self . port ) , handler , ipv6 = self . use ipv6 , threading = threading )
import sys
connection . check constraints ( table names = table names )
except NameError :
try :
palette [ role ] = definition
if not bytes :
year = in t ( m . group ( STR_ ) )
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " % app label ) + " STR_ " )
def prepare value ( self , value ) :
else :
def handle fk field ( self , obj , field ) :
password = force bytes ( password )
class AppRegistryNotReady ( Exception ) :
kwargs [ STR_ ] = labels [ f . name ]
if self . parent instance is not None :
self . stdout . write ( " STR_ " % title )
from django . utils import timezone
self . stdout . write ( " STR_ " )
tzinfo . init ( self )
for attr in urllib parse moved attributes :
if opname not in roots :
command , source = self . command stack . pop ( )
try :
except OSError :
import shutil
query string = query string . decode ( )
sys . stderr = NullDevice ( )
raise UnrecognizedArchiveFormat ( " STR_ " % filename )
return os . path . join ( self . dirpath , self . file )
def reader enters ( self ) :
def handle inspection ( self , options ) :
stream class = BytesIO
if value is not None :
def setitem ( self , key , value ) :
for i , handler in enumerate ( handlers ) :
return True
super ( LocaleRegexURLResolver , self ) . init ( None , urlconf name , default kwargs , app name , namespace )
if is in stance ( loader , ( tuple , list ) ) :
if header == STR_ and is accept language redundant :
raise EnvironmentError ( " STR_ " " STR_ " % self . dir )
def render ( self , context ) :
from django . core import serializers
def init ( self , attrs = None , format = None ) :
bits = urlsplit ( location )
return value
raise
url fields [ NUM_ ] = url fields [ NUM_ ]
while k < endpos :
obj = Node ( connector = self . connector , negated = self . negated )
return None
else :
for child in node . childNodes :
except Exception :
logger . disabled = True
if not hasattr ( self , STR_ ) :
return
elif tzinfo is not None :
else :
dictConfigClass = DictConfigurator
nodelist false = parser . parse ( ( STR_ , ) )
os . makedirs ( self . file path )
l = len ( tokens )
if changes :
def add item elements ( self , handler , item ) :
if hasattr ( value , STR_ ) :
def strptime ( self , value , format ) :
self . close ( )
return match . group ( NUM_ )
except Exception as e :
def has changed ( self , in itial , data ) :
return force text ( value )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : val } , )
if renderer :
def autodiscover modules ( * args , ** kwargs ) :
connection = connections [ options [ STR_ ] ]
def color style ( ) :
class Http404 ( Exception ) :
def get max age ( response ) :
in ner args . extend ( args )
import smtplib
TEMPLATE FRAGMENT KEY TEMPLATE = STR_
def gen filenames ( only new = False ) :
wm = pyinotify . WatchManager ( )
return obj
else :
gettempdir = tempfile . gettempdir
def chunks ( self , chunk size = None ) :
from django . utils . deprecation import RemovedInDjango20Warning
def init ( self , value ) :
return callback ( request , ** param dict )
super ( Command , self ) . add arguments ( parser )
dec part = dec part [ : decimal pos ]
options [ k . lower ( ) ] = v
if not hasattr ( self , STR_ ) :
l = - ( - dklen // hlen )
def get name ( self ) :
self . stream = six . StringIO ( stream or string )
try :
else :
return lambda x : x
def comment ( parser , token ) :
class EmailBackend ( BaseEmailBackend ) :
try :
if transfer encoding == STR_ :
if kwargs :
try :
self . xml . startElement ( " STR_ " , { } )
return self . text words ( length , truncate )
else :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
status code = NUM_
if ch == + :
if len ( in itial ) ! = len ( data ) :
if len ( x ) == NUM_ :
endblock re = re . compile ( r " " " STR_ " " " )
from django . core . serializers . base import SerializerDoesNotExist
def exit ( self , exc type , exc value , traceback ) :
if not widget :
NON FIELD ERRORS = STR_
test runner = TestRunner ( ** options )
ISO INPUT FORMATS = { STR_ : ( STR_ , ) , STR_ : ( STR_ , STR_ , STR_ ) , STR_ : ( STR_ , STR_ , STR_ , STR_ ) , }
write pot file ( potfile , msgs )
from django . conf import settings
for key in keys :
return self . cache . add ( key , value , self . get backend timeout ( timeout ) )
if base64d [ : NUM_ ] == b STR_ :
salt = force bytes ( salt )
use grouping = use grouping and grouping > NUM_
elif self . reason phrase is None :
if is in stance ( value , list ) :
def encode ( self , i ) :
output , errors = p . communicate ( )
else :
else :
if self . use ssl and self . use tls :
self . closable objects . append ( value )
context [ STR_ ] = self
self . max width = max width
new class . base fields = fields
return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in [ STR_ , STR_ , STR_ , STR_ , STR_ ] )
import time
widget = HiddenInput
continue
except ( LookupError , TypeError ) :
full statement . append ( STR_ )
field params [ STR_ ] = col name
for app in sorted ( commands dict . keys ( ) ) :
return self . clear ( )
ULONG PTR = c ulong
lookups . appendlist ( pattern . callback , ( bits , p pattern , pattern . default args ) )
result = str ( in t ( round ( ratio ) ) )
LockFileEx = windll . kernel32 . LockFileEx
cull frequency = params . get ( STR_ , options . get ( STR_ , NUM_ ) )
for app config in apps . get app configs ( ) :
if self . cdata tag is not None :
return value
MIMEText . init ( self , text , subtype , charset )
basedirs = [ os . path . join ( os . path . dirname ( os . path . dirname ( file ) ) , STR_ , STR_ ) , STR_ ]
def fixture dirs ( self ) :
self . merge = options . get ( STR_ , False )
except KeyError :
self . stdout = OutputWrapper ( options . get ( STR_ , sys . stdout ) )
super ( TypedMultipleChoiceField , self ) . init ( * args , ** kwargs )
except IndexError :
path = path override if path override is not None else request . path
self . value = set ( force text ( v ) for v in self . value )
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
request repr = STR_ . format ( filter . get request repr ( request ) )
from django . db import connections , DEFAULT DB ALIAS
if memo is None :
if action == " STR_ " :
from django . core . validators import validate ipv4 address
if not self . use natural primary keys or not hasattr ( obj , STR_ ) :
if cwords [ NUM_ ] == STR_ :
in put type = STR_
data value = data if data is not None else
def add ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
tables = connection . in trospection . table names ( )
safe data = { }
if push is not None :
in t part gd += digit
return False
wsgi opts [ STR_ ] = options [ STR_ ] is not None
shells = [ STR_ , STR_ ]
warn msg = ( " STR_ " " STR_ " " STR_ " ) % ( c , filemsg , comment lineno cache )
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
os . rmdir ( tmpdir )
try :
id = widget . attrs . get ( STR_ ) or self . auto id
return self . META . get ( STR_ ) == STR_
return True
else :
self . starttag text = None
return self . stream . read ( * args , ** kwargs )
else :
if pop context :
nodes = [ ]
return False
from django . core . serializers import base
if not is in stance ( s , six . string types ) :
def get template from string ( source , or igin = None , name = None ) :
def handle ( self , app or project , name , target = None , ** options ) :
self . validators . remove ( self . regex validator )
raise TemplateSyntaxError ( STR_ STR_ % option )
reloader ( wrapped main func , args , kwargs )
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " % writer . filename ) + " STR_ " )
self . full clean ( )
path = [ path ]
raise self . error ( token , " STR_ " )
from future import unicode literals
if mtime ! = mtimes [ filename ] :
cursor . execute ( sql )
value = - + value
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
if dirname and not os . path . exists ( dirname ) :
for f in opts . concrete fields + opts . virtual fields + opts . many to many :
truncate len = length
shutil . rmtree ( path to remove , onerror = rmtree errorhandler )
try :
return
return ( STR_ )
class DateTimeField ( BaseTemporalField ) :
imatch = in line re . match ( t . contents )
for pattern in self . url patterns :
data set = set ( force text ( value ) for value in data )
from . . import Warning , register , Tags
parser . add argument ( STR_ , nargs = * )
if len ( words ) > length :
return self . post , self . files
opts . fields = None
self . saved forms . append ( form )
def media ( self ) :
return True
field desc += STR_
import decimal
from django . conf import settings
space = " "
formatted = " STR_ " . join ( sorted ( formatted ) )
if response . streaming :
def add library ( self , lib ) :
def split url ( url ) :
try :
singular = [ ]
from django . conf import settings
if self . feed [ STR_ ] is not None :
try :
else :
sys . exit ( NUM_ )
self . fed . append ( STR_ % name )
in cremental = config . pop ( STR_ , False )
else :
self . non form errors = None
self . post parse error = True
if match :
from django . core . management . base import BaseCommand , CommandError
exp = Decimal ( STR_ ) / ( Decimal ( NUM_ ) ** abs ( p ) )
parser . ExternalEntityRefHandler = self . external entity ref handler
if age > max age :
super ( SimpleCookie , self ) . load ( rawdata )
def listdir ( self , path ) :
from django . utils . encoding import force bytes , force str , force text
if app label not in executor . loader . migrated apps :
from django . conf import settings
return format html ( STR_ , option value , selected html , force text ( option label ) )
return DebugVariableNode ( contents )
self . appendlist ( force text ( key , encoding , errors = STR_ ) , force text ( value , encoding , errors = STR_ ) )
temp lib . tags [ name ] = lib . tags [ name ]
def execute ( self ) :
for header in cc delim re . split ( response [ STR_ ] ) :
def execute from command line ( argv = None ) :
deactivate ( )
for char in fmt :
return tf . format ( format string )
class HttpRequest ( object ) :
obj = self . var
return patterns
LOCK NB = fcntl . LOCK NB
namespaces [ namespace ] = ( p pattern + prefix , sub pattern )
result . queryset = result . queryset
if not hasattr ( e , STR_ ) :
yield " STR_ "
return self . add truncation text ( text [ : end index or NUM_ ] , truncate )
import os
cursor = connection . cursor ( )
try :
def utcoffset ( self , dt ) :
value = var . resolve ( context , True )
@ staticmethod
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
except KeyError :
if not dklen :
si = open ( STR_ , STR_ )
class Command ( BaseCommand ) :
if hasattr ( middleware , STR_ ) :
default error messages = { STR_ : ( STR_ ) , }
self . stderr . write ( " STR_ " " STR_ " " STR_ " % new path , self . style . NOTICE )
from future import unicode literals
else :
meth self = " STR_ "
output = [ ]
def constant time compare ( val1 , val2 ) :
for middleware method in self . request middleware :
self . in stance . full clean ( exclude = exclude , validate unique = False )
if cls . delegate text :
self . args = args
def get context stack frame ( self , context ) :
from django . db . migrations . autodetector import MigrationAutodetector
msg [ STR_ ] = self . subject
self . errors [ field ] = self . error class ( error class = STR_ )
expires = None
if options . pythonpath :
self . name = name
from django . utils . module loading import module has submodule
def iter ( self ) :
def regroup ( parser , token ) :
if self . verbosity >= NUM_ :
locales = set ( locales ) - set ( exclude )
if html :
class NullBooleanSelect ( Select ) :
pass
from django . utils . itercompat import is iterable
opts = tuple ( s for s in styles if s in opt dict . keys ( ) )
in teger types = in t ,
mime type = STR_
class ModelFormMetaclass ( DeclarativeFieldsMetaclass ) :
def clean ( self ) :
TYPE = FIELD
def keys ( self ) :
class Form ( six . with metaclass ( DeclarativeFieldsMetaclass , BaseForm ) ) :
del serializers [ format ]
from django . utils . encoding import force bytes , force text , force str , iri to uri
file = file or path
if not strict :
from future import unicode literals
raise Resolver404 ( { STR_ : tried , STR_ : new path } )
return [ field for field in self if field . is hidden ]
attrs plus [ STR_ ] += STR_ . format ( i )
view = transaction . atomic ( using = db . alias ) ( view )
class Command ( BaseCommand ) :
return MONTHS 3 [ self . data . month ] . title ( )
validate ipv46 address ( ip address )
else :
settings . USE I18N = True
self . base url = base url
if daemonize :
generic lang code = lang code . split ( - ) [ NUM_ ]
def setitem ( self , name , val ) :
error = ValidationError ( error )
c = self . resolve ( c )
wrapper . cache info = cache info
def get unique error message ( self , unique check ) :
message . message = error messages [ message . code ]
if e . errno ! = errno . ENOENT :
LockFileEx . restype = BOOL
super ( QueryDict , self ) . setlist ( key , list )
in verse match = False
except Exception as e :
decompress = False
if use grouping :
result = super ( SortedDict , self ) . popitem ( )
while token . contents . startswith ( elif ) :
for , nodelist in self . conditions nodelists :
for t in Lexer ( src , or igin ) . tokenize ( ) :
return out
statements = connection . ops . sequence reset sql ( self . style , models )
return getattr ( in stance , name ) ( value )
compare = lambda self , a , b : a < b
daemonize = False
import subprocess
@ register . tag ( if )
from django . forms . forms import DeclarativeFieldsMetaclass , BaseForm
requires system checks = False
def filter ( self , record ) :
result . parent = self
def execute ( self , * args , ** options ) :
warnings . warn ( " STR_ " % ( self . class name , self . old method name , self . new method name ) , self . deprecation warning , NUM_ )
self . current app = current app
def delete ( self , key , version = None ) :
get git changeset . cache = changeset
output = [ ]
self . timezone = get default timezone ( )
exp = exp . replace ( microsecond = NUM_ )
@ classmethod
extra params [ STR_ ] = True
from django . apps import apps
def str ( self ) :
def get standard processors ( ) :
upto = end
import imp
cache key = STR_ % ( key prefix , method , url . hexdigest ( ) , ctx . hexdigest ( ) )
self . COOKIES = { }
class TemplateTagNode ( Node ) :
from django . utils . timezone import get current timezone name
except TemplateSyntaxError as e :
@ property
raise
import threading
mask = ( pyinotify . IN MODIFY | pyinotify . IN DELETE | pyinotify . IN ATTRIB | pyinotify . IN MOVED FROM | pyinotify . IN MOVED TO | pyinotify . IN CREATE )
class CheckboxFieldRenderer ( ChoiceFieldRenderer ) :
if val is None :
from django . utils . html import conditional escape , format html
except AttributeError :
return any ( self . dicts )
self . assert mutable ( )
while True :
pass
def I ( self ) :
else :
raise ImproperlyConfigured ( " STR_ " " STR_ " " STR_ " % name )
if self . verbosity >= NUM_ :
self . content type extra = None
args . append ( self . choices )
from django . core import signing
self . pointer = i
return get resolver ( urlconf ) . resolve ( path )
else :
return set ( chain ( * [ check . tags for check in self . registered checks if hasattr ( check , STR_ ) ] ) )
return ZERO
def COOKIES ( self ) :
requires system checks = False
TestRunner = get runner ( settings , options . get ( STR_ ) )
def iterkeys ( self ) :
data = self . coerce ( data )
if key not in self :
if child . nodeType == child . TEXT NODE or child . nodeType == child . CDATA SECTION NODE :
with connection . cursor ( ) as cursor :
def make parser ( self ) :
if pattern . app name :
if options [ " STR_ " ] is None :
show traceback = options . get ( STR_ )
parser . add argument ( STR_ , metavar = STR_ , nargs = * , help = STR_ )
return value
self . set payload ( text , utf8 charset )
return bool ( self . name )
return NUM_
class ReferenceLocalTimezone ( tzinfo ) :
def init ( self , template , context = None , content type = None , status = None ) :
date data = ( date . year , date . month , date . day )
return NUM_ << NUM_
def server bind ( self ) :
logger . addHandler ( self . config [ STR_ ] [ h ] )
else :
from django . utils import six
from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning
if filename :
if settings . TEMPLATE DEBUG and or igin is None :
def add metaclass ( metaclass ) :
p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE , close fds = os . name ! = STR_ , universal newlines = True )
from io import BytesIO
def init ( self , view name , args , kwargs , asvar ) :
return datetime . fromtimestamp ( os . path . getatime ( self . path ( name ) ) )
app configs = reversed ( list ( apps . get app configs ( ) ) )
class dummy :
def init ( self , * args , ** kwargs ) :
sign = - if offset < NUM_ else +
return text
help = " STR_ "
zfile = GzipFile ( mode = STR_ , compresslevel = NUM_ , fileobj = buf )
def value from datadict ( self , data , files , name ) :
continue
return escapejs ( value )
return self . keyOrder [ : ]
from django . utils . module loading import import string
for field in model . meta . many to many :
try :
continue
locale dir = self . default locale path
pass
from django . db . backends . utils import typecast timestamp
class MultiWidget ( Widget ) :
self . stdout . write ( self . style . SQL KEYWORD ( connection . ops . start transaction sql ( ) ) )
self . stdout . write ( STR_ % get text list ( list ( self . extensions ) , and ) )
def clean ( self , value ) :
in itial set = set ( force text ( value ) for value in in itial )
max width = in t ( self . max width . resolve ( context ) )
except TypeError :
def parse color setting ( config string ) :
response = middleware method ( request )
target app labels only = False
try :
import cgi
for func in self . response fixes :
if not match :
try :
def handle m2m ( value ) :
neg , value = self . convert ( s , self . digits , self . decimal digits , self . sign )
else :
except TypeError :
words [ i ] = mark safe ( STR_ % ( lead , middle , trail ) )
try :
def get storage class ( import path = None ) :
if proto >= NUM_ :
load serializers ( )
if safe and not is in stance ( data , dict ) :
from django . db . migrations . loader import MigrationLoader , AmbiguityError
def ne ( self , other ) :
def create message ( self , msg ) :
return True
return errors
candidate subs = dict ( zip ( prefix args + params , text args ) )
self . creation counter = Field . creation counter
name = self . fk . name
from itertools import product
from django . utils . safestring import mark safe , SafeData
chunk = stream . read ( max header size )
db name = connection . creation . create test db ( verbosity = verbosity , autoclobber = not in teractive , serialize = False )
self . lookups = tuple ( var . split ( VARIABLE ATTRIBUTE SEPARATOR ) )
else :
out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ]
parser . add argument ( STR_ , nargs = argparse . REMAINDER , help = STR_ )
if self . cmd . called from command line :
if version is None :
return backend cls ( location , params )
continue
return smart text ( auto id ) % self . html name
push = block = block context . pop ( self . name )
return AssignmentNode ( takes context , args , kwargs , target var )
pass
return i18n cache key suffix ( request , cache key )
return singular suffix
if not is in stance ( value , list ) :
def validate key ( self , key ) :
if not is in stance ( s , six . string types ) :
try :
full module name = package name + STR_ + module name
from future import unicode literals
field output . append ( " STR_ " )
representative = ESCAPE MAPPINGS . get ( ch , ch )
class CheckMessage ( object ) :
elif not is in stance ( value , ( list , tuple ) ) :
def unescape entities ( text ) :
default error messages = { STR_ : ( STR_ ) }
ORDERING FIELD NAME = STR_
response [ STR_ ] = STR_ . join ( vary headers + additional headers )
stream = LazyStream ( ChunkIter ( self . input data , self . chunk size ) )
model dependencies . append ( ( model , deps ) )
elif option == STR_ :
class LabelCommand ( BaseCommand ) :
fixture dirs = [ os . path . dirname ( fixture name ) ]
self . cull ( )
if in itial is None :
@ stringfilter
raise NotImplementedError ( STR_ )
raise ValidationError ( self . message , code = self . code )
Module six moves urllib parse . moved attributes = urllib parse moved attributes
shutil . copymode ( old path , new path )
value = new value
delta = delta + datetime . timedelta ( seconds = NUM_ )
handler . endElement ( " STR_ " )
time re = re . compile ( r STR_ r STR_ )
return quote ( force bytes ( path ) . replace ( b " STR_ " / " STR_ " / ~ ! * ( ) " )
except Exception :
return self . get connection ( fail silently ) . send messages ( [ self ] )
return self . open ( name , mode )
with connections [ db ] . cursor ( ) as cursor :
class ChoiceInput ( SubWidget ) :
if is in stance ( s , Exception ) :
bit = node
return True
def in cr ( self , key , delta = NUM_ , version = None ) :
raise TemplateSyntaxError ( " STR_ " " STR_ " % token . contents )
class FixedOffset ( tzinfo ) :
in ner result . extend ( res )
def init ( self , file = None , name = None , content type = None , size = None , charset = None , content type extra = None ) :
state frame = self . get context stack frame ( context )
def as text ( self , attrs = None , ** kwargs ) :
if lib :
if unicodedata . combining ( char ) :
import hashlib
def listdir ( self , path ) :
def setitem ( self , name , val ) :
return { STR_ : timezone . get current timezone name ( ) }
def http date ( epoch seconds = None ) :
else :
except AttributeError :
try :
def delete ( self , key , version = None ) :
global format cache , format modules cache
context [ self . asvar ] = result
if model not in app list value :
elif options [ " STR_ " ] . lower ( ) in ( STR_ , STR_ , STR_ ) :
self . add filters ( logger , filters )
decorator = Node ( syms . decorator , [ Leaf ( token . AT , " STR_ " ) , Name ( STR_ ) ] )
continue
def ungettext ( singular , plural , number ) :
else :
candidate pat = prefix norm . replace ( % , STR_ ) + result
return [ " " , " STR_ " , " STR_ " , " STR_ " % table name ]
obj pk = field . rel . to . meta . pk . to python ( n . getAttribute ( STR_ ) )
data = self . to python ( data )
self . startElement ( name , attrs )
def pretty name ( name ) :
return trans . check for language ( lang code )
exclude = self . get validation exclusions ( )
else :
for frag in name :
self . request = datastructures . MergeDict ( self . POST , self . GET )
urlconfs . value = urlconf name
self . in itial = in itial or { }
class Archive ( object ) :
if self . help :
self . stdout . write ( " STR_ " , self . style . MIGRATE FAILURE )
try :
except UnicodeEncodeError :
if kwargs . get ( STR_ ) and self . widget == NumberInput :
finally :
self . to = list ( to )
if in stance is None :
return True
link [ PREV ] = last
for cache alias in settings . CACHES :
from future import unicode literals
self . months = months
def open ( self , mode = None ) :
for name in pattern . reverse dict :
class ChoiceField ( Field ) :
from django . conf . locale import LANG INFO
msg . attach ( self . create mime attachment ( * alternative ) )
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
memo [ id ( self ) ] = result
return not ( self == other )
with connection . cursor ( ) as curs :
print ( " STR_ " % ( name , member . name , exc ) )
from django . core . cache . backends . base import BaseCache , DEFAULT TIMEOUT
best doublecolon start = - NUM_
t = select template ( file name )
if missing fields :
cursor . execute ( sql )
related att = getattr ( obj , field . get attname ( ) )
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
parser . delete first token ( )
matches = filter re . finditer ( token )
args , kwargs = parse bits ( parser , bits , params , varargs , varkw , defaults , takes context , function name )
from io import BytesIO
base36 = BaseConverter ( BASE36 ALPHABET )
super ( DateTimeBaseInput , self ) . init ( attrs )
except ValueError :
in itial = bool ( in itial )
def init ( self , value , text ) :
if i >= len ( subject ) :
global cached modules , cached filenames
self . prefix = prefix or self . get default prefix ( )
best doublecolon len = NUM_
def list ( self , * args , ** kwargs ) :
new context [ STR_ ] = csrf token
else :
r = r [ : NUM_ ]
lookups . appendlist ( name , ( new matches , p pattern + pat , dict ( defaults , ** pattern . default kwargs ) ) )
if literal match :
def add prefix ( self , in dex ) :
self . waiting writers -= NUM_
if self . connection :
import contextlib
request = None
password = digest ( password ) . digest ( )
if number == NUM_ and self . allow empty first page :
return repr ( list ( self ) )
formfield = self . fields [ field name ]
logger . removeHandler ( h )
def add arguments ( self , parser ) :
if not file name :
if schemes is not None :
cursor . execute ( " STR_ " % table , [ key ] )
from django . utils import six
if self . field . empty label is not None :
raise
raise ValueError ( " STR_ " % timezone )
request finished = Signal ( )
field value = value [ i ]
try :
self . post render callbacks . append ( callback )
in put formats = formats . get format lazy ( STR_ )
mapped tokens = [ ]
parser . delete first token ( )
active = local ( )
while True :
def P ( self ) :
def endChannelElement ( self , handler ) :
pass
self . changed data . append ( name )
return
self . per page = in t ( per page )
empty value = None
from django . db . migrations . executor import MigrationExecutor
self . none value = ( NUM_ , empty label )
self . regex = regex
import sys
for i , ( dirpath , f ) in enumerate ( locations ) :
for item in sequence :
field value = None
except ( ValueError , TypeError ) :
self . name = name
print ( " STR_ " + flup module )
return self . template cache [ key ]
current = current [ in t ( bit ) ]
else :
def get dump object ( self , obj ) :
del Trans
escaper = conditional escape
if in plural :
serializers = { }
parse = sys . modules [ name + " STR_ " ]
return self
assertRaisesRegex = " STR_ "
request . resolver match = resolver match
def init ( self ) :
output = self . nodelist . render ( context )
class LoadNode ( Node ) :
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
from django . template . base import Origin , Template , Context , TemplateDoesNotExist
with self . lock . reader ( ) :
def init ( self , token type , contents ) :
dictConfigClass ( config ) . configure ( )
return self . as widget ( Textarea ( ) , attrs , ** kwargs )
RFC850 DATE = re . compile ( r STR_ % ( D , M , Y2 , T ) )
def validate ( self , value ) :
return STR_ % ( self . g ( ) , self . i ( ) )
if t is not None :
self . file . seek ( NUM_ )
self . subject = subject
num existing = len ( existing )
e . django template source = node . source
return mark safe ( self . format output ( output ) )
if is in stance ( title , ( list , tuple ) ) :
return number format ( value , use l10n = use l10n )
if not cookie encodes correctly :
return STR_ % RESET
return random module . choice ( value )
except OSError as e :
return tempdir
msgattrib options = [ STR_ ]
def popitem ( self ) :
def widthratio ( parser , token ) :
if self . id for label :
def save existing objects ( self , commit = True ) :
filename . encode ( STR_ )
def urlizetrunc ( value , limit , autoescape = None ) :
id = final attrs . get ( STR_ , None )
elif cmatches :
options = [ opt for opt in options if opt [ NUM_ ] not in prev opts ]
res = func ( * self . args , ** self . kw )
data = data . replace ( microsecond = NUM_ )
if self . is bound :
self . file . size = file size
def upload handlers ( self , upload handlers ) :
try :
if class in attrs :
def handle charref ( self , name ) :
@ encoding . setter
def handle raw input ( self , in put data , META , content length , boundary , encoding = None ) :
nodelist loop = parser . parse ( ( else , end tag ) )
script name = get bytes from wsgi ( environ , STR_ , )
from django . db import models , DEFAULT DB ALIAS
from django . db import connection
class datetime ( real datetime ) :
sec = in t ( m . group ( STR_ ) )
except IndexError :
result = logging . Formatter ( fmt , dfmt )
def tzname ( self , dt ) :
i = self . pointer
widget . is localized = True
result = super ( MultiValueField , self ) . deepcopy ( memo )
self . sysid = sysid
output , references = connection . creation . sql create model ( model , style , known models )
get ns resolver . cache clear ( )
if num loopvars ! = len item :
import types
cmd options = vars ( options )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
except KeyError :
if key not in self :
m = in t ( d ) - d
response [ STR_ ] = request . build absolute uri ( response [ STR_ ] )
raise base . DeserializationError ( " STR_ " % model identifier )
def compress ( self , data list ) :
if sys . version info [ NUM_ ] <= NUM_ :
if arg < NUM_ :
return ZERO
def reset ( self ) :
response . handler class = self . class
return
import os
if self . body :
raise ImproperlyConfigured ( STR_ )
def localtime ( value , timezone = None ) :
if STR_ in locale :
if location is None :
def send mass mail ( datatuple , fail silently = False , auth user = None , auth password = None , connection = None ) :
from future import unicode literals
except ( ValueError , TypeError ) :
def save ( self , commit = True ) :
length = in t ( num )
file name = disposition . get ( STR_ )
data [ Model . meta . pk . attname ] = Model . meta . pk . to python ( node . getAttribute ( STR_ ) )
patterns = getattr ( self . urlconf module , " STR_ " , self . urlconf module )
def add to builtins ( module ) :
def eq ( self , other ) :
if self . has expired ( key ) :
return
from django . utils import six
hidden fields . append ( six . text type ( bf ) )
del self . tokens [ NUM_ ]
def init ( self , name ) :
if fixture name ! = STR_ and not fixture files :
def modelform defines fields ( form class ) :
call = type . call
self . token = token
if new conn created :
def addQuickElement ( self , name , contents = None , attrs = None ) :
self . handle starttag ( tag , attrs )
if not self . keep pot :
class Options ( object ) :
key = bytes to text ( key , self . encoding )
def remove move ( name ) :
elif is in stance ( value , datetime . datetime ) :
self . reader leaves ( )
return binascii . unhexlify ( ( hex format string % x ) . encode ( STR_ ) )
if STR_ not in arg :
pass
for cmatch in cmatches :
nodelist loop = parser . parse ( ( STR_ , STR_ , ) )
yield self [ key ]
try :
import os
merge migrations = [ ]
attrs = super ( IntegerField , self ) . widget attrs ( widget )
def strftime ( self , fmt ) :
if truncate text :
iteritems = iteritems
from collections import OrderedDict
def add arguments ( self , parser ) :
def phone2numeric filter ( value ) :
supports microseconds = False
use reloader = options . get ( STR_ )
response . add post render callback ( set response etag )
except BASE64 DECODE ERROR :
attrs = dict ( attrs or { } , ** { for : id for label } )
migration = executor . loader . get migration by prefix ( app label , migration name )
if sep is not None :
M = r STR_
return django . get version ( )
msg = ( " STR_ " " STR_ " " STR_ " )
if len ( bits ) < NUM_ or bits [ NUM_ ] ! = as :
yield field , list ( ValidationError ( errors ) )
from lib2to3 import fixer base
out . write ( STR_ % join tokens ( singular , trimmed ) )
content = content or b
self . code = code
import struct
self . upload handlers = [ uploadhandler . load handler ( handler , self ) for handler in settings . FILE UPLOAD HANDLERS ]
criticals = [ e for e in all issues if checks . CRITICAL <= e . level ]
obj = template localtime ( obj , context . use tz )
if truncate len == NUM_ :
form = self . forms [ i ]
else :
if is in stance ( number , in t ) and not use grouping and not decimal pos :
return self . forms [ NUM_ ] . media
if value in self . empty values :
continue
= { }
raise NotImplementedError ( STR_ )
if s [ NUM_ ] not in " STR_ " or s [ - NUM_ ] ! = s [ NUM_ ] :
else :
self . cull ( db , cursor , now )
else :
except VariableDoesNotExist :
unhandled params = list ( params )
fields = list ( six . iteritems ( base . declared fields ) ) + fields
class EventHandler ( pyinotify . ProcessEvent ) :
def init ( self , options = None ) :
styles = in structions . split ( STR_ )
output = template localtime ( output , use tz = context . use tz )
for i , ( seconds , name ) in enumerate ( chunks ) :
from django . template . base import Variable , Library , VariableDoesNotExist
import sys
return True
return df . format ( format string )
from django . core . management . base import BaseCommand , CommandError
try :
def handle m2m field ( self , obj , field ) :
plan = executor . migration plan ( targets )
if locs is None :
if self . num pages is None :
d [ k ] = val
if six . PY2 :
for app config in apps . get app configs ( ) :
self . request = request
if ( domain part not in self . domain whitelist and not self . validate domain part ( domain part ) ) :
except KeyError :
else :
filename = os . path . join ( to path , name )
if self . field . label is None :
raise ValueError ( " STR_ " % ch )
return data
cursor . execute ( statement )
import django . core . checks . compatibility . django 1 7 0
try :
if PY3 :
parser . add argument ( STR_ , metavar = STR_ , nargs = + , help = STR_ )
self . dict . update ( state )
pass
if plen < ( alen - dlen ) or plen > alen :
exhaust ( stream )
from django . db . migrations . writer import MigrationWriter
for name in self . fields :
u = dig2 . digest ( )
class TimestampSigner ( Signer ) :
parser . add argument ( STR_ , default = None , dest = STR_ , type = in t , help = STR_ )
class = property ( new method proxy ( operator . attrgetter ( " STR_ " ) ) )
def repr ( self ) :
BaseCache . init ( self , * args , ** kwargs )
encoding = STR_
def learn cache key ( request , response , cache timeout = None , key prefix = None , cache = None ) :
elif STR_ in cc and STR_ in kwargs :
contents = format html ( STR_ , attrs , contents )
if is in stance ( s , bytes ) :
template with clear = STR_
elif name is not None and filter func is not None :
if exctype is not WindowsError or STR_ not in str ( value ) :
def tell ( self ) :
if result is not None :
from django . utils import lru cache
logger . error ( STR_ , request . path , exc info = exc info , extra = { STR_ : NUM_ , STR_ : request } )
def init ( self , name ) :
from django . core . servers . fastcgi import FASTCGI OPTIONS
self . loader , self . loadname , self . dirs = loader , name , dirs
value = STR_
msg count += NUM_
supported = OrderedDict ( settings . LANGUAGES )
from importlib import import module
return DefusedExpatParser ( )
self . blocks = dict ( ( n . name , n ) for n in nodelist . get nodes by type ( BlockNode ) )
if not router . allow migrate ( database , cache . cache model class ) :
call command ( " STR_ " , ** options )
return self . parent widget . render ( * args )
from django . template . base import TemplateDoesNotExist
message = ( STR_ STR_ STR_ )
readline . set completer ( rlcompleter . Completer ( imported objects ) . complete )
for cache in caches . all ( ) :
continue
if options . get ( STR_ ) :
i += NUM_
for name in MEDIA TYPES :
if i < NUM_ :
raise ValueError ( " STR_ " )
else :
def m ( self ) :
add doc ( get unbound function , " " " STR_ " " " )
def build attrs ( self , extra attrs = None , ** kwargs ) :
out . write ( blankout ( part , STR_ ) )
self . allow empty file = kwargs . pop ( STR_ , False )
def delete ( self , key ) :
if not hasattr ( self , STR_ ) :
piece = . join ( source [ last : ] )
return sites
response = func ( request , response )
for role in termcolors . PALETTES [ termcolors . NOCOLOR PALETTE ] :
import types
self . connection . sendmail ( from email , recipients , message . as bytes ( ) )
checkbox id = self . clear checkbox id ( checkbox name )
deps . append ( rel model )
value = self . to python ( value ) . strip ( )
parser . add option ( opt )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ ) ,
if is templatized :
for pattern in reversed ( self . url patterns ) :
except ImportError :
if not func name :
import json
return self
def init ( self , content ) :
self . archive . printdir ( * args , ** kwargs )
@ register . filter ( is safe = False )
if STR_ in str number :
from django . utils . functional import cached property
if ignore :
for var in self . vars :
return . join ( base36 )
def get text list ( list , last word = ugettext lazy ( or ) ) :
WindowsError = WindowsError
def runfastcgi ( argset = [ ] , ** kwargs ) :
def lock ( f , flags ) :
handler . startDocument ( )
def init ( self , attrs = None , years = None , months = None , empty label = None ) :
@ wraps ( fdel )
@ lru cache . lru cache ( maxsize = NUM_ )
if getattr ( e , STR_ , NUM_ ) ! = NUM_ and getattr ( e , STR_ , NUM_ ) ! = NUM_ :
self . month none value = ( NUM_ , empty label [ NUM_ ] )
yield
def repr ( self ) :
file = os . fdopen ( fd , mode )
assertCountEqual = " STR_ "
class SortedDict ( dict ) :
ret = LockFileEx ( hfile , flags , NUM_ , NUM_ , NUM_ xFFFF0000 , byref ( overlapped ) )
def is aware ( value ) :
return False
self . importer ( used )
def close ( self ) :
output . extend ( custom sql for model ( model , style , connection ) )
models . signals . pre migrate . send ( sender = app config , app config = app config , verbosity = verbosity , in teractive = in teractive , using = db )
root = nonlocal root [ NUM_ ] = oldroot [ NEXT ]
if current len == truncate len :
formatters = config . get ( STR_ , EMPTY DICT )
except ValueError :
parser = self . parser
converter = self . value converters . get ( prefix , None )
import threading
d = m . groupdict ( )
version = " STR_ "
field type = STR_ % rel to
nofollow attr =
def string concat ( * strings ) :
return super ( SortedDict , self ) . setdefault ( key , default )
elif ns not in app list :
else :
for chunk in self . chunks ( ) :
self . choices = choices
def format ( self , formatstr ) :
data = obj dict . pop ( STR_ , { } )
return
super ( SplitDateTimeWidget , self ) . init ( widgets , attrs )
def s ( self ) :
def wrapper ( cls ) :
path = self . path ( path )
pdict [ name ] = value
else :
raise ValueError ( " STR_ " % key )
return iri
for name , block in six . iteritems ( blocks ) :
for statement in sql statements :
def create alternatives ( self , msg ) :
if self . language == settings . LANGUAGE CODE or self . language == " STR_ " :
tzinfo . init ( self )
def make aware ( value , timezone ) :
if is in stance ( s , ( SafeData , EscapeData ) ) :
class EmailInput ( TextInput ) :
pass
from django . utils import six
return settings . DEBUG
id = self . attrs . get ( STR_ , None )
try :
super ( HttpResponseNotAllowed , self ) . init ( * args , ** kwargs )
def wrapper ( * args , ** kw ) :
self . file . exit ( exc , value , tb )
opts = model . meta
extra params . update ( params )
def get many ( self , keys , version = None ) :
return mark safe ( result )
regex = re . compile ( r STR_ r STR_ r STR_ r STR_ r STR_ r STR_ r STR_ , re . IGNORECASE )
m = plural forms re . search ( fp . read ( ) )
if self . use ipv6 and not socket . has ipv6 :
self . count = len ( self . object list )
from django . utils . deprecation import RemovedInDjango19Warning
if not use workaround :
self . size = self . get size from underlying file ( )
else :
return STR_ % self . g ( )
except ( AttributeError , UnsupportedOperation ) :
pkg name = STR_ + template name
old app dir = os . path . normpath ( os . path . join ( app dir , STR_ ) )
return self . request
else :
def end object ( self , obj ) :
open ( in it path , " STR_ " ) . close ( )
key = self . cache key ( template name , template dirs )
fn = in otify code changed
value = dict . get ( self , key , default )
self . settings exception = None
from django . apps import apps
raise
return s
dklen = None
return ret
field = Model . meta . get field ( field name )
compare to = None
plural . append ( contents )
raise NotImplementedError ( STR_ )
sub match = pattern . resolve ( new path )
else :
self . read started = False
val = force text ( val )
return result . lower ( )
if " STR_ " in options :
tell = property ( lambda self : self . file . tell )
self . object dict = dict ( ( o . pk , o ) for o in self . get queryset ( ) )
if settings . SETTINGS MODULE :
return STR_ % ( t [ NUM_ ] , t [ NUM_ ] )
def get default timezone ( ) :
except ValueError :
@ stringfilter
nodelist = parser . parse ( ( STR_ , ) )
self . directory permissions mode = ( directory permissions mode if directory permissions mode is not None else settings . FILE UPLOAD DIRECTORY PERMISSIONS )
for node in self :
self . vars = variables
LOCK EX = fcntl . LOCK EX
if app config . models module is None or app config in excluded apps :
return WidthRatioNode ( parser . compile filter ( this value expr ) , parser . compile filter ( max value expr ) , parser . compile filter ( max width ) , asvar = asvar )
return value
yield key , self [ key ]
raise TemplateDoesNotExist ( name )
class SimpleUploadedFile ( InMemoryUploadedFile ) :
value , decimals = value . split ( decimal separator , NUM_ )
match = True
from django . utils import six
base subdir = STR_ % app or project
from future import unicode literals
def force text ( s , encoding = STR_ , strings only = False , errors = STR_ ) :
self . upload handlers = ImmutableList ( self . upload handlers , warning = " STR_ " )
else :
except ( ValueError , TypeError ) :
template source loaders = None
return
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
def is expired ( self , f ) :
else :
class DeserializedObject ( object ) :
from future import unicode literals
return self . nodelist false . render ( context )
if self . language == settings . LANGUAGE CODE :
sep = kwargs . pop ( " STR_ " , None )
WARNING = NUM_
if path . startswith ( ( STR_ , STR_ , / ) ) :
global default
kwargs [ key ] = parser . compile filter ( value )
break
else :
if ( ( os . stat ( path ) . st mode & stat . S IREAD ) ! = stat . S IREAD ) :
filename , display url = cleanup url ( url )
if six . PY2 and not is in stance ( path , bytes ) :
import itertools
self . years = range ( this year , this year + NUM_ )
domain part = domain part . encode ( STR_ ) . decode ( STR_ )
if self closing or tagname in html4 singlets :
tags re = STR_ % | . join ( tags )
class RegexField ( CharField ) :
res = to digits [ NUM_ ]
elif options [ STR_ ] in ( STR_ , STR_ ) :
if value is not result :
self [ STR_ ] = STR_ . join ( permitted methods )
self . event stream = pulldom . parse ( self . stream , self . make parser ( ) )
while NUM_ :
raise AttributeError ( " STR_ " )
t = s . split ( = , NUM_ )
class HttpResponseBase ( six . Iterator ) :
in stance = construct instance ( form , in stance , fields , exclude )
e . reason += STR_ % charset
with self . lock . writer ( ) :
prefix += /
oldroot [ KEY ] = key
return self . dispatch [ t ] [ funcname ] ( res , * args , ** kw )
kwargs [ " STR_ " ] = self . parent instance . pk
else :
if field . rel . through . meta . auto created :
cache timeout = NUM_
else :
method = kwargs . pop ( STR_ )
elif form . has changed ( ) :
if code is not None :
if k == STR_ :
return self . filter function ( name , ** flags )
def F ( self ) :
elif settings . USE TZ :
parsed = urlparse ( force text ( redirect to ) )
def raw value ( self , fieldname ) :
command = token . contents . split ( ) [ NUM_ ]
def L ( self ) :
ns resolver = RegexURLResolver ( ns pattern , resolver . url patterns )
current len += NUM_
paras = [ STR_ % escape ( p ) . replace ( STR_ , STR_ ) for p in paras ]
return func ( context , self . first )
if not squash :
def render ( self , context ) :
for field node in node . getElementsByTagName ( " STR_ " ) :
url info = urlparse ( url )
self . label suffix = label suffix
if not self . has expired ( key ) :
thousand sep = get format ( STR_ )
if val is not None :
pass
sites . append ( site )
iter = xreadlines
return
from django . db . models . fields import Field as ModelField
self . error dict = { }
super ( Command , self ) . add arguments ( parser )
elif finder . find module ( name ) :
if is in stance ( field , InlineForeignKeyField ) :
try :
if hasattr ( text , STR_ ) :
else :
if not settings . configured :
MovedItems . moved attributes = moved attributes
message . message ( )
def ugettext ( message ) :
self . js = [ ]
if is in stance ( f , models . FileField ) :
if self . language is not None :
BM compatible = True
def get language from path ( path ) :
widget = TimeInput
output . append ( pformat ( sys . modules ) )
kwargs = { }
else :
def copy ( self ) :
template = template [ NUM_ : ]
if os . path . is dir ( os . path . join ( path , entry ) ) :
raise BadHeaderError ( " STR_ " % ( val , name ) )
for widget in self . widgets :
self . num pages = self . count = None
def dst ( self , dt ) :
if command in parse until :
os . mkdir ( migrations directory )
if truncate is None :
raise CommandError ( " STR_ " " STR_ " % program )
def make style ( opts = ( ) , ** kwargs ) :
for model in model list :
kwargs = dict ( ( smart text ( k , STR_ ) , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
or ig file = os . path . join ( self . dirpath , self . file )
arg = settings . TIME FORMAT
warnings . warn ( " STR_ " % fixture name )
return saved instances
try :
def str ( self ) :
advance iterator = next
match = condition . eval ( context )
return formats . localize input ( value )
validate comma separated integer list = RegexValidator ( comma separated int list re , ( STR_ ) , STR_ )
self . load middleware ( )
if is in stance ( value , str ) :
return True
statements . append ( " " . join ( statement ) )
with open ( path , STR_ ) :
if is in stance ( empty label , ( list , tuple ) ) :
try :
matches = False
from future import unicode literals
if urlconf is None :
class BoundaryIter ( six . Iterator ) :
yield node
self . setlistdefault ( key ) . append ( value )
from django . utils import six
raise Resolver404 ( { STR_ : path } )
except TypeError :
for j in xrange ( in t ( iterations ) ) :
header names = [ key . lower ( ) for key in self . extra headers ]
try :
if not callback :
if resolved path :
def construct form ( self , i , ** kwargs ) :
@ register . filter ( is safe = True )
app name = get commands ( ) [ name ]
return get valid filename ( name )
@ property
return msgs
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
DNS NAME = CachedDnsName ( )
warnings . warn ( " STR_ " % loader )
return self
def dst ( self , dt ) :
raise value . with traceback ( tb )
def sign ( self , value ) :
timeout = - NUM_
objects in fixture = NUM_
help = " STR_ "
if options [ STR_ ] > NUM_ :
exec ( compile ( handle . read ( ) , pythonrc , STR_ ) , imported objects )
from django . utils . six . moves import in put
self . renderer = renderer
return import string ( key func )
return super ( SimpleTemplateResponse , self ) . content
if in itial is None :
def attach ( self , filename = None , content = None , mimetype = None ) :
def resolve ( path , urlconf = None ) :
if is in stance ( value , datetime . date ) :
if is in stance ( option label , ( list , tuple ) ) :
self . resolver match = None
def add arguments ( self , parser ) :
end = rawdata [ k : endpos ] . strip ( )
defaults . update ( kwargs )
if fields :
except OSError as e :
if event == " STR_ " and node . nodeName == " STR_ " :
if conflicts and not self . merge :
urlconf = settings . ROOT URLCONF
finally :
if not hasattr ( translation , STR_ ) :
setattr ( obj , self . fk . get attname ( ) , getattr ( pk value , STR_ , pk value ) )
if hasattr ( request , STR_ ) :
msg . attach ( body msg )
elif char in STR_ :
class BoundField ( object ) :
messages . update ( getattr ( c , STR_ , { } ) )
raise NotImplementedError ( STR_ )
raise TemplateSyntaxError ( " STR_ " % name )
for option value , option label in chain ( self . choices , choices ) :
except ImportError :
if fake :
if len ( list ) == NUM_ :
if args is None :
class Command ( AppCommand ) :
return value
def items ( self ) :
raise ValidationError ( self . message , code = self . code , params = params )
def handle field ( self , obj , field ) :
return self . create attachments ( self . create alternatives ( msg ) )
def add move ( move ) :
return dec
data = compressed
for key , value in data . items ( ) :
def has error ( self , field , code = None ) :
def init ( self ) :
for node app , node name in migration . branch :
callback = lambda response : middleware . process response ( request , response )
return default
params = { STR_ : value , STR_ : current timezone }
while model dependencies :
self . charset = charset
if html message :
from django . apps import apps
return not module has submodule ( package , module )
def delattr ( self , name ) :
message context = message context . strip ( " STR_ " )
self . func path = STR_ . join ( [ func . class . module , func . class . name ] )
self . cache = caches . setdefault ( name , { } )
self . nodelist = t . nodelist
def init ( self , * args , ** kwargs ) :
if self . is localized :
return new value
for ( k , v ) in kwargs . items ( ) :
new class . declared fields = declared fields
if len ( parts ) > NUM_ and parts [ - NUM_ ] in self . compression formats :
return STR_ . join ( statements )
def handle ( self , ** options ) :
shutdown message = options . get ( STR_ , )
import copy
def check for language ( lang code ) :
from django . apps import apps
elif dirname == STR_ :
return result == NUM_
def errors ( self ) :
class BaseConfigurator ( object ) :
if item [ STR_ ] is not None :
args , kwargs = parse bits ( parser , bits , params , varargs , varkw , defaults , takes context , name )
from django . utils import datetime safe
return value
elif not callable ( formfield callback ) :
if format not in serializers . get public serializer formats ( ) :
e . django template source = self . source
if hasattr ( os , STR_ ) :
DEFAULT MAX NUM = NUM_
self . cdata tag = None
from django . utils . os import safe join
def set ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
dirs . remove ( dirname )
return self . var
return ( t [ NUM_ ] . lower ( ) , t [ NUM_ ] )
in valid tag = next ( tag for tag in tags if not checks . tag exists ( tag ) )
def create var ( self , value ) :
return self . as ul ( )
localedir = os . path . join ( os . path . dirname ( settingsfile ) , STR_ )
extra params . update ( field params )
value = ugettext ( " STR_ " ) % filesize number format ( bytes / MB )
new modules = module values - cached modules
translated = func ( ** kwargs )
raise TemplateSyntaxError ( " STR_ " % ( name , alen - dlen , plen ) )
@ register . tag
else :
from django . conf import settings
self . create table ( db , tablename )
from django . conf import settings
self . path info =
result . append ( ch )
except ( ValueError , TypeError ) :
help = " STR_ "
from future import unicode literals
from django . apps import apps
self . reader enters ( )
all = ( STR_ , STR_ )
if not response . streaming :
for d in object list :
from django . utils import six
else :
yield
def setstate ( self , state ) :
def ungettext lazy ( singular , plural , number = None ) :
num pages = property ( get num pages )
context [ self . var name ] = obj
major = get major version ( version )
if not self . leave locale alone :
else :
for path in paths :
output = [ ]
self . full clean ( )
parser . skip past ( STR_ )
return decorator ( * args , ** kwargs )
pass
except LookupError :
try :
status code = NUM_
if not settings . is overridden ( STR_ ) :
statements = sql delete ( app config , self . style , connection )
ugettext noop = gettext noop
return smart text ( value )
return
now = now . replace ( microsecond = NUM_ )
if self . max digits is not None and digits > self . max digits :
raise ValueError ( " STR_ " )
errors . append ( self . get unique error message ( unique check ) )
from django . core . cache import caches
response = self . get response ( request )
if self . timeout is not None :
args = options . args
meta = getattr ( form , STR_ , None )
self . stdout . write ( " STR_ " % filename )
writer = MigrationWriter ( migration )
widget . is localized = True
pass
return self . queryset
new name = STR_ % new name
return self . encoding
return not self . file or self . file . closed
else :
except OSError as e :
if widgets and f . name in widgets :
if name is not None :
timeout = self . default timeout
def new ( mcs , name , bases , attrs ) :
if not is abs ( path ) :
return value
self . POST = QueryDict ( mutable = True )
try :
pass
if name == " STR_ " :
if is in stance ( current , BaseContext ) and getattr ( type ( current ) , bit ) :
if language code not in self . namespace dict :
options = self . render options ( choices , value )
new environ [ " STR_ " ] = STR_
sql files . append ( os . path . join ( app dir , " STR_ " % opts . model name ) )
try :
try :
base , ext = posixpath . splitext ( the path )
def write message ( self , message ) :
self . add error ( name , e )
if cursor and close connection :
num sent = NUM_
for i , row in enumerate ( connection . in trospection . get table description ( cursor , table name ) ) :
digits = decimals
if not value or is in stance ( value , ( list , tuple ) ) :
except Exception as e :
guid attrs [ STR_ ] = str ( item [ STR_ ] ) . lower ( )
ch = next ( in put iter )
from django . conf import urls
else :
self . tag ( function name , compile func )
return len ( self . children )
in itLock = Lock ( )
def nonzero ( self ) :
msg = self . style . HTTP REDIRECT ( msg )
return out . getvalue ( )
mail . attach alternative ( html message , STR_ )
if kwargs . get ( k , v ) ! = v :
return False
if source is None :
database = options . get ( STR_ )
@ python 2 unicode compatible
BUILTIN SERIALIZERS = { " STR_ " : " STR_ " , " STR_ " : " STR_ " , " STR_ " : " STR_ " , " STR_ " : " STR_ " , }
parent = ( form . Meta , object )
from xml . sax . expatreader import ExpatParser as ExpatParser
pass
val1 = parser . compile filter ( bits [ NUM_ ] )
content type = in fo . get ( STR_ )
if option value in selected choices :
count = since // seconds
DEFAULT CACHE ALIAS = STR_
import warnings
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , NUM_ , NUM_ )
def size ( self , name ) :
for key , value in six . iterlists ( self ) :
raise
sys . stderr . write ( " STR_ " )
attrs [ STR_ ] = self . html initial id
iterkeys = " STR_ "
class ValidationError ( Exception ) :
def display ( self ) :
return result
self . params = params
tmp = url . rstrip ( / )
url = property ( lambda self : self [ STR_ ] )
sys . exit ( NUM_ )
with self . lock . writer ( ) :
func closure = " STR_ "
create models = set ( itertools . chain ( * manifest . values ( ) ) )
def phone2numeric ( phone ) :
self . connection . quit ( )
from pprint import pformat
return http . QueryDict ( raw query string , encoding = self . encoding )
import pylibmc
with transaction . atomic ( using = database , savepoint = connection . features . can rollback ddl ) :
if len ( fks to parent ) == NUM_ :
if not self . fail silently :
self . xml . endElement ( " STR_ " )
msg = ( " STR_ " " STR_ " % ( { STR_ : app path , STR_ : e , } ) )
def update ( self , other dict ) :
if os . path . exists ( filename ) :
self . error list = [ self ]
return value
if exclude and f . name in exclude :
continue
else :
LPOVERLAPPED = POINTER ( OVERLAPPED )
hextets [ in dex ] = hextets [ in dex ] . lstrip ( STR_ )
return False
if not self . connection :
in valid var format string = None
warnings . warn ( STR_ STR_ , RemovedInDjango19Warning , NUM_ )
from django . utils . translation import get language
msg count = NUM_
return self
fd = os . open ( full path , flags , NUM_ o666 )
except AttributeError :
class TimeInput ( DateTimeBaseInput ) :
class Variable ( object ) :
def is ajax ( self ) :
loaded objects in fixture = NUM_
output . append ( STR_ % ( in dent , escaper ( force text ( title ) ) , sublist ) )
if not hasattr ( obj , " STR_ " ) :
match = html parser . endtagfind . match ( rawdata , i )
from django . utils . deprecation import RemovedInDjango19Warning
for name , field in self . fields . items ( ) :
return cls ( file dict [ STR_ ] , file dict [ STR_ ] , file dict . get ( STR_ , STR_ ) )
po path = os . path . join ( dirpath , f )
if field . error messages [ STR_ ] not in errors :
return len ( list ( self . iter ( ) ) )
last = root [ PREV ]
with open ( old path , STR_ ) as template file :
rest = rest [ m . end ( ) : ]
daemon kwargs [ STR_ ] = in t ( options [ STR_ ] , NUM_ )
def handle fk field ( self , obj , field ) :
self . callback = None
if pickled is not None :
option value = force text ( option value )
if val is None :
fp = kwargs . pop ( " STR_ " , sys . stdout )
self . is olated context = kwargs . pop ( STR_ , False )
dirs . append ( )
output . append ( self . render option ( selected choices , * option ) )
self . add fallback ( )
def get ( self , key , default = None ) :
if opts . model is None :
if not UserModel . default manager . exists ( ) and options . get ( STR_ ) :
help = " STR_ "
def dec ( func ) :
content = template . render ( context )
errors = [ ]
class IPAddressField ( CharField ) :
if not ( self . in verse match is not bool ( self . regex . search ( force text ( value ) ) ) ) :
else :
def render ( self , context ) :
try :
if endblock . contents not in acceptable endblocks :
return trans . deactivate ( )
if graph . nodes [ plan node ] . replaces :
class StreamingHttpResponse ( HttpResponseBase ) :
from django . template . loader import BaseLoader
else :
nan = ( NUM_ * NUM_ ) // ( NUM_ * NUM_ )
logger = logging . getLogger ( STR_ )
return calendar . is leap ( self . data . year )
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ STR_ )
def clean ipv6 address ( ip str , unpack ipv4 = False , error message = ( " STR_ " ) ) :
def as table ( self ) :
add move ( MovedModule ( " STR_ " , " STR_ " ) )
relations = { }
DELETION FIELD NAME = STR_
try :
from django . conf import settings
elif ch == STR_ :
if hasattr ( hashlib , " STR_ " ) :
return pickle . loads ( base64 . b64decode ( force bytes ( value ) ) )
for dict in self . dicts :
handler . startElement ( " STR_ " , self . item attributes ( item ) )
class CacheClass ( LocMemCache ) :
unlink = os . unlink
with transaction . atomic ( using = db ) :
if settings . USE TZ :
args = [ STR_ ] + self . msgmerge options + [ pofile , potfile ]
def ungettext ( singular , plural , number ) :
return map ( self . make bytes , self . iterator )
class FirstOfNode ( Node ) :
from django . conf import settings
raise
html [ STR_ ] = self . create select ( name , self . year field , value , year val , choices , self . year none value )
def is protected type ( obj ) :
class UnreadablePostError ( IOError ) :
raise AttributeError ( " STR_ " % ( name , ) )
def visible fields ( self ) :
for c in lineno comment map [ comment lineno cache ] :
try :
if is in stance ( loader , six . string types ) :
return self . file . closed
for attr , value in base . dict . items ( ) :
wrap = allow lazy ( wrap , six . text type )
from django . db import models
from django . utils import six
self . stdout . write ( " STR_ " % ( self . style . MIGRATE LABEL ( writer . filename ) , ) )
if os . fork ( ) > NUM_ :
self . replace header ( STR_ , STR_ % ( subtype , charset ) )
d = d [ n ]
kwargs [ STR_ ] = safe
def save new ( self , form , commit = True ) :
raise ImportError
with open ( new path , STR_ ) as new file :
FormSet . model = model
if props :
return new class
offset = date . tzinfo . utcoffset ( date )
lbp = NUM_
try :
else :
pass
result += ugettext ( STR_ ) + avoid wrapping ( name2 % count2 )
def next ( self ) :
empty = object ( )
for replacement in set ( [ thousand sep , unicodedata . normalize ( STR_ , thousand sep ) ] ) :
else :
standard context processors = tuple ( processors )
mod = import module ( mod name )
elif is in stance ( value , datetime . date ) :
if self . paginator . count == NUM_ :
return os . path . samefile ( src , dst )
name = " STR_ " . join ( [ package . name , module name ] )
try :
self . field name = field name
self . year none value = ( NUM_ , empty label [ NUM_ ] )
if node . getElementsByTagName ( None ) :
mixed subtype = STR_
except NotImplementedError :
except StandardError as e :
if pk is not editable ( pk ) or pk . name not in form . fields :
from django . utils . six . moves import cPickle as pickle
resolved path . append ( ns )
from django . core . mail . utils import DNS NAME
else :
from django . utils . timezone import get default timezone , is aware , is naive
g = generator . BytesGenerator ( fp , mangle from = False )
netloc = netloc . encode ( STR_ ) . decode ( STR_ )
cc = { }
basedirs . extend ( settings . LOCALE PATHS )
if self . callback is not None :
return self . as widget ( TextInput ( ) , attrs , ** kwargs )
d = Decimal ( in put val )
i = j + NUM_
self . css . setdefault ( medium , [ ] ) . append ( path )
return generate cache key ( request , request . method , headerlist , key prefix )
self . setlistdefault ( key ) . append ( value )
choices = property ( get choices , set choices )
def iter ( self ) :
def add arguments ( self , parser ) :
getattr ( self , STR_ )
from django . conf import settings
verbosity = options . get ( STR_ )
logging . acquireLock ( )
self . html initial name = form . add initial prefix ( name )
if self . data . hour > NUM_ :
self . buffer = self . buffer [ size : ]
if result is not None :
self . extra headers = headers or { }
if e . errno ! = errno . EEXIST :
return base , ext
if root :
raise
try :
if f is None :
must be first = False
terminal char = >
return self . urlconf module
def exit command ( self ) :
resolved args , resolved kwargs = self . get resolved arguments ( context )
if ( is in stance ( message , ValidationError ) and message . code in error messages ) :
return True
self . validate key ( key )
else :
class LazyObject ( object ) :
from django . forms . utils import flatatt , ErrorDict , ErrorList
else :
text type = str
if key in d :
return self . regex dict [ language code ]
parser = parser class ( lexer . tokenize ( ) )
raise
return PALETTES [ DEFAULT PALETTE ]
return ( or d ( byte ) for byte in buf )
def init ( self , config ) :
while ( i < num existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :
check for migrations ( app config , connection )
bits = token . split contents ( ) [ NUM_ : ]
return ( len ( self . queryset ) + ( NUM_ if self . field . empty label is not None else NUM_ ) )
buffer = None
fp . write ( data )
child loggers . append ( existing [ i ] )
else :
if opts . fields is None and opts . exclude is None :
context . render context [ self ] = itertools cycle ( self . cyclevars )
ugettext = gettext
return force bytes ( value , self . charset )
utc = pytz . utc if pytz else UTC ( )
def contains ( self , key ) :
value = getattr ( obj , field . get attname ( ) )
self . message = message
op . id = key
self . cache . set ( key , value , self . get backend timeout ( timeout ) )
self . stdout . write ( " STR_ " % ( self . loaded object count , self . fixture count ) )
if settings . FILE UPLOAD TEMP DIR :
raise ValidationError ( ungettext ( " STR_ " , " STR_ " , self . max num ) % self . max num , code = STR_ , )
return " STR_ " % force text ( e , errors = " STR_ " )
root , = nonlocal root
s = m . group ( NUM_ )
if f == STR_ :
@ register . filter ( is safe = True )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
return dot re . sub ( char , src )
return self . dicts . pop ( )
default validators = [ validators . validate slug ]
if attr in obj dict :
def w ( self ) :
locales = locale or all locales
return " STR_ "
def fastcgi help ( message = None ) :
if self . selected fields is None or field . attname in self . selected fields :
in put format = get format ( STR_ ) [ NUM_ ]
table names = [ model . meta . db table for model in self . models ]
if arg is None :
from django . utils import six
from django . apps import apps
if not settings . ADMINS :
if not locale dir :
return cached filenames
return changeset
if os . path . sep in fixture name :
not found . append ( e . args [ NUM_ ] )
except ImportError :
class SplitHiddenDateTimeWidget ( SplitDateTimeWidget ) :
if self . match is not None :
sys . stderr . write ( " STR_ " )
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
del attr
value = dict . getitem ( self , key )
self . chunk size = chunk size
def G ( self ) :
return self . resolve ( value )
if termios :
parser . loaded blocks = [ block name ]
for code in ( lang code , generic lang code ) :
continue
return six . text type ( name )
return self . num pages
if hasattr ( error , STR_ ) :
help = " STR_ "
def render ( self , context ) :
default error messages = { STR_ : ( STR_ STR_ ) , }
if item [ STR_ ] is not None :
patterns = [ pattern for ( possibility , pattern , defaults ) in possibilities ]
sites . append ( j )
return tuple ( bits )
if not self . use ssl and self . use tls :
from . registry import register , run checks , tag exists , Tags
try :
self . extra context = extra context or { }
func closure = " STR_ "
self . bad cookies = set ( )
if not old method and new method :
updates . update ( processor ( request ) )
from django . utils . deprecation import RemovedInDjango19Warning
self . stream . write ( " " )
bpython . embed ( )
return ugettext ( message )
e , tb = sys . exc info ( ) [ NUM_ : ]
for check in checks :
response = self . handle uncaught exception ( request , resolver , sys . exc info ( ) )
mail = EmailMultiAlternatives ( STR_ % ( settings . EMAIL SUBJECT PREFIX , subject ) , message , settings . SERVER EMAIL , [ a [ NUM_ ] for a in settings . MANAGERS ] , connection = connection )
def m2m convert ( n ) :
field desc += STR_ . join ( [ STR_ % ( k , strip prefix ( repr ( v ) ) ) for k , v in extra params . items ( ) ] )
return STR_ % id
language code = get language ( )
compare = lambda self , a , b : a is not b
def compile func ( parser , token ) :
self . base set ( STR_ , key , value , timeout )
return settings . LANGUAGE CODE
class Command ( BaseCommand ) :
StringIO = io . StringIO
dig1 , dig2 = in ner . copy ( ) , outer . copy ( )
result . fields = tuple ( [ x . deepcopy ( memo ) for x in self . fields ] )
else :
current fields . append ( ( key , value ) )
self . validators . append ( validators . MinLengthValidator ( in t ( min length ) ) )
if not is in stance ( var , six . string types ) :
class BaseMemcachedCacheMethods ( RenameMethodsBase ) :
if self . wrapped is empty :
else :
else :
def handle app config ( self , app config , ** options ) :
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc info ( ) [ NUM_ ] )
if m is None :
return URLNode ( viewname , args , kwargs , asvar )
else :
class NumberInput ( TextInput ) :
yield " STR_ "
self . day none value = self . none value
from django . utils import six
def init ( self , cmd , ** kwargs ) :
from future import unicode literals
response = sys . modules [ name + " STR_ " ]
raise TemplateSyntaxError ( " STR_ " )
def check for migrations ( app config , connection ) :
try :
yield
iterator = None
elif self . name and os . path . exists ( self . name ) :
def send messages ( self , messages ) :
self . stream . write ( STR_ % msg data )
using sysrandom = True
return in t ( value ) + in t ( arg )
return debug . technical 500 response ( request , * sys . exc info ( ) , status code = NUM_ )
first , lang , priority = pieces [ i : i + NUM_ ]
class SimpleTemplateResponse ( HttpResponse ) :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
if kwargs . pop ( STR_ , False ) :
self . stderr . write ( " STR_ " % app label )
alter sql . extend ( [ STR_ + sql for sql in connection . creation . sql for pending references ( model , style , pending references ) ] )
if self . localize :
def end object ( self , obj ) :
BASE2 ALPHABET = STR_
is usable = True
final attrs [ STR_ ] = force text ( self . format value ( value ) )
if not response . has header ( STR_ ) :
def strip once ( value ) :
def handle ( self , ** options ) :
def close files ( self ) :
add to builtins ( STR_ )
if field . rel . through . meta . auto created :
return format html ( STR_ , flatatt ( final attrs ) )
def in cr ( self , key , delta = NUM_ , version = None ) :
from django . utils import six
self . file = os . fdopen ( fd , mode , bufsize )
return item in self . dict
except IOError as e :
filename = os . path . basename ( path )
if supported is None :
except socket . error as e :
resolved args , resolved kwargs = self . get resolved arguments ( context )
name = [ ]
block context = context . render context . get ( BLOCK CONTEXT KEY )
self . connection . login ( self . username , self . password )
break
raise
in put type = STR_
alen = len ( args )
class SplitDateTimeWidget ( MultiWidget ) :
if is in stance ( value , six . string types ) and value . lower ( ) in ( STR_ , STR_ ) :
exc info = sys . exc info ( )
def time format ( value , format string ) :
return smart text ( self . name or )
parser . add argument ( STR_ , STR_ , dest = STR_ , action = STR_ , default = [ STR_ ] , help = STR_ STR_ STR_ )
else :
try :
try :
if is in stance ( source , in st ) :
self . ordering . append ( ( i , form . cleaned data [ ORDERING FIELD NAME ] ) )
if self . active writers == NUM_ and self . waiting writers == NUM_ :
if len ( new operations ) == len ( operations ) :
super ( ContentFile , self ) . init ( stream class ( content ) , name = name )
in itial value = in itial value ( )
self . nodelist loop = nodelist loop
return VerbatimNode ( nodelist . render ( Context ( ) ) )
except ( ValueError , TypeError ) :
pass
nm , addr = addr
obj . pk = Model . default manager . db manager ( db ) . get by natural key ( * natural key ) . pk
return LazyStream ( BoundaryIter ( self . stream , self . boundary ) )
iter ( patterns )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
upto = match . end ( )
walk to end ( ch , pattern iter )
dict = func ( * resolved args , ** resolved kwargs )
base64d = force bytes ( TimestampSigner ( key , salt = salt ) . unsign ( s , max age = max age ) )
self . table = table
connection = connections [ options [ STR_ ] ]
weekday = self . data . weekday ( ) + NUM_
else :
if not parent :
return
if os . path . exists ( django po ) :
STATUS OK = NUM_
del obj dict [ attr ]
return result
return FASTCGI HELP
self . models . add ( obj . object . class )
from django . core . files . utils import FileProxyMixin
return STR_
if app name not in loader . migrated apps :
if self . cull frequency == NUM_ :
all files = [ ]
value = self . to python ( value ) . strip ( )
found = getattr ( found , frag )
content disposition = in fo . get ( STR_ )
return self . render ( )
for name in formatters :
generic lang code = lang code . split ( - ) [ NUM_ ]
while ch ! = terminal char :
def repr ( self ) :
super ( CheckboxChoiceInput , self ) . init ( * args , ** kwargs )
if hasattr ( self , STR_ ) :
class Module six moves urllib parse ( LazyModule ) :
trailing empty content re = re . compile ( r STR_ )
return val if is in stance ( val , bytes ) else val . encode ( encoding )
from django . utils . encoding import force unicode
Context . init ( self , dict , current app = current app , use l10n = use l10n , use tz = use tz )
error msg = " STR_ " % parent
def do block ( parser , token ) :
register = Library ( )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
if content length > settings . FILE UPLOAD MAX MEMORY SIZE :
return STR_ % ( bits . hostname , d , bits . path , bits . fragment )
for filename in filelist :
headerlist = [ ]
wsgi opts [ STR_ ] = None
to unicode = lambda s : force text ( s , strings only = True )
self . namespace dict = { }
from threading import local
def validate host ( host , allowed hosts ) :
new ip += hextet [ NUM_ ] . split ( STR_ )
return super ( URLField , self ) . clean ( value )
def setup ( self ) :
use func = False
trans real . translations = { }
def set many ( self , data , timeout = DEFAULT TIMEOUT , version = None ) :
raise base . DeserializationError ( " STR_ " % ( node . nodeName , model identifier ) )
from django . forms . models import *
class BlockNode ( Node ) :
def validate ( self , value ) :
m2m data = { }
data [ Model . meta . pk . attname ] = Model . meta . pk . to python ( d . get ( " STR_ " , None ) )
return node . render ( context )
if len ( bits ) == NUM_ :
break
return lambda text : colorize ( text , opts , ** kwargs )
return in itial value ! = data value
fixture files in dir . append ( ( candidate , fixture dir , fixture name ) )
return EscapeBytes ( bytes ( s ) )
silent = True
return
else :
if vary on is None :
block . context = context
form . fields [ self . pk field . name ] = ModelChoiceField ( qs , in itial = pk value , required = False , widget = widget )
try :
else :
def send messages ( self , email messages ) :
if not self . is valid ( ) or not self . can order :
msg = STR_ % ( error prefix , dotted path , e )
signals . got request exception . send ( sender = self . class , request = request )
def flatten result ( source ) :
if key not in self :
if meta is None :
out = StringIO ( )
if field == NON FIELD ERRORS :
self . template response middleware = [ ]
else :
filter name = match . group ( " STR_ " )
now = now . replace ( microsecond = NUM_ )
def copy ( self ) :
BaseRunserverCommand = Command
self . request middleware = None
format module path = settings . FORMAT MODULE PATH
finally :
raise CommandError ( STR_ % self . addr )
del self [ STR_ ]
import decimal
raise ValueError ( STR_ % ( f , e ) )
raise CommandError ( " STR_ " % app label )
current uri = STR_ . format ( scheme = self . scheme , host = self . get host ( ) , path = self . path )
def init ( self , connection reset = False ) :
try :
final attrs [ STR_ ] = force text ( value )
def serialize ( format , queryset , ** options ) :
fp . write ( msgs )
self . hint = hint
def handle m2m field ( self , obj , field ) :
last row = ( normal row % { STR_ : , STR_ : , STR_ : , STR_ : , STR_ : html class attr } )
link next [ PREV ] = link prev
self . post = QueryDict ( , mutable = True )
except Exception :
if line :
content length = in t ( environ . get ( STR_ ) )
form = self . form ( auto id = self . auto id , prefix = self . add prefix ( STR_ ) , empty permitted = True , )
parser . add argument ( STR_ , STR_ , default = [ ] , dest = STR_ , action = STR_ , help = STR_ STR_ )
if not match or not match . group ( NUM_ ) :
MIMEText . setitem ( self , name , val )
elif getattr ( current , STR_ , False ) :
self . locale paths = [ os . path . abspath ( os . path . join ( STR_ , STR_ ) ) ]
while end > NUM_ and s . count ( b STR_ , NUM_ , end ) % NUM_ :
if urlconf name :
objects = model . default manager
def end index ( self ) :
run syncdb = False
if t . token type ! = TOKEN COMMENT :
return len ( list ( email messages ) )
if STR_ in config :
self . exit command ( )
raise NoReverseMatch ( " STR_ " % ( key , STR_ . join ( resolved path ) ) )
def utcoffset ( self , dt ) :
except Exception :
exp = connections [ db ] . ops . value to db datetime ( exp )
mail . outbox . extend ( messages )
getcallargs ( current )
return " STR_ " % ( self . func path , self . args , self . kwargs , self . url name , self . app name , self . namespaces )
def log message ( self , format , * args ) :
return hmac . new ( key , msg = force bytes ( value ) , digestmod = hashlib . sha1 )
else :
def same origin ( url1 , url2 ) :
bits = token . contents . split ( )
if settings . is overridden ( STR_ ) :
from threading import RLock
elif self . META . get ( STR_ , ) . startswith ( STR_ ) :
lookup view s = " STR_ " % ( m , n )
change = fn ( )
def write pot file ( potfile , msgs ) :
if hasattr ( timezone , STR_ ) :
def title ( value ) :
etags = ETAG MATCH . findall ( etag str )
return six . iteritems ( super ( MultiValueDict , self ) )
if STR_ not in attrs :
result = getattr ( t , translation function ) ( eol message )
try :
return trans . ungettext ( singular , plural , number )
if self . verbosity > NUM_ :
handler . startElement ( STR_ , self . root attributes ( ) )
return
def auto id ( self ) :
block context . add blocks ( self . blocks )
try :
self . validate unique = False
m2m convert = lambda n : field . rel . to . meta . pk . to python ( n . getAttribute ( STR_ ) )
try :
nodes = [ ]
new class = ( super ( MediaDefiningClass , mcs ) . new ( mcs , name , bases , attrs ) )
Field . init ( self , required , widget , label , in itial , help text , * args , ** kwargs )
if simple url re . match ( middle ) :
flush = property ( lambda self : self . file . flush )
msgs = msgs . decode ( STR_ )
from django . utils import six
output . append ( STR_ )
SINGLE BRACE START = STR_
super ( EmailBackend , self ) . init ( fail silently = fail silently )
try :
def add ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
new context = context class ( dict , ** { STR_ : context . autoescape , STR_ : context . current app , STR_ : context . use l10n , STR_ : context . use tz , } )
if endpos < NUM_ :
def init ( self , language , deactivate = False ) :
elif auto id :
return range ( NUM_ , self . num pages + NUM_ )
iter ( x )
copystat ( old file name , new file name )
from django . template . loader import BaseLoader
else :
super ( BaseModelForm , self ) . init ( data , files , auto id , prefix , object data , error class , label suffix , empty permitted )
msg count += NUM_
for namespace , ( prefix , sub pattern ) in pattern . namespace dict . items ( ) :
class TextNode ( Node ) :
from django . template . base import TemplateSyntaxError , Library , Node , TextNode , token kwargs , Variable
return
del self . cleaned data [ field ]
from django . core . management . utils import handle extensions
split = [ ]
if self . has key ( key , version ) :
nodelist = parser . parse ( ( STR_ , ) )
escaped = False
if self . base url is None :
pass
from PIL import Image
def handle app config ( self , app config , ** options ) :
if i % NUM_ :
self . path =
def new file ( self , field name , file name , content type , content length , charset = None , content type extra = None ) :
def mark post parse error ( self ) :
ipv4 re = re . compile ( r STR_ )
self . initialize handlers ( )
return context extras
except http cookies . CookieError :
def add root elements ( self , handler ) :
query = query . items ( )
def fetch command ( self , subcommand ) :
class DefaultCacheProxy ( object ) :
import StringIO
sign = - if seconds < NUM_ else +
if p . image :
@ property
if not tag or current len >= truncate len :
while len ( digits ) <= abs ( exponent ) :
if self . content length == NUM_ :
renamed methods = ( ( STR_ , STR_ , RemovedInDjango19Warning ) , )
super ( SortedDict , self ) . setitem ( key , value )
return value
six . reraise ( ImportError , ImportError ( msg ) , sys . exc info ( ) [ NUM_ ] )
if not commit :
if message context [ NUM_ ] == STR_ :
return RequestContext ( self . request , context , current app = self . current app )
return format html ( self . outer html , id attr = format html ( STR_ , id ) if id else , content = mark safe ( STR_ . join ( output ) ) )
if json . version . split ( STR_ ) >= [ STR_ , STR_ , STR_ ] :
return property ( fget , fset , fdel , doc )
except StandardError as e :
def pgettext ( context , message ) :
return new key
fields . update ( new class . declared fields )
return value + arg
for fixture file , fixture dir , fixture name in self . find fixtures ( fixture label ) :
assert not is in stance ( cc , six . string types ) , STR_
anonymous = [ STR_ ]
if os . path . is file ( f ) :
def getitem ( self , in dex ) :
parser . add argument ( STR_ , STR_ , dest = STR_ , action = STR_ , default = [ ] , help = STR_ STR_ )
if self . queryset is not None :
from django . conf import settings
app names = sorted ( loader . migrated apps )
if cleaned line . endswith ( " STR_ " ) :
return iri to uri ( resolver . reverse with prefix ( view , prefix , * args , ** kwargs ) )
ipv4 unpacked = unpack ipv4 ( ip str )
date = form . cleaned data [ unique for ]
if max num is None :
self . locale paths . append ( os . path . abspath ( STR_ ) )
self . merge ( translation )
message %= error . params
for loader in self . loaders :
work file = os . path . join ( self . dirpath , thefile )
if not new method and old method :
return str ( dict ( self . items ( ) ) )
before import registry = copy . copy ( register to . registry )
elif pluralmatch :
return STR_ % ( self . f ( ) , self . a ( ) )
missing args message = " STR_ " % label
def init ( self , META , in put data , upload handlers , encoding = None ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
class MLStripper ( HTMLParser ) :
def iter ( self ) :
self . servers = server . split ( STR_ )
self . cookies [ key ] [ STR_ ] = path
finally :
if not form . is valid ( ) :
klass . deconstruct = deconstruct
if hasattr ( self , STR_ ) :
def repr ( self ) :
return True
else :
EventHandler . modified code = FILE MODIFIED
parser . add argument ( STR_ , STR_ , dest = STR_ , action = STR_ , default = [ ] , help = STR_ STR_ STR_ )
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , NUM_ , NUM_ )
for db in connections . all ( ) :
try :
self . charset = None
repo dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( file ) ) )
else :
from django . core . exceptions import ValidationError
declared fields . update ( base . declared fields )
return format html ( " STR_ " , csrf token )
attrs . pop ( key )
try :
errors . extend ( m for m in e . error list if m not in errors )
self . m2m data = m2m data
if hasattr ( self , STR_ % name ) :
else :
extensions = options . get ( STR_ )
if is in stance ( offset , timedelta ) :
from django . template . base import ( compile string , resolve variable , unescape string literal , generic tag compiler )
except ImportError as e :
for lineno , line in enumerate ( content . splitlines ( True ) ) :
usage . append ( " STR_ " % name )
def getattr ( self , attr ) :
reloader = jython reloader
else :
self . active writers += NUM_
class ManagementUtility ( object ) :
def is secure ( self ) :
from django . utils . encoding import force str
def has changed ( self , in itial , data ) :
def repr ( self ) :
value = False
from django . utils import six
options = FASTCGI OPTIONS . copy ( )
else :
self . parent widget = parent widget
signals . request finished . connect ( cache . close )
except TemplateDoesNotExist as e :
hextets [ in dex ] = STR_
result = self . configurator . convert ( value )
locks . unlock ( fd )
raise TypeError ( STR_ )
new obj = func ( obj , * arg vals )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
try :
from django . utils . six import StringIO
continue
setattr ( self , real name , getattr ( trans , real name ) )
while self . tokens :
except InvalidOperation :
weight += NUM_
m2m data = { }
val = self . get ( k , version = version )
except AttributeError :
result = user function ( * args , ** kwds )
class LocaleRegexProvider ( object ) :
assert not is in stance ( bcc , six . string types ) , STR_
filters = config . get ( STR_ , None )
@ register . filter ( " STR_ " , is safe = False )
return mark safe ( six . text type ( value ) )
if func is None :
import flup
import os
self . cache [ key ] = value
context . pop ( )
if bases == ( BaseModelForm , ) :
def len ( self ) :
raise StopIteration ( )
warning = STR_
def handle ( self , ** options ) :
class FilterExpression ( object ) :
res = to digits [ digit ] + res
return True
if six . PY3 :
if self . waiting writers ! = NUM_ :
return
if is in stance ( form . meta . fields , tuple ) :
return False
if ( getattr ( Meta , STR_ , None ) is None and getattr ( Meta , STR_ , None ) is None ) :
extend = complain
while True :
def str ( self ) :
try :
return property ( media )
return
m2m convert = lambda v : smart text ( field . rel . to . meta . pk . to python ( v ) )
def path ( self ) :
fp . write ( src data )
args = hashlib . md5 ( force bytes ( key ) )
args . append ( work file )
return template
from django . apps import apps
return current
self . handle m2m field ( obj , field )
if re . search ( STR_ % ( prefix norm , pattern ) , candidate pat % candidate subs , re . UNICODE ) :
return { }
elif safe input :
pass
if is in stance ( s , Promise ) :
if STR_ in args [ NUM_ ] :
def promise ( cls , klass , funcname , method ) :
else :
def delitem ( self , key ) :
elif cls . delegate bytes :
exclude . append ( name )
kwargs = dict ( ( k , config [ k ] ) for k in config if valid ident ( k ) )
return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )
from django . utils . xmlutils import SimplerXMLGenerator
data = method ( self , * args , ** kwargs )
else :
response . content = b
termios . tcsetattr ( fd , termios . TCSANOW , attr list )
for app label in app labels :
if words and length <= NUM_ :
try :
nodelist . append ( node . render ( context ) )
class VerbatimNode ( Node ) :
raise CommandError ( STR_ )
def get regex ( self ) :
def chunks ( self , chunk size = None ) :
return output
from django . utils import six , timezone
from django . utils . safestring import SafeData , mark safe
return
continue
for statement in sql :
in ternal use only = False
self . alternatives . append ( ( content , mimetype ) )
changes = autodetector . changes ( graph = loader . graph , trim to apps = app labels or None , convert apps = app labels or None , )
self . addr = STR_ if self . use ipv6 else STR_
self . label = pretty name ( name )
self . close ( )
if not in clude is allowed ( filepath ) :
message = email message . message ( )
if len ( compressed ) < ( len ( data ) - NUM_ ) :
output . extend ( f . post create sql ( style , model . meta . db table ) )
yes , no , maybe = bits
break
parser . add argument ( STR_ , help = STR_ )
language code = get language ( )
return timezone . make aware ( value , current timezone )
return force text ( widget . render ( name , self . value ( ) , attrs = attrs ) )
import pickle
TOKEN COMMENT = NUM_
warnings . warn ( " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
@ cached property
def as ul ( self ) :
if sublist item :
elif bytes < TB :
return NUM_ , ch2
return version
executor = MigrationExecutor ( connection , self . migration progress callback )
from django . core . management . base import CommandError
break
parser . add argument ( STR_ , metavar = STR_ , nargs = * )
raise ValueError ( " STR_ " % ( model . meta . app label , model . meta . object name , parent model . meta . app label , parent model . meta . object name ) )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
self . name = name
except ValueError :
self . cache . clear ( )
return value
from collections import UserList
if resolver . urlconf module is None :
value = self . coerce ( value )
else :
class ModelChoiceField ( ChoiceField ) :
self . filter expression = filter expression
def writer leaves ( self ) :
tagname = tagname . lower ( )
if not self . populated :
widget . is localized = self . is localized
def tz ( request ) :
try :
return [ k for k , v in six . iteritems ( serializers ) if not v . Serializer . in ternal use only ]
@ stringfilter
words = self . wrapped . split ( )
except ImportError :
def iter ( self ) :
class CacheClass ( DummyCache ) :
for app name , model list in manifest . items ( ) :
return func
if settings . TEMPLATE DEBUG :
comment re = re . compile ( r " STR_ " )
cc = dict ( dictitem ( el ) for el in cc )
self . cookies = SimpleCookie ( self . cookies )
return value
class LazyStream ( six . Iterator ) :
code = STR_
return self . strptime ( value , format )
def eq ( self , other ) :
return STR_ . join ( output )
return None
def wrapper ( * args , ** kwds ) :
digits . in sert ( - exponent , STR_ )
except IndexError :
table output . append ( " " . join ( field output ) )
self . dict . update ( obj dict )
from django . utils import six
else :
if name is None :
continue
fp . write ( content )
if sys . version info [ : NUM_ ] >= ( NUM_ , NUM_ ) :
if o in opt dict :
i = i + NUM_
def add never cache headers ( response ) :
if STR_ in d :
LocaleRegexProvider . init ( self , regex )
return mark safe ( STR_ . join ( lines ) )
def writer ( self ) :
self . widgets = [ w ( ) if is in stance ( w , type ) else w for w in widgets ]
m = Media ( )
if date is not None :
raise TypeError ( msg )
elif type ( s ) ! = six . text type :
default storage = DefaultStorage ( )
return self . as ul ( )
if not os . path . exists ( self . dir ) :
raise TemplateSyntaxError ( STR_ STR_ % bits [ NUM_ ] )
if new value == value :
strip entities = allow lazy ( strip entities , six . text type )
self . current token = self . next token ( )
def get ( self , key , default = None , version = None ) :
finally :
sublist item = next item
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
except KeyError :
return text
return all ( w . is hidden for w in self . widgets )
if new attr is None :
from django . apps import apps
return urlquote ( value , ** kwargs )
expression = parser . compile filter ( var name + VARIABLE ATTRIBUTE SEPARATOR + bits [ NUM_ ] )
super ( EmailBackend , self ) . init ( * args , ** kwargs )
items = iteritems
from django . utils . functional import Promise
BLOCK TAG START = STR_
def get ( self , key , default = None ) :
raise
raise ValueError ( STR_ % s )
self . app dict = { }
msg [ name ] = value
else :
self . fixture object count += objects in fixture
value = None
raise ValidationError ( errors )
def patch vary headers ( response , newheaders ) :
except KeyError :
def new ( cls , name , bases , attrs ) :
local , domain = middle . rsplit ( STR_ , NUM_ )
with connections [ db ] . cursor ( ) as cursor :
return data
self . settings exception = exc
class Command ( BaseCommand ) :
yield self
self . locale paths = [ ]
def in dent ( self , level ) :
def handle ( self , * args , ** options ) :
if not self . is required :
return msg count
return len ( value )
parser = OptionParser ( prog = prog name , usage = self . usage ( subcommand ) , version = self . get version ( ) )
@ wraps ( func )
sites = [ ]
if trim :
pass
raise ValueError ( " STR_ " )
def tag ( self ) :
from django . utils . deprecation import RemovedInDjango19Warning
x = x * len ( from digits ) + from digits . in dex ( digit )
day of year = self . z ( )
def render ( self , name , value , attrs = None ) :
return self . get fqdn ( )
else :
class MultiPartParser ( object ) :
self . name = name or func . name
random = random . SystemRandom ( )
def back ( self ) :
if os . environ . get ( " STR_ " ) == " STR_ " :
if in stance is None :
def init ( self , filter expr , nodelist ) :
raise NotImplementedError ( STR_ )
use func = True
else :
from future import unicode literals
def method decorator ( decorator ) :
self . offset = offset
key = self . make key ( key , version = version )
current len = NUM_
def num items ( self ) :
if not autoescape or is in stance ( value , SafeData ) :
try :
result = force text ( message )
INFO = NUM_
except ImportError :
validate slug = RegexValidator ( slug re , ( " STR_ " ) , STR_ )
DEFAULT ATTACHMENT MIME TYPE = STR_
escaped = True
return localtime ( value ) if should convert else value
if not in hibit post migrate :
self . set ( key , value , timeout , version )
return retval
from django . conf import settings
if sys . platform . startswith ( STR_ ) :
raise ValueError ( " STR_ " % ch )
super ( Command , self ) . add arguments ( parser )
self . help text = field . help text or
self . merge ( translation )
self . format = format if format else None
except TypeError as te :
else :
raise ValueError ( STR_ STR_ % name )
return None
self . config = ConvertingDict ( config )
if attrvalue :
except LookupError :
in itial = [ for x in range ( NUM_ , len ( data ) ) ]
args = [ self . program ] + self . program options + [ STR_ , npath ( base path + STR_ ) , npath ( base path + STR_ ) ]
try :
def remove potfiles ( self ) :
if objects in fixture == NUM_ :
return mark safe ( value . replace ( STR_ , STR_ ) )
if getattr ( self , STR_ , None ) is None :
from django . utils import six
status = STR_ % ( response . status code , response . reason phrase )
from django . utils . deprecation import RemovedInDjango19Warning , RemovedInDjango20Warning
self . save as new = save as new
self . fields = copy . deepcopy ( self . base fields )
if not content type :
return self . object list [ in dex ]
for key , value in data . items ( ) :
else :
return False
raise
yield bit . group ( NUM_ )
dirs = [ os . path . join ( basedir , l , STR_ ) for l in locales ]
raise ValueError ( STR_ )
for supported code in supported :
for f in fields :
win = ( sys . platform == " STR_ " )
from django . template . defaultfilters import date
from django . core . management . base import BaseCommand , CommandError
return mark safe ( STR_ . join ( in puts ) )
if is in stance ( attachment , MIMEBase ) :
from future import unicode literals
if BLOCK CONTEXT KEY not in context . render context :
from django . utils . six . moves import socketserver
if value :
from django . utils import six
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
with context . push ( var = output ) :
if six . PY2 :
return value . pk
format cache = { }
result = middleware . process exception ( request , e )
this year = datetime . date . today ( ) . year
return self . has key ( key )
days = ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ )
else :
return self . copy ( )
dot = len ( package )
if or d ( char ) < NUM_ or or d ( char ) == NUM_ :
return offset . days * NUM_ + offset . seconds
loader = MigrationLoader ( None , ignore no migrations = True )
import time
import warnings
def skip past ( self , endtag ) :
return True
if ip str . count ( STR_ ) ! = NUM_ :
def join tokens ( tokens , trim = False ) :
in dent = options . get ( STR_ )
class URLInput ( TextInput ) :
handler . addQuickElement ( " STR_ " , cat )
return get template ( parent )
from importlib import import module
values = itervalues
return STR_
def open ( self , name , mode = STR_ ) :
@ register . tag ( STR_ )
fn ( * args , ** kwargs )
if used name ! = guessed filename :
iter ( second item )
if not hasattr ( e , STR_ ) :
setitem = complain
from django . db import connections , DEFAULT DB ALIAS
basedirs . extend ( [ upath ( path ) for path in settings . LOCALE PATHS ] )
def add arguments ( self , parser ) :
r = o . is oformat ( )
self . create table ( db , cache . table )
self . attr = old attr
POST = property ( get post , set post )
self . dict [ item ] = None
renderer = CheckboxFieldRenderer
def lru cache ( maxsize = NUM_ , typed = False ) :
return response
super ( Truncator , self ) . init ( lambda : force text ( text ) )
gettext lazy = lazy ( gettext , str )
from future import unicode literals
else :
load serializers ( )
dec . decorated function = getattr ( func , STR_ , func )
if tzinfo [ NUM_ ] == - :
return super ( Debug , self ) . init ( DEBUG , * args , ** kwargs )
if self . connection reset :
return result
silent variable failure = True
localize = kwargs . get ( STR_ , False )
class Module six moves urllib robotparser ( LazyModule ) :
def urlsafe base64 encode ( s ) :
@ property
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
module = importlib . import module ( STR_ % flup module , STR_ )
if self . isdst ( dt ) :
def enter ( self ) :
class Rss201rev2Feed ( RssFeed ) :
return time . tzname [ self . isdst ( dt ) ]
pass
def init ( self , file , name = None ) :
self [ key ] = result
def in itial form count ( self ) :
if callable ( limit choices to ) :
response = self . get exception response ( request , resolver , NUM_ )
return trans . pgettext ( context , message )
def write ( self , msg , style func = None , ending = None ) :
return self . handle object ( node )
self . active readers += NUM_
cookies = ( pformat ( COOKIES override ) if COOKIES override is not None else pformat ( request . COOKIES ) )
if tags and any ( not checks . tag exists ( tag ) for tag in tags ) :
for attr in ( STR_ , STR_ , STR_ ) :
apps . setdefault ( app name , [ ] ) . extend ( namespace list )
if is in stance ( source , NonCapture ) :
def init ( self , redirect to , * args , ** kwargs ) :
@ stringfilter
pass
app configs = None
html [ STR_ ] = self . create select ( name , self . day field , value , day val , choices , self . day none value )
self . silent = silent
LOCK SH = fcntl . LOCK SH
self . is rendered = False
self . stderr . write ( msg )
self . require all fields = kwargs . pop ( STR_ , True )
def list ( self ) :
return self . html name
return not ( self == other )
if self . variable name :
cache = create cache ( backend , ** kwargs )
def configure ( self ) :
return copy . copy ( self )
assert iterations > NUM_
num sent += NUM_
class HttpResponseNotAllowed ( HttpResponse ) :
return value . replace ( tzinfo = None )
for template name in template name list :
sup cls = super ( cls , self )
choice value , choice label = choice
return self . loader ( self . loadname , self . dirs ) [ NUM_ ]
s = s . replace ( " STR_ " , " STR_ " )
for lineno , line in enumerate ( content . splitlines ( True ) ) :
except KeyError :
if match :
mtimes [ filename ] = mtime
output . append ( options )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = None , help = STR_ STR_ STR_ ) ,
error messages = kwargs . get ( STR_ ) or { }
return wrapper
pdict = { }
in ternal use only = True
return iri to uri ( location )
self . content length = content length
if app config . models module is None :
final attrs = self . build attrs ( attrs , type = self . in put type , name = name )
collect . extend ( builtin context processors )
import tempfile
def get complete version ( version = None ) :
class FileInput ( Input ) :
break
if is in stance ( self . regex , six . string types ) :
if bf . label :
except ValueError :
def get language from path ( request ) :
major = STR_ . join ( str ( x ) for x in version [ : parts ] )
def close ( self ) :
import memcache
if item [ STR_ ] is not None :
def init ( self , table ) :
class dummy :
return self . has key ( key )
best doublecolon start = doublecolon start
next = in dex + len ( self . boundary )
version = get complete version ( version )
IDENTIFIER = re . compile ( STR_ , re . I )
@ deconstructible
nodelist = parser . parse ( ( elif , else , STR_ ) )
delitem = new method proxy ( operator . delitem )
def compile filter ( self , token ) :
else :
return language . lower ( )
def time format ( value , format = None , use l10n = None ) :
def cleanup url ( url ) :
def handle default options ( options ) :
plist = [ ]
from django . utils . safestring import mark safe , SafeData , mark for escaping
def do extends ( parser , token ) :
pofile = os . path . join ( basedir , STR_ % str ( self . domain ) )
def write items ( self , handler ) :
model dependencies = [ ]
filemsg = STR_ % or igin
else :
def resolve error handler ( self , view type ) :
def push ( self , name , block ) :
for d in reversed ( self . dicts ) :
label output = self . handle label ( label , ** options )
def upload handlers ( self ) :
combined = Media ( )
class Command ( BaseCommand ) :
i += NUM_
dirs . append ( app dir )
if not self . in voked for django :
def init ( self , attrs = None , render value = False ) :
def get digit ( value , arg ) :
try :
def get host ( self ) :
def get foreign key ( parent model , model , fk name = None , can fail = False ) :
for sql file in sql files :
out += truncate text
raise EntitiesForbidden ( name , value , base , sysid , pubid , not ation name )
logging config func ( DEFAULT LOGGING )
if data :
f = s [ : end ]
return False
@ register . filter ( is safe = True )
for obj in self . queryset . all ( ) :
try :
return len ( value . split ( ) )
self . stderr . write ( " STR_ " % ( app name , model . meta . object name , e ) )
else :
attrname , rest , attrvalue = m . group ( NUM_ , NUM_ , NUM_ )
old field name = field name
else :
def unparsed entity decl ( self , name , base , sysid , pubid , not ation name ) :
def has changed ( self , in itial , data ) :
message = " STR_ " % top dir
ch , escaped = next ( pattern iter )
objects = json . loads ( stream or string )
widget = SelectMultiple
else :
def init ( self , protocol = STR_ , unpack ipv4 = False , * args , ** kwargs ) :
stream = StringIO ( stream or string )
return False
self . command stack . pop ( )
raise
@ property
def init ( self , message = None , code = None , whitelist = None ) :
import re
def emit post migrate ( verbosity , in teractive , database ) :
formfield = f . formfield ( ** kwargs )
class MovedAttribute ( LazyDescr ) :
def repr ( self ) :
else :
self . name = name
self . callback = None
def exists ( self , name ) :
if STR_ not in klass . dict :
path = join ( os . getcwdu ( ) , path )
tt = ( NUM_ , ) + tt [ NUM_ : ]
for node in self . nodelist loop :
def import library ( taglib module ) :
from itertools import chain
import zipfile
yield representative , True
return reversed ( self . keyOrder )
except ValueError :
self . validate key ( key )
return obj
raise self . error class ( " STR_ " % self . current token . display ( ) )
in ner text . extend ( getInnerText ( child ) )
if key in d :
import msvcrt
bool = new method proxy ( bool )
cls . delegate bytes = bytes in resultclasses
def getattr ( self , name ) :
output = [ ]
self . keyOrder . append ( key )
from django . utils . functional import LazyObject
html = endtag re . sub ( , html )
def as p ( self ) :
try :
return pformat ( value )
fk = fks to parent [ NUM_ ]
if namespaces :
@ register ( Tags . compatibility )
raise SignatureExpired ( STR_ % ( age , max age ) )
def nud ( self , parser ) :
raise ValueError ( " STR_ " % config [ STR_ ] )
def prefix ( bp , func ) :
super ( Command , self ) . handle ( STR_ , app name , target , ** options )
def utcoffset ( self , dt ) :
escaped = False
return os . path . getsize ( self . file . name )
def import by path ( dotted path , error prefix = ) :
def get request ( self ) :
def media property ( cls ) :
super ( WSGIServer , self ) . init ( * args , ** kwargs )
return False
g = g . strip ( STR_ )
supported = None
sys . exit ( NUM_ )
def u ( s ) :
try :
return self . filter ( name , func , ** flags )
self . attachments = attachments or [ ]
return True
if self . no obsolete :
error class = TemplateSyntaxError
encoding = encoding or settings . DEFAULT CHARSET
return None
continue
self . salt = force str ( salt or STR_ % ( self . class . module , self . class . name ) )
parts . append ( value )
def extend nodelist ( self , nodelist , node , token ) :
re newlines = re . compile ( r STR_ )
del self . dict [ item ]
except UnicodeEncodeError :
import sys
msg [ STR_ ] = formatdate ( )
def init ( self , stream , boundary ) :
try :
self . localized fields = getattr ( options , STR_ , None )
self . make writeable ( new path )
raise ValidationError ( self . message , code = self . code )
if domain == STR_ and file ext in command . extensions :
param , value = list ( six . iteritems ( kwarg ) ) [ NUM_ ]
taglib module = STR_ % ( module , library name )
if m . group ( NUM_ ) :
for field , messages in message . items ( ) :
from email . mime . text import MIMEText
def list ( self ) :
file move safe ( content . temporary file path ( ) , full path )
old field name = None
return self . load template ( template name , template dirs )
app list value = app list . setdefault ( app config , [ ] )
deps = [ apps . get model ( dep ) for dep in deps ]
for templatetag module in templatetags modules candidates :
priority = float ( priority )
self . func = func
return bytes ( ( i , ) )
return text . html ( )
def popitem ( self ) :
def start serialization ( self ) :
return [ ]
self . assert mutable ( )
value = [ conditional escape ( v ) for v in value ]
target app labels only = True
response = middleware method ( request , e )
if hasattr ( cls , k ) :
import re
from django . utils . deconstruct import deconstructible
pass
app list value . append ( model )
else :
if localized fields == ALL FIELDS or ( localized fields and f . name in localized fields ) :
attrs = { STR_ : id } if id else { }
app label , migration name = options [ STR_ ] , options [ STR_ ]
raise ContentNotRenderedError ( STR_ STR_ )
if bits [ NUM_ ] ! = as :
bit = self . render node ( node , context )
continue
if value in ( True , True , STR_ ) :
return ( STR_ )
try :
@ property
class ResolverMatch ( object ) :
return key , pdict
parser . in valid block tag ( endblock , STR_ , acceptable endblocks )
if limit choices to is not None :
def repr ( self ) :
cursor . execute ( " STR_ " " STR_ " % table , [ key ] )
@ property
BaseCache . init ( self , params )
self . in voked for django = False
res = subject [ p : i ]
meth func = " STR_ "
from django . core . files . base import File
return self . is rendered
def has key ( self , key , version = None ) :
for i , handler in enumerate ( self . upload handlers ) :
bf = self [ name ]
self . populate ( )
result . setLevel ( checkLevel ( level ) )
except Resolver404 as e :
self . lock = locks . setdefault ( name , RWLock ( ) )
title = plan node [ NUM_ ]
def set cookie ( self , key , value = , max age = None , expires = None , path = / , domain = None , secure = False , httponly = False ) :
return name , ser fmt , cmp fmt
from django . template . base import Lexer , Parser , tag re , NodeList , VariableNode , TemplateSyntaxError
return s . decode ( STR_ , errors ) . encode ( encoding , errors )
value = super ( URLField , self ) . to python ( value )
for name , field in self . fields . items ( ) :
for processor in get standard processors ( ) + processors :
self . model name = STR_
def get field type ( self , connection , table name , row ) :
@ python 2 unicode compatible
raise
try :
message context = None
cache . set ( cache key , headerlist , cache timeout )
opt dict = { STR_ : STR_ , STR_ : STR_ , STR_ : STR_ , STR_ : STR_ , STR_ : STR_ }
import warnings
new result . append ( item + i item )
self . iterator = iter ( value )
elif locs is None :
DEFAULT LOCALE ENCODING = get system encoding ( )
import operator
return len ( self . non form errors ( ) ) + sum ( len ( form errors ) for form errors in self . errors )
class SimpleCookie ( http cookies . SimpleCookie ) :
if root :
else :
from django . utils import six
content length = in t ( META . get ( STR_ , META . get ( STR_ , NUM_ ) ) )
CacheInfo = namedtuple ( " STR_ " , [ " STR_ " , " STR_ " , " STR_ " , " STR_ " ] )
if args [ - NUM_ ] ! = " STR_ " :
old = STR_ + work file [ NUM_ : ]
if name :
return self . class ( * self . dicts )
self . choices . append ( ( f , f . replace ( path , " " , NUM_ ) ) )
else :
else :
sys . stderr . write ( " STR_ " % ( e . errno , e . strerror ) )
cursor . execute ( line )
statement = [ ]
return force text ( unquote ( force str ( quoted url ) ) )
return wrapper
remaining bits = bits [ NUM_ : ]
else :
else :
if ( ( context . autoescape and not is in stance ( value , SafeData ) ) or is in stance ( value , EscapeData ) ) :
return . join ( rendered widgets )
return STR_
output = self . handle ( * args , ** options )
html class attr = STR_ % css classes
chunk length = len ( chunk )
if css classes :
if not is in stance ( self . object list , list ) :
if not os . access ( self . file path , os . W OK ) :
return self . data . is ocalendar ( ) [ NUM_ ]
in trans = True
else :
self . add item elements ( handler , item )
offset = self . timezone . utcoffset ( self . data )
try :
except LookupError :
newretval = post callback ( retval )
return list ( self . iterkeys ( ) )
warnings . warn ( " STR_ " , RemovedInDjango19Warning )
value . encode ( charset )
def make naive ( value , timezone ) :
return response
if id :
timezone = ( offset . days * NUM_ * NUM_ ) + ( offset . seconds // NUM_ )
def source error ( self , source , msg ) :
return
self . separator = b STR_ + boundary
if self . connection is None :
bits = token . split contents ( )
pattern iter = next char ( iter ( pattern ) )
seen . add ( k )
lookup view = get callable ( lookup view , True )
self . handler class = None
pass
from django . utils . translation import ugettext as
pass
class RegexURLResolver ( LocaleRegexProvider ) :
pass
leave locale alone = True
if self . verbosity >= NUM_ :
if level is not None :
if fields is not None :
if not is in stance ( error , ValidationError ) :
attrs [ class ] = self . form . required css class
self . method = environ [ STR_ ] . upper ( )
if len ( bits ) ! = NUM_ :
del self . get
in put text = ugettext lazy ( STR_ )
base36 . append ( digits [ i // j ] )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ STR_ ) ,
class SignatureExpired ( BadSignature ) :
return type ( self ) . next ( self )
if is in stance ( settings . TIME ZONE , six . string types ) and pytz is not None :
new name = STR_ % new name
msgs = msgs . replace ( old , new )
if new is None :
return bool ( value )
else :
if six . PY3 or os . name == STR_ :
class SelectMultiple ( Select ) :
if not language code re . search ( lang code ) :
for func , args in self . filters :
if self . feed [ STR_ ] is not None :
nonzero = new method proxy ( bool )
@ stringfilter
self . cookies [ key ] [ STR_ ] = domain
t = file name
pass
if not dictionary :
return False
raise NotImplementedError ( STR_ )
return
try :
DEFAULT MIN NUM = NUM_
def add arguments ( self , parser ) :
self . label suffix = label suffix if label suffix is not None else ( STR_ )
import time
super ( MovedAttribute , self ) . init ( name )
raise
date re = re . compile ( r STR_ )
for template dir in template dirs :
def init ( self , display name , loader , name , dirs ) :
else :
def dictitem ( s ) :
list = [ bytes to text ( elt , self . encoding ) for elt in list ]
assert version [ NUM_ ] in ( STR_ , STR_ , STR_ , STR_ )
date = datetime safe . new datetime ( date )
self . unpack ipv4 = unpack ipv4
self . payload = payload . decode ( STR_ , STR_ )
try :
from django . utils . encoding import force text , iri to uri
def render ( self , context ) :
clean = lambda self , x : len ( x )
cached modules = set ( )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , help = STR_ )
return SafeBytes ( data )
def activate ( timezone ) :
@ register . filter ( is safe = False )
if options [ " STR_ " ] . lower ( ) in ( STR_ , STR_ , STR_ ) :
def to locale ( language , to lower = False ) :
msg . attach ( attachment )
self . label = self . field . label
if hasattr ( timezone , STR_ ) :
return smart text ( obj )
node . replace ( decorated )
if self . feed [ STR_ ] is not None :
last [ NEXT ] = root [ PREV ] = cache [ key ] = link
try :
TRANSLATOR COMMENT MARK = STR_
if value in self . empty values :
def iter ( self ) :
class InvalidCacheBackendError ( ImproperlyConfigured ) :
new result = [ ]
self . second = None
if request . post parse error :
key = self . make key ( key , version = version )
value = related . natural key ( )
super ( PyLibMCCache , self ) . init ( server , params , library = pylibmc , value not found exception = pylibmc . NotFound )
def get template sources ( self , template name , template dirs = None ) :
def cache ( self ) :
pass
def check errors ( fn ) :
stderr . write ( STR_ % ( e . class . name , e ) )
except ( TypeError , AttributeError ) :
return STR_ . join ( usage )
for finder in sys . meta path :
return None
except KeyError :
field value = [ getInnerText ( k ) . strip ( ) for k in keys ]
self . template cache [ key ] = ( template , None )
self . validate ( out )
def init ( self , callback ) :
s = six . text type ( s )
import datetime
return " STR_ " % ( self . class . name , self )
str = serialize headers
return view
else :
os . makedirs ( directory )
def lock ( f , flags ) :
def clean ( self , value ) :
lang code = request . COOKIES . get ( settings . LANGUAGE COOKIE NAME )
self . active readers += t
loop dict [ STR_ ] = ( i == len values - NUM_ )
import calendar
def patch response headers ( response , cache timeout = None ) :
self . addr =
end -= NUM_
obj = Model ( ** data )
def reverse with prefix ( self , lookup view , prefix , * args , ** kwargs ) :
if show traceback :
output . append ( STR_ )
if self . verbosity >= NUM_ :
return potfiles
value =
if nodelist . get nodes by type ( ExtendsNode ) :
from django . db . migrations . state import ProjectState
return self . regex
pass
from future import unicode literals
keys = n . getElementsByTagName ( STR_ )
if not ip str . split ( STR_ ) [ - NUM_ ] == hextet :
return False
try :
loaders = [ ]
signature = base64 hmac ( self . salt + STR_ , value , self . key )
from django . utils . encoding import force str
if confirm == STR_ :
def addslashes ( value ) :
if self . merge and not conflicts :
attrvalue = None
def to locale ( language ) :
return value . replace ( STR_ \ \ \ \ STR_ " STR_ " " , "\\'" )
if token . contents == else :
parser . add argument ( STR_ , nargs = STR_ , help = STR_ )
state = tok . next
except ( ValueError , TypeError ) :
@ property
if ch in STR_ :
def module has submodule ( package , module name ) :
itervalues = " STR_ "
raise CommandError ( " STR_ " " STR_ " " STR_ " % app name )
self . path info = path info
if i >= NUM_ :
os . unlink ( work file )
current expires = typecast timestamp ( str ( current expires ) )
handler . addQuickElement ( " STR_ " , " " , { " STR_ " : " STR_ " , " STR_ " : self . feed [ STR_ ] } )
if self . verbosity >= NUM_ and not fixture files in dir :
style . ERROR OUTPUT = style . ERROR
if attrs :
for k , list in self . lists ( ) :
choices . in sert ( NUM_ , none value )
return self . namespace dict [ language code ]
closed = property ( get closed )
else :
def add prefix ( self , field name ) :
pass
def add arguments ( self , parser ) :
middle = middle [ len ( opening ) : ]
def render ( self , context ) :
if fake :
if self . current token is not EndToken :
def get current timezone name ( ) :
try :
continue
else :
return ( STR_ )
except KeyError as key :
alternative subtype = STR_
def prepare data ( self , data ) :
if set ( kwargs . keys ( ) ) | set ( defaults . keys ( ) ) ! = set ( params ) | set ( defaults . keys ( ) ) | set ( prefix args ) :
for char in self . add truncation text ( , truncate ) :
msgs = msgs . replace ( STR_ , STR_ )
else :
values = dict ( ( key , val . resolve ( context ) ) for key , val in six . iteritems ( self . extra context ) )
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
old handler = None
fname = self . key to file ( key , version )
bits = iter ( smart split ( self . contents ) )
def make middleware decorator ( middleware class ) :
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc info ( ) [ NUM_ ] )
if options [ STR_ ] in ( STR_ , STR_ ) :
class ConvertingList ( list ) :
else :
for attr in moved attributes :
def linebreaksbr ( value , autoescape = None ) :
else :
version = " STR_ "
def add arguments ( self , parser ) :
return str ( self )
value = values . get ( value . lower ( ) , value )
self . attrs = { }
try :
if secure :
def set choices ( self , value ) :
return etags
match = None
obj = copy . copy ( self )
if self . count is None :
class DateField ( BaseTemporalField ) :
class DebugParser ( Parser ) :
if self . flags and not is in stance ( self . regex , six . string types ) :
from django . core . management . templates import TemplateCommand
import sys
self . help text = help text
request middleware . append ( mw instance . process request )
args = [ sys . executable ] + [ STR_ % o for o in sys . warnoptions ] + sys . argv
pending references = { }
attrs . setdefault ( STR_ , STR_ )
class TypedChoiceField ( ChoiceField ) :
return self . queryset
else :
def has key ( self , key , version = None ) :
else :
pickled = pickle . dumps ( value , pickle . HIGHEST PROTOCOL )
self . context = context
res = in stance . dict [ self . name ] = self . func ( in stance )
ctx . update ( force bytes ( value ) )
if not using sysrandom :
eol message = message . replace ( str ( STR_ ) , str ( STR_ ) ) . replace ( str ( STR_ ) , str ( STR_ ) )
return mark safe ( contents )
def call ( self , value ) :
return sign + in t part + dec part
result = middleware . process request ( request )
return locale [ : p ] . lower ( ) + - + locale [ p + NUM_ : ] . lower ( )
else :
else :
class SelectDateWidget ( Widget ) :
if not hasattr ( callback , STR_ ) :
return cls ( date . year , date . month , date . day , time . hour , time . minute , time . second , time . microsecond , time . tzinfo )
return True
raise base . SerializationError ( " STR_ " % type ( obj ) )
from django . conf import settings
return True
from django . db . migrations . loader import MigrationLoader
if is in stance ( choice label , ( tuple , list ) ) :
field params = OrderedDict ( )
args = [ self . name , self . value , self . attrs ]
if six . PY2 :
return self . language
self . xgettext options = self . xgettext options [ : ] + [ STR_ ]
s = s . replace ( STR_ \ \ \ \ )
self . callback strs . add ( lookup str )
return fp . getvalue ( )
cc delim re = re . compile ( r STR_ )
""" """
sub match dict . update ( sub match . kwargs )
from django . core . management import call command
return json . loads ( data . decode ( STR_ ) )
from django . utils . six . moves . urllib . parse import quote
if app == STR_ :
return self . app dict [ language code ]
fs encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
else :
d = d [ idx ]
for site in sites :
def prepare class ( cls ) :
self . configure logger ( name , loggers [ name ] )
self . callback strs . add ( pattern . callback str )
app dirs = [ ]
namelist = self . archive . namelist ( )
def new ( cls , name , this bases , d ) :
def exit ( self , exc , value , tb ) :
check for migrations ( app config , connection )
if self . encoding is None :
localtime = LocalTimezone ( )
timeout = self . get backend timeout ( timeout )
sub match dict = dict ( match . groupdict ( ) , ** self . default kwargs )
from django . utils . datastructures import MultiValueDict
yield STR_
return force text ( s , encoding , strings only , errors )
def is safe url ( url , host = None ) :
self . stdout . write ( " STR_ " % new path )
self . msgattrib options = self . msgattrib options [ : ] + [ STR_ ]
widget = form . meta . widgets . get ( self . pk field . name , HiddenInput )
os . dup2 ( si . fileno ( ) , sys . stdin . fileno ( ) )
else :
with open ( path , STR_ ) as f :
self . saved forms = [ ]
class Tok ( object ) :
return STR_ % ( y , m , d )
primary keys = [ ]
value = field . clean ( value )
self . stdout . write ( " STR_ " )
if not is in stance ( urlconf name , six . string types ) :
break
with open ( old file name , STR_ ) as old file :
raise NotImplementedError ( STR_ )
key = self . make key ( key , version = version )
from django . views . debug import ExceptionReporter , get exception reporter filter
new matches = normalize ( parent pat + pat )
time . sleep ( NUM_ )
class DictWrapper ( dict ) :
def callback ( self ) :
headerlist . append ( STR_ + header )
import warnings
self . add handlers ( logger , handlers )
if not response . has header ( STR_ ) :
setattr ( cls , opname , opfunc )
widget = CheckboxInput
self . app label = STR_
return result
del self . cache [ key ]
for location in format locations :
for name , tok in lexer . lex ( js ) :
if display num errors :
def extract ( self , to path ) :
filemsg = STR_ % or igin
return self . cleaned data
from django . core . exceptions import ImproperlyConfigured
if next item and is in stance ( next item , ( list , tuple ) ) :
from django . utils . http import urlquote
output = force text ( output )
def main ( main func , args = None , kwargs = None ) :
except InvalidTemplateLibrary as e :
hlen = digest ( ) . digest size
post = STR_
if contains ( elt , in st ) :
return False
self [ key ] = result
text args = [ force text ( v ) for v in args ]
end = len ( s )
try :
file , , = imp . find module ( module name , [ entry ] )
new class = super ( ModelFormMetaclass , mcs ) . new ( mcs , name , bases , attrs )
self . xgettext options = self . xgettext options [ : ] + [ STR_ ]
except AttributeError :
for x in arg . split ( STR_ ) :
func globals = " STR_ "
return p . image . size
if hasattr ( active , " STR_ " ) :
@ python 2 unicode compatible
def splitext ( self , the path ) :
if use base manager :
return " STR_ "
from django . conf import settings
from django . http . multipartparser import MultiPartParser , MultiPartParserError
values = { STR_ : True , STR_ : False }
del self . expire info [ key ]
def add arguments ( self , parser ) :
basedirs = [ os . path . abspath ( basedir ) for basedir in basedirs if os . path . is dir ( basedir ) ]
self . close ( )
def init ( self , * args , ** kwargs ) :
return result
except IndexError :
def id for label ( self , id ) :
arg = args [ NUM_ ]
return . join ( force text ( s ) for s in strings )
from django . utils . translation import trans real as trans
label = STR_
break
yield " STR_ "
class URLValidator ( RegexValidator ) :
def is url ( self , template ) :
ch2 = None
for ldir in dirs :
self . nodelist = nodelist
return not bool ( self . option list )
return self . data . hour
pass
extra files . extend ( map ( lambda x : x . strip ( ) , file . split ( STR_ ) ) )
if item [ STR_ ] is not None :
if settings . DEBUG PROPAGATE EXCEPTIONS :
def import module ( name , package = None ) :
return date ( datetime . now ( tz = tzinfo ) , self . format string )
def format html join ( sep , format string , args generator ) :
if settings . configured :
key = self . make key ( key , version = version )
return final path
from django . conf import settings
params = [ source [ NUM_ ] ]
return t [ NUM_ ]
self [ k ] = v
try :
class Command ( BaseCommand ) :
def filepath to uri ( path ) :
self . auto id = auto id
else :
else :
option = STR_
elif hasattr ( s , STR_ ) :
from future import unicode literals
except Exception as e :
raise TypeError ( STR_ STR_ )
in itial value = in itial if in itial is not None else
for matches , pat , defaults in pattern . reverse dict . getlist ( name ) :
if self . takes context :
count = itertools . count ( NUM_ )
try :
if self . should delete form ( form ) :
for error in self . as data ( ) :
streaming = True
usage = sorted ( get commands ( ) . keys ( ) )
from future import unicode literals
from django . db import connections , DEFAULT DB ALIAS
@ register . filter ( is safe = True )
else :
space = unicode ( " " )
def content ( self ) :
value =
def render ( self , name , value , attrs = None ) :
super ( HttpResponseRedirectBase , self ) . init ( * args , ** kwargs )
match = ( pattern == * or pattern . startswith ( STR_ ) and ( host . endswith ( pattern ) or host == pattern [ NUM_ : ] ) or pattern == host )
return id
return guessed path
self . body = self . read ( )
pass
if best doublecolon end == len ( hextets ) :
smart str = smart text
def render to string ( template name , dictionary = None , context instance = None , dirs = None ) :
signals = STR_
def next char ( in put iter ) :
from django . utils . html import format html , format html join , escape
else :
if not template dirs :
return type ( form ) ( class name , ( form , ) , form class attrs )
for module in templatetags modules :
raise NotImplementedError ( STR_ )
from django . utils . six import StringIO
endbmatch = endblock re . match ( t . contents )
return repr ( dict ( self ) )
else :
raise self . error ( token , " STR_ " % ( command , get text list ( [ " STR_ " % p for p in parse until ] ) ) )
return " STR_ "
else :
return value
def urlize ( value , autoescape = None ) :
return value [ NUM_ ]
import code
if protocol ! = STR_ and unpack ipv4 :
or ig vars . pop ( STR_ , None )
if value in self . empty values :
if threading :
self . input data = in put data
return func ( * self . args , ** self . kw )
if app config . models module is None :
return True
memoryview = buffer
try :
in put type = STR_
return not self . is expired ( f )
if tag not in TemplateTagNode . mapping :
mail = EmailMultiAlternatives ( subject , message , from email , recipient list , connection = connection )
def render ( self , name , value , attrs = None ) :
base url = settings . MEDIA URL
in ternal use only = False
if auto id and STR_ not in attrs and STR_ not in widget . attrs :
ttl = force text ( ttl )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
def build instance ( Model , data , db ) :
if code changed ( ) :
vary on = ( )
for path in collect :
def get validation exclusions ( self ) :
bits = bits [ : - NUM_ ]
start = non capturing groups . pop ( )
@ register . filter ( expects localtime = True , is safe = False )
return sorted ( all files )
return parser
except NoReverseMatch :
def to python ( self , value ) :
pass
raise
self . connection . ehlo ( )
if bf . is hidden :
table = connections [ db ] . ops . quote name ( self . table )
selected choices = set ( force text ( v ) for v in selected choices )
return STR_ % ( self . class . name , dictreprs )
return TimestampSigner ( key , salt = salt ) . sign ( base64d )
if has old option :
return obj dict
p = locale . find ( STR_ )
opts = in stance . meta
msgs , errors , status = popen wrapper ( args )
def enter ( self ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
self . id = id
self . options . update ( { STR_ : False } )
return
return [ ]
try :
@ python 2 unicode compatible
if is in stance ( rhs , SafeText ) :
if STR_ in self . attrs :
translators comment start = None
else :
self . populate ( )
error msg = " STR_ "
def resolve variable ( path , context ) :
ip ( )
def pbkdf2 ( password , salt , iterations , dklen = NUM_ , digest = None ) :
get format lazy = lazy ( get format , six . text type , list , tuple )
except KeyError :
class MovedItems ( LazyModule ) :
class Command ( BaseCommand ) :
return super ( SlugField , self ) . clean ( value )
self . post = QueryDict ( )
try :
@ stringfilter
def wrapped view ( request , * args , ** kwargs ) :
validate ipv6 address ( value )
confirm = STR_
lineno comment map . setdefault ( t . lineno , [ ] ) . append ( t . contents )
id = final attrs . get ( STR_ , None )
config [ STR_ ] = self . as tuple ( config [ STR_ ] )
except AttributeError :
parser . add argument ( STR_ , metavar = self . label , nargs = + )
HttpResponse . content . fset ( self , value )
name , ext = os . path . splitext ( name )
else :
for field , errors in self . error dict . items ( ) :
import sys
data = base64 . b64decode ( raw data )
mode = stat . S IMODE ( st . st mode )
try :
else :
ext = self . splitext ( guessed filename ) [ NUM_ ]
language code = get language ( )
if end not in ( " > " , " STR_ " ) :
from django . utils . module loading import import string
for field name in self . fields :
import django
or iginal = UnicodeDecodeError . str ( self )
from django . core . files . utils import FileProxyMixin
def encoding ( self , value ) :
from django . core . files import temp as tempfile
old style list = True
current = current [ bit ]
self . saved forms . append ( form )
import logging
if STR_ not in os . environ :
tried = [ ]
else :
except KeyboardInterrupt :
if CONTEXT SEPARATOR in result :
return func ( self . wrapped , * args )
for x , y in zip ( val1 , val2 ) :
return STR_ . join ( statements )
renamed = False
return [ widget . value from datadict ( data , files , name + STR_ % i ) for i , widget in enumerate ( self . widgets ) ]
def truncate html ( self , length , truncate , text , truncate len , words ) :
if klass not in cls . dispatch :
def init ( self , * args , ** kwargs ) :
return self . id
return False
os . remove ( old file name )
from binascii import Error as BinasciiError
return False
except KeyError :
VARIABLE ATTRIBUTE SEPARATOR = STR_
return language [ : p ] . lower ( ) + STR_ + language [ p + NUM_ ] . upper ( ) + language [ p + NUM_ : ] . lower ( )
return val , encoded
elif is in stance ( o , decimal . Decimal ) :
if form in forms to delete :
if is in stance ( expires , datetime . datetime ) :
extra classes = extra classes . split ( )
filters = config . pop ( STR_ , None )
if i + NUM_ < len ( chunks ) :
for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :
self . num pages = NUM_
self . set regex ( regex )
if not is in stance ( stream or string , ( bytes , six . string types ) ) :
def get val ( ) :
from django . core . serializers . python import Deserializer as PythonDeserializer
base , ext = os . path . splitext ( base )
new msg = ( " STR_ " " STR_ " " STR_ " " STR_ " " STR_ " " STR_ " ) % ( connection . settings dict [ STR_ ] , e )
patch response headers ( response , cache timeout = - NUM_ )
class PageNotAnInteger ( InvalidPage ) :
else :
def add item elements ( self , handler , item ) :
raise CommandError ( " STR_ " )
cursor . execute ( connections [ db ] . ops . cache key culling sql ( ) % table , [ cull num ] )
return ValidationError ( self . data ) . error list
if options :
in itial value = field . to python ( hidden widget . value from datadict ( self . data , self . files , in itial prefixed name ) )
self . object list = object list
if self . save as new :
parser . add argument ( STR_ , STR_ , dest = STR_ , help = STR_ STR_ STR_ , action = STR_ )
from django . utils . datastructures import MultiValueDict , MergeDict
ULONG PTR = c int64
return super ( Info , self ) . init ( INFO , * args , ** kwargs )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
class ContentNotRenderedError ( Exception ) :
pk = self . data [ pk key ]
def find command ( cmd , path = None , pathext = None ) :
def default ( self , o ) :
if settings . STATIC URL is None :
super ( DictWrapper , self ) . init ( data )
return mark safe ( STR_ . join ( output ) )
def regex ( self ) :
msgs = STR_ . join ( dropwhile ( len , msgs . split ( STR_ ) ) )
self . fail silently = fail silently
self . closable objects . append ( value )
deactivate ( )
parser . add argument ( STR_ , help = STR_ )
from django . core . files import uploadhandler
for x , y in zip ( val1 , val2 ) :
def chars ( self , num , truncate = None , html = False ) :
def prepare value ( self , value ) :
if hasattr ( self . file , STR_ ) and hasattr ( self . file , STR_ ) :
s = six . text type ( s , encoding , errors )
def stringfilter ( func ) :
return import string ( path ) ( * args , ** kwargs )
class CsrfTokenNode ( Node ) :
raise MultiPartParserError ( STR_ % boundary )
return [ ]
return self . management form . cleaned data [ INITIAL FORM COUNT ]
module = import module ( self . mod )
else :
extension map = { STR_ : TarArchive , STR_ : TarArchive , STR_ : TarArchive , STR_ : TarArchive , STR_ : TarArchive , STR_ : ZipArchive , }
elif len ( fks to parent ) == NUM_ :
yield key , self [ key ]
def init ( self , url , length , mime type ) :
def simple tag ( self , func = None , takes context = None , name = None ) :
raise OverflowError ( STR_ )
token = self . next token ( )
cache = dict ( )
assert name , " STR_ "
loader = MigrationLoader ( connection )
def add arguments ( self , parser ) :
if not self . render value :
def slugify ( value ) :
if not want unicode :
if app config . models module is None :
if self . field . cache choices :
if result and ( mode == STR_ or ( mode == STR_ and current expires < now ) ) :
else :
class Serializer ( object ) :
if id :
raise NotImplementedError ( STR_ )
break
from future import unicode literals
f . seek ( NUM_ )
self . tags = { }
from django . utils . safestring import mark safe
if STR_ in kwargs :
def templatize ( src , or igin = None ) :
try :
continue
pass
else :
collect = [ ]
if filename not in mtimes :
return self . field . prepare value ( data )
context . render context . pop ( )
else :
raise InvalidTemplateLibrary ( " STR_ " " STR_ " , ( name , filter func ) )
def d ( self ) :
all unique checks = all unique checks . union ( set ( unique checks ) )
if STR_ in context :
def timeuntil filter ( value , arg = None ) :
self . archive = zipfile . ZipFile ( file )
if not supported platform or not is a tty :
self . save m2m = save m2m
self . template dirs = template dirs
def start serialization ( self ) :
new class = super ( RenameMethodsBase , cls ) . new ( cls , name , bases , attrs )
def get format modules ( lang = None , reverse = False ) :
return settings . LANGUAGE CODE
first item , second item = list
def media ( self ) :
if field type == STR_ and row [ NUM_ ] :
hfile = msvcrt . get osfhandle ( fd ( f ) )
self . kwargs = kwargs
if middle . startswith ( opening ) :
if t . contents . lstrip ( ) . startswith ( TRANSLATOR COMMENT MARK ) :
for line in content . split ( " STR_ " ) :
import sys
UnlockFileEx = windll . kernel32 . UnlockFileEx
value = str ( value )
base64d = base64d [ NUM_ : ]
import re
self . can write . release ( )
import io
return mark safe ( value )
class BaseEmailBackend ( object ) :
week number = j // NUM_
for part in singular :
selected choices . remove ( option value )
plural = [ ]
handler . endElement ( " STR_ " )
resolver = urlresolvers . RegexURLResolver ( r STR_ , urlconf )
if urlconf is None :
if self . is bound and i < self . in itial form count ( ) :
self . add root elements ( handler )
errors . extend ( new errors )
if value and hasattr ( value , " STR_ " ) :
choices = [ ( i , i ) for i in range ( NUM_ , NUM_ ) ]
from io import BytesIO
if not url :
cmp fmt = None
def handle ( self , * app labels , ** options ) :
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning )
class BooleanField ( Field ) :
def delete cookie ( self , key , path = / , domain = None ) :
if token . contents == STR_ :
except ( OSError , IOError ) :
self . active writers += NUM_
except OSError as err :
code list . append ( opt dict [ o ] )
try :
for f in opts . many to many + opts . virtual fields :
if self . use natural keys :
if six . PY2 :
else :
def to python ( self , value ) :
import os
elif options [ " STR_ " ] and not options [ " STR_ " ] and not options [ " STR_ " ] :
self . callback = callback
if os . path . abspath ( dirpath ) . startswith ( os . path . dirname ( path ) ) :
def quote etag ( etag ) :
args = [ STR_ , STR_ , domain , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ] + command . xgettext options
raise TemplateSyntaxError ( " STR_ " " STR_ " % var )
if is in stance ( stream or string , bytes ) :
self . start relational field ( field )
self . validate key ( key )
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
new value = value + delta
defaults [ STR_ ] = self . data
f . required = False
result . parent = self
except StopIteration :
commands = get commands ( )
[ m [ k ] ] = v
def has vary header ( response , header query ) :
parentmod , submod = get mod func ( mod name )
if not is valid ipv6 address ( ip str ) :
config [ STR_ ] = config . pop ( STR_ )
def iter format modules ( lang , format module path = None ) :
except IndexError :
def do ntranslate ( singular , plural , number , translation function ) :
except UnicodeDecodeError as e :
def open ( self , mode = None ) :
super ( HttpResponseNotModified , self ) . init ( * args , ** kwargs )
if not m :
self . style = no style ( )
def in ner ( check ) :
return [ Warning ( " STR_ " , hint = ( " STR_ " " STR_ " " STR_ " ) , obj = field , id = STR_ , ) for field in problem fields ]
return s
write ( end )
obj pk = obj pk . pk
return False
def long to bin ( x , hex format string ) :
if format not in serializers :
raise LookupError ( lang code )
self . nodelist = compile string ( template string , or igin )
iterator = ChunkIter ( stream or iterable , NUM_ )
if app names :
for obj in PythonDeserializer ( yaml . load ( stream , Loader = SafeLoader ) , ** options ) :
else :
from django . db import connections , router , transaction , DEFAULT DB ALIAS
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning )
if self . paths to remove :
except OSError as e :
return [ self [ k ] for k in self . keyOrder ]
if STR_ in response and request . get host ( ) :
return id
id for label = widget . id for label ( id )
def send messages ( self , email messages ) :
offset mins = in t ( tzinfo [ - NUM_ : ] ) if len ( tzinfo ) > NUM_ else NUM_
def repr ( self ) :
subcommand cls = self . fetch command ( cwords [ NUM_ ] )
field params [ STR_ ] = row [ NUM_ ] if row [ NUM_ ] is not None else NUM_
number = str ( number ) [ NUM_ : ]
bad serializer = BadSerializer ( exc )
response = middleware method ( request , callback , callback args , callback kwargs )
else :
value = tuple . getitem ( self , key )
if value is None :
parts . append ( " STR_ " % ( groupid , tok . regex ) )
def sanitize address ( addr , encoding ) :
return self . data . month
def ngettext ( singular , plural , number ) :
empty values = list ( validators . EMPTY VALUES )
self . mutex = threading . RLock ( )
s = s1
bits = [ ]
def clear url caches ( ) :
with self . mutex :
message = ( STR_ )
def default ( value , arg ) :
def getstate ( self ) :
from importlib import import module
break
def get ns resolver ( ns pattern , resolver ) :
new class . base fields = declared fields
context [ self . target var ] = func ( * resolved args , ** resolved kwargs )
def clear ( self ) :
continue
if six . PY3 :
if pos >= last :
final attrs = dict ( final attrs , id = STR_ % ( id , i ) )
app dirs . append ( os . path . normpath ( os . path . join ( app dir , STR_ ) ) )
return min ( self . management form . cleaned data [ TOTAL FORM COUNT ] , self . absolute max )
if self . dispatch is None :
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
from django . utils . encoding import force text
if STR_ in content params :
raise CommandError ( " STR_ " " STR_ " % top dir )
if result is not None :
if not self . is expired ( f ) :
@ stringfilter
self . template parser = parser
signals . got request exception . send ( sender = self . class , request = request )
if is in stance ( obj , models . signals . ModelSignal ) :
self . requires system checks = ( self . requires system checks if has new option else self . requires model validation if has old option else True )
save m2m ( )
return json . dumps ( obj , separators = ( STR_ , STR_ ) ) . encode ( STR_ )
handler . endElement ( " STR_ " )
def striptags ( value ) :
def check all models ( app configs = None , ** kwargs ) :
except ValueError :
return palette
extracted . close ( )
def init ( self , filter expression ) :
def ngettext lazy ( singular , plural , number = None ) :
return False
from django . utils . functional import lazy
@ cached property
if language not in translations :
class LoaderOrigin ( Origin ) :
def reload ( self ) :
return func ( * resolved args , ** resolved kwargs )
elif ch == STR_ :
warnings . warn ( " STR_ " )
from django . utils . six . moves . urllib . parse import parse qsl , urlencode , quote , urljoin , urlsplit
method = kwargs . pop ( STR_ )
return cache
def dumps ( self , obj ) :
if six . PY3 :
def repr ( self ) :
from django . utils . six . moves import xrange
if var obj is None :
subcommand = STR_
response . streaming content = [ ]
shutdown message = STR_ % db name
if is in stance ( value , datetime . datetime ) :
value = str ( Header ( value , STR_ , maxlinelen = sys . maxsize ) . encode ( ) )
if current app and current app in app list :
models . add ( model )
requires system checks = False
self . remaining = length
def get choices ( self ) :
check . tags = tags
try :
form . fields [ name ] = InlineForeignKeyField ( self . in stance , ** kwargs )
return serializer ( ) . loads ( data )
all files . append ( TranslatableFile ( dirpath , filename , locale dir ) )
if self . verbosity >= NUM_ :
doy += NUM_
def get scheme ( self ) :
for opt in self . option list :
except UnicodeError :
from django . utils . module loading import import string
app name = commands [ subcommand ]
self . file . close ( )
@ register . filter ( " STR_ " , is safe = True )
from django . core . mail import get connection
op = OPERATORS [ token ]
created models = [ ]
HTMLParser = html parser . HTMLParser
self . deleted form indexes = [ ]
if self . data . day in ( NUM_ , NUM_ , NUM_ ) :
os . umask ( umask )
self . stdout . write ( " STR_ " % writer . path )
can import settings = False
else :
def add handlers ( self , logger , handlers ) :
if target app labels only :
elif callable ( func ) :
class DjangoJSONEncoder ( json . JSONEncoder ) :
return None
supported platform = plat ! = STR_ and ( plat ! = STR_ or STR_ in os . environ )
self . extra context = kwargs . pop ( STR_ , { } )
return name + STR_
def create variable node ( self , contents ) :
self . active writers += NUM_
@ property
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
elif len ( cache ) >= maxsize :
elif ch == STR_ :
final attrs = self . build attrs ( attrs , name = name )
from django . utils . module loading import module has submodule
elif not hasattr ( message , STR_ if six . PY3 else STR_ ) :
return super ( ModelChoiceField , self ) . prepare value ( value )
if mimetype is None :
I18N MODIFIED = NUM_
return week number
if is in stance ( s , Promise ) :
set script prefix ( get script name ( environ ) )
@ content . setter
if nodelist :
import sys
if bf errors :
logging . Handler . init ( self )
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
elif subcommand == STR_ or self . argv [ NUM_ : ] == [ STR_ ] :
raise ImproperlyConfigured ( STR_ )
format key = STR_
in teger types = ( in t , long )
self . base fields [ TOTAL FORM COUNT ] = IntegerField ( widget = HiddenInput )
return path
if in stance is not None :
except StandardError as e :
content = content . encode ( STR_ )
def request ( request ) :
if args [ NUM_ ] [ NUM_ ] == STR_ :
pass
def delete ( self , key , version = None ) :
name = self . save ( name , content )
substitutions [ STR_ ] = format html ( self . url markup template , value . url , force text ( value ) )
else :
if with base fields :
if auto id and STR_ in smart text ( auto id ) :
@ lru cache . lru cache ( maxsize = NUM_ )
def init ( self , server , params ) :
return bytes ( s )
raise InvalidTemplateLibrary ( " STR_ " " STR_ " % taglib module )
help = STR_
return ForNode ( loopvars , sequence , is reversed , nodelist loop , nodelist empty )
current chunk = old file . read ( chunk size )
data = BytesIO ( self . body )
buf = self . readline ( )
try :
elif field . required :
self . nodelist true , self . nodelist false = nodelist true , nodelist false
if not hasattr ( self , STR_ ) :
return repr ( self . value )
from future import unicode literals
six . reraise ( * exc info )
if is relation :
def add filters ( self , filterer , filters ) :
if self . body :
def close ( self , ** kwargs ) :
self . children . append ( data )
@ stringfilter
if data [ last : last + NUM_ ] == b STR_ :
super ( TemplateResponse , self ) . init ( template , context , content type , status )
handlers = config . get ( STR_ , None )
return types . MethodType ( func , obj , obj . class )
week number = NUM_
self . name = name
ETAG MATCH = re . compile ( r STR_ )
yield import module ( STR_ % ( location % loc ) )
if hasattr ( parent , STR_ ) :
cursor . close ( )
return fastcgi help ( )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : ( self . max digits - self . decimal places ) } , )
var , constant = match . group ( " STR_ " , " STR_ " )
if not hasattr ( self , STR_ ) :
p pattern = p pattern [ NUM_ : ]
def default if none ( value , arg ) :
try :
iterbytes = iter
return wrapper
opts = in stance . meta
import warnings
yield node
from django . forms . formsets import BaseFormSet , formset factory
raise NotImplementedError ( STR_ )
def wrapper ( * args , ** kwargs ) :
from django . conf import settings
if str number [ NUM_ ] == - :
for handler in self . upload handlers :
except IndexError :
def init ( self , urlconf name , default kwargs = None , app name = None , namespace = None ) :
raise ValueError ( " STR_ " % ( model . meta . app label , model . meta . object name , parent model . meta . app label , parent model . meta . object name ) )
return six . unichr ( html entities . name2codepoint [ text ] )
self . chunk size = min ( [ NUM_ ** NUM_ - NUM_ ] + possible sizes )
USE INOTIFY = False
attachment . add header ( STR_ , STR_ , filename = filename )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
class EndToken ( TokenBase ) :
value = force text ( value )
from future import unicode literals
return response
template dir = template dir . decode ( fs encoding )
from django . utils . encoding import force str
add doc ( b , " " " STR_ " " " )
if is in stance ( stream or string , bytes ) :
if msg :
def has changed ( self , in itial , data ) :
from django . conf import settings
def all valid ( formsets ) :
def has changed ( self , in itial , data ) :
from email . header import Header
def save m2m ( ) :
return path . encode ( fs encoding )
comment lineno cache = None
continue
super ( Serializer , self ) . handle field ( obj , field )
break
return message
from django . core . signals import request finished
converter = connection . in trospection . table name converter
to delete = set ( )
default settings = module to dict ( global settings )
form = self . forms [ i ]
return MONTHS [ self . data . month ]
databases = [ self . using , None ]
DEFAULT CHUNK SIZE = NUM_ * NUM_ ** NUM_
self . msguniq options = self . msguniq options [ : ] + [ STR_ ]
for cnt , digit in enumerate ( in t part [ : : - NUM_ ] ) :
def enter ( self ) :
self . domain whitelist = whitelist
def T ( self ) :
finally :
self [ STR_ ] = content type
else :
def list ( self , * args , ** kwargs ) :
cursor . execute ( " STR_ " " STR_ " % table , [ key ] )
field = self . fields [ name ]
return make middleware decorator ( middleware class ) ( )
function name = ( name or getattr ( func , STR_ , func ) . name )
pk key = " STR_ " % ( self . add prefix ( i ) , self . model . meta . pk . name )
class RendererMixin ( object ) :
def abspathu ( path ) :
def iter ( self ) :
proxy = lazy ( func , resultclass ) ( ** kwargs )
try :
for chunk in content . chunks ( ) :
result = super ( SortedDict , self ) . pop ( k , * args )
continue
class HttpResponseRedirectBase ( HttpResponse ) :
if arg not in ( STR_ , STR_ ) :
UNKNOWN SOURCE = STR_
for form in valid forms :
from django . core . management . base import AppCommand
lead = lead + opening
def handle uncaught exception ( self , request , resolver , exc info ) :
def init ( self , file , field name , name , content type , size , charset , content type extra = None ) :
def set name ( self , name ) :
return self . count
format = force str ( default or get format ( STR_ ) [ NUM_ ] )
def init ( self , timezone ) :
self . empty = options . get ( STR_ , False )
value = [ ]
parser . add argument ( STR_ , action = STR_ , dest = STR_ , help = STR_ )
self . regex = re . compile ( self . regex , self . flags )
help = " STR_ "
FIELD = " STR_ "
return strftime ( self , fmt )
if decimals > digits :
if not self . mutable :
value = urlunsplit ( url fields )
pass
all = ( STR_ , STR_ , STR_ , STR_ )
self . populate ( )
raise NotImplementedError ( STR_ )
full statement . append ( STR_ % ( line , STR_ if i < len ( table output ) - NUM_ else ) )
def init ( self , nodelist ) :
else :
if timeout == DEFAULT TIMEOUT :
else :
return output
from django . utils . jslex import prepare js for gettext
try :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = None , help = STR_ )
if is in stance ( value , str ) :
self . errors = None
from django . core . management . base import AppCommand
GB = NUM_ << NUM_
import errno
def handle template ( self , template , subdir ) :
called from command line = False
df = DateFormat ( value )
self . encoding = settings . DEFAULT CHARSET
parser . print help ( )
id = self . field . widget . attrs . get ( STR_ ) or self . auto id
obj = force str ( self . obj )
if e . errno ! = errno . EEXIST :
trail = punctuation + trail
from django . core . management . base import BaseCommand
if not is in stance ( data , basestring ) :
if not self . has expired ( key ) :
gettext noop = gettext lazy = = gettext
b64encoded = base64 . b64encode ( pickled )
self . limit value = limit value
name , val = forbid multi line headers ( name , val , self . encoding )
urlresolvers . set urlconf ( urlconf )
for path in self . locale paths :
else :
if tags is not None :
pop context = True
elif self . verbosity > NUM_ :
data = zlib . decompress ( data )
if not re . search ( r STR_ , name ) :
def register ( self , * tags ) :
thread . start new thread ( main func , args , kwargs )
if item [ STR_ ] is not None :
from datetime import datetime
potfiles = self . build potfiles ( )
raise NotImplementedError ( STR_ )
newline = unicode ( " STR_ " )
obj . children = copy . deepcopy ( self . children , memodict )
if hasattr ( file or path , STR_ ) :
base2 = BaseConverter ( BASE2 ALPHABET )
from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist
kw = match . groupdict ( )
pass
try :
if filename . endswith ( " STR_ " ) or filename . endswith ( " STR_ " ) :
try :
for field in model . meta . fields :
return filename and filename [ filename . rfind ( " \\" ) + 1 : ] . strip ( )
def callable ( obj ) :
msg = self . style . HTTP INFO ( msg )
def render ( self , context ) :
if file :
from django . conf import settings
changeset = timestamp . strftime ( STR_ )
additional headers = [ newheader for newheader in newheaders if newheader . lower ( ) not in existing headers ]
if num > self . max entries :
except ImportError :
def render ( self , context ) :
used = name . pop ( NUM_ )
setattr ( Module six moves urllib error , attr . name , attr )
for model in app models :
self . value = value
except UnicodeDecodeError :
definition [ STR_ ] = opts
import sys
yield STR_ % line [ : space - NUM_ ]
from django . core . exceptions import ValidationError , NON FIELD ERRORS
content = File ( content )
def add arguments ( self , parser ) :
used column names . append ( att name )
new name = STR_ % ( new name , num )
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
except VariableDoesNotExist :
script url = get bytes from wsgi ( environ , STR_ , )
class InMemoryUploadedFile ( UploadedFile ) :
url = quote ( url , safe = b STR_ )
@ classmethod
m = re . match ( naiveip re , options [ STR_ ] )
while i < l :
except SuspiciousOperation as e :
msgmerge options = [ STR_ , STR_ ]
class CachedDnsName ( object ) :
return bytes ( value )
if len ( bits ) == NUM_ :
def new ( mcs , name , bases , attrs ) :
return OrderedDict ( fields )
from django . core . files . move import file move safe
cursor . execute ( " STR_ " " STR_ " % table , [ key ] )
ExpatParser . reset ( self )
style = no style ( )
message = STR_
class Node ( object ) :
for name , field in self . fields . items ( ) :
assert mimetype is not None
if not self . upload handlers :
s = get serializer ( format ) ( )
k = force bytes ( k , self . encoding )
def add item elements ( self , handler , item ) :
help = STR_
locale dirs = filter ( os . path . is dir , glob . glob ( STR_ % basedir ) )
self . error class = error class
def empty variable ( self , token ) :
def render ( self , context ) :
handler . new file ( field name , file name , content type , content length , charset , content type extra )
result . validators = self . validators [ : ]
def render ( self , name , value , attrs = None , choices = ( ) ) :
import os
settings . configure ( )
domains = ( STR_ , )
if hasattr ( self . data , STR_ ) and self . data . tzinfo :
if not digest :
connection = connections [ options [ STR_ ] ]
def format html ( format string , * args , ** kwargs ) :
if is in stance ( other , BaseContext ) :
if settings . DEBUG :
for field , in itial , data in zip ( self . fields , in itial , data ) :
return STR_ % self . data . microsecond
app = STR_
messages = ValidationError ( messages )
raw query string = get bytes from wsgi ( self . environ , STR_ , )
requires system checks = False
content = content . decode ( STR_ )
target dir = path . join ( top dir , relative dir )
unique id = get tag uri ( item [ STR_ ] , item [ STR_ ] )
for migration in app migrations :
from django . core . exceptions import ValidationError
result = factory ( ** kwargs )
exc value = exc type ( " STR_ " % dt )
f . save form data ( in stance , cleaned data [ f . name ] )
if hasattr ( extra classes , STR_ ) :
cmatch = constant re . match ( parts [ NUM_ ] )
else :
del kwargs [ STR_ ]
raise NotImplementedError ( STR_ )
self . setFeature ( handler . feature external pes , False )
return STR_
self . mark post parse error ( )
import re
if STR_ in word or STR_ in word or STR_ in word :
try :
else :
for handler in handlers :
if dt . year >= NUM_ :
return value
except ( archive . ArchiveException , IOError ) as e :
try :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
in put type = STR_
@ decorator
extra params [ STR_ ] = True
def add js ( self , data ) :
pass
self . next = next
return self . size
self . dirpath = dirpath
import re
current = settings . TEMPLATE STRING IF INVALID
docs version = STR_ % django . VERSION [ : NUM_ ]
CONVERT PATTERN = re . compile ( r STR_ )
use workaround = ( ( current version < ( NUM_ , NUM_ , NUM_ ) ) or ( current version >= ( NUM_ , NUM_ ) and current version < ( NUM_ , NUM_ , NUM_ ) ) )
self . namespaces = [ ]
msg = self . style . HTTP SERVER ERROR ( msg )
if self . in stance . pk is None :
translation . activate ( STR_ )
self . url name = url name
if fields is not None and f . name not in fields :
def multiple chunks ( self , chunk size = None ) :
pass
def make bytes ( self , value ) :
def init ( self , offset ) :
class AutoEscapeControlNode ( Node ) :
options += [ ( app config . label , NUM_ ) for app config in app configs ]
return
if self . old timezone is None :
pass
if len ( fks to parent ) == NUM_ :
while i < len ( subject ) and subject [ i ] ! = subject [ p ] :
if path is None :
raise BadSignature ( STR_ % sig )
if cached is not None :
if cache timeout is None :
def save new objects ( self , commit = True ) :
getitem = new method proxy ( operator . getitem )
if decimal pos is not None :
elif simple url 2 re . match ( middle ) :
return message
self . in teractive = options . get ( STR_ )
if args :
field desc += STR_
if PY3 :
if status ! = STATUS OK :
return self . id in settings . SILENCED SYSTEM CHECKS
return
raise CommandError ( STR_ % exclude )
guts = re . sub ( r " STR_ " , escape quotes , tok [ NUM_ : - NUM_ ] )
return bytes ( value )
for field , messages in errors . error dict . items ( ) :
if PY3 :
self . add arguments ( parser )
raise InvalidTemplateLibrary ( " STR_ " % ( taglib module , e ) )
file field list = [ ]
def keys ( self ) :
if hasattr ( request , STR_ ) :
linebreaks = allow lazy ( linebreaks , six . text type )
default error messages = { STR_ : ( STR_ ) , }
if strings only and is protected type ( s ) :
if is in stance ( data , ( MultiValueDict , MergeDict ) ) :
except ( ValueError , TypeError ) :
if not os . path . exists ( top dir ) :
def has key ( self , key ) :
for filepath in self . get template sources ( template name , template dirs ) :
from importlib import import module
raise TemplateSyntaxError ( " STR_ " % bits [ NUM_ ] )
pass
with io . open ( work file , " STR_ " , encoding = STR_ ) as fp :
if STR_ in ip str . split ( STR_ ) [ - NUM_ ] :
Module six moves urllib robotparser . moved attributes = urllib robotparser moved attributes
display url = url
value = unicodedata . normalize ( STR_ , value ) . encode ( STR_ , STR_ ) . decode ( STR_ )
parts = [ ]
memo [ id ( self ) ] = result
attrs [ STR_ ] = auto id
attrs [ STR_ ] = widgets
class StringOrigin ( Origin ) :
handle default options ( options )
parser . add argument ( STR_ , help = STR_ )
pass
@ python 2 unicode compatible
class UnrecognizedArchiveFormat ( ArchiveException ) :
from django . core . management . base import AppCommand
self . first = True
self . write migration files ( changes )
in hibit post migrate = options . get ( STR_ , False )
except :
import copy
found = self . importer ( used )
self . close ( )
def get valid filename ( s ) :
self . boundary = boundary
def lower ( value ) :
if is in stance ( addr , six . string types ) :
except UnicodeDecodeError :
def deactivate ( ) :
def init ( self , params ) :
def forms ( self ) :
break
outdict [ name ] = value , params
if field in self . errors :
return
def has leading dir ( self , paths ) :
return self . represent scalar ( STR_ , str ( data ) )
extra classes . add ( self . form . error css class )
try :
context match = context re . match ( bmatch . group ( NUM_ ) )
elif str ( level ) == level :
self . stdout . write ( " STR_ " % operation . describe ( ) )
return timedelta ( seconds = - time . altzone )
def init ( self , media = None , ** kwargs ) :
return str ( o )
else :
break
self . stream = options . pop ( " STR_ " , six . StringIO ( ) )
return list ( self . iter ( ) ) [ idx ]
def create mime attachment ( self , content , mimetype ) :
from django . core . mail . backends . base import BaseEmailBackend
def wrapper ( * args , ** kwds ) :
default = translation ( settings . LANGUAGE CODE )
in put type = STR_
return attrs
@ property
arg vals . append ( arg . resolve ( context ) )
from django . core . management . base import CommandError
tag exists = registry . tag exists
choices = ( ( STR_ , ugettext lazy ( STR_ ) ) , ( STR_ , ugettext lazy ( STR_ ) ) , ( STR_ , ugettext lazy ( STR_ ) ) )
def render ( self ) :
def init ( self ) :
get language = lambda : settings . LANGUAGE CODE
super ( Textarea , self ) . init ( default attrs )
match = date re . match ( value )
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
super ( EmailBackend , self ) . init ( * args , ** kwargs )
def ne ( self , other ) :
msg = message . message ( )
BASE56 ALPHABET = STR_
else :
return time str + STR_
try :
def in fix ( bp , func ) :
import sys
new ip . append ( STR_ )
elif hasattr ( query , STR_ ) :
self . max digits , self . decimal places = max digits , decimal places
except Exception as e :
r = r [ : - NUM_ ] + STR_
else :
pass
if hasattr ( rel model , STR_ ) and rel model ! = model :
extra params [ STR_ ] = True
yield item
raise AttributeError ( " STR_ " % self . class . name )
return value . strftime ( format )
kwargs [ str ( param ) ] = value
def Deserializer ( object list , ** options ) :
from xml . dom import pulldom
return result
for f in file list :
cursor . execute ( " STR_ " % table )
return STR_
self . tags . update ( lib . tags )
return SafeText ( data )
def constant time compare ( val1 , val2 ) :
return self . STDOFFSET
class TextInput ( Input ) :
try :
model fields = Model . meta . get all field names ( )
if not bits :
return
fileno = property ( lambda self : self . file . fileno )
return ( NUM_ , NUM_ )
unichr = chr
value = data . get ( name , None )
return list ( self )
self . default locale path = None
try :
ignored = [ ]
BASE62 ALPHABET = STR_
self . stream . write ( " STR_ " )
def to python ( self , value ) :
if not extra context :
e . message = self . error messages [ e . code ]
from django . http . cookie import SimpleCookie
def transform ( self , node , results ) :
stats [ HITS ] += NUM_
def m2m convert ( value ) :
except ImportError :
bytes = serialize
prefix = get script prefix ( )
pass
from future import unicode literals
bits = arg . split ( STR_ )
return dec
if typed :
ip str = sanitize ipv4 mapping ( ip str )
extensions = tuple ( handle extensions ( options [ STR_ ] , ignored = ( ) ) )
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
return in put val
self . caches = local ( )
class TemplateDoesNotExist ( Exception ) :
self . symlinks = options . get ( STR_ )
class Trans ( object ) :
if not getattr ( f , STR_ , False ) :
else :
return urljoin ( self . base url , filepath to uri ( name ) )
val = STR_ . join ( sanitize address ( addr , encoding ) for addr in getaddresses ( ( val , ) ) )
response [ STR_ ] = http date ( time . time ( ) + cache timeout )
bytes read += len ( bytes )
if self . allow folders :
try :
import fcntl
if not email messages :
continue
from django . core . servers . basehttp import run , get internal wsgi application
value = bool ( value )
import base64
constant string = constant string . replace ( " STR_ " , " " )
unhandled params . pop ( NUM_ )
return result
, params = cgi . parse header ( content disposition )
import warnings
def get serializer ( format ) :
else :
if old handler is not None :
if field . help text :
if bytes < KB :
TYPE = RAW
return unbound
if last == NUM_ :
assert remaining > NUM_ , STR_
key += kwd mark
kwargs safe = dict ( ( k , conditional escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
clean = lambda self , x : x
result = c ( ** kwargs )
signed value = force str ( signed value )
def str ( self ) :
try :
def getvalue ( self ) :
if self . active writers == NUM_ and self . waiting writers == NUM_ and self . active readers == NUM_ :
raise CommandError ( " STR_ " % format )
def upload complete ( self ) :
return self . cast ( ) % rhs
raise TemplateSyntaxError ( " STR_ " % ( name , param ) )
def id for label ( self , id ) :
for refto , refs in references . items ( ) :
illegal formatting = illegal formatting . search ( fmt )
try :
raise self . exception
j = NUM_ ** factor
for statement in in dex output :
s = s . encode ( STR_ )
with Archive ( path ) as archive :
def cull ( self , db , cursor , now ) :
def run from argv ( self , argv ) :
os . utime ( dst , ( st . st atime , st . st mtime ) )
self . fields = getattr ( options , STR_ , None )
KB = NUM_ << NUM_
self . GET = QueryDict ( mutable = True )
def unsign ( self , value , max age = None ) :
item , old style list = convert old style list ( sublist )
return get timezone name ( get current timezone ( ) )
return self . regex dict [ language code ]
def send messages ( self , email messages ) :
from django . core import checks
try :
super ( SimpleTemplateResponse , self ) . init ( , content type , status )
suffixes = ( STR_ . join ( ext for ext in combo if ext ) for combo in product ( databases , ser fmts , cmp fmts ) )
except ( ValueError , TypeError ) :
if is in stance ( o , datetime . datetime ) :
x = NUM_
return self . limit choices to
def enter command ( self , command , token ) :
def date ( self ) :
html parser . HTMLParser . init ( self , convert charrefs = convert charrefs , ** kwargs )
os . utime ( path , None )
top errors = self . non field errors ( )
requires system checks = False
ret ip = [ ]
label = conditional escape ( force text ( bf . label ) )
if is in stance ( value , datetime . date ) :
elif self . delegate text :
def text words ( self , length , truncate ) :
if self . is checked ( ) :
help = " STR_ "
def literals ( choices , prefix = " " , suffix = " " ) :
for line in text . splitlines ( True ) :
def gettext ( message ) :
tt = time . localtime ( stamp )
def latest post date ( self ) :
if new name . startswith ( STR_ ) :
meth = cls . promise ( resultclass , k , v )
del cc [ STR_ ]
try :
def convert ( self , value ) :
if in itial is None :
f = super ( ImageField , self ) . to python ( data )
if is in stance ( s , six . memoryview ) :
return obj
exclude = options . get ( STR_ )
def combine ( cls , date , time ) :
pass
total forms = in itial forms
args safe = map ( conditional escape , args )
return - NUM_
except UnicodeEncodeError :
def is valid ( self ) :
else :
modules = format modules cache . setdefault ( lang , list ( iter format modules ( lang , settings . FORMAT MODULE PATH ) ) )
def sanitize ipv4 mapping ( ip str ) :
del options [ STR_ ]
new path = path . join ( top dir , relative dir , filename . replace ( base name , name ) )
pass
if template . startswith ( STR_ ) :
return func ( * args , ** kwargs )
writelines = property ( lambda self : self . file . writelines )
def render ( self , context ) :
try :
return form . cleaned data . get ( DELETION FIELD NAME , False )
if value in self . empty values :
self . post , self . files = QueryDict ( self . body , encoding = self . encoding ) , MultiValueDict ( )
return EscapeText ( s )
def contains ( self , other ) :
declared fields = OrderedDict ( )
elif name is not None and compile function is not None :
def create token ( self , token string , in tag ) :
if is in stance ( value , bytes ) :
if not hasattr ( self , STR_ ) :
try :
except ValueError :
self . html initial id = form . add initial prefix ( self . auto id )
def find files ( self , root ) :
return force str ( self . tzname )
result . append ( ch )
k = item [ NUM_ ]
value = self . get ( key , version = version )
in dex sql = connection . creation . sql indexes for model ( model , no style ( ) )
from django . utils . encoding import force text , python 2 unicode compatible
if fget is not None :
def init ( self , data = None , files = None , in stance = None , save as new = False , prefix = None , queryset = None , ** kwargs ) :
handler . addQuickElement ( " STR_ " , " " , { " STR_ " : cat } )
return { }
self . event stream . expandNode ( node )
try :
except IndexError :
kwargs = { }
from . messages import ( CheckMessage , Debug , Info , Warning , Error , Critical , DEBUG , INFO , WARNING , ERROR , CRITICAL )
self . varlist = varlist
try :
obj = form . save ( commit = False )
obj . widgets = copy . deepcopy ( self . widgets )
from io import BytesIO
def check boolean field default value ( app configs = None , ** kwargs ) :
from django . utils import six
def in itial form count ( self ) :
except ( ImportError , IndentationError , NameError , SyntaxError , TypeError , AttributeError ) :
if settings . USE L10N :
stream = open ( output , STR_ ) if output else None
filter expr = parser . compile filter ( " STR_ " % ( rest ) )
is usable = False
if escaped :
else :
def process default ( self , event ) :
except ValueError :
MAXSIZE = in t ( ( NUM_ << NUM_ ) - NUM_ )
return f ( * args , ** kwargs )
def update unget history ( self , num bytes ) :
return self [ key ]
s = Select ( choices = choices )
self . mod = new
sites2 = findall ( s2 , str ( year + NUM_ ) )
from . import six
return ret
basedirs . append ( os . path . join ( app config . path , STR_ ) )
out . write ( STR_ % cmatch )
ch , escaped = next ( pattern iter )
if not is in stance ( value , ( bytes , six . text type ) ) :
yield " STR_ "
if check path :
raise KeyError ( " STR_ " % lang code )
msg = SafeMIMEMultipart ( subtype = self . mixed subtype , encoding = encoding )
from django . core . management . sql import sql custom
if getattr ( current , STR_ , False ) :
def wrapper ( self , * args , ** kw ) :
return
if in stance . pk is None :
opfunc . name = opname
pass
def repr ( self ) :
if key not in self :
def tokenize ( self ) :
self . deleted objects . append ( obj )
if data is FILE INPUT CONTRADICTION :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , help = STR_ STR_ ) ,
defaults = parser . parse args ( args = args )
args = [ ]
yield buf . read ( )
time . sleep ( NUM_ )
self . attrs = attrs . copy ( )
table = connections [ db ] . ops . quote name ( self . table )
else :
return r
else :
class MemoryFileUploadHandler ( FileUploadHandler ) :
raise SuspiciousFileOperation ( " STR_ " % name )
check for migrations ( app config , connection )
except IndexError :
if transfer encoding is not None :
for bit in tag re . split ( self . template string ) :
if not self . is rendered :
try :
else :
for log in existing :
def unescape string literal ( s ) :
self . clear ( )
line = sio . readline ( size )
final attrs = self . build attrs ( attrs , type = STR_ , name = name )
pattern = pattern . lower ( )
with connections [ db ] . cursor ( ) as cursor :
super ( LazyModule , self ) . init ( name )
try :
if field in form . cleaned data :
yield node
result = None
found = getattr ( found , frag )
self . nodelist empty = NodeList ( )
def call ( self , value ) :
start ipython ( argv = [ ] )
file = tempfile . NamedTemporaryFile ( suffix = STR_ )
except AttributeError :
locks . unlock ( fd )
if i < self . in itial form count ( ) and STR_ not in kwargs :
try :
self . remove potfiles ( )
loggers = config . get ( STR_ , EMPTY DICT )
def add ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
def render ( self , name , value , attrs = None ) :
def is multipart ( self ) :
import os
try :
import hashlib
unhandled params = unhandled params [ : - len ( defaults ) ]
raise TemplateDoesNotExist ( template name )
else :
if value :
translation = self . new gnu trans ( localedir )
if key in cache :
widget = EmailInput
else :
val , encoded = super ( SimpleCookie , self ) . value encode ( val )
if formatter :
self . xml . startElement ( " STR_ " , attrs )
data = self . form . in itial . get ( self . name , self . field . in itial )
return filenames
fields = new class . declared fields
target = parser . compile filter ( bits [ NUM_ ] )
definition = getattr ( cls , STR_ , None )
def set many ( self , data , timeout = DEFAULT TIMEOUT , version = None ) :
stream class = StringIO if is in stance ( content , six . text type ) else BytesIO
while field . rel is not None :
name = self . get available name ( name )
for app config in apps . get app configs ( ) :
BLOCK TAG END = STR_
self . stdout . write ( " STR_ " )
pass
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
reset translations ( )
default = translation ( settings . LANGUAGE CODE )
lists = iterlists
cls = extension map . get ( ext )
in plural = False
if self . app label and app config . label ! = self . app label :
if value is not result :
self . use natural keys = options . pop ( " STR_ " , False )
return value
return duplicate
old attr = name
return from current timezone ( result )
urlunquote plus = allow lazy ( urlunquote plus , six . text type )
from django . utils . six . moves import zip
or ig vars = cls . dict . copy ( )
except Exception as e :
attrs . setdefault ( STR_ , step )
return self . data . year
return errors
except TypeError :
os . umask ( old umask )
ALL FIELDS = STR_
response . add post render callback ( callback )
return language [ : p ] . lower ( ) + STR_ + language [ p + NUM_ : ] . upper ( )
sys . stderr . write ( msg )
def get nodes by type ( self , nodetype ) :
if kwarg format :
except InputStreamExhausted :
raise ValueError ( " STR_ " % line )
if is in stance ( offset , timedelta ) :
header = header . upper ( ) . replace ( - , STR_ )
itervalues = " STR_ "
opts = self . meta
self . max length = kwargs . pop ( STR_ , None )
def b ( self ) :
import warnings
def repr ( self ) :
app models = router . get migratable models ( app config , connection . alias )
if - not in lang code :
with lock :
except UnicodeDecodeError :
xgettext options = [ STR_ , STR_ ]
unpacked vars = dict ( zip ( self . loopvars , item ) )
def init ( self , name , content type , size , charset , content type extra = None ) :
self . view name = view name
if self . verbosity > NUM_ :
def get image dimensions ( file or path , close = False ) :
last = self . data . day % NUM_
def bpython ( self ) :
ch , escaped = next ( pattern iter )
possibilities = self . reverse dict . getlist ( lookup view )
UnlockFileEx . restype = BOOL
super ( JsonResponse , self ) . init ( content = data , ** kwargs )
def render ( self , context ) :
return getattr ( self . caches , STR_ , { } ) . values ( )
location = settings . MEDIA ROOT
handle app = self . handle app
@ python 2 unicode compatible
self . in dent ( NUM_ )
return STR_ . join ( statements )
return . join ( output )
self . connection . starttls ( )
class BaseModelForm ( BaseForm ) :
colors = styles . pop ( ) . split ( / )
if callable ( lookup view ) :
if filters :
else :
self . in dent ( NUM_ )
def readline ( self , * args , ** kwargs ) :
self . validate key ( key )
attr = import string ( dotted path )
class CacheEntry ( object ) :
iadd = complain
return trans . get language ( )
content type = META . get ( STR_ , META . get ( STR_ , ) )
return self . flatten ( ) == other . flatten ( )
import pytz
if self . verbosity >= NUM_ :
if self . to field name :
def add ( self , rhs ) :
readlines = property ( lambda self : self . file . readlines )
if default is not RAISE ERROR :
self . callback = get callable ( self . callback str )
return ( STR_ % ( token name , self . contents [ : NUM_ ] . replace ( STR_ , ) ) )
translations [ language ] = DjangoTranslation ( language )
self . fqdn = socket . getfqdn ( )
rel model = field . rel . to
except UnicodeDecodeError :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : value } , )
def eq ( self , other ) :
self . value = value
except StandardError as e :
from django . utils import translation
return raw data
self . current = None
if ( BLOCK CONTEXT KEY in render context and render context [ BLOCK CONTEXT KEY ] . get block ( self . name ) is not None ) :
obj = new obj
import stat
self . buffer = b
self . stdout . write ( " STR_ " )
try :
start response ( force str ( status ) , response headers )
response . content = b
value = localize ( value , use l10n = context . use l10n )
provided = list ( provided )
def urlencode ( query , doseq = NUM_ ) :
class RWLock ( object ) :
p = i
assertCountEqual = " STR_ "
return
self . show hidden initial = show hidden initial
colors . reverse ( )
return klass
class ContextPopException ( Exception ) :
class override ( object ) :
def iriencode ( value ) :
substitutions = { STR_ : self . in itial text , STR_ : self . in put text , STR_ : , STR_ : self . clear checkbox label , }
yield self [ key ]
try :
result = super ( TimestampSigner , self ) . unsign ( value )
fixture name = os . path . basename ( fixture name )
from django . core . cache . backends . db import BaseDatabaseCache
if settings . is overridden ( STR_ ) :
return NowNode ( format string )
from django . core . management . base import BaseCommand , CommandError
def init ( self , host , * args , ** kwargs ) :
@ register . filter ( is safe = True )
def iterlists ( self ) :
data = b64 decode ( base64d )
self . value = value
return self . save existing objects ( commit ) + self . save new objects ( commit )
for message in messages :
return result
from django . apps import apps
migrations directory = os . path . dirname ( writer . path )
@ property
if not hasattr ( template , STR_ ) :
status code = NUM_
pass
num = NUM_
def in otify code changed ( ) :
if hasattr ( decorator , STR_ ) :
for app config , model list in app list :
if STR_ in options :
fail message = STR_
if six . PY2 :
return update wrapper ( wrapper , user function )
i = next space index ( subject , i )
f . required = False
new = STR_ + or ig file [ NUM_ : ]
def save existing ( self , form , in stance , commit = True ) :
self . file . seek ( NUM_ )
@ register . filter ( is safe = True , needs autoescape = True )
if id :
def verbatim ( parser , token ) :
quant = [ ]
def parse boundary stream ( stream , max header size ) :
while i < len ( subject ) and subject [ i ] in ( , STR_ ) :
if self . verbosity >= NUM_ :
return host
if not name :
def getitem ( self , in dex ) :
self . empty value = kwargs . pop ( STR_ , )
def getitem ( self , name ) :
""" """
timestamp = datetime . datetime . utcfromtimestamp ( in t ( timestamp ) )
self . stdout . write ( shutdown message )
date data = ( getattr ( form . cleaned data [ unique for ] , lookup ) , )
return ip str . rsplit ( STR_ , NUM_ ) [ NUM_ ]
self . validate key ( key )
class BaseConverter ( object ) :
warnings . warn ( msg % ( language , DJANGO DEPRECATED LOCALES [ language ] ) , RemovedInDjango19Warning , stacklevel = NUM_ )
object data = model to dict ( in stance , opts . fields , opts . exclude )
else :
return trans . deactivate all ( )
handler . startElement ( STR_ , self . item attributes ( item ) )
else :
if autoescape :
call command ( STR_ , STR_ , verbosity = self . verbosity , database = connection . alias , skip validation = True , app label = app label , hide empty = True )
super ( SortedDict , self ) . init ( data )
for basedir in basedirs :
return
if self . errors and hasattr ( self . form , STR_ ) :
pass
self . cookies [ key ] [ STR_ ] = expires
del attrs [ attr ]
final output = [ ]
PVOID = c void p
field output . append ( " STR_ " )
new errors = check ( app configs = app configs )
raise CommandError ( " STR_ " % ( " STR_ " if app or project == " STR_ " else " STR_ " , app or project ) )
else :
literal regex = re . compile ( r STR_ , re . IGNORECASE )
return LANG INFO [ generic lang code ]
bits = urlparse ( url )
result = self . class ( )
replaces = [ ]
class date ( real date ) :
raise ValueError ( " STR_ " % ( fk name , parent model . meta . app label , parent model . meta . object name ) )
self . lineno = NUM_
decode = curry ( proxy method , method = bytes . decode )
from django . http import QueryDict
return self . html output ( normal row = STR_ , error row = STR_ , row ender = STR_ , help text html = STR_ , errors on separate row = False )
if type ( field type ) is tuple :
raise ValueError ( " STR_ " % ( self . class . name , field ) )
else :
self . stream . write ( " STR_ " )
if link is not None :
ns = app list [ NUM_ ]
return sys . modules [ name ]
@ deconstructible
else :
def gettext noop ( message ) :
yield data
class UTC ( tzinfo ) :
conditions nodelists = [ ( condition , nodelist ) ]
return field . rel . to . meta . get field ( field . rel . field name ) . to python ( field value )
def render ( self , context ) :
if self . verbosity >= NUM_ :
if self . should delete form ( form ) :
@ stringfilter
for fixture label in fixture labels :
return STR_ . join ( output )
def str ( self ) :
try :
return STR_ % STR_ . join ( STR_ % ( k , v ) for k , v in six . iteritems ( self ) )
from future import unicode literals
else :
from django . core . cache . backends . base import BaseCache , DEFAULT TIMEOUT
get function globals = operator . attrgetter ( func globals )
@ classmethod
def ipython pre 011 ( self ) :
return func . get ( self , type ( self ) ) ( * args2 , ** kwargs2 )
self . stderr . write ( " STR_ " % error text )
media = sorted ( self . css . keys ( ) )
pass
role , in structions = part . split ( = )
if is in stance ( self . warning , Exception ) :
from django . utils . html import format html
year = dt . year
ns pattern = ns pattern + extra
FILE MODIFIED = NUM_
from django . db . migrations . writer import MigrationWriter
value = next ( cycle iter ) . resolve ( context )
executor = MigrationExecutor ( connection )
with io . open ( fname , STR_ ) as f :
class BaseLoader ( object ) :
def init ( self , parent instance , * args , ** kwargs ) :
processors . append ( func )
name = args [ - NUM_ ]
styles . reverse ( )
t = super ( SafeBytes , self ) . add ( rhs )
except LookupError :
if end . endswith ( STR_ ) :
ASCTIME DATE = re . compile ( r STR_ % ( M , D2 , T , Y ) )
from django . apps import apps
try :
from collections import OrderedDict
else :
src = force text ( src , settings . FILE CHARSET )
raise ValueError ( " STR_ " )
for form in valid forms :
renderer = None
payload = text . encode ( utf8 charset . output charset )
self . validate key ( key )
self . META [ STR_ ] = path info
M = self . get ( key , Morsel ( ) )
if encoding == STR_ :
return getattr ( settings , format type )
backend name = connection . settings dict [ STR_ ] . split ( STR_ ) [ - NUM_ ]
key = self . make key ( key , version = version )
cache key = generate cache header key ( key prefix , request )
from email = sanitize address ( email message . from email , email message . encoding )
clean data . append ( field . clean ( field value ) )
def start object ( self , obj ) :
def init ( self , tup , hash = hash ) :
starttag re = re . compile ( r STR_ % tags re , re . U )
handler . setLevel ( checkLevel ( level ) )
self . can write . acquire ( )
import datetime
from shutil import copystat
Morsel = http cookies . Morsel
self . error messages = messages
return t . render ( context instance )
if is in stance ( arg , unicode ) :
continue
result = func ( * args )
except AttributeError :
return build request repr ( self )
from django . core . management . base import BaseCommand , CommandError
from django . conf import settings
import re
raise TemplateSyntaxError ( " STR_ " " STR_ " % subject )
return callback [ : dot ] , callback [ dot + NUM_ : ]
raise CommandError ( " STR_ " % e )
for field in self . fields :
namemap = options . get ( with , { } )
value = timezone . normalize ( value )
break
active . value = gettext module . NullTranslations ( )
super ( SortedDict , self ) . clear ( )
raise ImproperlyConfigured ( STR_ % ( self . file path , err ) )
self . add library ( lib )
if nodelist empty is None :
from functools import lru cache
return self
except KeyError :
else :
else :
return val
return self
base62 = BaseConverter ( BASE62 ALPHABET )
self . changed data = [ ]
basedir = os . path . join ( os . path . dirname ( potfile ) , locale , STR_ )
table name filter = options . get ( STR_ )
def get language from path ( path , strict = False ) :
if hasattr ( rel model , STR_ ) and rel model ! = model :
def set cdata mode ( self , tag ) :
timezone = ( offset . days * NUM_ * NUM_ ) + ( offset . seconds // NUM_ )
for h in logger . handlers [ : ] :
def ifnotequal ( parser , token ) :
choice input class = RadioChoiceInput
del urlconfs . value
else :
def readlines ( self ) :
from django . utils . encoding import force str , force text , iri to uri
ignore patterns += [ STR_ , STR_ , STR_ , STR_ ]
opts = model . meta
base path = abspathu ( base )
from future import unicode literals
return [ field for field in self if not field . is hidden ]
output = [ ]
if is in stance ( callback , functools . partial ) :
return sample [ : NUM_ ] == b STR_ or sample . startswith ( codecs . BOM UTF16 LE ) or sample . startswith ( codecs . BOM UTF16 BE )
for f in sorted ( opts . concrete fields + sortable virtual fields + opts . many to many ) :
from django . utils . functional import total ordering
return func ( context , self . first , self . second )
extra , resolver = resolver . namespace dict [ ns ]
color names = ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ )
if len ( self . namelist ( ) ) ! = NUM_ :
super ( Command , self ) . handle ( ** options )
if hasattr ( self , STR_ ) :
else :
@ lru cache . lru cache ( maxsize = None )
self . cookies [ key ] = value
def render ( self ) :
from django . utils . encoding import force text
CRITICAL = NUM_
def load label ( self , fixture label ) :
def ipython ( self ) :
@ cached property
return timesince ( value , arg )
n = in t ( idx )
fill to = NUM_
try :
widget = TextInput
error files . append ( filename )
in dex output = [ ]
try :
form . save m2m ( )
elif is in stance ( self . obj , models . base . ModelBase ) :
else :
key , value = match . groups ( )
response = self . get exception response ( request , resolver , NUM_ )
else :
self . buffer = b
try :
self . code = code
def unpack ipv4 ( ip str ) :
autodetector = MigrationAutodetector ( loader . project state ( ) , ProjectState . from apps ( apps ) , InteractiveMigrationQuestioner ( specified apps = app labels , dry run = self . dry run ) , )
else :
from io import BytesIO , StringIO , UnsupportedOperation
def media ( self ) :
raise
def getitem ( self , key ) :
t = getattr ( active , " STR_ " , None )
self . files = files or { }
from xml . sax import handler
import module ( templatetag module )
if msgs :
if sys . version info [ : NUM_ ] == ( NUM_ , NUM_ ) :
else :
from future import unicode literals
super ( CommandParser , self ) . init ( ** kwargs )
get function closure = operator . attrgetter ( func closure )
except ( OverflowError , ValueError ) as exc :
natural key = obj . natural key ( )
pass
class ObjectDoesNotExist ( Exception ) :
import binascii
closable . close ( )
return value
elif not is in stance ( value , ConvertingList ) and is in stance ( value , list ) :
import warnings
kwargs . update ( self . default args )
value = timezone . normalize ( value )
def repr ( self ) :
from django . core . management . color import color style , no style
m2m value = lambda value : smart text ( value . get pk val ( ) , strings only = True )
year = year + ( ( NUM_ - year ) // NUM_ ) * NUM_
len item = NUM_
len values = len ( values )
default error messages = { STR_ : ( STR_ ) , }
return new name , field params , field notes
return [ ]
p . feed ( data )
def parse args ( self , args = None , namespace = None ) :
return template . render ( context )
dec . name = STR_ % decorator . class . name
def force escape ( value ) :
tag , this value expr , max value expr , max width , as , asvar = bits
k = match . end ( )
self . widgets = getattr ( options , STR_ , None )
return value
return False
script name = get script name ( environ )
def to python ( self , value ) :
try :
if data is None :
if token . contents == else :
if is in stance ( number , in t ) :
check programs ( STR_ , STR_ , STR_ )
localpart = str ( Header ( localpart , encoding ) )
output = self . leftover
value = self . get ( key , version = version )
return self . fname
return self . urlconf module
raise TypeError ( STR_ )
return other in self . children
def rendered content ( self ) :
return timezone . make naive ( value , current timezone )
import zipfile
return mark safe ( six . text type ( number ) )
while current len <= length :
if second item == [ ] :
all = [ STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , ]
widget = NumberInput
load serializers ( )
hextets = [ ] + hextets
return None
except AppRegistryNotReady :
encode = lambda k , v : STR_ % ( ( quote ( k , safe ) , quote ( v , safe ) ) )
check programs ( STR_ )
whole digits = digits - decimals
self . stdout . write ( " STR_ " % app labels . pop ( ) )
self . form = form
anonymous = [ STR_ ]
return func
if hasattr ( self , STR_ ) :
def init ( self , attrs = None , choices = ( ) ) :
return get supported language variant ( lang code )
except ValidationError as e :
EMPTY DICT = { }
return expanded template
if hasattr ( self , STR_ ) :
def calculate app template dirs ( ) :
self . old method name = old method name
super ( SimpleUploadedFile , self ) . init ( BytesIO ( content ) , None , name , content type , len ( content ) , None , None )
elif field in self . errors . keys ( ) :
self . regex = regex
def lt ( self , other ) :
return LoaderOrigin ( display name , loader , name , dirs )
boundary = opts . get ( STR_ )
import sys
context match = context re . match ( imatch . group ( NUM_ ) )
debugs = [ e for e in all issues if e . level < checks . INFO and not e . is silenced ( ) ]
msg = " STR_ " % ( command , STR_ . join ( parse until ) )
hits = max ( NUM_ , self . count - self . or phans )
continue
from django . utils . itercompat import is iterable
attrs = super ( FloatField , self ) . widget attrs ( widget )
else :
except AmbiguityError :
forms valid = True
del self . post
else :
def init ( self , data , func , prefix ) :
def handle label ( self , label , ** options ) :
self . name = name
from django . db . migrations . loader import AmbiguityError
if not self . recipients ( ) :
flags = NUM_
return list ( self . iterlists ( ) )
t = getattr ( active , " STR_ " , None )
class CacheClass ( FileBasedCache ) :
self . dicts [ - NUM_ ] [ key ] = value
help =
del self [ STR_ ]
self . cache . disconnect all ( )
content = templatize ( src data , or ig file [ NUM_ : ] )
if is in stance ( callback , types . FunctionType ) :
if pattern . namespace :
cursor . close ( )
from . . import Warning , register , Tags
def is iterable ( x ) :
def write ( self , s ) :
from django . core . management . color import color style
for header in headerlist :
result = self . configure custom ( config )
while t > NUM_ :
elif var is None :
continue
def fset ( in stance , value , name = fset . name ) :
for v in self . validators :
warnings . warn ( " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
return STR_ % self . G ( )
except ZeroDivisionError :
return self . size > chunk size
if not is in stance ( node , TextNode ) :
basetype , subtype = mimetype . split ( / , NUM_ )
def to python ( self , value ) :
def value encode ( self , val ) :
nodelist = getattr ( self , attr , None )
hfile = msvcrt . get osfhandle ( fd ( f ) )
try :
self . style func = style func
statements = connection . ops . sql flush ( style , tables , seqs , allow cascade )
if hasattr ( value , STR_ ) and not is in stance ( value , ( bytes , six . string types ) ) :
from django . utils . encoding import force text
@ register . filter ( is safe = False )
else :
activate = lambda x : None
return dec
def all ( self ) :
return STR_ . join ( statements )
self . endChannelElement ( handler )
for pythonrc in ( os . environ . get ( " STR_ " ) , STR_ ) :
super ( ModelMultipleChoiceField , self ) . init ( queryset , None , cache choices , required , widget , label , in itial , help text , * args , ** kwargs )
if self . negated :
break
self . set ( key , value , timeout = timeout , version = version )
print ( FASTCGI HELP )
self . errors . append ( form . errors )
pass
or ig = getattr ( self . parent instance , self . to field )
if self . localize :
def init ( self , limit value ) :
def iri to uri ( iri ) :
compatibility = STR_
super ( Command , self ) . add arguments ( parser )
l = lambda x : self . make key ( x , version = version )
raise NotImplementedError ( STR_ )
self . close called = False
if middle . endswith ( punctuation ) :
host = host . lower ( )
if self . selected fields is None or field . attname in self . selected fields :
if url :
self . children = [ obj , data ]
value = field . get val from obj ( obj )
new keys = [ self . make key ( x , version = version ) for x in keys ]
args . append ( ( False , Variable ( constant arg ) . resolve ( { } ) ) )
if item [ STR_ ] is not None :
errors . extend ( check test runner ( ** kwargs ) )
def init ( self ) :
return Field . validate ( self , value )
try :
from django . core . exceptions import ValidationError
pgettext lazy = lazy ( pgettext , six . text type )
return self . reverse dict [ language code ]
class BaseMemcachedCache ( six . with metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :
def init ( self , var ) :
raise ValueError ( STR_ STR_ % ( value , rest ) )
return force text ( url )
if hasattr ( out , STR_ ) and out . is atty ( ) :
def iterlists ( d , ** kw ) :
answer = " STR_ "
return scheme in self . url schemes
function name = ( name or getattr ( func , STR_ , func ) . name )
def is library missing ( name ) :
bmatch = block re . match ( t . contents )
def ensure echo on ( ) :
return in t ( value )
msg = " "
from django . utils . text import normalize newlines , slugify as slugify
current = context
else :
except UnicodeEncodeError :
message = ( STR_ )
if widgets is not None :
class RenderContext ( BaseContext ) :
autodetector = MigrationAutodetector ( executor . loader . project state ( ) , ProjectState . from apps ( apps ) , )
lines = [ ]
class ForNode ( Node ) :
pass
return " STR_ " % ( len ( self . digits ) , self . digits )
yield line
return QueryDict ( , encoding = self . encoding ) , MultiValueDict ( )
except ValueError :
self . xml . addQuickElement ( " None " )
test runner class . add arguments ( parser )
time str = date . strftime ( STR_ )
existing . remove ( name )
@ register . filter ( is safe = False )
except UnicodeError as e :
return dateformat . time format ( value , get format ( format or STR_ , use l10n = use l10n ) )
raise TemplateSyntaxError ( " STR_ " )
format module path = [ format module path ]
tables . append ( connection . in trospection . table name converter ( model . meta . db table ) )
self . mark post parse error ( )
MAXSIZE = in t ( ( NUM_ << NUM_ ) - NUM_ )
field desc = STR_ % ( att name , if STR_ in field type else STR_ , field type , )
pass
from django . conf import settings
else :
using = options . get ( STR_ )
self . xml . startElement ( " STR_ " , { " STR_ " : field . name , " STR_ " : field . get internal type ( ) } )
attachment . set payload ( content )
return CommentNode ( )
self . use l10n = use l10n
except NoReverseMatch :
return MONTHS ALT [ self . data . month ]
def iter ( self ) :
return self . in put type == STR_ if hasattr ( self , STR_ ) else False
end index = i
truncate text = self . add truncation text ( , truncate )
class JsLexer ( Lexer ) :
super ( BaseInlineFormSet , self ) . init ( data , files , prefix = prefix , queryset = qs , ** kwargs )
if is in stance ( slots , str ) :
def urlquote ( url , safe = / ) :
options = { }
plan = executor . migration plan ( executor . loader . graph . leaf nodes ( ) )
if g [ NUM_ ] == STR_ :
return self . handle merge ( loader , conflicts )
message , code , params = message . message , message . code , message . params
num = NUM_
def clean fields ( self ) :
except NotImplementedError :
self . attrs = attrs or { }
def init ( self , message , code = None , params = None ) :
return result
pluralmatch = plural re . match ( t . contents )
def init ( self , setting , nodelist ) :
def render node ( self , node , context ) :
if data list [ NUM_ ] in self . empty values :
out . write ( STR_ % ( message context , join tokens ( singular , trimmed ) , join tokens ( plural , trimmed ) ) )
raise TemplateSyntaxError ( " STR_ " " STR_ " % ( i , subject ) )
handler . startElement ( " STR_ " , { } )
if len ( fixture files in dir ) > NUM_ :
if kwargs :
space = line [ : max width + NUM_ ] . rfind ( ) + NUM_
builtins = { True : True , False : False , None : None }
else :
url =
self . validate ( display num errors = True )
lineno , offset = self . getpos ( )
return
csrf token = context . get ( STR_ , None )
global mtimes , win
@ register . filter ( is safe = True )
if options [ STR_ ] :
def safe join ( base , * paths ) :
raise NotImplementedError ( STR_ )
else :
return data
if col name ! = new name and field notes :
def has header ( self , header ) :
try :
if self . timezone and self . timezone . dst ( self . data ) :
class SafeText ( six . text type , SafeData ) :
try :
for in dex in range ( len ( hextets ) ) :
locale = to locale ( lang )
else :
with connections [ db ] . cursor ( ) as cursor :
selected html = mark safe ( STR_ )
from django . utils . timesince import timesince , timeuntil
def new ( cls , fget = None , fset = None , fdel = None , doc = None ) :
from django . utils import six
continue
class ChunkIter ( six . Iterator ) :
else :
if fields and f . name not in fields :
left = t . nud ( self )
for line in msgs . split ( STR_ ) :
last = pos + NUM_
RE DATE = re . compile ( r STR_ )
msg += " STR_ " % domain
app list = OrderedDict ( )
result ^= bin to long ( u )
else :
main value pair , params = parse header ( line )
try :
post = ( pformat ( POST override ) if POST override is not None else pformat ( request . POST ) )
try :
if num > self . max entries :
options = parser . parse args ( argv [ NUM_ : ] )
raise CommandError ( " STR_ " % ( name , app or project , message ) )
value = ConvertingDict ( value )
if m :
base56 = BaseConverter ( BASE56 ALPHABET )
return super ( PythonSerializer , self ) . getvalue ( )
host = host [ : - NUM_ ] if host . endswith ( STR_ ) else host
from django . utils . encoding import force text
from django . core . management . sql import sql destroy indexes
cookies = STR_
for i , char in enumerate ( text ) :
os . remove ( symlink path )
try :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
if options [ " STR_ " ] and options [ " STR_ " ] and not options [ " STR_ " ] :
if is in stance ( d , real datetime ) :
old = STR_ + work file
def get default prefix ( cls ) :
excluded models = set ( )
try :
def validate unique ( self ) :
return self . data . hour
obj = super ( klass , cls ) . new ( cls )
filemsg =
apps = { }
func defaults = " STR_ "
return format html ( " " )
logger . removeHandler ( handler )
message = list ( error ) [ NUM_ ]
RUN RELOADER = True
s = subject [ p : i ]
response fixes = [ http . fix location header , http . conditional content removal , ]
class Command ( AppCommand ) :
self . mod = old
return self
self . closable objects = [ ]
self . objects = [ ]
else :
super ( EmailBackend , self ) . init ( * args , ** kwargs )
sys . stderr . write ( " STR_ " % ( subcommand , self . prog name ) )
base64 = BaseConverter ( BASE64 ALPHABET , sign = STR_ )
def render ( self , context ) :
def top ( self ) :
stats [ MISSES ] += NUM_
val . encode ( STR_ )
def check 1 7 compatibility ( ** kwargs ) :
if len ( bits ) >= NUM_ and bits [ - NUM_ ] == " from " :
result = avoid wrapping ( name % count )
max value = self . max expr . resolve ( context )
choices = [ ( i , i ) for i in self . years ]
except VariableDoesNotExist :
self . context = context
import decimal
comma separated int list re = re . compile ( STR_ )
if not self . DIGIT PATTERN . match ( idx ) :
location = kwargs . pop ( STR_ , )
continue
s = s . replace ( STR_ , STR_ )
if self . is bound :
pieces = [ ]
if STR_ in context :
return result
if categories :
value = ConvertingTuple ( value )
return path
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
return reduce ( operator . add , dict ( self ) . values ( ) )
if kwds :
for program in programs :
class DjangoSafeDumper ( SafeDumper ) :
return self
return default
validate ipv4 address ( value )
for member in members :
self . write ( s , encoding )
attrs [ STR_ ] = smart text ( obj pk )
self . to field name = to field name
is usable = True
emit pre migrate signal ( create models , self . verbosity , self . in teractive , connection . alias )
cookie value = self . COOKIES [ key ]
want unicode = False
return self
return ( ( not url info . netloc or url info . netloc == host ) and ( not url info . scheme or url info . scheme in [ STR_ , STR_ ] ) )
return filelist
from django . forms . utils import *
addr = STR_ . join ( [ localpart , domain ] )
for i , v in enumerate ( value ) :
def error ( self , message ) :
value = token kwargs ( remaining bits , parser , support legacy = False )
class MultipleHiddenInput ( HiddenInput ) :
serializers = serializers
def streaming content ( self ) :
def bool ( self ) :
six . reraise ( * exc info )
else :
from django . conf import settings
return result
try :
return template . render ( context . new ( values ) )
with context instance . push ( dictionary ) :
et , ev , tb = sys . exc info ( )
now = datetime . now ( )
expires = typecast timestamp ( str ( expires ) )
if STR_ not in ip str and ip str . count ( STR_ ) ! = NUM_ :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
rollback = self . rollback
decimal digits = STR_
return in ner
pass
bits = token . contents . split ( )
retval = self . tokens [ self . pos ]
if self . wrapped is empty :
def dst ( self , dt ) :
def repr ( self ) :
def parse endtag ( self , i ) :
self . buffer = b
context . update ( unpacked vars )
except ( TypeError , ValueError , UnicodeDecodeError ) :
chunks = [ ]
if self . done :
else :
return any ( ignore ( pattern ) for pattern in ignore patterns )
return value
return mark for escaping ( value )
tagfind = re . compile ( STR_ )
new args . append ( args [ : ] + i args )
else :
from django . utils . encoding import python 2 unicode compatible
if not len ( self . backout ) :
raise TemplateSyntaxError ( " STR_ " " STR_ " )
xreadlines = property ( lambda self : self . file . xreadlines )
def has changed ( self , in itial , data ) :
def address string ( self ) :
if errors is None :
msgs , errors , status = popen wrapper ( args )
yield obj
return self . create attachments ( msg )
output transaction = True
try :
if not cls :
for field in self . fields . values ( ) :
options [ STR_ ] = get random string ( NUM_ , chars )
import pickle
except ( ValueError , TypeError ) :
cache = caches [ cache alias ]
for dirpath , dirnames , locale filenames in os . walk ( basedir ) :
super ( URLValidator , self ) . call ( value )
import re
def clean ( self , value ) :
result = self . buffer + self . read limited ( size - len ( self . buffer ) )
raise ValueError ( STR_ % level )
if min length is not None :
requires system checks = False
escapejs = allow lazy ( escapejs , six . text type )
raise AttributeError ( attr )
pass
CONTEXT SEPARATOR = " STR_ "
msgs , errors , status = popen wrapper ( args )
else :
regex compiled = re . compile ( STR_ % language code , re . UNICODE )
id = self . attrs [ STR_ ]
try :
self . verbosity = options . get ( STR_ )
def init ( self , argv = None ) :
else :
if self . feed [ STR_ ] is not None :
def str ( self ) :
if pieces [ - NUM_ ] :
try :
return STR_
state [ STR_ ] = str ( state [ STR_ ] )
def get language from request ( request , check path = False ) :
self . name = name
raise TemplateSyntaxError ( " STR_ " )
return data . get ( name , None )
binary type = str
if cleaned data is not None :
self . nodelist = nodelist
context extras = { }
if doublecolon start == - NUM_ :
try :
return d [ key ]
cull num = num // self . cull frequency
value = ConvertingList ( value )
def getvalue ( self ) :
return self [ key ]
pass
value = force text ( value )
except TemplateDoesNotExist :
def csrf ( request ) :
except AttributeError :
for ext in pathext :
i += NUM_
value = in t ( str ( value ) )
return tuple ( app template dirs )
self . add fields ( form , None )
def as bytes ( self , unixfrom = False ) :
if not self . can import settings :
if scheme not in self . schemes :
NamedTemporaryFile = tempfile . NamedTemporaryFile
return True
def value from datadict ( self , data , files , name ) :
self . labels = getattr ( options , STR_ , None )
str hidden = . join ( hidden fields )
if self . verbosity >= NUM_ :
class Module six moves urllib ( types . ModuleType ) :
if is in stance ( pattern , RegexURLResolver ) :
self . toks [ groupid ] = tok
if self . required :
raise AttributeError ( " STR_ " % self . class . name )
import ( name )
return time format ( value , STR_ , use l10n = use l10n )
except Exception :
@ property
from django . conf import settings
guid attrs = { }
self . unget history = [ num bytes ] + self . unget history [ : NUM_ ]
elif t . token type == TOKEN VAR :
handler . name = name
try :
ch , escaped = next ( pattern iter )
if os . path . is dir ( app dir ) :
def render css ( self ) :
def dict ( self ) :
return self . stream . readline ( * args , ** kwargs )
if settings . DEBUG :
raise NotImplementedError ( STR_ )
if six . PY3 :
if not self . close called :
data = field stream . read ( )
return obj
warnings = [ e for e in all issues if checks . WARNING <= e . level < checks . ERROR and not e . is silenced ( ) ]
class override ( object ) :
return new class
if obj pk is not None :
final attrs = self . build attrs ( attrs , name = name )
lib = import library ( taglib module )
if ch in " STR_ " :
except TemplateDoesNotExist :
if flags is not None :
return STR_
else :
min = in t ( m . group ( STR_ ) )
def clean form ( self ) :
print ( message )
kw = match . groupdict ( )
allowed schemes = [ STR_ , STR_ , STR_ ]
raise BadSignature ( STR_ % self . sep )
from django . conf import settings
def get callable ( lookup view , can fail = False ) :
out . write ( STR_ % ( join tokens ( singular , trimmed ) , join tokens ( plural , trimmed ) ) )
for uclass , unique check in all unique checks :
raise TemplateDoesNotExist ( " STR_ " )
model = self . obj
def has bom ( fn ) :
def render ( self , context ) :
elif closing tag :
args = [ ]
default error messages = { STR_ : ( STR_ ) , STR_ : ( STR_ STR_ ) , STR_ : ( STR_ ) }
msg = self . style . HTTP NOT MODIFIED ( msg )
def handle app config ( self , app config , ** options ) :
name = s . split ( STR_ )
error text = ERRORS [ e . errno ]
domain whitelist = [ STR_ ]
elif msg :
for field , error list in self . error dict . items ( ) :
self . remaining -= len ( result )
for name in sorted ( commands dict [ app ] ) :
from email . utils import formatdate
break
return nodes
class RegexURLPattern ( LocaleRegexProvider ) :
items = iteritems
from django . utils . dates import MONTHS
sys . exit ( exit code )
format cache = { }
try :
return path . join ( django . path [ NUM_ ] , STR_ , subdir )
from UserList import UserList
def close ( self ) :
connection = connections [ database ]
except Exception :
if samefile ( old file name , new file name ) :
return os . path . exists ( self . path ( name ) )
value = STR_ % tuple ( value )
for f in filters :
from future import unicode literals
if is in stance ( elt , ( Choice , NonCapture ) ) :
if self . delegate bytes and six . PY2 :
else :
def in cr version ( self , key , delta = NUM_ , version = None ) :
super ( EntitiesForbidden , self ) . init ( )
output = [ ]
from django . utils . dates import MONTHS , MONTHS 3 , MONTHS ALT , MONTHS AP , WEEKDAYS , WEEKDAYS ABBR
if filename and not os . path . exists ( filename ) :
super ( BaseInlineFormSet , self ) . add fields ( form , in dex )
if default is None :
if key prefix is None :
if len ( args ) < NUM_ :
def get json data ( self , escape html = False ) :
pass
return attrs
archive . extract ( to path )
project name = settings . SETTINGS MODULE . split ( STR_ ) [ NUM_ ]
if found :
if six . PY3 :
pickled = pickle . dumps ( value , pickle . HIGHEST PROTOCOL )
return list ( zip ( * flatten result ( result ) ) )
ext list . extend ( ext . replace ( , ) . split ( STR_ ) )
try :
break
if consume next :
return
yield choice
def update ( self , dict ) :
def init ( self ) :
fk = fks to parent [ NUM_ ]
def cull ( self ) :
def getitem ( self , i ) :
result . parent = self
from django . db import models
if is in stance ( elt , Group ) :
cache key = generate cache header key ( key prefix , request )
T = r STR_
from django . utils . deprecation import RemovedInDjango19Warning
def floatformat ( text , arg = - NUM_ ) :
except AttributeError :
if level is not None :
result . append ( self . create token ( self . template string [ upto : start ] , ( upto , start ) , False ) )
msg = SafeMIMEText ( self . body , self . content subtype , encoding )
from django . utils . encoding import force text
if self . data . minute == NUM_ :
value = data . get ( name )
field notes . append ( STR_ )
def templatize ( src , or igin = None ) :
except SkipFile :
def debug ( request ) :
for level in zip ( * [ m . ancestry for m in merge migrations ] ) :
if cache timeout < NUM_ :
value = smart text ( value ) . strip ( )
def read ( self ) :
self . delete ( key , version = version )
value = formats . sanitize separators ( value )
found = False
from django . db import connections , DEFAULT DB ALIAS
cursor . execute ( STR_ % table )
from future import unicode literals
return super ( NullBooleanSelect , self ) . render ( name , value , attrs , choices )
if imatch . group ( NUM_ ) :
self . file . write ( raw data )
substitutions [ STR_ ] = self . template with clear % substitutions
def repr ( self ) :
created models = set ( )
if not rest :
return " STR_ " % ( self . class . name , super ( MultiValueDict , self ) . repr ( ) )
return STR_ % calendar . monthrange ( self . data . year , self . data . month ) [ NUM_ ]
value = ungettext ( " STR_ " , " STR_ " , bytes ) % { STR_ : bytes }
else :
if first :
def iterbytes ( buf ) :
else :
patch cache control ( response , max age = cache timeout )
except Model . DoesNotExist :
if key in dict :
except ImportError :
from django . utils . module loading import import string
for path in self . locale paths :
if data [ last : last + NUM_ ] == b STR_ :
from django . utils . encoding import force str , force text
import tarfile
prefix = d [ STR_ ]
def in t to base36 ( i ) :
return EscapeBytes ( s )
return STR_ % self . data . second
self . unclosed block tag ( [ endtag ] )
def filter ( self , record ) :
formfield = formfield callback ( f , ** kwargs )
message context = message context . strip ( STR_ )
field name = disposition [ STR_ ] . strip ( )
MAXSIZE = sys . maxsize
if is in stance ( data , bytes ) :
self . base fields [ MAX NUM FORM COUNT ] = IntegerField ( required = False , widget = HiddenInput )
django po = os . path . join ( django dir , STR_ , STR_ , locale , STR_ , STR_ % domain )
if parsed . scheme and parsed . scheme not in self . allowed schemes :
from django . utils . translation import ugettext lazy , ugettext as , pgettext
field value = getInnerText ( node ) . strip ( )
if self . verbosity > NUM_ :
return response
try :
self . level = level
def getitem ( self , key ) :
kw . extend ( [ d . hour , d . minute , d . second , d . microsecond , d . tzinfo ] )
self . func = func
sys . exit ( NUM_ )
try :
s = MLStripper ( )
def new datetime ( d ) :
class FilterNode ( Node ) :
elif t . token type == TOKEN TEXT :
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ )
if not prefix :
close = True
kwargs [ STR_ ] = widgets [ f . name ]
except ( ValueError , TypeError , ValidationError ) :
class ComboField ( Field ) :
def get default prefix ( cls ) :
value = self . to python ( value )
Model = get model ( d [ " STR_ " ] )
form = super ( BaseInlineFormSet , self ) . construct form ( i , ** kwargs )
update watch ( )
TOKEN TEXT = NUM_
return self . html output ( normal row = STR_ , error row = STR_ , row ender = STR_ , help text html = STR_ , errors on separate row = True )
elif token string . startswith ( BLOCK TAG START ) :
def new gnu trans ( self , localedir , use null fallback = True ) :
@ stringfilter
unifunc = results [ " STR_ " ]
def prepare js for gettext ( js ) :
if opts . managed :
leave locale alone = True
def autoescape ( parser , token ) :
return self . parent instance
if mimetype is None :
if new name . endswith ( STR_ ) :
return end , next
if hasattr ( model , STR_ ) :
locales . append ( locale . split ( STR_ ) [ NUM_ ] )
if fk . unique :
raise TemplateSyntaxError ( " STR_ " " STR_ " % token . contents )
self . in verse match = in verse match
pos = m . end ( NUM_ )
for plan node in graph . forwards plan ( node ) :
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
func code = " STR_ "
import datetime
def get valid name ( self , name ) :
else :
class Command ( BaseCommand ) :
obj = " STR_ "
return force text ( name . replace ( STR_ / ) )
return mark safe ( output )
for name in bits [ NUM_ : - NUM_ ] :
new value = [ ]
daemon kwargs [ STR_ ] = options [ STR_ ]
verbosity = options . get ( STR_ )
@ register . filter ( is safe = True )
to python = self . get to python ( pk field )
else :
self . attrs [ STR_ ] += " STR_ " % self . in dex
except ( ValueError , TypeError ) :
for dict in self . dicts :
block re = re . compile ( r " " " STR_ " [ ^ " STR_ " ) | ( ? : STR_ ] * ? )))?(?:\s+|$)""" )
def catalog ( ) :
check for language . cache clear ( )
if is in stance ( format module path , six . string types ) :
ip address = literal match . group ( NUM_ )
style = no style ( )
return datetime . utcnow ( ) . replace ( tzinfo = utc )
app label , migration name = options [ STR_ ] , options [ STR_ ]
return key [ NUM_ ]
for app config in reversed ( list ( apps . get app configs ( ) ) ) :
else :
directory created [ app label ] = True
def handle field ( self , obj , field ) :
from django . utils import six
if response is None :
def npgettext lazy ( context , singular , plural , number = None ) :
return value . replace ( tzinfo = timezone )
from . base import CommandError
return super ( BaseModelFormSet , self ) . construct form ( i , ** kwargs )
def init ( self , takes context , args , kwargs , target var ) :
all = ( STR_ , STR_ , STR_ , STR_ , STR_ )
class RegexValidator ( object ) :
for d in self . dicts :
def gettext noop ( message ) :
except http cookies . CookieError :
from django . utils import dateformat , numberformat , datetime safe
@ register . tag
return { }
def get count ( self ) :
if event . path . endswith ( STR_ ) :
m2m data [ field . name ] = [ m2m convert ( pk ) for pk in field value ]
return strip tags ( value )
if as ! = as :
resolved args , resolved kwargs = self . get resolved arguments ( context )
else :
except ImportError :
return force text ( time . tzname [ is dst ] , DEFAULT LOCALE ENCODING )
class Command ( BaseCommand ) :
else :
t = self . waiting readers
raise IOError ( " STR_ " % directory )
compile func . doc = func . doc
@ register . tag
def gettext ( message ) :
class Parser ( object ) :
def exists ( self , name ) :
def iteritems ( self ) :
self . position -= len ( bytes )
if not roots :
args = ( )
def register serializer ( format , serializer module , serializers = None ) :
self . old language = get language ( )
if self not in state frame :
html parser . HTMLParser . init ( self )
def generate cache key ( request , method , headerlist , key prefix ) :
self . LibraryValueNotFoundException = value not found exception
except StandardError as e :
def namespace dict ( self ) :
drive re = re . compile ( STR_ , re . I )
return getattr ( in stance , name ) ( )
return cls
assert is in stance ( level , in t ) , " STR_ "
if self not in context . render context :
self . regex dict [ language code ] = compiled regex
timeout = self . default timeout
return
return in itial ! = data
break
try :
@ property
token = " STR_ "
if upto ! = len ( token ) :
raise ValueError ( " STR_ " % key )
taglib = bits [ - NUM_ ]
return in t ( cc [ STR_ ] )
class RequireDebugFalse ( logging . Filter ) :
from django . core . management . utils import ( handle extensions , find command , popen wrapper )
for app name , namespace list in pattern . app dict . items ( ) :
raise FieldError ( message )
try :
super ( BaseMemcachedCache , self ) . init ( params )
pk value = None
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango20Warning , stacklevel = NUM_ )
if is in stance ( cache , BaseDatabaseCache ) :
func . doc = doc
var node = self . create variable node ( filter expression )
archive . extract ( filename , tempdir )
if bytes read > rollback :
raise TemplateSyntaxError ( " STR_ " % bits [ NUM_ ] )
return endpos
if ( locale is None and not exclude and not process all ) or self . domain is None :
encoding = settings . DEFAULT CHARSET
except UnicodeError :
self . id = Tok . num
self . bad cookies = set ( )
or ig = self . parent instance . pk
comment notes = [ ]
mail . send ( fail silently = fail silently )
raise NotImplementedError ( STR_ )
new key = self . key func ( key , self . key prefix , version )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
elif not os . path . exists ( self . file path ) :
if color settings :
if is in stance ( elt , six . string types ) :
def last ( value ) :
shown . add ( plan node )
sys . exit ( NUM_ )
encode = curry ( proxy method , method = six . text type . encode )
if not self . required :
for base in bases [ : : - NUM_ ] :
if related :
return latest date or datetime . datetime . now ( )
elif prefix ! = common prefix :
endblock = parser . next token ( )
return parser . namedCycleNodes [ name ]
tmpdir = tempfile . mkdtemp ( )
newlines = property ( lambda self : self . file . newlines )
self . set ( key , value , version = version + delta )
sys . exit ( NUM_ )
func globals = " STR_ "
context re = re . compile ( r " " " STR_ " [ ^ " STR_ " ) | ( ? : STR_ ] * ? ))\s*""" )
self . css = { }
new second item . extend ( item )
return
kwargs = match . groupdict ( )
extracted = self . archive . extractfile ( member )
if not buf :
NOCOLOR PALETTE = STR_
in ner result , in ner args = [ ] , [ ]
if log in child loggers :
def fget ( in stance , in stance type = None , name = fget . name ) :
return self . class ( self )
import os
return loader . get template ( template )
else :
if message context [ NUM_ ] == STR_ :
import locale
security logger = logging . getLogger ( STR_ % e . class . name )
return default
from django . utils . formats import localize
return formats . date format ( value , arg )
def handle m2m field node ( self , node , field ) :
def is checked ( self ) :
end text pos = pos
class BaseArchive ( object ) :
elif name in lib . filters :
class Origin ( object ) :
cookiedict = { }
if errors :
if len ( hextet ) > NUM_ :
def show migration list ( self , connection , app names = None ) :
end = len ( text )
raise ValidationError ( errors )
truncate len -= NUM_
self . objects . append ( self . get dump object ( obj ) )
for root , dirs , files in os . walk ( template dir ) :
return str ( name ) , val
raise ValueError ( STR_ STR_ % ( formatter , e ) )
regex = self . regex
db = router . db for write ( self . cache model class )
if self . asvar :
else :
return self . size
memo [ id ( self ) ] = self
self . stdout . write ( self . style . MIGRATE SUCCESS ( " STR_ " ) )
return self . add truncation text ( . join ( words ) , truncate )
error messages = opts . error messages [ NON FIELD ERRORS ]
value = b . join ( self . make bytes ( chunk ) for chunk in value )
if len ( args ) > NUM_ :
def init ( self , * args , ** kwargs ) :
class CommandParser ( ArgumentParser ) :
os . chdir ( our home dir )
def parts ( ) :
def linebreaks ( value , autoescape = False ) :
self . errors = [ ]
result . append ( Group ( ( ( " STR_ " % param ) , param ) ) )
table names = connection . in trospection . table names ( cursor )
values = [ parser . compile filter ( arg ) for arg in args [ NUM_ : - NUM_ ] ]
import sys
client . behaviors = self . options
hash = new method proxy ( hash )
else :
except Exception as e :
models = set ( )
constant arg , var arg = match . group ( " STR_ " , " STR_ " )
elif disable existing :
@ property
for field , errors in self . items ( ) :
if level :
for i item , i args in zip ( in ner result , in ner args ) :
pop context = False
with context . push ( ** values ) :
formatter = config . pop ( STR_ , None )
from django . utils . translation import templatize
def represent decimal ( self , data ) :
self . context data = context
new second item = [ ]
def add arguments ( self , parser ) :
def get ( self , header , alternate = None ) :
else :
subject = STR_ % ( record . levelname , record . getMessage ( ) )
if self . username and self . password :
self . key prefix = params . get ( STR_ , )
output = self . filter expression . resolve ( context )
self . in dent ( NUM_ )
state = self . state
yield
if cmatch :
return ,
cc = cc delim re . split ( response [ STR_ ] )
if self . feed [ STR_ ] is not None :
raise self . source error ( source , msg )
import copy
except ValidationError :
result = NUM_
changed = True
for app label , migration names in conflicts . items ( ) :
continue
return " STR_ " % os . sep . join ( [ self . dirpath , self . file ] )
import re
digits = [ six . text type ( digit ) for digit in reversed ( digits ) ]
if not encoding :
for in iterator :
name str = " STR_ " . join ( " STR_ " % ( " STR_ " . join ( names ) , app ) for app , names in conflicts . items ( ) )
qs = queryset . filter ( ** { self . fk . name : self . in stance } )
self . verbatim = STR_ % block content
return self . fqdn
if comment lineno cache is not None :
data = ( form . cleaned data [ field ] , ) + date data
if self . verbosity > NUM_ :
self . asvar = asvar
first = second = None
or iginal path = os . path . join ( tmpdir , STR_ )
os . makedirs ( filename )
parent pat = pattern . regex . pattern
is usable = True
if options :
return value
warnings . warn ( " STR_ " , RemovedInDjango19Warning )
return name . replace ( STR_ , ) . capitalize ( )
from future import unicode literals
tupl = d . as tuple ( )
parser . namedCycleNodes [ name ] = node
def A ( self ) :
nodelist = parser . parse ( ( elif , else , STR_ ) )
class BaseTemporalField ( Field ) :
for model in model list :
if param in unhandled params :
help = " STR_ "
if is in stance ( content , EmailMessage ) :
weight += NUM_
value = ungettext ( " STR_ " , " STR_ " , NUM_ ) % { STR_ : NUM_ }
year += NUM_
return force text ( iri to uri ( value ) )
if options . get ( STR_ ) is not None :
class RawPostDataException ( Exception ) :
self . DSTOFFSET = self . STDOFFSET
if tag in self . CDATA CONTENT ELEMENTS :
bits = token . split contents ( )
data [ field . attname ] = self . handle fk field node ( field node , field )
else :
from django . utils . datastructures import MultiValueDict
obj pk = getattr ( obj , field . rel . field name )
def allow lazy ( func , * resultclasses ) :
templatetags modules = [ ]
return [ ]
in teractive = options . get ( STR_ )
self . lineno += token string . count ( STR_ )
i = existing . in dex ( name )
import glob
bits = token . split contents ( )
if CONTEXT SEPARATOR in result :
def update errors ( self , errors ) :
try :
return result
class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
def clear ( self ) :
yield obj
else :
ch = None
cmp fmt = parts [ - NUM_ ]
sys . stderr . write ( " STR_ " % ( e . errno , e . strerror ) )
continue
if value and STR_ in value :
status code = NUM_
except ImportError :
class MultipleObjectsReturned ( Exception ) :
def get post ( self ) :
plist = parse header params ( b STR_ + line )
self [ : ] = tup
self . text = text
try :
jan1 weekday = self . data . replace ( month = NUM_ , day = NUM_ ) . weekday ( ) + NUM_
else :
pass
return ( lazy proxy unpickle , ( func , self . args , self . kw ) + resultclasses )
def init ( self , text ) :
pass
return FilterNode ( filter expr , nodelist )
return
git log = subprocess . Popen ( STR_ , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True , cwd = repo dir , universal newlines = True )
match = kwarg re . match ( bits [ NUM_ ] )
cached loaders = [ ]
data = data . encode ( fp . encoding , errors )
self . deactivate = deactivate
if settings . DEBUG :
if is in stance ( value , six . string types ) and value ! = ALL FIELDS :
if not hasattr ( package , STR_ ) :
qs = f . value from object ( in stance )
def check 1 6 compatibility ( ** kwargs ) :
except AttributeError :
with open ( filepath , STR_ ) as fp :
self . dry run = options . get ( STR_ , False )
@ lru cache . lru cache ( maxsize = None )
try :
from django . db . utils import DatabaseError
value = self . decompress ( value )
context . autoescape = self . setting
kwargs . setdefault ( STR_ , STR_ )
return None
from django . core . management . base import AppCommand
raise AttributeError ( " STR_ " " STR_ " % self . class . name )
return ugettext ( " STR_ " " STR_ " ) % { " STR_ " : get text list ( unique check , six . text type ( ( " and " ) ) ) , }
for template dir in template dirs :
from django . forms . widgets import Media , MediaDefiningClass , TextInput , Textarea
self . url = iri to uri ( url )
except ValueError :
error = self . data [ i ]
cls . bytes = cls . bytes cast
class HiddenInput ( Input ) :
class RequireDebugTrue ( logging . Filter ) :
self . cyclevars = cyclevars
if value is not result :
result . append ( ch )
class TemplateLiteral ( Literal ) :
handler = SimplerXMLGenerator ( outfile , encoding )
def init ( self , * args , ** kwargs ) :
help = " STR_ "
value = self . val expr . resolve ( context )
self . timeout = timeout
def get ( self , key , default = None , version = None ) :
return bool ( ret )
def call ( self , f ) :
return value
except NotImplementedError :
for model in not installed models :
class Storage ( object ) :
LUHN ODD LOOKUP = ( NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ )
deactivate = deactivate all = lambda : None
if number == NUM_ :
cached filenames = [ ]
def save instance ( form , in stance , fields = None , fail message = STR_ , commit = True , exclude = None , construct = True ) :
for attr in self . rendering attrs :
self . pk field = pk = self . model . meta . pk
if self . m2m data and save m2m :
final output . extend ( output )
except IOError as e :
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
if model in created models :
return make decorator
if alter sql :
doublecolon start = - NUM_
def build potfiles ( self ) :
values = [ ]
raise ContentNotRenderedError ( STR_ STR_ )
import sys
os . unlink ( work file )
filename = os . path . basename ( path )
global templatetags modules
self . reason phrase = REASON PHRASES . get ( self . status code , STR_ )
@ register ( Tags . models , Tags . signals )
try :
import time
if not os . path . is dir ( migrations directory ) :
bits = bits [ NUM_ : ]
if file obj :
if options . get ( STR_ ) :
ext = ext [ : NUM_ ]
for app label in bad app labels :
kw = [ d . year , d . month , d . day ]
def str ( self ) :
raise InvalidCacheBackendError ( " STR_ " % ( backend , e ) )
def handle ( self , ** options ) :
mtimes = { }
def file complete ( self , file size ) :
self . validate key ( key )
def handle ( self , * app labels , ** options ) :
return result
attachment = SafeMIMEText ( content , subtype , encoding )
output . extend ( connection . creation . sql destroy indexes for model ( model , style ) )
work file = os . path . join ( self . dirpath , thefile )
super ( Command , self ) . add arguments ( parser )
connection class = smtplib . SMTP SSL if self . use ssl else smtplib . SMTP
if is in stance ( f , ManyToManyField ) :
filelist = new filenames
def save ( self , name , content ) :
tables = connection . in trospection . table names ( cursor )
class Command ( BaseCommand ) :
response . closable objects . append ( request )
def data ( self ) :
locale dir = None
def a ( self ) :
if file is not None :
tried . append ( [ pattern ] )
cursor . execute ( sql )
self . children . extend ( data . children )
backend = params . pop ( STR_ )
def add root elements ( self , handler ) :
namespaces = { }
import socket
else :
return self . to language
zfile . close ( )
def init ( self , file ) :
raise ValueError ( " STR_ " % ( protocol , list ( ip address validator map ) ) )
ns pattern =
chunk += over chunk
return True
if use natural keys :
raise IOError ( " STR_ " % new file name )
return templatetags modules
from django . core . cache import caches
return compile function
if not in dent :
locations . extend ( ( dirpath , f ) for f in filenames if f . endswith ( STR_ ) )
if hasattr ( formfield , STR_ ) :
def init ( self , func , name = None ) :
parent = self . parent name . resolve ( context )
if six . PY2 :
self . stdout . write ( " STR_ " % title )
if iri is None :
if os . path . basename ( candidate ) in targets :
else :
self . verbatim = False
else :
f . write ( pickle . dumps ( expiry , - NUM_ ) )
from pprint import pformat
def get handler ( self , * args , ** options ) :
if is in stance ( s , bytes ) :
import warnings
def clean ( self ) :
return " STR_ " % or d ( match . group ( NUM_ ) )
from django . utils . encoding import force bytes , force text , iri to uri
def init ( self , dict = None , autoescape = True , current app = None , use l10n = None , use tz = None ) :
if self . verbosity >= NUM_ :
def find template loader ( loader ) :
if not hextets [ in dex ] :
return kwargs
ignore = lambda pattern : fnmatch . fnmatchcase ( filename , pattern )
result . setlist ( copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )
try :
pickled = pickle . dumps ( new value , pickle . HIGHEST PROTOCOL )
if getattr ( func , STR_ , False ) :
compiled parent = self . get parent ( context )
cls . str = cls . text cast
from django . forms . extras . widgets import SelectDateWidget
result = [ ]
key = STR_ . join ( urlquote ( var ) for var in vary on )
pass
module path , class name = dotted path . rsplit ( STR_ , NUM_ )
def number format ( value , decimal pos = None , use l10n = None , force grouping = False ) :
default error messages = { STR_ : ( STR_ ) , }
def time ( value , arg = None ) :
raise ValueError ( " STR_ " % key )
return [ ]
def more ( self ) :
def init ( self , name , nodelist , parent = None ) :
def close ( self ) :
self . options = options
limit choices to = limit choices to ( )
from django . utils . timezone import is aware
if commit :
use null fallback = True
match = kwarg re . match ( bit )
kwargs [ name ] = parser . compile filter ( value )
html gunk re = re . compile ( r STR_ , re . IGNORECASE )
choice = self . choices [ idx ]
current version = sys . version info
bits = token . split contents ( ) [ NUM_ : ]
if self . L ( ) and self . data . month > NUM_ :
try :
def get path info ( environ ) :
filter = get exception reporter filter ( request )
return self . tag ( name , func )
if len ( name ) > NUM_ :
del cc [ STR_ ]
link = [ last , root , key , result ]
from collections import OrderedDict
@ register . tag
else :
fixture = open method ( fixture file , mode )
params , varargs , varkw , defaults = getargspec ( func )
domain = domain . encode ( STR_ ) . decode ( STR_ )
return ustring re . sub ( fix , s )
return caches [ DEFAULT CACHE ALIAS ] ! = other
def parse http date ( date ) :
try :
for item , args in zip ( result , result args ) :
def javascript quote ( s , quote double quotes = False ) :
self . field = field
return otherwise
start = NUM_
link prev [ NEXT ] = link next
if file is None :
return ( self . newobj , ( self . class , ) , self . getstate ( ) )
class Library ( object ) :
substitutions [ STR_ ] = conditional escape ( checkbox name )
def init ( self , out , style func = None , ending = STR_ ) :
def root attributes ( self ) :
self . template cache [ key ] = ( template , or igin )
raise AttributeError ( attr )
domain regex = re . compile ( r STR_ , re . IGNORECASE )
obj list = self . target . resolve ( context , True )
if os . name == STR_ :
os . remove ( fname )
from gzip import GzipFile
from django . apps import apps
try :
re escaped = re . compile ( r STR_ )
for pattern in allowed hosts :
value = bytes to text ( value , self . encoding )
if labels is not None :
return output
from django . utils . os import safe join , abspathu
import time
msg = " STR_ " % dotted path
new environ = os . environ . copy ( )
r = r [ : NUM_ ] + r [ NUM_ : ]
def bound data ( self , data , in itial ) :
if code is not None :
super ( ChoiceField , self ) . init ( required = required , widget = widget , label = label , in itial = in itial , help text = help text , * args , ** kwargs )
from django . utils . functional import lazy
raise RawPostDataException ( " STR_ " )
def has changed ( self , in itial , data ) :
result += STR_ + ipv4 address
top dir = path . join ( os . getcwd ( ) , name )
self . current [ field . name ] = [ m2m value ( related ) for related in getattr ( obj , field . name ) . iterator ( ) ]
base = sup cls . media
fd , tmp path = tempfile . mkstemp ( dir = self . dir )
root , = nonlocal root
return in itial forms
django . setup ( )
self . fname = None
def run from argv ( self , argv ) :
encoding = self . encoding or settings . DEFAULT CHARSET
def add ( self , item ) :
def configure custom ( self , config ) :
url fields = split url ( urlunsplit ( url fields ) )
try :
pass
class ChoiceFieldRenderer ( object ) :
answer = six . moves . in put ( " STR_ " )
if ( NUM_ , NUM_ ) < sys . version info < ( NUM_ , NUM_ , NUM_ ) :
form . errors [ NON FIELD ERRORS ] = self . error class ( [ self . get form error ( ) ] )
super ( InlineForeignKeyField , self ) . init ( * args , ** kwargs )
self . cull ( )
def to python ( self , value ) :
@ register . filter ( is safe = False )
if filename . endswith ( ( STR_ , STR_ , STR_ ) ) :
call command ( STR_ , addrport = options [ STR_ ] , shutdown message = shutdown message , use reloader = False , use ipv6 = options [ STR_ ] , use threading = use threading )
def get language ( ) :
trans real . default = None
raise TemplateSyntaxError ( " STR_ " " STR_ " % bits [ NUM_ ] )
if settings . USE I18N or settings . USE L10N :
in comment = False
self . stdout . write ( " STR_ " % display url )
self . writer leaves ( )
return bytes ( value . encode ( self . charset ) )
def find template ( self , name , dirs = None ) :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
import json
if takes context :
try :
if os . path . is abs ( fixture name ) :
id = STR_ % name
value = datetime safe . new datetime ( value )
def get backend timeout ( self , timeout = DEFAULT TIMEOUT ) :
else :
def hash ( self ) :
else :
else :
from django . utils . translation import ugettext as
if status :
return language [ : p ] . lower ( ) + STR_ + language [ p + NUM_ : ] . upper ( )
import hmac
def bool ( self ) :
else :
return & . join ( output )
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc info ( ) [ NUM_ ] )
self . file = file name
raise
logging . releaseLock ( )
sign =
self . status code = status
state frame [ self ] = compare to
templatetags modules = templatetags modules
from django . core . mail . backends . base import BaseEmailBackend
else :
value = field . rel . to . meta . get field ( field . rel . field name ) . to python ( field value )
from django . utils . safestring import mark safe
self . source = source
for medium , paths in data . items ( ) :
while x > NUM_ :
self . vals = [ ]
try :
if self . has header ( STR_ ) :
values = { name : var . resolve ( context ) for name , var in six . iteritems ( self . extra context ) }
if in dent :
if ch :
handler . file . close ( )
if has old option and has new option :
class ContentFile ( File ) :
utf8 charset = Charset . Charset ( STR_ )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
return False
finder = hook ( entry )
from django . utils . safestring import mark safe
field notes . append ( " STR_ " )
num args = NUM_
content = message from string ( content )
return r STR_
sys . stdout , sys . stderr = so , se
self . cull frequency = NUM_
if not options . get ( STR_ ) :
def handle ( self , * app labels , ** options ) :
def init ( self , attrs = None ) :
subject = self . format subject ( subject )
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " ) )
in ner text = [ ]
self . backout . append ( self . pointer )
return j
else :
c = config . pop ( STR_ )
connection = connections [ options . get ( STR_ , DEFAULT DB ALIAS ) ]
def close ( self ) :
def now ( ) :
os . chdir ( our home dir )
nodelist empty = None
for i , widget in enumerate ( self . widgets ) :
if out log :
else :
return result
prefix = settings . STATIC URL
handler = logging . StreamHandler ( )
except ( ValueError , TypeError , ValidationError ) :
f . close ( )
else :
return bytes ( s )
return
return trans . templatize ( src , or igin )
self . stdout . write ( self . style . MIGRATE LABEL ( " STR_ " % migration . name ) )
WORD PATTERN = re . compile ( r STR_ )
@ register . filter ( is safe = False )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
class Info ( CheckMessage ) :
version = " STR_ "
supported = OrderedDict ( settings . LANGUAGES )
DJANGO DEPRECATED LOCALES = BROWSERS DEPRECATED LOCALES
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " ) )
continue
def iter ( self ) :
def handle ( self , * labels , ** options ) :
def split contents ( self ) :
stats [ MISSES ] += NUM_
force str = force text
self . command stack = [ ]
remaining -= len ( emitting )
i = p . find ( b = )
def loaders ( self ) :
self . stdout . write ( " STR_ " )
year days = [ None , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ]
with io . open ( or ig file , encoding = settings . FILE CHARSET ) as fp :
kwargs [ STR_ ] = True
if prefix is None :
def blankout ( src , char ) :
TYPE = FILE
self . app dict [ language code ] = apps
return sorted ( value , key = Variable ( arg ) . resolve )
self . stdout . ending = None
else :
if not lib :
signals . request started . send ( sender = self . class )
wm . add watch ( path , mask )
i = i % j
if exit code ! = NUM_ :
app = app . rpartition ( STR_ ) [ - NUM_ ]
from django . utils . encoding import smart text
raise
hextets = ip str . split ( STR_ )
if app config . models module is None :
self . max entries = NUM_
response = middleware method ( request , response )
self . message = message
statements = sql indexes ( app config , self . style , connection )
value = re . sub ( STR_ , , value ) . strip ( ) . lower ( )
return True
if timeout is not None :
key = bytes to text ( key , self . encoding )
def as hidden ( self , attrs = None , ** kwargs ) :
def ugettext ( message ) :
if kw [ STR_ ] :
def no style ( ) :
if field value in self . empty values :
nofollow attr = STR_ if nofollow else
script url = get bytes from wsgi ( environ , STR_ , )
return " " . join ( in ner text )
return field in self . errors
content = template . render ( context )
def add fields ( self , form , in dex ) :
kwarg format = match and match . group ( NUM_ )
fg = colors . pop ( )
self . file path = getattr ( settings , STR_ , None )
def repr ( self ) :
from django . utils . six . moves import reduce
if cookie encodes correctly and cookie allows colon in names :
chars = allow lazy ( chars )
if not matches :
if STR_ in self . attrs :
except :
else :
loop dict [ STR_ ] = len values - i - NUM_
results = ( [ ] , [ ] )
from django . utils . module loading import import string
all = ( STR_ , STR_ , STR_ )
rel to = " STR_ " if relations [ i ] [ NUM_ ] == table name else table2model ( relations [ i ] [ NUM_ ] )
resolved path = [ ]
return data
return self . number * self . paginator . per page
from django . utils . encoding import smart text , force str , force text
self . delete ( fname )
self . stderr . write ( " STR_ " % ( app name , model . meta . object name , e ) )
self . addr , ipv4 , ipv6 , fqdn , self . port = m . groups ( )
@ stringfilter
self . warning = warning
stats [ HITS ] += NUM_
if sent :
week number = NUM_
template = get template from string ( template , or igin , template name )
def U ( self ) :
if is in stance ( stream or string , six . string types ) :
break
time str = time str . decode ( STR_ )
def handle field ( self , obj , field ) :
if hasattr ( mw instance , STR_ ) :
def repr ( self ) :
if source [ NUM_ ] is None :
self . coerce = kwargs . pop ( STR_ , lambda val : val )
self . vals = [ ]
yield subwidget
return super ( TimestampSigner , self ) . sign ( value )
if win :
if force text ( value ) ! = force text ( or ig ) :
else :
val = getattr ( module , format type )
self . cookies [ key ] [ STR_ ] = True
if self . verbosity >= NUM_ :
yield line
def add ( value , arg ) :
return STR_ % ( usage , self . help )
VARIABLE TAG START = STR_
self . seek ( NUM_ )
try :
return self . file
if plan :
def getitem ( self , key ) :
encode = lambda k , v : urlencode ( { k : v } )
self . keyOrder . remove ( result [ NUM_ ] )
all = ( STR_ , STR_ )
from math import ceil
return STR_ % ( text , truncate )
if tag . lower ( ) ! = self . cdata tag :
from importlib import find loader as importlib find
def repr ( self ) :
for tag in open tags :
def eval ( self , context ) :
from django . db import connection
mem args = args [ : num args ]
bytes = serialize headers
raise CommandError ( " STR_ " % ( " STR_ " . join ( in valid apps ) ) )
import ssl
continue
name = os . path . join ( dir name , " STR_ " % ( file root , next ( count ) , file ext ) )
help = " STR_ "
if in itial is not None :
assertRegex = " STR_ "
@ classmethod
pass
import sys
super ( ComboField , self ) . clean ( value )
self . encoding = encoding
def tags available ( self ) :
return self . position
return TEMPLATE FRAGMENT KEY TEMPLATE % ( fragment name , args . hexdigest ( ) )
write ( sep )
def get size ( self ) :
def init ( self , data = None ) :
units = len ( tupl [ NUM_ ] ) - tupl [ NUM_ ]
return mark safe ( linebreaks ( value , autoescape ) )
accept = request . META . get ( STR_ , )
if STR_ in val or STR_ in val :
self . children = children [ : ] if children else [ ]
def validate ( self , value ) :
def strptime ( self , value , format ) :
def compress string ( s ) :
comment lineno cache = t . lineno
context extras [ STR_ ] = settings . LANGUAGES
def init ( self , environ ) :
smart str = smart bytes
secret = force bytes ( secret )
from django . http import Http404
def handle ( self , * fixture labels , ** options ) :
def set ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
pieces = accept language re . split ( lang string . lower ( ) )
git changeset = get git changeset ( )
in itial = self . widget . decompress ( in itial )
text = force text ( text )
cache . clear ( )
except ( ValueError , TypeError ) :
if value in self . empty values :
def get ( self , in stance , type = None ) :
return STR_ % ( self . prefix , field name ) if self . prefix else field name
def eval ( self , context ) :
else :
pass
errors = [ ]
return self . name
import fnmatch
in t part , dec part = str number ,
def to python ( self , value ) :
message context = message context . strip ( " STR_ " )
fname = self . key to file ( key , version )
except KeyError :
for elt in source :
obj = base . build instance ( Model , data , db )
def init ( self , stream , boundary ) :
DefaultFeed = Rss201rev2Feed
return path
parser . add argument ( STR_ , STR_ , dest = STR_ , action = STR_ , default = [ ] , help = STR_ )
raise
value = ugettext ( " STR_ " ) % filesize number format ( bytes / GB )
all = ( STR_ , STR_ , STR_ , STR_ )
def close ( self ) :
else :
paths = [ force text ( p ) for p in paths ]
def clear ( self ) :
expire info = { }
if offset is not None :
if field . rel . to . meta . pk . rel :
compiled regex = re . compile ( regex , re . UNICODE )
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " ) )
for f in sorted ( os . listdir ( self . path ) ) :
try :
def smart split ( text ) :
def to python ( self , value ) :
return value if six . PY2 else value . encode ( ISO 8859 1 ) . decode ( UTF 8 )
with io . open ( os . path . join ( self . dirpath , thefile ) , " STR_ " , encoding = STR_ ) as fp :
raise self . error ( token , " STR_ " % command )
content type = " STR_ " % ( settings . DEFAULT CONTENT TYPE , self . charset )
if months :
except LookupError :
self . caches . caches [ alias ] = cache
raise
output = self . nodelist . render ( context )
keys = iterkeys
for app config in apps . get app configs ( ) :
filters [ name ] = self . configure filter ( filters [ name ] )
try :
resolver = urlresolvers . RegexURLResolver ( r STR_ , urlconf )
DjangoSafeDumper . add representer ( decimal . Decimal , DjangoSafeDumper . represent decimal )
def serialize headers ( self ) :
kwarg re = re . compile ( r " STR_ " )
if value in self . empty values :
from django . core . mail . backends . console import EmailBackend as ConsoleEmailBackend
self . keep pot = options . get ( STR_ )
try :
self . old timezone = getattr ( active , STR_ , None )
def add doc ( func , doc ) :
def widget attrs ( self , widget ) :
def model installed ( model ) :
@ stringfilter
self . serialization formats = serializers . get public serializer formats ( )
def decode ( self , s ) :
widget = self . field . widget
executor . migrate ( targets , plan , fake = options . get ( " STR_ " , False ) )
warnings . warn ( " STR_ " , RemovedInDjango19Warning )
command = load command class ( app name , name )
count2 = ( since - ( seconds * count ) ) // seconds2
except StopIteration :
is compressed = False
remove = complain
else :
else :
unescape string literal = allow lazy ( unescape string literal )
return getattr ( default , translation function ) ( singular , plural , number )
raise TemplateSyntaxError ( " STR_ " % bits [ NUM_ ] )
max num = DEFAULT MAX NUM
def flatatt ( attrs ) :
if not expires :
kw [ STR_ ] = kw [ STR_ ] . ljust ( NUM_ , STR_ )
sys . exit ( bool ( failures ) )
def cache info ( ) :
for h in handlers :
messages = { }
FILES = property ( get files )
elif self . required :
from django . utils import six
targets = [ ( app label , None ) ]
return force str ( super ( BaseMemcachedCache , self ) . make key ( key , version ) )
if is in stance ( sep , unicode ) :
from django . core . exceptions import MiddlewareNotUsed , PermissionDenied , SuspiciousOperation
if settings . USE X FORWARDED HOST and ( STR_ in self . META ) :
changed = False
raise TemplateSyntaxError ( " STR_ " " STR_ " % function name )
if row [ NUM_ ] is None or row [ NUM_ ] is None :
if field type == STR_ :
super set ( key , value )
version = self . version
pass
self . name = name
del self . cache [ key ]
dlen = len ( defaults or [ ] )
from django . utils import datetime safe
DateTimeAwareJSONEncoder = DjangoJSONEncoder
iterator = iter ( stream or iterable )
os . chmod ( full path , self . file permissions mode )
val . append ( is o input )
if row data and None not in row data :
msg [ STR_ ] = self . extra headers . get ( STR_ , STR_ . join ( self . to ) )
host = self . META [ STR_ ]
return ( os . path . normcase ( os . path . abspath ( src ) ) == os . path . normcase ( os . path . abspath ( dst ) ) )
class Parser ( object ) :
def make origin ( display name , loader , name , dirs ) :
def init ( self , stream or string , ** options ) :
ret ip . append ( ( STR_ * ( NUM_ - len ( hextet ) ) + hextet ) . lower ( ) )
if keys :
with transaction . atomic ( using = connection . alias , savepoint = connection . features . can rollback ddl ) :
for i , line in enumerate ( table output ) :
opts = self . meta
def get urlconf ( default = None ) :
if e . errno == errno . EEXIST :
def read limited ( self , size = None ) :
def cache key ( self , template name , template dirs ) :
return self . path == other . path
def str ( self ) :
cache [ mem args ] = result
if is in stance ( value , six . string types ) :
if language code not in self . regex dict :
output transaction = True
def get commands ( ) :
if fields is not None and f . name not in fields :
compare = lambda self , a , b : a < b
resolved args = [ context ] + resolved args
self . tokens = mapped tokens
field output = [ qn ( f . name ) , f . db type ( connection = connection ) ]
if in itial == False :
return self . level >= ERROR
value = normalize newlines ( value )
loader = MigrationLoader ( connection )
self . encoding = value
sign = - if offset < NUM_ else +
field notes . append ( STR_ )
self . setFeature ( handler . feature external ges , False )
self . not ation name = not ation name
class EmailBackend ( BaseEmailBackend ) :
output . extend ( [ encode ( k , force bytes ( v , self . encoding ) ) for v in list ] )
error msg += " STR_ " % self . parent name . token
return
def handle noargs ( self , ** options ) :
if fields and f . name not in fields :
consume next = True
return qs
get val = lazy ( get val , six . text type )
BytesIO = io . BytesIO
super ( TextInput , self ) . init ( attrs )
return STR_ . join ( paras )
if in tag and not self . verbatim :
else :
pass
self . help texts = getattr ( options , STR_ , None )
TOKEN VAR = NUM_
def get model ( model identifier ) :
@ property
return repr ( self . dicts )
daemon kwargs [ STR_ ] = options [ STR_ ]
except StandardError as e :
binary type = bytes
warnings . warn ( " STR_ " , RemovedInDjango19Warning )
field value = self . cleaned data . get ( field , None )
for candidate in ( ( d not in models or d in model list ) for d in deps ) :
self . content = content
elif char in STR_ :
if ignore and field name not in model fields :
arg = STR_ + arg
self . dicts . append ( value )
if fdel is not None :
def copy ( self ) :
raise ValueError ( " STR_ " " STR_ " % ( opts . object name , fail message ) )
return msg count
from functools import wraps , update wrapper , WRAPPER ASSIGNMENTS
delslice = complain
try :
return self . render ( )
d = get deserializer ( format )
try :
mw class = import string ( middleware path )
def parse etags ( etag str ) :
def changed data ( self ) :
confirm = in put ( STR_ )
data = self . read ( chunk size )
trans bit = [ bit ]
skipped . append ( ( model , deps ) )
warnings . warn ( " STR_ " , RemovedInDjango19Warning )
if callable ( self . limit choices to ) :
elif = in part :
for lookup , arg in args :
def E ( self ) :
if safe and arg ! = STR_ :
def has expired ( self , key ) :
except KeyError :
self . stdout . write ( app name , self . style . MIGRATE LABEL )
default = None
cursor . execute ( " STR_ " " STR_ " % table , [ key , b64encoded , exp ] )
encoded = STR_ + encoded + STR_
if version [ NUM_ ] == STR_ and version [ NUM_ ] == NUM_ :
context [ STR_ ] = block
def modified time ( self , name ) :
self . buffer += chunk
if app config . label in loader . migrated apps :
if cache is None :
from django . utils . encoding import smart text , is protected type
return six . text type ( s ) . encode ( encoding , errors )
@ property
if self . required and not value :
raise ValueError ( STR_ STR_ % ( name , e ) )
return value
if self . fail silently :
self . object name = STR_
in itial prefixed name = self . add initial prefix ( name )
iterkeys = iterkeys
return { " STR_ " : self . ns }
translation . catalog = { }
return header query . lower ( ) in existing headers
return
if settings . DEBUG :
try :
def assertRaisesRegex ( self , * args , ** kwargs ) :
if autoescape and not safe input :
return [ first item ] , True
if is in stance ( self . var , Variable ) :
if self . attachments :
media = Media ( )
def strip tags ( value ) :
T = [ F ( x ) for x in range ( NUM_ , l ) ]
value = bytes to text ( value , self . encoding )
return setattr ( caches [ DEFAULT CACHE ALIAS ] , name , value )
from xml . sax . saxutils import XMLGenerator
if len ( key ) > MEMCACHE MAX KEY LENGTH :
kwargs = { }
return True
class SerializationError ( Exception ) :
setattr ( filter func , attr , value )
if not self . form . is bound :
connection params = { STR_ : DNS NAME . get fqdn ( ) }
if use l10n or ( use l10n is None and settings . USE L10N ) :
@ classmethod
outer . update ( password . translate ( hmac . trans 5C ) )
except ValueError :
raise AttributeError ( " STR_ " )
from django . conf import settings
def timesince ( d , now = None , reversed = False ) :
return False
if attrs is not None :
in ner html = STR_
view name = callback . name
def init ( self ) :
if is in stance ( item . get ( STR_ ) , bool ) :
if " = " in x :
def curried ( * moreargs , ** morekwargs ) :
if self . use natural foreign keys and hasattr ( field . rel . to , STR_ ) :
def pgettext ( context , message ) :
PATTERN = " " " STR_ " " "
try :
else :
pass
if is in stance ( filename , MIMEBase ) :
if keyword . is keyword ( new name ) :
if STR_ in truncate :
if not self . data :
val = self . cache . in cr ( key , delta )
if not field . show hidden initial :
hex format string = " STR_ " % ( hlen * NUM_ )
if or igin :
for line in sequence sql :
else :
if iterator is None :
forms = . join ( form . as ul ( ) for form in self )
return copy . deepcopy ( self . wrapped , memo )
if len ( language [ p + NUM_ : ] ) > NUM_ :
if self . feed [ STR_ ] is not None :
author = " STR_ "
self . error ( " STR_ " % ( rawdata [ i : j ] , ) )
return dict ( self )
self . reverse dict [ language code ] = lookups
return pickle . loads ( pickled )
if not response . has header ( STR_ ) :
if connection . settings dict [ STR_ ] == STR_ :
for form in self . saved forms :
raise EntitiesForbidden ( name , None , base , sysid , pubid , not ation name )
value = [ ]
def set many ( self , data , timeout = DEFAULT TIMEOUT , version = None ) :
def init ( self , streaming content = ( ) , * args , ** kwargs ) :
if message context :
class CommentNode ( Node ) :
model list = [ ]
except re . error as e :
from django . utils import six
def flush ( self ) :
return False
WRAPPING PUNCTUATION = [ ( STR_ , STR_ ) , ( < , > ) , ( STR_ , STR_ ) , ( STR_ , STR_ ) , ( STR_ , STR_ ) , ( STR_ , STR_ ) ]
self . stdout . write ( " STR_ " )
self . validators . append ( validators . MinValueValidator ( min value ) )
if self . wrapped is empty :
@ register . tag ( STR_ )
if self . verbosity > NUM_ :
self . var = var obj
def create parser ( self , prog name , subcommand ) :
return in t ( binascii . hexlify ( x ) , NUM_ )
def check ( self , app configs = None , tags = None , display num errors = False ) :
func = TemplateLoader
in put format = get format ( STR_ ) [ NUM_ ]
contents = conditional escape ( contents )
else :
if getattr ( func , STR_ , False ) :
from django . utils . translation import ugettext , ungettext lazy
hextets [ best doublecolon start : best doublecolon end ] = [ ]
if len ( bits ) :
super ( InMemoryUploadedFile , self ) . init ( file , name , content type , size , charset , content type extra )
sys . modules [ name + " STR_ " ] = sys . modules [ name + " STR_ " ] = Module six moves urllib parse ( name + " STR_ " )
except OSError as e :
pass
def date format ( value , format = None , use l10n = None ) :
def handle ( self , * args , ** options ) :
if self . options . get ( " STR_ " ) :
self . connection = connection class ( self . host , self . port , ** connection params )
if kwargs [ STR_ ] in ( STR_ , STR_ ) :
super ( MultipleHiddenInput , self ) . init ( attrs )
def enter ( self ) :
continue
try :
class ClearableFileInput ( FileInput ) :
break
thefile = self . file
return value . strftime ( format )
g = one percent re . sub ( STR_ , g )
return ModelChoiceIterator ( self )
def super ( self ) :
def repr ( self ) :
from django . core . management . commands . check import Command as CheckCommand
def is shorthand ip ( ip str ) :
def resolve ( self , path ) :
def len ( self ) :
return value . rjust ( in t ( arg ) )
handle m2m ( relobj )
else :
raise
self . first = parser . expression ( bp )
def delitem ( self , key ) :
self . var1 , self . var2 = var1 , var2
else :
extra attrs = self . widget attrs ( widget )
size = self . file . tell ( )
from django . utils . module loading import import string
from django . utils . deprecation import RemovedInDjango19Warning
other = other . cast ( )
return decorating function
for operation in migration . merged operations :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
self . waiting writers = NUM_
if is in stance ( query , MultiValueDict ) :
self . keyOrder . remove ( key )
raise MultiPartParserError ( " STR_ " % content length )
return type ( self ) . bool ( self )
if name . startswith ( STR_ ) :
except OSError :
from django . conf import settings
for handler in handlers :
import module ( project name )
else :
fname = " STR_ " % ( timestamp , abs ( id ( self ) ) )
zbuf = BytesIO ( )
if boundary :
except KeyError :
connection . client . runshell ( )
targets = [ ( app label , migration . name ) ]
def conditional content removal ( request , response ) :
TOTAL FORM COUNT = STR_
@ register . filter ( is safe = False )
DJANGO COLORS = os . environ . get ( STR_ , )
cc [ k . replace ( STR_ , - ) ] = v
mimetype , = mimetypes . guess type ( filename )
self . stdout . write ( " STR_ " % ( fixture name , humanize ( fixture dir ) ) )
last [ NEXT ] = root [ PREV ] = link
getattr ( combined , STR_ + name ) ( getattr ( other , STR_ + name , None ) )
import os
def parse file upload ( self , META , post data ) :
project name , target = options . pop ( STR_ ) , options . pop ( STR_ )
else :
def sanitize separators ( value ) :
d = data . get ( self . day field % name )
return STR_
def handle app config ( self , app config , ** options ) :
self . cached loaders = [ ]
value = ugettext ( " STR_ " ) % filesize number format ( bytes / PB )
digest = hashlib . sha256
f . write ( zlib . compress ( pickle . dumps ( value ) , - NUM_ ) )
raise NotImplementedError ( " STR_ " )
errors = [ ]
in put type = STR_
print ( " STR_ " % app config . label )
trimmed = STR_ in t . split contents ( )
try :
class TranslatableFile ( object ) :
remaining = self . remaining if size is None else size
zfile = GzipFile ( mode = STR_ , compresslevel = NUM_ , fileobj = zbuf )
pass
if not only initial :
return attrs
from django . db import connections , DEFAULT DB ALIAS
urlconf repr = STR_ % self . urlconf name [ NUM_ ] . class . name
deps = getattr ( model . natural key , STR_ , [ ] )
raise NotImplementedError ( STR_ )
class OFFSET ( Structure ) :
from importlib import import module
from django . utils . safestring import mark safe
return six . unichr ( c )
elif not is in stance ( content , Message ) :
pass
except KeyError :
self . content length = content length
if os . path . exists ( fname ) :
else :
if config [ STR_ ] ! = NUM_ :
from django . utils . html import escape
if len ( bits ) ! = NUM_ :
in teractive = options . get ( STR_ )
from django . forms . forms import *
if block context is None :
if digest is None :
not ifier = pyinotify . Notifier ( wm , EventHandler ( ) )
duplicate = super ( Context , self ) . copy ( )
self . pos += NUM_
potfiles . append ( potfile )
self . stdout . write ( " STR_ " % ( app name , model . meta . object name ) )
return copy . deepcopy ( self . wrapped , memo )
if domain :
for f in dirs :
self . limit choices to = limit choices to
import keyword
try :
subclass = type ( " STR_ " , ( Migration , ) , { " STR_ " : [ ( app label , migration . name ) for migration in merge migrations ] , } )
value = self . empty value
singular . append ( STR_ % t . contents )
return { " STR_ " : self . version , " STR_ " : " STR_ " }
raise ValueError ( " STR_ " % ( model . meta . app label , model . meta . object name , fk name ) )
from django . core . management . base import BaseCommand , CommandError
if not content type . startswith ( STR_ ) :
if upload :
else :
return super ( ModelMultipleChoiceField , self ) . prepare value ( value )
model = app config . get model ( model label )
if hasattr ( base , STR_ ) :
value = in t ( value )
else :
path = os . environ . get ( STR_ , ) . split ( os . pathsep )
self . deleted form indexes . append ( i )
c . append ( tok )
self . digits = digits
return " STR_ " + " " . join ( out ) + " STR_ "
MB = NUM_ << NUM_
num += NUM_
return self . base set ( STR_ , key , value , timeout )
if serializers is None and not serializers :
setattr ( style , role , termcolors . make style ( ** format ) )
language code re = re . compile ( r STR_ , re . IGNORECASE )
def is rendered ( self ) :
if is in stance ( field , FileField ) :
locs = frame . f locals
if only new :
self . conditions nodelists = conditions nodelists
if cword == NUM_ :
for p in path :
lexer = JsLexer ( )
if m :
sys . stdout . write ( django . get version ( ) + STR_ )
default error messages = { STR_ : ( STR_ ) , STR_ : ( STR_ ) , }
try :
class HttpResponseForbidden ( HttpResponse ) :
self . takes context = takes context
def add fields ( self , form , in dex ) :
def bool ( self ) :
errors . append ( self . get date error message ( date check ) )
if response :
self . validate name ( name , app or project )
super ( Command , self ) . add arguments ( parser )
except ImportError :
self . sep = force str ( sep )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
for label in app labels :
if kwargs is None :
urlconfs = local ( )
def stringformat ( value , arg ) :
load serializers ( )
if ( context . autoescape and not is in stance ( output , SafeData ) ) or is in stance ( output , EscapeData ) :
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
all models . extend ( router . get migratable models ( app config , database , in clude auto created = True ) )
elif is in stance ( template , six . string types ) :
targets = executor . loader . graph . leaf nodes ( )
elif value is False :
elif piece :
raise ValidationError ( self . message , code = self . code )
except ValueError :
class DateInput ( DateTimeBaseInput ) :
def init ( self , attrs = None ) :
self . populated = True
def as widget ( self , widget = None , attrs = None , only initial = False ) :
return force text ( list [ NUM_ ] )
import os
if self . verbosity >= NUM_ :
self . xml . endElement ( " STR_ " )
def isdst ( self , dt ) :
import warnings
except TypeError :
flat . update ( d )
else :
from future import unicode literals
new context . reset dicts ( values )
@ property
else :
value = None
self . no obsolete = options . get ( STR_ )
def validate ( self , value ) :
def url ( self , name ) :
make key = make key
try :
def pop ( self , idx = - NUM_ ) :
class BaseModelFormSet ( BaseFormSet ) :
return form . save ( commit = commit )
try :
except LookupError :
errors = [ ]
def init ( self , * args , ** kwargs ) :
for key in self . keyOrder :
obj . attrs = self . attrs . copy ( )
elif is in stance ( value , datetime . datetime ) :
@ property
raise ValueError ( " STR_ " )
try :
def iter ( self ) :
def str ( self ) :
week number = None
from django . conf import settings
def init ( self , attrs = None ) :
else :
from django . utils import six
return
from itertools import chain
for possibility , pattern , defaults in possibilities :
def ipython ( self ) :
self . args = args
def len ( self ) :
from django . apps import apps
return self . create var ( token )
return " STR_ "
doomed = [ k for ( i , k ) in enumerate ( self . cache ) if i % self . cull frequency == NUM_ ]
parser = self . create parser ( prog name , subcommand )
date value = datetime safe . new date ( date value )
msgid = STR_ % ( utcdate , pid , randint , idstring , idhost )
return ResolverMatch ( self . callback , args , kwargs , self . name )
from django . utils . translation import get language
def ifchanged ( parser , token ) :
or igin = make origin ( display name , self . load template source , template name , template dirs )
if not app labels :
def render ( self ) :
return remove tags ( value , tags )
i += NUM_
return lazy number ( ungettext , six . text type , singular = singular , plural = plural , number = number )
raise TypeError ( " STR_ " % len ( args ) )
class Module six moves urllib error ( LazyModule ) :
plural . append ( STR_ % t . contents )
from datetime import timedelta , tzinfo
except VariableDoesNotExist :
self . method = None
def add arguments ( self , parser ) :
def validate ( self , value ) :
output = [ format html ( STR_ , flatatt ( final attrs ) ) ]
for post callback in self . post render callbacks :
if response is None :
from django . utils import six
if min value is not None :
def bound data ( self , data , in itial ) :
defaults = { STR_ : data , STR_ : files , STR_ : auto id , STR_ : prefix }
if value is None :
def start index ( self ) :
if self . field . show hidden initial :
i = NUM_
if newretval is not None :
candidate = str ( candidate )
data [ f . name ] = list ( qs . values list ( STR_ , flat = True ) )
message = ( STR_ )
else :
def init ( self , file ) :
response headers . append ( ( str ( STR_ ) , str ( c . output ( header = ) ) ) )
locs = globs
pid = NUM_
def render ( self , name , value , attrs = None ) :
self . cleaned data = cleaned data
return self . data . day
register to = kwargs . get ( STR_ )
formatted subject = subject . replace ( STR_ , STR_ ) . replace ( STR_ , STR_ )
else :
def next token ( self ) :
if not email messages :
cache key += STR_ % tz name . encode ( STR_ , STR_ ) . decode ( STR_ ) . replace ( , STR_ )
import collections
from django . utils . os import safe join
if comment notes :
self . writer enters ( )
class TranslatorCommentWarning ( SyntaxWarning ) :
import time
return self
else :
if cursor :
if STR_ in ip str :
model = apps . get model ( exclude )
def wrapper ( * args , ** kwds ) :
qn = connection . ops . quote name
utility = ManagementUtility ( argv )
source , display name = self . load template source ( template name , template dirs )
self . obj = obj
self . connection = None
def strftime ( self , fmt ) :
logger . warning ( STR_ , exc info = sys . exc info ( ) , extra = { STR_ : NUM_ , } )
all = ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , )
in t2byte = operator . methodcaller ( " STR_ " , NUM_ , " STR_ " )
else :
if ( form . cleaned data and form . cleaned data [ field ] is not None and form . cleaned data [ unique for ] is not None ) :
self . file = open ( self . name , mode or self . mode )
if six . PY2 :
for taglib in bits [ NUM_ : ] :
saved locale = None
if top errors :
self . state = first
assert content is not None
else :
from django . utils . encoding import force text
var name = bits [ NUM_ ]
return truncate % { STR_ : text }
if not locale dir :
return
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = [ ] , metavar = STR_ , help = STR_ STR_ )
from django . middleware . csrf import get token
if os . path . is dir ( template dir ) :
import os
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango20Warning )
if self . decimal places is not None and decimals > self . decimal places :
self . max entries = in t ( max entries )
except CommandError :
raise KeyError ( STR_ STR_ STR_ % number )
self . non form errors = self . error class ( )
raise TemplateSyntaxError ( " STR_ " " STR_ " % ( tag , list ( TemplateTagNode . mapping ) ) )
import os
return True
class Command ( AppCommand ) :
timeout = params . get ( STR_ , params . get ( STR_ , NUM_ ) )
def init ( self , regex , max length = None , min length = None , error message = None , * args , ** kwargs ) :
value = tuple ( value )
self . filter expr , self . nodelist = filter expr , nodelist
return super ( QueryDict , self ) . setdefault ( key , default )
operations = [ ]
class SubWidget ( object ) :
def parse accept lang header ( lang string ) :
return self . caches . caches [ alias ]
raise
self . data = obj
params = { STR_ : self . limit value , STR_ : cleaned }
ext list = [ ]
return attachment
pass
def validate unique ( self ) :
return STR_
from django . test . signals import setting changed
def message dict ( self ) :
else :
from django . forms . widgets import Widget , Select
return [ ]
hidden widget = field . hidden widget ( )
return None
finally :
from django . core . exceptions import ( ImproperlyConfigured , ValidationError , NON FIELD ERRORS , FieldError )
return force text ( gettext ( message ) )
except Resolver404 :
self . add fields ( form , i )
now = now . decode ( STR_ )
self . argv = argv or sys . argv [ : ]
raise NotImplementedError ( STR_ )
name = sign + hhmm
return in t ( value ) % in t ( arg ) == NUM_
import re
return text
def add ( self , key , value , timeout = DEFAULT TIMEOUT , version = None ) :
name = property ( get name , set name )
def init ( self , dict = None ) :
if i >= self . in itial form count ( ) and i >= self . min num :
def handle ( self , * tablenames , ** options ) :
decompress = True
return value
return json . dumps ( self . get json data ( escape html ) )
self . callback strs . update ( pattern . callback strs )
from django . core . management . color import no style
pass
else :
self . domain = options . get ( STR_ )
if len ( app labels ) == NUM_ :
return list ( error ) [ NUM_ ]
if version is None :
for loader in template source loaders :
base path = os . path . splitext ( po path ) [ NUM_ ]
signals . request finished . send ( sender = self . handler class )
def delete ( self , name ) :
def samefile ( src , dst ) :
for app config in apps . get app configs ( ) :
if qs . result cache is not None :
from django . db import connections , transaction
label for = format html ( STR_ , self . id for label )
break
except KeyError :
if block name in parser . loaded blocks :
return escape ( value )
try :
if in plural :
raise ImportError ( " STR_ " % lookup view )
factory = klass
TOKEN BLOCK = NUM_
with connections [ db ] . cursor ( ) as cursor :
def getitem ( self , name ) :
def iteritems ( self ) :
weight += NUM_
def parse http date safe ( date ) :
return size
settingsfile = upath ( sys . modules [ settings . module ] . file )
for ch in in put iter :
def end serialization ( self ) :
html = starttag re . sub ( , html )
data [ f . name ] = [ item . pk for item in qs ]
with lock :
try :
def init ( self , table , params ) :
from django . conf import settings
handler = logging . handlers [ name ]
self . empty = False
for k in doomed :
return self . nodelist . render ( context )
def init ( self , context , * args , ** kwargs ) :
for sub stream in boundarystream :
return sql create ( app config , style , connection ) + sql custom ( app config , style , connection ) + sql indexes ( app config , style , connection )
raise NotImplementedError ( STR_ )
in put type = None
if self . verbosity >= NUM_ :
def format output ( self , rendered widgets ) :
value = environ . get ( str ( key ) , str ( default ) )
context . dicts . append ( self )
def display ( self ) :
self . request middleware = self . view middleware = self . template response middleware = self . response middleware = self . exception middleware = None
if unpack ipv4 :
def to language ( locale ) :
return retval
if is in stance ( s , ( six . text type , Promise ) ) :
except ImportError :
if not template name list :
if not self . port . is digit ( ) :
continue
try :
def as textarea ( self , attrs = None , ** kwargs ) :
field = f . name
s = s [ : site ] + syear + s [ site + NUM_ : ]
app configs = [ apps . get app config ( app label ) for app label in app labels ]
tok = STR_
raise DTDForbidden ( name , sysid , pubid )
return None
return False
key = self . make key ( key , version = version )
help = ( " STR_ " " STR_ " " STR_ " " STR_ " " STR_ " )
if url . startswith ( STR_ ) :
cache key = ( format type , lang )
unescape entities = allow lazy ( unescape entities , six . text type )
return metaclass ( STR_ , None , { } )
new value = value + delta
from django . conf import settings
except TypeError :
output . extend ( connection . creation . sql indexes for model ( model , style ) )
if count == NUM_ :
translation . info = { }
strip tags = allow lazy ( strip tags )
pickled = pickle . dumps ( value , pickle . HIGHEST PROTOCOL )
from django . utils . encoding import force text
return from current timezone ( value )
iterkeys = iterkeys
self . in itial extra = kwargs . pop ( STR_ , None )
raise CommandError ( " STR_ " )
return default
validate ipv4 address ( hextet )
if is in stance ( unicode value , six . text type ) :
else :
value = template localtime ( value , use tz = context . use tz )
def as data ( self ) :
class InvalidTemplateLibrary ( Exception ) :
else :
with context . push ( ** values ) :
leave locale alone = False
return Variable ( path ) . resolve ( context )
full path = self . path ( name )
continue
return statements
except ( OSError , TypeError ) :
except ( LookupError , ImportError ) as e :
import os
return " STR_ " % self . language
with io . open ( potfile , STR_ , encoding = STR_ ) as fp :
lang = get language ( )
comment . append ( t . contents )
propagate = config . get ( STR_ , None )
from django . conf import settings
klass = app name
self . name , self . nodelist , self . parent = name , nodelist , parent
try :
app dir = os . path . join ( app config . path , STR_ )
known models . append ( table2model ( table name ) )
if self . forms :
from future import unicode literals
elif timeout == NUM_ :
for renamed method in cls . renamed methods :
output . append ( format html ( self . in ner html , choice value = force text ( w ) , sub widgets = ) )
@ register . filter ( is safe = True )
def init ( self , in itlist = None , error class = None ) :
def unlock ( f ) :
def new ( self , values = None ) :
if is templatized :
self . mode = file . mode
else :
except UnicodeDecodeError :
def deepcopy ( self , memo = None ) :
tzinfo = timezone . get current timezone ( ) if settings . USE TZ else None
return path ,
if constant arg :
try :
nodelist false = NodeList ( )
if contains ( result [ - NUM_ ] , Group ) :
sequence sql = connection . ops . sequence reset sql ( no style ( ) , self . models )
output . append ( app output )
handlers = self . upload handlers
return default
raise
offset = NUM_ * in t ( tzinfo [ NUM_ : NUM_ ] ) + offset mins
return MONTHS AP [ self . data . month ]
return filename , display url
def language ( self ) :
output . extend ( connection . creation . sql destroy model ( model , references to delete , style ) )
import module ( STR_ , app config . name )
return value
def code changed ( ) :
if not hasattr ( self , STR_ ) :
self . stream = stream
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
if not os . path . exists ( directory ) :
link target attribute re = re . compile ( r STR_ )
else :
loggers = config . get ( STR_ , EMPTY DICT )
elt = [ elt ]
raise Exception ( " STR_ " % self . class . name )
yield line
handler . addQuickElement ( " STR_ " , cat )
return
self . archive = tarfile . open ( file )
self . stdout . write ( statement )
from django . http import HttpResponse
for bit in bits :
s = s . replace ( STR_ , STR_ )
return func
try :
params = [ ]
return normpath ( path )
output = next ( self . producer )
def render ( self , context ) :
in trans = False
from django . utils . xmlutils import SimplerXMLGenerator
dirs = [ ]
def r ( self ) :
if item [ STR_ ] is not None :
def led ( self , left , parser ) :
return mark safe ( format string . format ( * args safe , ** kwargs safe ) )
return self
def html output ( self , normal row , error row , row ender , help text html , errors on separate row ) :
from django . utils . daemonize import become daemon
if text == and len ( opts ) == NUM_ and opts [ NUM_ ] == STR_ :
dirname = os . path . dirname ( filename )
class Deserializer ( base . Deserializer ) :
def init ( self , tagtype ) :
for hook in sys . path hooks :
return s . get data ( )
else :
if id :
super ( PasswordInput , self ) . init ( attrs )
help = STR_ + CheckCommand . help
self . nodelist true , self . nodelist false = nodelist true , nodelist false
def dir ( self ) :
fixture dirs = [ os . path . join ( dir , os . path . dirname ( fixture name ) ) for dir in fixture dirs ]
if y and m and d :
import cgi
if self . leftover :
value . configurator = self
def init ( self ) :
contents = format html ( STR_ , contents , label suffix )
fields = list ( six . iteritems ( base . base fields ) ) + fields
import os
update wrapper ( wrapper , dummy )
assertRaisesRegex = " STR_ "
for base in reversed ( new class . mro ) :
add to builtins ( STR_ )
if chunk is None :
return rv
if in dex sql :
result . key = key
try :
self . data = data or { }
return fixture files
date keys = ( STR_ , STR_ )
return super ( QueryDict , self ) . pop ( key , * args )
choice input class = CheckboxChoiceInput
except Exception :
class Module six moves urllib response ( LazyModule ) :
def parse header ( line ) :
except IOError :
paras = re . split ( STR_ , value )
m2m data [ field . name ] = self . handle m2m field node ( field node , field )
valid = False
for i in range ( NUM_ , len ( pieces ) - NUM_ , NUM_ ) :
else :
else :
if ignore failures :
used name = the path . split ( / ) [ - NUM_ ]
return " "
class Command ( AppCommand ) :
self . deprecation warning = deprecation warning
except AttributeError :
@ register . filter ( " STR_ " , is safe = True )
fext = f + ext
parser . add library ( lib )
try :
if help texts is not None :
def escape quotes ( m ) :
if remaining bits :
try :
return NUM_
field value = getInnerText ( node ) . strip ( )
from django . forms . utils import ErrorList
old method = base . dict . get ( old method name )
value = Decimal ( value )
self . nodelist = nodelist
if token string . startswith ( VARIABLE TAG START ) :
def writer enters ( self ) :
if not os . path . is file ( pythonrc ) :
except UnicodeDecodeError :
handler config = handlers [ name ]
import cgi
return
else :
params = kwargs
class WindowsError ( Exception ) :
@ stringfilter
if git changeset :
super ( ExternalReferenceForbidden , self ) . init ( )
self . stdout . write ( " STR_ " )
def do translate ( message , translation function ) :
@ property
six . reraise ( ImportError , ImportError ( msg ) , sys . exc info ( ) [ NUM_ ] )
if len ( bits ) < NUM_ :
format string = bits [ NUM_ ] [ NUM_ : - NUM_ ]
in t part , dec part = str number . split ( STR_ )
def post clean ( self ) :
self . content type extra = content type extra
value = connections [ db ] . ops . process clob ( row [ NUM_ ] )
if pattern . name is not None :
def deconstructible ( * args , ** kwargs ) :
return iter ( self . container )
return [ form . cleaned data for form in self . forms ]
cursor . execute ( " STR_ " % table )
return LANG INFO [ lang code ]
from django . core . serializers . json import DjangoJSONEncoder
return FormSet
self . object = obj
str = serialize
for middleware method in self . view middleware :
from django . utils import timezone
result . key = key
return False
setattr ( MovedItems , move . name , move )
key = key [ len ( self . prefix ) : ]
if not self . cached loaders :
def dec ( func ) :
subject = self . subject
if p . find ( STR_ ) >= NUM_ :
self . use tls = settings . EMAIL USE TLS if use tls is None else use tls
except IndexError :
def mail admins ( subject , message , fail silently = False , connection = None , html message = None ) :
return result
if format module path is None :
new method = base . dict . get ( new method name )
raise ValueError ( " STR_ " )
ns = current app
if self . activated :
self . regex = regex
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
return mark safe ( template % substitutions )
field params [ STR_ ] = in t ( row [ NUM_ ] )
from django . utils import six
else :
def init ( self , queryset , cache choices = None , required = True , widget = None , label = None , in itial = None , help text = , * args , ** kwargs ) :
remove tags = allow lazy ( remove tags , six . text type )
obj . class = self . class
else :
else :
self . run ( ** options )
def b64 encode ( s ) :
if tok . startswith ( " STR_ " ) :
return s
self . callback str = callback
else :
self . fed . append ( d )
self . delete ( key , version = version )
raise InvalidTemplateLibrary ( " STR_ " " STR_ " , ( name , compile function ) )
charset = content type extra . get ( STR_ )
raise base . DeserializationError ( " STR_ " % ( node . nodeName , attr ) )
def g ( self ) :
post sql fields = [ f for f in opts . local fields if hasattr ( f , STR_ ) ]
from future import unicode literals
self . stdout . write ( " STR_ " % ( app name , model . meta . object name ) )
self . style = color style ( )
for receiver , , in receivers :
raise TemplateSyntaxError ( " STR_ " )
super ( GenericIPAddressField , self ) . init ( * args , ** kwargs )
title += " STR_ " % len ( graph . nodes [ plan node ] . replaces )
self . response middleware . in sert ( NUM_ , mw instance . process response )
break
os . remove ( tmp path )
created models = self . sync apps ( connection , executor . loader . unmigrated apps )
if in dex < NUM_ :
raise
handler . startDocument ( )
from io import StringIO
raise TemplateSyntaxError ( error msg )
use null fallback = False
def in itial form count ( self ) :
PREV , NEXT , KEY , RESULT = NUM_ , NUM_ , NUM_ , NUM_
return " STR_ "
else :
def words ( self , num , truncate = None , html = False ) :
def str ( self ) :
connection = connection or get connection ( username = auth user , password = auth password , fail silently = fail silently )
def next ( self ) :
ignore = options . pop ( STR_ , False )
from django . forms import Form
self . loaded object count += loaded objects in fixture
del frame
import unicodedata
except HTMLParseError :
self . STDOFFSET = timedelta ( seconds = - time . timezone )
get method self = operator . attrgetter ( meth self )
leading = self . has leading dir ( x . name for x in members )
return do ifequal ( parser , token , True )
self . tag ( function name , compile func )
self . tags [ name ] = compile function
app dir = apps . get app config ( model . meta . app label ) . path
simple url re = re . compile ( r STR_ , re . IGNORECASE )
if item [ STR_ ] is not None :
def write po file ( self , potfile , locale ) :
string concat = lazy ( string concat , six . text type )
def validate ( self , value ) :
length = in t ( num )
plural = [ ]
row = cursor . fetchone ( )
from django . core . management . color import color style
for f in file field list :
msg . attach ( self . create attachment ( * attachment ) )
return False
lang = None
def B ( self ) :
func = getattr ( func , STR_ , func )
self . assert mutable ( )
super ( SortedDict , self ) . init ( )
raise TemplateSyntaxError ( " STR_ " " STR_ " )
def setlist ( self , key , list ) :
while escaped or ch ! = STR_ :
pass
return self . client
options . update ( kwargs )
return STR_ . join ( output )
EndToken = EndToken ( )
header , value = settings . SECURE PROXY SSL HEADER
def load template source ( self , template name , template dirs = None ) :
class FileSystemStorage ( Storage ) :
from django . utils import six
localedir = os . path . join ( app config . path , STR_ )
tok = tok . replace ( " STR_ " U " )
except ValidationError as e :
registry = CheckRegistry ( )
objects in fixture += NUM_
MIN NUM FORM COUNT = STR_
template source loaders = tuple ( loaders )
super ( CheckboxInput , self ) . init ( attrs )
def clean ( self , value ) :
raise NotImplementedError ( STR_ )
writer = MigrationWriter ( new migration )
value = None
if app config is None :
raise ContentNotRenderedError ( STR_ STR_ )
return [ value . date ( ) , value . time ( ) . replace ( microsecond = NUM_ ) ]
from django . db . migrations . state import ProjectState
widget = DateTimeInput
c = in t ( text [ NUM_ : ] , NUM_ )
from django . conf import settings
def handle ( self , ** options ) :
def next ( self ) :
@ register . filter ( expects localtime = True , is safe = False )
from django . utils import six
try :
output . append ( self . render option ( selected choices , option value , option label ) )
if default is None :
old setting = context . autoescape
if bits [ in index ] ! = in :
except NameError :
def u ( s ) :
except ValueError :
for ext in pathext :
def decr ( self , key , delta = NUM_ , version = None ) :
option = remaining bits . pop ( NUM_ )
class DateTimeInput ( DateTimeBaseInput ) :
digit = x % len ( to digits )
for i in range ( len ( result ) ) :
return bool ( ret )
to delete . add ( model )
self . content length = None
if USE INOTIFY :
class Iterator ( object ) :
if six . PY3 :
def key to file ( self , key , version = None ) :
in dent = STR_ * tabs
second item = new second item
@ deconstructible
except IOError :
errors = [ ]
digits = " STR_ "
import rlcompleter
factory = config [ STR_ ]
if self . wrapped is empty :
self . container = [ ]
raise StopIteration ( )
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
raise TemplateSyntaxError ( " STR_ " % bits [ NUM_ ] )
statements = sql create ( app config , self . style , connection )
self . username = settings . EMAIL HOST USER if username is None else username
def str ( self ) :
if not hasattr ( e , STR_ ) :
return . join ( words )
return chunk [ : end ]
msg = " STR_ " % ( self . program , errors )
for part in singular :
return dec
def sort dependencies ( app list ) :
args = ( )
return result
if option value is None :
return self
warnings . warn ( " STR_ " " STR_ " . format ( num loopvars , len item ) , RemovedInDjango20Warning )
for ( field name , field value ) in six . iteritems ( d [ " STR_ " ] ) :
if ip str . count ( STR_ ) > NUM_ :
def handle ( self , * args , ** options ) :
key = force str ( key )
upto = start
self . stdout . write ( " STR_ " % tablename )
from email . message import Message
except IndexError :
if value in self . empty values :
except ( IOError , OSError ) :
from django . utils import six , lru cache
return super ( QueryDict , self ) . popitem ( )
def has key ( self , key ) :
from optparse import OptionParser
return False
self . keyOrder . remove ( k )
def make key ( self , key , version = None ) :
from datetime import datetime
getattr ( combined , STR_ + name ) ( getattr ( self , STR_ + name , None ) )
fields = [ ( STR_ , DWORD ) , ( STR_ , DWORD ) ]
return baseconv . base62 . encode ( in t ( time . time ( ) ) )
from django . apps import apps
return self . attrs . get ( STR_ , )
errors . extend ( check boolean field default value ( ** kwargs ) )
if str ( number ) [ NUM_ ] == sign :
os . dup2 ( so . fileno ( ) , sys . stdout . fileno ( ) )
def validate ( self , value ) :
try :
self . set charset ( utf8 charset )
parser = command . create parser ( , name )
def handle raw input ( self , in put data , META , content length , boundary , encoding = None ) :
for bytes in stream :
for app name , model list in manifest . items ( ) :
def checkLevel ( level ) :
name , value = main value pair . split ( STR_ , NUM_ )
queryset = self . model . default manager
cls = extension map . get ( tail ext )
import os
factory = c
def get script name ( environ ) :
def loaddata ( self , fixture labels ) :
def base64 hmac ( salt , value , key ) :
module = importlib . import module ( serializer module )
len = new method proxy ( len )
except Exception as e :
result = " STR_ " . join ( hextets )
if regex is not None :
f . close ( )
if col name . lower ( ) . find ( STR_ ) >= NUM_ :
return supported code
try :
raise CommandError ( " STR_ " % name str )
try :
except ( TypeError , VariableDoesNotExist ) :
truncate = pgettext ( STR_ , STR_ )
if is in stance ( other , Promise ) :
try :
executor = MigrationExecutor ( connections [ DEFAULT DB ALIAS ] )
return value
else :
return None
new mod = name
self . file path = os . path . abspath ( self . file path )
lineno comment map = { }
compare to = [ var . resolve ( context , True ) for var in self . varlist ]
exclude . append ( f . name )
super ( Command , self ) . init ( )
words [ i ] = escape ( word )
return getattr ( self , shell ) ( )
except AttributeError :
def join ( value , arg , autoescape = None ) :
self . parsed = parsed
if j == - NUM_ :
super ( AssignmentNode , self ) . init ( takes context , args , kwargs )
self . pointer = i
self . dict [ " STR_ " ] = value
self . backout . append ( self . pointer )
pass
parser . add argument ( STR_ , help = STR_ )
return host
force unicode = force text
if reason is not None :
return context . render context
localtime = pytz . timezone ( settings . TIME ZONE )
super ( SortedDict , self ) . delitem ( key )
if param not in params and varkw is None :
value = value . astimezone ( timezone )
out . write ( blankout ( part , STR_ ) )
import re
from future import unicode literals
cookiedict [ key ] = c . get ( key ) . value
def init ( self , cyclevars , variable name = None , silent = False ) :
else :
if pathext is None :
for sql in in dex sql :
return pgettext lazy ( self . message context , value )
str number = six . text type ( number )
if data list [ NUM_ ] in self . empty values :
raise TemplateSyntaxError ( " STR_ " % filter name )
def init ( self , func , args , kwargs , url name = None , app name = None , namespaces = None ) :
else :
def run ( addr , port , wsgi handler , ipv6 = False , threading = False ) :
if not self . allow empty file and not file size :
as form = True
return debug . technical 500 response ( request , * exc info )
return result
return True
in put formats = formats . get format lazy ( STR_ )
return msgid
locks . lock ( fd , locks . LOCK EX )
error messages [ STR_ ] = error message
self . template response middleware . in sert ( NUM_ , mw instance . process template response )
lbp = bp
if self . domain == STR_ :
if not value :
from django . utils . module loading import import string
supports microseconds = False
from email . mime . multipart import MIMEMultipart
compare = lambda self , a , b : a > b
elif autoescape :
return sys . modules [ name ] is not None
if self . file permissions mode is not None :
if expires < now :
if not chunk size :
for chunk in field stream :
number equal = len ( [ current number for current number in self . unget history if current number == num bytes ] )
return get internal wsgi application ( )
return self . number > NUM_
context . autoescape = old setting
in ternal use only = False
if error . code == code :
def xreadlines ( self ) :
etags = [ e . encode ( STR_ ) . decode ( STR_ ) for e in etags ]
return curried
from ctypes import ( sizeof , c ulong , c void p , c int64 , Structure , Union , POINTER , windll , byref )
resource string = None
def get default timezone name ( ) :
if lang code not in supported and replacement in supported :
if not email message . recipients ( ) :
from django . utils . six . moves import cPickle as pickle
class InterBoundaryIter ( six . Iterator ) :
if key in dict :
value = str ( STR_ ) % ( value , self . sep , self . timestamp ( ) )
try :
from django . utils . text import normalize newlines
self . field = field
from django . template . context import ( BaseContext , Context , RequestContext , ContextPopException )
self . choice label = force text ( choice [ NUM_ ] )
from django . utils . functional import allow lazy
nodelist = [ ]
if common ancestor is None :
top = self . count
args . append ( parser . compile filter ( value ) )
def copy ( self ) :
class DatabaseCache ( BaseDatabaseCache ) :
if ttl is not None :
self . error ( self . cmd . missing args message )
opts = model . meta
super ( ChoiceField , self ) . validate ( value )
raise
parser = subcommand cls . create parser ( , cwords [ NUM_ ] )
else :
error messages = self . fields [ field ] . error messages
import copy
if timeout is None :
self . open ( )
self . assert mutable ( )
raise TemplateSyntaxError ( " STR_ " " STR_ " % token )
result . choices = copy . deepcopy ( self . choices , memo )
self . name = name
yield widget
def get files ( self ) :
return None
return self . msg % tuple ( force text ( p , errors = STR_ ) for p in self . params )
return mark safe ( formats . number format ( STR_ % ( in t ( d ) ) , NUM_ ) )
elif version [ NUM_ ] ! = STR_ :
values = list ( values )
raise UnrecognizedArchiveFormat ( " STR_ " )
super ( FileField , self ) . init ( * args , ** kwargs )
while True :
return mark safe ( . join ( force text ( n ) for n in nodelist ) )
def widget attrs ( self , widget ) :
return obj dict
chunk buffer = BytesIO ( chunk )
for k , v in self . iteritems ( ) :
def handle file complete ( self , old field name , counters ) :
missing args message = " STR_ "
if STR_ in config :
seen = set ( )
if value is None :
pass
return split
excluded models . add ( model )
elif value in ( False , False , STR_ ) :
out = b . join ( parts ( ) )
self . blocks [ name ] . append ( block )
i += NUM_
token = parser . next token ( )
while True :
return value
self . stdout . write ( " STR_ " % locale )
return value
filemsg =
return self . sign + value
if not installed models :
if self . feed [ STR_ ] is not None :
return plural
import base64
sub = STR_ % git changeset
for migration in migrations to squash :
kwargs = { STR_ : True }
import codecs
opfunc . doc = getattr ( in t , opname ) . doc
@ python 2 unicode compatible
except ImportError :
def do for ( parser , token ) :
else :
if self . verbosity >= NUM_ and sql :
self . timezone = timezone
field = self . fields [ fieldname ]
return self . getlist ( key )
def get script prefix ( ) :
super ( DebugParser , self ) . extend nodelist ( nodelist , node , token )
if text [ NUM_ ] == STR_ :
if self . message context :
self . filepath = filepath
def resolve lookup ( self , context ) :
form . save m2m ( )
kwargs [ STR_ ] = error messages
if len ( in itial ) ! = len ( data ) :
return avoid wrapping ( ugettext ( STR_ ) )
file obj = handler . file complete ( counters [ i ] )
if self . use natural foreign keys and hasattr ( field . rel . to , STR_ ) :
except ValueError :
fixture files in dir = [ ]
buffer types = ( bytearray , memoryview )
else :
return self . paginator . count
def is writable ( path ) :
self . current token = self . next token ( )
from django . utils . datastructures import MultiValueDict , ImmutableList
self . style = color style ( )
return
else :
except TypeError :
if not self . is rendered :
use threading = connection . features . test db allows multiple connections
self . new method name = new method name
with io . open ( fd , STR_ ) as f :
output , hidden fields = [ ] , [ ]
visible issue count = NUM_
iterlists = iterlists
new context = copy ( self )
ret = b . join ( self . vals )
if t . token type == TOKEN BLOCK :
def item attributes ( self , item ) :
msg = " STR_ " % e
fixture dirs = self . fixture dirs
commands = { name : STR_ for name in find commands ( path [ NUM_ ] ) }
if value in ( None , ) :
return
sep = len ( hextet [ NUM_ ] . split ( STR_ ) ) + len ( hextet [ NUM_ ] . split ( STR_ ) )
return combined
def M ( self ) :
class SuspiciousOperation ( Exception ) :
base url += /
param = None
d = { }
def repr ( self ) :
@ content . setter
def get data ( self ) :
if STR_ not in header names :
if self . changed data is None :
if getattr ( e , STR_ , False ) :
if error message is not None :
return do translate ( message , STR_ )
model , deps = model dependencies . pop ( )
pass
renderer = RadioFieldRenderer
for root , dirs , files in sorted ( os . walk ( self . path ) ) :
usage = STR_ % ( subcommand , self . args )
SafeUnicode = SafeText
loopvars = re . split ( r STR_ , . join ( bits [ NUM_ : in index ] ) )
if is in stance ( field value , str ) :
for app config in apps . get app configs ( ) :
else :
self . update errors ( e )
def decompress ( self , value ) :
if not ext and content type :
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
def length is ( value , arg ) :
for key , value in list ( attrs . items ( ) ) :
app template dirs . append ( template dir )
re camel case = re . compile ( r STR_ )
self . execute ( * args , ** cmd options )
raise CommandError ( " STR_ " % ( migration name , app label ) )
self . end serialization ( )
from future import unicode literals
return get supported language variant ( lang code , strict = strict )
in dexes = { }
return re . sub ( " STR_ " , lambda m : m . group ( NUM_ ) . lower ( ) , t )
saved instances . append ( self . save existing ( form , obj , commit = commit ) )
self . encoding = val
if use reloader :
if hidden fields :
return result
return self . connection
class EmptyPage ( InvalidPage ) :
caches = { }
self . config . configurator = self
i = NUM_
line = STR_ % plural form line
result = self . buffer + self . read limited ( )
PB = NUM_ << NUM_
all date checks = all date checks . union ( set ( date checks ) )
if self . data . minute == NUM_ and self . data . hour == NUM_ :
class ConvertingDict ( dict ) :
self . in stance = in stance
return super ( BaseInlineFormSet , self ) . get unique error message ( unique check )
return value . serializable value ( self . to field name )
raise TemplateSyntaxError ( " STR_ " " STR_ " % ( token [ upto : ] , token ) )
return result
return mark safe ( STR_ . join ( [ six . text type ( self . management form ) , forms ] ) )
self . object list = object list
return type ( form . name + str ( STR_ ) , ( formset , ) , attrs )
elif item [ " STR_ " ] :
if not cleaned line :
for error in self . errors . as data ( ) [ field ] :
func = import string ( path )
unhandled params . remove ( param )
obj = field . rel . to . default manager . db manager ( db ) . get by natural key ( * field value )
def generator ( ) :
result . append ( Group ( ( ( " STR_ " % name ) , name ) ) )
kwargs . setdefault ( STR_ , super ( IntegerField , self ) . widget )
expires = row [ NUM_ ]
msg [ STR_ ] = self . extra headers . get ( STR_ , self . from email )
if len ( bits ) < NUM_ :
if match :
m = m + base [ medium ]
self . cache . flush all ( )
raise CommandError ( " STR_ " % app label )
if ( getattr ( meta , STR_ , fields ) is None and getattr ( meta , STR_ , exclude ) is None ) :
key = self . make key ( key , version = version )
def pop ( self , name ) :
obj = Node ( children , connector , negated )
statement . append ( cleaned line )
return lazy number ( ngettext , str , singular = singular , plural = plural , number = number )
self . autocomplete ( )
result . widget = copy . deepcopy ( self . widget , memo )
hour = in t ( m . group ( STR_ ) )
try :
if connection . in trospection . table name converter ( model . meta . db table ) in table names :
for domain in domains :
def call command ( name , * args , ** options ) :
url fields = split url ( value )
return value
def add arguments ( self , parser ) :
return obj pk
self . stdout . write ( STR_ % ( filename , dirpath ) )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : choice } , )
return False
if accept lang == * :
output . in sert ( NUM_ , error row % force text ( top errors ) )
continue
raise TypeError ( " STR_ " )
break
value = value . replace ( b STR_ \ \ STR_ \ \ " STR_ " )
file name = self . IE sanitize ( unescape entities ( file name ) )
match = html parser . endendtag . search ( rawdata , i + NUM_ )
factor -= NUM_
locale = options . get ( STR_ )
@ deconstructible
self . add item elements ( handler , item )
connection = connections [ options [ STR_ ] ]
if not chunk [ : - rollback ] :
class Context ( BaseContext ) :
self . model = getattr ( options , STR_ , None )
return self . name
finder = sys . path importer cache [ entry ]
getattr = new method proxy ( getattr )
def nud ( self , parser ) :
extra classes = set ( extra classes or [ ] )
yield key
error = sys . modules [ name + " STR_ " ]
if self . options :
class ImageFile ( File ) :
app config = apps . get app config ( exclude )
return settings . TEMPLATE STRING IF INVALID % self . var
if len ( parts ) > NUM_ :
def mod ( self , rhs ) :
break
finally :
return " "
return ( RAW , { } , stream )
def eval ( self , context ) :
self . variable name = variable name
except ( ValueError , OverflowError , InvalidOperation ) :
activate ( self . language )
strerror = force text ( e . strerror , DEFAULT LOCALE ENCODING , strings only = True )
app name , target = options . pop ( STR_ ) , options . pop ( STR_ )
pass
def getvalue ( self ) :
if self . count == NUM_ and not self . allow empty first page :
else :
from django . forms . formsets import *
self . activated = True
if self . asvar is None :
lexer = lexer class ( template string , or igin )
if bits [ NUM_ ] ! = and :
key = self . make key ( key , version = version )
stamp = time . mktime ( tt )
if dec part :
view = viewname
def str ( self ) :
def unclosed block tag ( self , parse until ) :
from django . utils import six
if processors is None :
words [ i ] = mark safe ( word )
result = user function ( * args , ** kwds )
def init ( self , attrs = None , date format = None , time format = None ) :
if node . hasAttribute ( STR_ ) :
def unsign ( self , signed value ) :
if new name in used column names :
cache suffix = STR_
self . cache . delete ( key )
cached loaders . append ( find template loader ( loader ) )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ , params = { STR_ : value } , )
bad app labels . add ( app label )
while i < len ( subject ) and subject [ i ] in ( , STR_ ) :
try :
chunk = base64 . b64decode ( chunk )
dec part = decimal sep + dec part
try :
for attr in self . child nodelists :
def call ( self , environ , start response ) :
else :
def init ( self , obj , * args ) :
self . stdout . write ( self . style . NOTICE ( " STR_ " ) )
from django . utils . six . moves . urllib . request import urlretrieve
from django . utils import six
def deepcopy ( self , memo ) :
return self . name
return
def IE sanitize ( self , filename ) :
from django . core . handlers . wsgi import WSGIHandler
DARK PALETTE = STR_
pos inf = NUM_ * NUM_
i = next space index ( subject , i )
else :
self . validate unique ( )
error msg = " STR_ " % tried
self . xml . addQuickElement ( " STR_ " , attrs = { STR_ : smart text ( value . get pk val ( ) ) } )
def repr ( self ) :
daemonize = True
return False
from collections import defaultdict
class MIMEMixin ( ) :
if not getattr ( f , STR_ , False ) :
import itertools
return trans . to locale ( language )
sentinal = bit [ NUM_ ] + STR_
return self . bytes cast ( )
elif is in stance ( message , list ) :
quote = s [ NUM_ ]
def messages ( self ) :
return self . truncate html ( length , truncate , text , truncate len , False )
prec = abs ( p ) + units + NUM_
return ( ret == NUM_ )
if STR_ in addr :
super ( BaseModelFormSet , self ) . init ( ** defaults )
from django . core . exceptions import ValidationError
return final output
raise ValidationError ( ungettext ( " STR_ " , " STR_ " , self . min num ) % self . min num , code = STR_ )
from django . utils . datastructures import MultiValueDict
from future import unicode literals
tag = match . group ( NUM_ ) . strip ( )
from django . utils import six
del bits [ : NUM_ ]
try :
raise CommandError ( message )
class ZipArchive ( BaseArchive ) :
import django
active . value = pytz . timezone ( timezone )
self . in stance = opts . model ( )
return s . getvalue ( )
sio = BytesIO ( self . buffer )
raise NoReverseMatch ( " STR_ " % key )
continue
def to python ( self , value ) :
now = timezone . now ( )
return self . mapping . get ( self . tagtype , )
app . start ( )
from django . utils . deprecation import RemovedInNextVersionWarning
try :
if m is not None and n is not None :
raise MultiPartParserError ( STR_ % content type )
media = property ( get media )
def iterkeys ( self ) :
return Context ( context )
filelist = [ os . path . join ( self . dir , fname ) for fname in glob . glob1 ( self . dir , STR_ % self . cache suffix ) ]
for key , value list in other dict . lists ( ) :
list length = len ( list )
return super ( FileField , self ) . clean ( data )
kwarg = token kwargs ( [ bit ] , parser )
self . META [ STR_ ] = script name
boolean attrs . append ( ( attr , ) )
filter func = parser . find filter ( filter name )
def filter function ( self , func , ** flags ) :
def to language ( self ) :
if is in stance ( field , models . TimeField ) and getattr ( obj , field . name ) is not None :
exc value . cause = exc
from django . utils . six . moves . urllib . parse import urljoin
import datetime
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
return mark safe ( func ( * args , ** kwargs ) )
app models = app config . get models ( in clude auto created = True )
raise CommandError ( " STR_ " % ( self . file , errors ) )
def init ( self , content = b , * args , ** kwargs ) :
self . headers [ header . lower ( ) ] = ( header , value )
def css classes ( self , extra classes = None ) :
if sys . platform . startswith ( STR_ ) :
if fp is None :
return self . s
try :
self . stdout . write ( " STR_ " % ( self . loaded object count , self . fixture object count , self . fixture count ) )
stream . unget ( chunk )
for p in plist :
if args and kwargs :
result = handler . handle raw input ( self . input data , self . meta , self . content length , self . boundary , encoding )
self . connection = None
import re
from django . core . cache . backends . base import BaseCache , DEFAULT TIMEOUT
template = self . resolve template ( self . template name )
else :
def check middleware classes ( app configs = None , ** kwargs ) :
result = ugettext ( msg with ctxt )
self . validate unique = True
help = " STR_ "
self . literal = in t ( self . literal )
result . append ( Group ( ( ( " STR_ " % param ) , None ) ) )
for item in values :
return [ ]
class RemovedInDjango20Warning ( PendingDeprecationWarning ) :
else :
if connection . ops . start transaction sql ( ) :
t = select template ( template name , dirs )
root = [ ]
if self . directory permissions mode is not None :
try :
if last bit :
if version is None :
def unget ( self , bytes ) :
import copy
del self [ key ]
format cache [ cache key ] = val
return b STR_ . join ( headers )
return . join ( pieces )
view name = callback . class . name + STR_
else :
def get templatetags modules ( ) :
if in dexes [ column name ] [ STR_ ] :
value = signing . get cookie signer ( salt = key + salt ) . sign ( value )
curs . execute ( " STR_ " . join ( full statement ) )
if urlconf is None :
return False
return field . rel . to . default manager . db manager ( db ) . get by natural key ( * value ) . pk
template dir = os . path . join ( app config . path , STR_ )
klass . prefix = STR_ + find indentation ( node )
@ register . filter ( is safe = False )
if field node . getElementsByTagName ( None ) :
raise ValueError ( " STR_ " % value )
def cache clear ( ) :
def compile filter error ( self , token , e ) :
def deleted forms ( self ) :
end = s . find ( b STR_ )
command . stdout . write ( errors )
def wrap ( text , width ) :
else :
raise AppRegistryNotReady ( " STR_ " " STR_ " " STR_ " )
form . meta . fields . append ( self . fk . name )
return self . cache . decr ( key , - delta )
if is compressed :
import importlib
connection = connections [ db ]
def rjust ( value , arg ) :
self . can write . release ( )
for i , arg in enumerate ( args ) :
except StopUpload as e :
if buffer is not None :
def get size from underlying file ( self ) :
raise BadHeaderError ( " STR_ " % value )
pass
if value is True :
regex match = language code prefix re . match ( path )
if data :
return self . choice value in self . value
Field . creation counter += NUM_
if self . options . get ( " STR_ " ) :
models = STR_
seen models = connection . in trospection . in stalled models ( tables )
collect . extend ( settings . TEMPLATE CONTEXT PROCESSORS )
def init ( self , text , subtype , charset ) :
name = self . split leading dir ( name ) [ NUM_ ]
httpd cls = type ( str ( STR_ ) , ( socketserver . ThreadingMixIn , WSGIServer ) , { } )
self . current [ field . name ] = str ( getattr ( obj , field . name ) )
key = make key ( args , kwds , typed ) if kwds or typed else args
from django . core . mail . utils import DNS NAME
@ deconstructible
def handle ( self , * args , ** options ) :
cursor . execute ( " STR_ " " STR_ " % table , [ key , connections [ db ] . ops . value to db datetime ( now ) ] )
self . template string = template string
try :
def add arguments ( self , parser ) :
hextets += [ ]
if params . get ( STR_ ) :
data = bool ( data )
else :
class SuspiciousMultipartForm ( SuspiciousOperation ) :
categories = [ ( c ) for c in categories ]
cache timeout = settings . CACHE MIDDLEWARE SECONDS
key = self . make key ( key , version = version )
data = data ( )
args = token . split contents ( )
if server port ! = ( STR_ if self . is secure ( ) else STR_ ) :
self . coerce = kwargs . pop ( STR_ , lambda val : val )
if params [ NUM_ ] == STR_ :
plan = [ ( executor . loader . graph . nodes [ targets [ NUM_ ] ] , options [ STR_ ] ) ]
from future import unicode literals
def add root elements ( self , handler ) :
if not hasattr ( self , STR_ ) :
return
if ( is in stance ( data , ( datetime . datetime , datetime . time ) ) and not getattr ( self . field . widget , STR_ , True ) ) :
except KeyboardInterrupt :
except VariableDoesNotExist :
except IndexError :
def get num pages ( self ) :
del self . expire info [ key ]
self . sysid = sysid
def readline ( self , size = None ) :
except ( ValueError , TypeError ) :
yield STR_
form . save m2m = save m2m
try :
except TypeError :
continue
conflicts = executor . loader . detect conflicts ( )
def reader ( self ) :
ext = mimetypes . guess extension ( content type )
if sizeof ( c ulong ) ! = sizeof ( c void p ) :
if lookup == STR_ :
return plural suffix
def has key ( self , key , version = None ) :
app = model . meta . app label
def deactivate all ( ) :
else :
class Command ( AppCommand ) :
if register to :
return mark safe ( STR_ . join ( output ) )
return field . widget . value from datadict ( self . data , self . files , prefix )
from django . apps import apps
other dict = args [ NUM_ ]
dot re = re . compile ( r STR_ )
@ register . filter ( is safe = True )
if self . read started :
content type = content type . strip ( )
global template source loaders
def exit ( self , exc type , exc value , traceback ) :
return " "
def write ( self , outfile , encoding ) :
cursor . execute ( " STR_ " % table , [ connections [ db ] . ops . value to db datetime ( now ) ] )
if is in stance ( context , Context ) :
def setdefault ( self , key , default = None ) :
if key prefix is None :
if size :
return ( NUM_ , k [ NUM_ ] )
self . msg = msg
daemon kwargs = { }
out . write ( STR_ % ( message context , join tokens ( singular , trimmed ) ) )
def add arguments ( self , parser ) :
fixture name = os . path . basename ( fixture name )
self . buffer = sio . read ( )
return in itial
def render options ( self , choices , selected choices ) :
self . connector = connector or self . default
except :
def ngettext ( singular , plural , number ) :
if not os . path . is dir ( basedir ) :
exhaust ( field stream )
code = STR_
number = self . validate number ( number )
def o ( self ) :
self . stdout . flush ( )
for model in model list :
return http . parse cookie ( raw cookie )
ERROR = NUM_
if not ( self . data or self . files ) :
return curried func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
m = base
super set = super ( SortedDict , self ) . setitem
attrs . update ( extra attrs )
return STR_ % self
words = words [ : length ]
if value is None :
if value in self . empty values :
@ register . tag
return Media ( ** { str ( name ) : getattr ( self , STR_ + name ) } )
self . stdout . write ( errors )
return fastcgi help ( " STR_ " " STR_ " )
def hash ( self ) :
if not allow overwrite and os . access ( new file name , os . F OK ) :
active . value = timezone
if options . get ( " STR_ " , False ) :
return base64 . urlsafe b64encode ( s ) . strip ( b = )
def getinitargs ( self ) :
base = base [ : - NUM_ ]
def value from datadict ( self , data , files , name ) :
def utcoffset ( self , dt ) :
readinto = property ( lambda self : self . file . readinto )
class HttpResponseRedirect ( HttpResponseRedirectBase ) :
if not priority :
if not hasattr ( self , STR_ ) :
pass
@ register . filter ( is safe = True )
super ( TemplateIfParser , self ) . init ( * args , ** kwargs )
temp lib . filters [ name ] = lib . filters [ name ]
if len ( bits ) >= NUM_ and bits [ - NUM_ ] == as :
content = content . message ( )
if self . isdst ( dt ) :
else :
if self . stream is not None :
if p == NUM_ :
continue
for hextet in new ip :
raise
if queryset is None :
data = { }
loader = find template loader ( loader name )
class DisallowedHost ( SuspiciousOperation ) :
if self . first :
return date format ( value , use l10n = use l10n )
from django . utils import termcolors
except IOError as e :
while model dependencies :
return
except ImportError as e :
if six . PY2 and not is in stance ( path , six . text type ) :
except ImportError :
def setattr ( self , name , value ) :
class name = base . name
except NotImplementedError :
import re
if size is None or size > self . remaining :
result |= x ^ y
pass
TemplateLoader = import string ( loader )
for node in compiled parent . nodelist :
return obj
tc = http cookies . SimpleCookie ( )
@ property
except ImportError as e :
while s [ : NUM_ ] == b STR_ :
continue
from django . conf import settings
def add arguments ( self , parser ) :
if not hasattr ( func , STR_ ) :
return False
super ( DTDForbidden , self ) . init ( )
except DatabaseError :
hidden widget = MultipleHiddenInput
def delete many ( self , keys , version = None ) :
return attrs
for f in post sql fields :
else :
in sert = complain
from pkg resources import resource string
except StandardError as e :
self . xml . addQuickElement ( " None " )
@ stringfilter
format modules cache = { }
RemovedInNextVersionWarning = RemovedInDjango19Warning
name = self . html initial name
class Loader ( BaseLoader ) :
return format html ( STR_ , flatatt ( final attrs ) , force text ( value ) )
if self . max length is not None :
return self . cleaned data
common ancestor = None
except ( ssl . SSLError , smtplib . SMTPServerDisconnected ) :
creation counter = NUM_
def dictConfig ( config ) :
from django . conf import settings
raise StopFutureHandlers ( )
def init ( self , digits , sign = - ) :
def construct instance ( form , in stance , fields = None , exclude = None ) :
raise ValueError ( " STR_ " )
from future import unicode literals
all locales = map ( os . path . basename , locale dirs )
else :
parser . add argument ( STR_ , nargs = STR_ , help = STR_ )
self . delete ( fname )
class OFFSET UNION ( Union ) :
@ HttpResponse . content . setter
def clean ( self ) :
name = self . html name
elif args [ NUM_ ] [ NUM_ ] == STR_ :
def h ( self ) :
try :
return in stance
ZERO = timedelta ( NUM_ )
result . parent = self
return klass ( fail silently = fail silently , ** kwds )
from django . core . management . sql import sql create
super ( TemporaryUploadedFile , self ) . init ( file , name , content type , size , charset , content type extra )
finally :
try :
if is in stance ( elt , NonCapture ) :
def clear ( self ) :
regex = force text ( self . regex )
headerlist . sort ( )
else :
migration = loader . get migration ( app label , migration name )
self . remaining = limit
missing args message = " STR_ "
if not field desc . endswith ( STR_ ) :
return language . lower ( )
tc . load ( str ( STR_ ) )
else :
def get cache ( backend , ** kwargs ) :
import zlib
return False
filenames = [ ]
except GeneratorExit :
all = [ STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , ]
signals . request finished . connect ( close caches )
else :
except ValidationError as e :
iteritems = " STR_ "
if six . PY2 :
while remaining ! = NUM_ :
values = itervalues
except VariableDoesNotExist :
else :
raise CommandError ( " STR_ " )
usage . append ( style . NOTICE ( " STR_ " % app ) )
else :
for formset in formsets :
daemonize = ( wsgi opts [ STR_ ] is not None )
app output = self . handle app config ( app config , ** options )
for character in name :
cache get = cache . get
except ImportError as e :
self . post , self . files = self . parse file upload ( self . META , data )
raise ValueError ( STR_ )
return six . text type ( s ) . encode ( encoding )
self . stream = stream or string
elif cwords [ NUM_ ] in ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ) :
file . close ( )
self . choices = [ ( " " , " STR_ " ) ]
def mark for escaping ( s ) :
cache = caches [ settings . CACHE MIDDLEWARE ALIAS ]
app label , model label = label . split ( STR_ )
while STR_ % ( new name , num ) in used column names :
if not is in stance ( cookie , http cookies . BaseCookie ) :
kw [ STR_ ] = tzinfo
else :
off = NUM_ * ( delta // NUM_ + delta // NUM_ )
class Command ( BaseCommand ) :
self . start relational field ( field )
from django . core . serializers . python import Deserializer as PythonDeserializer
start = match . start ( )
candidate subs = text kwargs
except StandardError as e :
if errors :
for x in argset :
return match . group ( NUM_ )
except ( ValueError , self . queryset . model . DoesNotExist ) :
else :
class OrderedSet ( object ) :
import signal
return ugettext ( " STR_ " ) % { " STR_ " : unique check [ NUM_ ] , }
db module = STR_
def get timezone name ( timezone ) :
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc info ( ) [ NUM_ ] )
if self . parent name . filters or is in stance ( self . parent name . var , Variable ) :
secret = settings . SECRET KEY
value = signing . get cookie signer ( salt = key + salt ) . unsign ( cookie value , max age = max age )
if / in path and ( ( STR_ / STR_ \ \ STR_ \ \ not in path ) :
raise NotImplementedError ( STR_ )
self . waiting writers += NUM_
if value in self . empty values :
NamedTemporaryFile = TemporaryFile
for closable in self . closable objects :
elif len ( fks to parent ) == NUM_ :
form . data [ form . add prefix ( self . pk field . name ) ] = None
output = self . filter expression . resolve ( context )
description = " STR_ " % receiver . name
t = getattr ( active , " STR_ " , None )
ch , escaped = next ( pattern iter )
try :
callback , callback args , callback kwargs = resolver match
@ register . tag
msg += STR_ % ( group name , formatted )
key = self . make key ( key , version = version )
return do ntranslate ( singular , plural , number , STR_ )
if has bom ( po path ) :
else :
chunk = self . read limited ( )
if to lower :
del attr
return msg
return None
class QueryDict ( MultiValueDict ) :
for app label , app migrations in changes . items ( ) :
func = TemplateLoader ( * args )
import re
msgs , errors , status = popen wrapper ( args )
return new class
from django . utils . deprecation import RemovedInDjango19Warning
class Paginator ( object ) :
def render ( self , name , value , attrs = None ) :
return self . tag function
for is sues , group name in sorted issues :
if os . path . is dir ( os . path . join ( STR_ , STR_ ) ) :
def normalize ( pattern ) :
for i , choice in enumerate ( self . choices ) :
class NonCapture ( list ) :
if " STR_ " not in str ( te ) :
option list = ( )
@ stringfilter
class HttpResponseGone ( HttpResponse ) :
from django . db import connections , DEFAULT DB ALIAS
from django . utils . deprecation import RemovedInDjango19Warning
if in put formats is not None :
if primary keys :
def replace entity ( match ) :
raise TemplateSyntaxError ( " STR_ " % ( taglib , e ) )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
raise ValueError ( " STR_ " )
def rfc2822 date ( date ) :
except AttributeError :
return exit code
class InlineForeignKeyField ( Field ) :
else :
name = self . pk field . name
self . xml . startElement ( " STR_ " , { " STR_ " : " STR_ " } )
from django . utils . encoding import force str
def render ( self , context ) :
bits = token . split contents ( ) [ NUM_ : ]
from django . conf import settings
if cnt and not cnt % grouping :
self . stdout . write ( " STR_ " " STR_ " % ( app or project , STR_ . join ( extra files ) ) )
return bool ( in itial ) ! = bool ( data )
def bin to long ( x ) :
elif command . verbosity > NUM_ :
else :
for name in sorted ( handlers ) :
if not data :
raise ValidationError ( errors )
from django . utils . encoding import python 2 unicode compatible
def write ( self , content ) :
return False
return chunk
elif field . rel and is in stance ( field . rel , models . ManyToOneRel ) :
raise ValueError ( STR_ STR_ % ( name , e ) )
message = message % ( STR_ . join ( missing fields ) , opts . model . name )
def add arguments ( self , parser ) :
self . regexes = { }
except ImportError as e :
class DateTimeBaseInput ( TextInput ) :
except TypeError :
if not model . meta . proxy and router . allow migrate ( using , model ) :
return
pass
pass
return statements
return kwargs
for func , unused in filter expr . filters :
if self . is reversed :
if ( self . validate min and self . total form count ( ) - len ( self . deleted forms ) < self . min num ) :
pass
def setitem ( self , key , value ) :
self . urlconf module = self . urlconf name
Signer = import string ( settings . SIGNING BACKEND )
super ( TypedChoiceField , self ) . init ( * args , ** kwargs )
return lazy ( func , * resultclasses ) ( * args , ** kwargs )
if filename not in error files :
for node in self . nodelist loop :
width = property ( get width )
@ deconstructible
if self . fname is None :
length = in t ( arg )
class CommandError ( Exception ) :
commands dict [ app ] . append ( name )
from django . utils . encoding import force text , smart text
return ExtendsNode ( nodelist , parent name )
class SimplerXMLGenerator ( XMLGenerator ) :
def validate ipv6 address ( value ) :
if label suffix and contents and contents [ - NUM_ ] not in ( STR_ ) :
from future import unicode literals
def path ( self , name ) :
for model in router . get migratable models ( app config , connection . alias , in clude auto created = True ) :
if self . pk field :
self . regex dict [ language code ] = regex compiled
return field dict
RFC1123 DATE = re . compile ( r STR_ % ( D , M , Y , T ) )
else :
def execute ( self , * args , ** options ) :
HTMLParser . init ( self )
if is in stance ( value , six . text type ) :
class JsonResponse ( HttpResponse ) :
key = self . make key ( key , version = version )
except ImportError :
DOT PATTERN = re . compile ( r STR_ )
try :
def total form count ( self ) :
seen data . add ( data )
def dec ( func ) :
settings . configure ( USE I18N = True )
silent = False
else :
self . expire info . clear ( )
bits = token . split contents ( )
else :
def handle data ( self , d ) :
load serializers ( )
Iterator = object
def extra forms ( self ) :
return mark safe ( STR_ . join ( [ six . text type ( self . management form ) , forms ] ) )
return value
if not is in stance ( node , ExtendsNode ) :
priority = NUM_
if DEFAULT CACHE ALIAS not in settings . CACHES :
file . close ( )
return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
return self . DSTDIFF
if format not in serializers :
try :
self . stream . close ( )
def init ( self , regex ) :
raise SyntaxError ( " STR_ " % ( t . contents , filemsg , t . lineno ) )
return STR_
checks = self . registered checks
over bytes = len ( chunk ) % NUM_
if errors :
with self . lock . writer ( ) :
def has changed ( self , in itial , data ) :
return self . headers . values ( )
elif is subclass ( klass , logging . handlers . SysLogHandler ) and STR_ in config :
top = bottom + self . per page
super ( WSGIServer , self ) . server bind ( )
stats [ MISSES ] += NUM_
location = params . pop ( STR_ , )
def should delete form ( self , form ) :
from django . utils . formats import localize
unique id = item [ STR_ ]
self . container = [ value ]
self . meta = META
proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )
timetuple = dt . timetuple ( )
c = cookie
break
from django . core . management . base import CommandError
self . expire info = expire info . setdefault ( name , { } )
def regex ( self ) :
if errors :
for ip in ( self . ipython , self . ipython pre 100 , self . ipython pre 011 ) :
if hasattr ( response , STR_ ) and callable ( response . render ) :
msgs = self . copy plural forms ( msgs , locale )
template = get template ( template )
if self . require all fields :
else :
kwargs = { STR_ : getattr ( form . fields . get ( name ) , STR_ , capfirst ( self . fk . verbose name ) ) }
def clear checkbox id ( self , name ) :
def strptime ( self , value , format ) :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
elif \\' in path :
return self . errors . get ( NON FIELD ERRORS , self . error class ( error class = STR_ ) )
finally :
if kw [ STR_ ] :
qs = self . model . default manager . get queryset ( )
from django . dispatch import Signal
for site in sites1 :
if finder is None :
except zlib . error as e :
s = subject [ p : i ]
self . default locale path = self . locale paths [ NUM_ ]
return self
lookups = MultiValueDict ( )
file . write ( chunk )
except DecimalException :
self . fname = os . path . join ( self . file path , fname )
existing = list ( root . manager . loggerDict )
app template dirs = [ ]
self . validate name ( project name , " STR_ " )
except ImportError :
for name , field in self . fields . items ( ) :
self . xml . characters ( smart text ( key value ) )
parser . namedCycleNodes = { }
raise KeyError ( " STR_ " % ( lang code , generic lang code ) )
e . django template source = source
raise KeyError ( " STR_ " % ( name , self . class . name ) )
import datetime
if error messages and f . name in error messages :
self [ STR_ ] = iri to uri ( redirect to )
elif is in stance ( o , datetime . date ) :
pk value = None
all = [ STR_ ]
else :
if is in stance ( widget , NumberInput ) :
dirs = [ basedir ]
import warnings
final attrs = self . build attrs ( attrs )
nodelist = parser . parse ( ( STR_ , ) )
if app config . models module is None :
self . dicts = [ builtins ]
def setdefault ( self , key , default ) :
for module to search in args :
for result , params in possibility :
if filename . endswith ( extensions ) or filename in extra files :
return date ( d . year , d . month , d . day )
class NowNode ( Node ) :
return self . dimensions cache
exec ( " " " STR_ " " " )
except OSError :
if form . meta . widgets :
from django . utils . module loading import module has submodule
raise TypeError ( " STR_ " )
singular = [ ]
self . regex dict = { }
statements = [ ]
return " STR_ " % ( self . name , self . nodelist )
choices = list ( six . iteritems ( self . months ) )
class NullBooleanField ( BooleanField ) :
else :
return entity re . sub ( replace entity , text )
import django . core . checks . model checks
else :
return field type , field params , field notes
if len ( bits ) < NUM_ or bits [ NUM_ ] ! = as :
try :
if not bytes :
if self . isdst ( dt ) :
elif args [ NUM_ ] == STR_ :
itervalues = itervalues
handler . addQuickElement ( STR_ , rfc3339 date ( item [ STR_ ] ) )
output transaction = True
def truncatewords html ( value , arg ) :
if run syncdb and executor . loader . unmigrated apps :
if is in stance ( context , Context ) :
def is multipart ( self ) :
if self . cc :
if len ( self . dicts ) == NUM_ :
cursor = None
self . connection . close ( )
self . file path = kwargs . pop ( STR_ )
if len ( tablenames ) :
if not os . access ( filename , os . W OK ) :
except Exception :
self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
def init ( self , * args , ** kwargs ) :
factor += NUM_
self . json kwargs . pop ( STR_ , None )
yield buf . read ( )
help = " STR_ "
import time
def new file ( self , file name , * args , ** kwargs ) :
INITIAL FORM COUNT = STR_
transfer encoding = transfer encoding [ NUM_ ] . strip ( )
def do filter ( parser , token ) :
def init ( self , * args , ** kwargs ) :
value = ugettext ( " STR_ " ) % filesize number format ( bytes / TB )
factor = NUM_
value = in t ( s , NUM_ )
pass
import warnings
elif self . nodelist false :
@ property
msg count = NUM_
if six . PY3 :
elif STR_ not in middle and simple email re . match ( middle ) :
if item [ STR_ ] is not None :
if token string . find ( TRANSLATOR COMMENT MARK ) :
return self . in cr ( key , - delta , version = version )
t = Template ( output , name = filepath )
def helper ( list , tabs = NUM_ ) :
return exclude
m = self . CONVERT PATTERN . match ( value )
biggest number = max ( [ x for x in numbers if x is not None ] )
else :
return
else :
self . ending = ending
self . META = environ
from ctypes . wintypes import BOOL , DWORD , HANDLE
raise CommandError ( " STR_ " " STR_ " % ( . join ( parts [ : - NUM_ ] ) , parts [ - NUM_ ] ) )
token name = TOKEN MAPPING [ self . token type ]
def delete ( self , key , version = None ) :
else :
sql . extend ( connection . creation . sql for pending references ( refto , no style ( ) , pending references ) )
ext list [ i ] = STR_ % ext list [ i ]
self . msguniq options = self . msguniq options [ : ] + [ STR_ ]
return translation
try :
in plural = True
st = os . stat ( src )
dfmt = config . get ( STR_ , None )
if template is None :
attrs [ STR_ ] = self . min value
if to :
except http cookies . CookieError :
try :
@ register . filter ( is safe = True )
class GenericIPAddressField ( CharField ) :
if six . PY3 :
raise ValidationError ( self . message , code = self . code )
def itervalues ( d , ** kw ) :
try :
return False
is relation = i in relations
from django import http
if hasattr ( value , STR_ ) and not is in stance ( value , six . text type ) :
return iter ( self . forms )
if self . asvar is None :
raise self . error ( None , " STR_ " % STR_ . join ( parse until ) )
parser . add library ( temp lib )
if self . feed [ STR_ ] is not None :
return cache key
return major
sequence = parser . compile filter ( bits [ in index + NUM_ ] )
yield v
try :
for lib in builtins :
args , varargs , varkw , defaults = getargspec ( func )
self . auto id = auto id
for message in email messages :
s = s [ end : ]
translation . activate ( saved locale )
from django . utils . encoding import force text
dot = callback . rindex ( STR_ )
if neg :
if self . verbosity > NUM_ :
def resolve ( self ) :
def init ( self , stream , boundary ) :
if hasattr ( self , STR_ ) :
return mark safe ( urlize ( value , nofollow = True , autoescape = autoescape ) )
return result
def reverse ( self , lookup view , * args , ** kwargs ) :
if not self . timezone :
if self . options . get ( STR_ , None ) is not None :
if self . feed [ STR_ ] is not None :
auto id = self . form . auto id
from future import unicode literals
cleaned = self . clean ( value )
if data in ( None , FILE INPUT CONTRADICTION ) :
def init ( self , name , old , new = None ) :
else :
for smigration in migrations to squash :
from IPython . frontend . terminal . ipapp import TerminalIPythonApp
return parser . parse ( )
import django
@ classmethod
if value [ NUM_ ] in self . empty values and value [ NUM_ ] in self . empty values :
readline . parse and bind ( " STR_ " )
self . prepend token ( token )
global supported
else :
self . locale dir = locale dir
handler . addQuickElement ( " STR_ " , unique id )
value = { True : STR_ , False : STR_ , STR_ : STR_ , STR_ : STR_ } [ value ]
def timeuntil ( d , now = None ) :
check for migrations ( app config , connection )
def tell ( self ) :
def clear script prefix ( ) :
parser . add argument ( STR_ , action = STR_ , version = self . get version ( ) )
return translated
for char in key :
return response
dict . setitem ( self , key , M )
self . use ssl = settings . EMAIL USE SSL if use ssl is None else use ssl
self . port = DEFAULT PORT
in itial = False
return localtime
in put type = STR_
if not is in stance ( in dex , ( slice , ) + six . in teger types ) :
if not self . css . get ( medium ) or path not in self . css [ medium ] :
def init ( self , mode = STR_ , bufsize = - NUM_ , suffix = , prefix = , dir = None ) :
from django . forms . fields import IntegerField , BooleanField
defaults , = parser . parse args ( args = [ ] )
yield obj
open tags . in sert ( NUM_ , tagname )
DEBUG = NUM_
@ contextlib . contextmanager
except ( ImportError , AttributeError ) :
else :
raise TemplateSyntaxError ( " STR_ " " STR_ " % ( token [ : upto ] , token [ upto : start ] , token [ start : ] ) )
try :
dirname = os . path . dirname ( filename )
for subwidget in self . field . widget . subwidgets ( self . html name , self . value ( ) , attrs ) :
def handle app config ( self , app config , ** options ) :
if key not in default settings :
def strip entities ( value ) :
import codecs
self . cleaned data [ name ] = value
pass
return format ( value , arg )
warnings . warn ( STR_ STR_ % ( key , MEMCACHE MAX KEY LENGTH ) , CacheKeyWarning )
file , , = imp . find module ( module name , [ entry ] )
scheme , netloc , path , query , fragment = urlsplit ( url )
result = self . buffer [ : size ]
self . json kwargs = self . options . copy ( )
raise MultiValueDictKeyError ( repr ( key ) )
month field = STR_
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
meta = ( pformat ( META override ) if META override is not None else pformat ( request . META ) )
field params . update ( new params )
sign , digits , exponent = d . quantize ( exp , ROUND HALF UP , Context ( prec = prec ) ) . as tuple ( )
return { STR_ : settings . MEDIA URL }
for format in self . in put formats :
return result
return model list
class NoReverseMatch ( Exception ) :
else :
message = message . error list
if is in stance ( widget , NumberInput ) and STR_ not in widget . attrs :
media = media + w . media
directory = os . path . dirname ( full path )
class DefusedXmlException ( ValueError ) :
self . address family = socket . AF INET6
data = self . archive . read ( name )
return do ifequal ( parser , token , False )
try :
class proxy ( Promise ) :
for k , v in ret . items ( ) :
for key , value in six . iteritems ( kwargs ) :
for i , word in enumerate ( words ) :
match = tagfind . match ( rawdata , i + NUM_ )
self . non form errors = self . error class ( e . error list )
for node in nodelist :
if not supports color ( ) :
return b . join ( T ) + F ( l ) [ : r ]
elif common prefix is None :
format locations . append ( path + STR_ )
def render ( self , name , value , attrs = None ) :
if hasattr ( urlconfs , " STR_ " ) :
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
migration . branch = migration . ancestry [ ( migration . ancestry . in dex ( common ancestor ) + NUM_ ) : ]
except ( TypeError , VariableDoesNotExist ) :
import warnings
self . first = left
def reloader thread ( ) :
for message in email messages :
return ( self . field . prepare value ( obj ) , self . field . label from instance ( obj ) )
class SingleZipReader ( zipfile . ZipFile ) :
from copy import copy
if language in DJANGO DEPRECATED LOCALES :
return self . show migration list ( connection , [ options [ STR_ ] ] if options [ STR_ ] else None )
if ext :
base name = STR_ % app or project
text = unicodedata . normalize ( STR_ , self . wrapped )
try :
result args = [ [ ] ]
thefile = STR_ % self . file
for node in graph . leaf nodes ( app name ) :
nodes . extend ( nodelist . get nodes by type ( nodetype ) )
return
result . append ( ( lang , priority ) )
config [ STR_ ] = factory
dec . name = STR_ % decorator . name
self . msgattrib options = self . msgattrib options [ : ] + [ STR_ ]
if name == " STR_ " :
value = flags [ attr ]
return STR_ % ( self . path , ( STR_ + iri to uri ( self . META . get ( STR_ , ) ) ) if self . META . get ( STR_ , ) else )
db = router . db for write ( self . cache model class )
def open ( self , name , mode = STR_ ) :
format = color settings . get ( role , { } )
attachment = self . create mime attachment ( content , mimetype )
def do if ( parser , token ) :
self . stdout . write ( " STR_ " )
if output :
return self . forms [ : self . in itial form count ( ) ]
def ssi ( parser , token ) :
context extras [ STR_ ] = connection . queries
return self . field . widget . value from datadict ( self . form . data , self . form . files , self . html name )
data [ field . name ] = field . to python ( field value )
result = self . class ( , mutable = True , encoding = self . encoding )
self . configure root ( root , True )
month = MONTHS . in dex ( m . group ( STR_ ) . lower ( ) ) + NUM_
args = [ STR_ % arg for arg in args ]
bit = next ( bits )
chunks . append ( bytes )
import zlib
from django . template . base import TemplateDoesNotExist
class TemplateSyntaxError ( Exception ) :
if header end == - NUM_ :
return output [ : : - NUM_ ]
def escapejs ( value ) :
from django . utils . safestring import mark safe
cls . dispatch [ resultclass ] = { }
token = Token ( TOKEN VAR , token string [ NUM_ : - NUM_ ] . strip ( ) )
try :
if hasattr ( field . rel . to . default manager , STR_ ) :
cursor . execute ( " STR_ " " STR_ " % table , [ cursor . fetchone ( ) [ NUM_ ] ] )
data [ field . attname ] = field . rel . to . meta . get field ( field . rel . field name ) . to python ( field value )
self . setting , self . nodelist = setting , nodelist
raise TemplateSyntaxError ( " STR_ " " STR_ " )
def init ( self , offset = None , name = None ) :
if os . path . exists ( sql file ) :
data = self . flo . read ( self . chunk size )
else :
raise RuntimeError ( " STR_ " " STR_ " " STR_ " )
handler . endElement ( " STR_ " )
if os . path . exists ( old app dir ) :
return trans . gettext noop ( message )
import traceback
def initialize handlers ( self ) :
class Command ( BaseCommand ) :
except Exception as e :
msg = " STR_ " % host
if value is None and attr in declared fields :
self . validate key ( key )
return cls . new ( cls , * args )
errors = getattr ( fp , " STR_ " , None )
self . use natural foreign keys = options . pop ( STR_ , False ) or self . use natural keys
return False
def setlistdefault ( self , key , default list = None ) :
self . waiting writers -= NUM_
return
setslice = complain
def byte2int ( bs ) :
app configs = None
if tried :
return formats . time format ( value , arg )
if not app config . path :
def popen wrapper ( args , os err exc type = CommandError ) :
return value
self . post = post
arg = settings . DATE FORMAT
return " STR_ " % ( self . id , self . value )
self . lineno = None
return list ( serializers )
if arg . startswith ( option ) :
self . cdata tag = None
msg = ( " STR_ " " STR_ " )
itervalues = itervalues
return datetime ( * kw )
tzinfo = kw . pop ( STR_ )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
if hasattr ( f , STR_ ) and callable ( f . seek ) :
if dirname and not os . path . exists ( dirname ) :
url = reverse ( project name + STR_ + view name , args = args , kwargs = kwargs , current app = context . current app )
num = cursor . fetchone ( ) [ NUM_ ]
def encoding ( self ) :
field = field . rel . get related field ( )
if self . number == self . paginator . num pages :
Module six moves urllib error . moved attributes = urllib error moved attributes
from django . utils import six
output . append ( STR_ . join ( STR_ % e for e in errors ) )
else :
if host [ - NUM_ ] == STR_ :
field type = STR_
self . producer = [ ]
from django . utils . encoding import python 2 unicode compatible , force str
def enter ( self ) :
password += b STR_ * ( in ner . block size - len ( password ) )
def coerce ( self , value ) :
if value in self . empty values and self . required :
self . populate ( )
pass
out . write ( blankout ( t . contents , STR_ ) )
parts = viewname . split ( STR_ )
if value :
import base64
if options . get ( STR_ ) :
import calendar
filepath = parser . compile filter ( bits [ NUM_ ] )
from django . utils . os import upath
self . var = var
if self . merge and conflicts :
return data . getlist ( name )
return delattr ( caches [ DEFAULT CACHE ALIAS ] , name )
from datetime import datetime , timedelta , tzinfo
return resolved args , resolved kwargs
if module has submodule ( app config . module , module to search ) :
import warnings
self . write po file ( potfile , locale )
output = [ ]
return FilterExpression ( token , self )
def create attachment ( self , filename , content , mimetype = None ) :
return
for option in options :
if sign :
def init ( self , * dicts ) :
cleaned data = self . clean ( )
for tablename in tablenames :
thread . start new thread ( main func , args )
if self . verbatim and block content == self . verbatim :
from future import unicode literals
if not ( value is True or value is False or value is None or value == ) :
if is aware ( date ) :
return self . offset
def compile filter error ( self , token , e ) :
from django . utils import six
from django . core . management . base import AppCommand
if field type == STR_ :
pass
raise CommandError ( " STR_ " " STR_ " " STR_ " % ( self . leave locale alone , self . can import settings ) )
for subnode in node :
if o . microsecond :
seconds2 , name2 = chunks [ i + NUM_ ]
self . xml . ignorableWhitespace ( STR_ + * self . options . get ( STR_ , None ) * level )
def send ( self , fail silently = False ) :
def write message ( self , message ) :
cls . dispatch [ klass ] = { }
output =
if self . choices :
else :
if self . localize :
self . field name = field name
app list = OrderedDict ( ( app config , None ) for app config in apps . get app configs ( ) if app config . models module is not None and app config not in excluded apps )
name = match . lastgroup
level = handler config . get ( STR_ , None )
def init ( self , max value = None , min value = None , * args , ** kwargs ) :
elif size < len ( self . buffer ) :
form . fields [ ORDERING FIELD NAME ] = IntegerField ( label = ( STR_ ) , in itial = in dex + NUM_ , required = False )
continue
elif token . token type == NUM_ :
def getattr ( self , real name ) :
if not callable ( view func ) :
if not host validation re . match ( host ) :
buffer = line
return [ ] , [ [ ] ]
try :
pass
self . filters = { }
else :
return cursor . fetchone ( ) is not None
def handle ( self , * args , ** options ) :
package path = package . path
elif is in stance ( o , datetime . time ) :
else :
self . fixture object count = NUM_
except signing . BadSignature :
from django . utils import six
if django . VERSION [ - NUM_ ] ! = STR_ :
output = [ ]
except PermissionDenied :
return generate cache key ( request , method , headerlist , key prefix )
so = open ( out log , STR_ , buffering )
return calendar . timegm ( result . utctimetuple ( ) )
from django . dispatch import receiver
return None
def delete ( self , name ) :
class Loader ( BaseLoader ) :
parser . add argument ( STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
digits = len ( digittuple )
if terminal char ! = STR_ :
except http . Http404 as e :
return bound func ( * args , ** kwargs )
@ deconstructible
template with initial = STR_
@ property
questioner = InteractiveMigrationQuestioner ( )
meta = STR_
try :
from django . utils . translation import TranslatorCommentWarning , trim whitespace , LANGUAGE SESSION KEY
exclude = form . get validation exclusions ( )
singular suffix , plural suffix = bits [ : NUM_ ]
if migration . replaces :
self . db = options . pop ( STR_ , DEFAULT DB ALIAS )
def getitem ( self , key ) :
return iter ( self . keyOrder )
root = config . get ( STR_ , None )
import sys
return list , False
self . target , self . expression = target , expression
scheme = value . split ( STR_ ) [ NUM_ ] . lower ( )
return value
return self . paginator . validate number ( self . number - NUM_ )
import sys
return NUM_
if settings . DEBUG :
except ValueError :
encoding = self . encoding or settings . DEFAULT CHARSET
db = router . db for read ( self . cache model class )
self . client = self . lib . Client ( self . servers )
custom sql = custom sql for model ( model , no style ( ) , connection )
for form in valid forms :
program options = [ STR_ ]
sql files = [ ]
if obj . pk is None :
self . schemes = schemes
if fk name :
def get fqdn ( self ) :
tf = TimeFormat ( value )
if settings . SECURE PROXY SSL HEADER :
relations = connection . in trospection . get relations ( cursor , table name )
for first select in parse date fmt ( ) :
return val
return
class TokenBase ( object ) :
yield buffer
import datetime
class SpacelessNode ( Node ) :
def valid value ( self , value ) :
result , upto = [ ] , NUM_
import time
continue
return mark safe ( conditional escape ( sep ) . join ( format html ( format string , * tuple ( args ) ) for args in args generator ) )
for accept lang , unused in parse accept lang header ( accept ) :
raise
from django . conf import settings
self . common logger config ( root , config , in cremental )
class HttpResponseServerError ( HttpResponse ) :
if not prefix or not hasattr ( self , STR_ ) :
from django . utils . deprecation import RemovedInDjango19Warning
if help texts and f . name in help texts :
if connections [ db ] . features . needs datetime string cast and not is in stance ( expires , datetime ) :
class SerializerDoesNotExist ( KeyError ) :
self . archive . close ( )
except OSError as e :
if line . lstrip ( ) . startswith ( TRANSLATOR COMMENT MARK ) :
raise ValidationError ( ( STR_ ) , code = STR_ , )
sql list = sql flush ( self . style , connection , only django = True , reset sequences = reset sequences , allow cascade = allow cascade )
with codecs . open ( sql file , STR_ , encoding = settings . FILE CHARSET ) as fp :
if six . PY3 :
def values ( self ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
return False
Encoders . encode base64 ( attachment )
@ register . filter ( is safe = True )
p pattern = pattern . regex . pattern
out . write ( STR_ )
unencoded ampersands re = re . compile ( r STR_ )
class Promise ( object ) :
self . max expr = max expr
callback = getattr ( urls , STR_ % view type )
def coerce ( self , value ) :
self . stdout . write ( self . style . MIGRATE LABEL ( " STR_ " ) + " STR_ " % ( targets [ NUM_ ] [ NUM_ ] , targets [ NUM_ ] [ NUM_ ] ) )
self . bad cookies . add ( key )
class Command ( TemplateCommand ) :
def resolve ( self , s ) :
self . createdir ( )
return
resolver = get ns resolver ( ns pattern , resolver )
if autoescape :
return value [ - NUM_ ]
try :
def init translation catalog ( self ) :
return " STR_ "
is usable = resource string is not None
def curry ( curried func , * args , ** kwargs ) :
self . queryset . filter ( ** { key : pk } )
reverse lazy = lazy ( reverse , str )
for opening , closing in WRAPPING PUNCTUATION :
return output
softspace = property ( lambda self : self . file . softspace )
return True
context [ self . loopvars [ NUM_ ] ] = item
else :
from django . utils . encoding import force text
bits = token . split contents ( ) [ NUM_ : ]
sys . modules [ name + " STR_ " ] = sys . modules [ name + " STR_ " ] = Module six moves urllib error ( name + " STR_ " )
request repr = " STR_ "
def decr version ( self , key , delta = NUM_ , version = None ) :
self . reverse dict = { }
absolute http url re = re . compile ( r " STR_ " , re . I )
attachment = SafeMIMEMessage ( content , subtype )
end = s . find ( b STR_ , end + NUM_ )
LockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , DWORD , LPOVERLAPPED ]
call command ( " STR_ " , in teractive = True , database = options [ STR_ ] )
raise TemplateSyntaxError ( " STR_ " )
response = debug . technical 404 response ( request , e )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
format locations = [ ]
def construct form ( self , i , ** kwargs ) :
result = [ ]
as form = True
pass
def tag function ( self , func ) :
def init ( self , fields = ( ) , * args , ** kwargs ) :
class URLField ( CharField ) :
def handle ( self , * args , ** options ) :
elif ch ! = STR_ :
return self . headers . get ( header . lower ( ) , ( None , alternate ) ) [ NUM_ ]
else :
pflen = len ( prefixed )
return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
new file . write ( content )
content = f . read ( )
elif total forms > self . max num >= NUM_ :
for obj in PythonDeserializer ( objects , ** options ) :
import base64
if mime encode :
import gzip
changes = autodetector . arrange for graph ( changes , loader . graph )
self . match re = re . compile ( self . match )
elif is in stance ( value , datetime . time ) :
return wrapper
return { }
name = self . timezone . tzname ( self . data ) if self . timezone else None
self . error messages = getattr ( options , STR_ , None )
check for migrations ( app config , connection )
from django . core . management . base import BaseCommand
for app config in apps . get app configs ( ) :
name = STR_ . join ( parts )
p = i
import os
def i18n cache key suffix ( request , cache key ) :
def normalize col name ( self , col name , used column names , is relation ) :
sublist =
return self . empty form . media
from django . utils import six
thefile = STR_ % self . file
def dummy ( * args , ** kwargs ) :
for bit in bits :
result . append ( self . create token ( last bit , ( upto , upto + len ( last bit ) ) , False ) )
class PasswordInput ( TextInput ) :
return mark safe ( STR_ . join ( output ) )
sql files . append ( os . path . join ( app dir , " STR_ " % ( opts . model name , backend name ) ) )
data = self . prepare data ( data )
if STR_ not in opts :
def init ( self , nodelist true , nodelist false , * varlist ) :
sublist item = None
form . fields [ ORDERING FIELD NAME ] = IntegerField ( label = ( STR_ ) , required = False )
def save new ( self , form , commit = True ) :
self . full clean ( )
reloader = python reloader
class Module six moves urllib request ( LazyModule ) :
self . stdout . write ( self . style . MIGRATE SUCCESS ( " STR_ " ) )
if hasattr ( self . file , STR_ ) :
else :
sample = f . read ( NUM_ )
from django . core . management . base import BaseCommand
parser . add argument ( STR_ , default = STR_ , dest = STR_ , help = STR_ )
url = reverse ( view name , args = args , kwargs = kwargs , current app = context . current app )
raise TemplateSyntaxError ( " STR_ " % name )
label = bf . label tag ( label ) or
msg [ STR_ ] = make msgid ( )
class TagHelperNode ( Node ) :
else :
return retval
result . key = key
locale dir = path
Model = self . get model from node ( node , " STR_ " )
widget . is required = self . required
tag = bits [ NUM_ ]
else :
if self . callback ( record ) :
elif not is in stance ( value , ConvertingTuple ) and is in stance ( value , tuple ) :
return in itial
return True
if hasattr ( value , STR_ ) :
replaces . extend ( migration . replaces )
import sys
def create message ( self , msg ) :
@ property
self . timezone = obj . tzinfo
if kwarg :
try :
try :
return ( resource , STR_ % ( app config . name , pkg name ) )
ser fmt = parts [ - NUM_ ]
if not is in stance ( self . file path , six . string types ) :
def init ( self , * args , ** kwargs ) :
import sys
from django . utils . encoding import smart text
try :
return settings . TEMPLATE STRING IF INVALID
fp . write ( " STR_ " % os . getpid ( ) )
return out
if self . timezone is None :
def init ( self , attrs = None ) :
def values ( self ) :
optimizer = MigrationOptimizer ( )
chunk size = self . DEFAULT CHUNK SIZE
output transaction = True
re formatchars = re . compile ( r STR_ )
sep = space
def value from datadict ( self , data , files , name ) :
self . wrapped = empty
except base . DeserializationError :
if six . PY3 :
FILE = " STR_ "
args = args [ : - NUM_ ]
PROTECTED TYPES = six . in teger types + ( type ( None ) , float , Decimal , datetime . datetime , datetime . date , datetime . time )
return mark safe ( self . render ( self . context ) )
return script name . decode ( UTF 8 )
non capturing groups . append ( len ( result ) )
os . remove ( path to remove )
handler . addQuickElement ( " STR_ " , None , { " STR_ " : " STR_ " , " STR_ " : self . feed [ STR_ ] } )
def remove ( self , item ) :
self . children . append ( data )
in dex = data . find ( self . boundary )
if hasattr ( middleware , STR_ ) :
def get cookie signer ( salt = STR_ ) :
if can fail :
return value
if extra attrs :
for arg in argv [ NUM_ : ] :
raise CommandError ( " STR_ " % ( migration name , app label ) )
def activate ( language ) :
guessed path = path . join ( tempdir , guessed filename )
from future import unicode literals
WSGIServer = module . WSGIServer
def u ( self ) :
if self . use natural foreign keys and hasattr ( field . rel . to , STR_ ) :
if self . ignore and field name not in model fields :
def new method proxy ( func ) :
from django . forms . fields import Field , ChoiceField
self . keyOrder . append ( key )
line = line [ space : ]
self . ignore = options . pop ( STR_ , False )
needs multipart form = False
self . dimensions cache = get image dimensions ( self , close = close )
if years :
memo [ id ( self ) ] = result
style func = [ f for f in ( style func , self . style func , lambda x : x ) if f is not None ] [ NUM_ ]
raise CommandError ( " STR_ " % name str )
from future import unicode literals
else :
return
print = getattr ( moves . builtins , " STR_ " , None )
new operations = optimizer . optimize ( operations , migration . app label )
break
return
file = data . temporary file path ( )
elif bytes < MB :
self . add error ( None , e )
import copy
elif bytes < PB :
try :
open tags = [ ]
else :
return force text ( error )
value = field . to python ( getInnerText ( field node ) . strip ( ) )
attrs = { " STR_ " : smart text ( obj . meta ) }
def walk to end ( ch , in put iter ) :
def wrapper ( * args , ** kwargs ) :
pending references . setdefault ( refto , [ ] ) . extend ( refs )
def has other pages ( self ) :
lang code = get language from path ( request . path info )
result = self . configure custom ( config )
val = None
def slice filter ( value , arg ) :
try :
args =
raise ValueError
self . archive . extract ( to path )
self . stdout . write ( self . style . MIGRATE HEADING ( " STR_ " % app label ) )
return STR_ % ( rfcdate [ : NUM_ ] , rfcdate [ NUM_ : NUM_ ] , rfcdate [ NUM_ : NUM_ ] )
try :
help = ( STR_ STR_ STR_ )
def handle ( self , ** options ) :
try :
def dictsort ( value , arg ) :
return apps . get model ( model identifier )
def repr ( self ) :
slug re = re . compile ( r STR_ )
loader , args = loader [ NUM_ ] , loader [ NUM_ : ]
class MiddlewareNotUsed ( Exception ) :
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
else :
mod = import module ( taglib module )
apps . get model ( STR_ , STR_ )
dot = package . rindex ( STR_ , NUM_ , dot )
response = callback ( request , ** param dict )
self . write items ( handler )
return force str ( " STR_ " % self . s [ : NUM_ ] , STR_ , errors = STR_ )
number value = rhs [ number ]
self . validate key ( key )
missing args message = ( " STR_ " " STR_ " )
import pickle
def handle app config ( self , app config , ** options ) :
class DateFormat ( TimeFormat ) :
self . tzname = self . tzname ( dt )
form . meta . fields = list ( form . meta . fields )
from django . utils import six
s . serialize ( queryset , ** options )
return format html ( STR_ , self . error class , format html join ( , STR_ , ( ( force text ( e ) , ) for e in self ) ) )
if is in stance ( data , bytes ) :
def label tag ( self , contents = None , attrs = None , label suffix = None ) :
walk to end ( ch , pattern iter )
if app config . models module is None :
def exit ( self , exc type , exc value , tb ) :
with self . lock :
file list = self . find files ( " STR_ " )
p = language . find ( - )
url = STR_ % ( local , domain )
except TypeError :
extra params = OrderedDict ( )
try :
return import module ( self . mod )
return strftime ( self , fmt )
return line
self . archive . close ( )
if name is None and filter func is None :
from django . core . mail . backends . base import BaseEmailBackend
if value is None :
return FirstOfNode ( [ parser . compile filter ( bit ) for bit in bits ] )
class types = type ,
n = getattr ( lookup view , STR_ , None )
def enter command ( self , command , token ) :
code list . append ( background [ v ] )
def end serialization ( self ) :
if construct :
def sign ( self , value ) :
if sep is None :
urlize = allow lazy ( urlize , six . text type )
else :
class NoArgsCommand ( BaseCommand ) :
@ property
self . attachments . append ( ( filename , content , mimetype ) )
output transaction = True
@ register . filter ( is safe = True )
from future import unicode literals
try :
@ stringfilter
if not directory created . get ( app label , False ) :
return dirs
pickled = self . cache [ key ]
warnings . warn ( " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ , )
max entries = params . get ( STR_ , options . get ( STR_ , NUM_ ) )
encoding = self . encoding or settings . DEFAULT CHARSET
doublecolon len = NUM_
out . write ( STR_ % cmatch . group ( NUM_ ) )
sites1 = findall ( s1 , str ( year ) )
for k in keys :
connection = connections [ options [ STR_ ] ]
if categories :
from django . core . management . base import BaseCommand , CommandError
connection = connections [ options . get ( STR_ ) ]
def read ( self , * args , ** kwargs ) :
while not answer or answer not in " STR_ " :
raise ImproperlyConfigured ( STR_ STR_ STR_ % self . class . name )
root = max ( roots )
timestamp = git log . communicate ( ) [ NUM_ ]
def t ( self ) :
return
from django . apps import apps
plural = [ ]
def in ner run ( self , * args , ** options ) :
if len ( t ) == NUM_ :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
os . chmod ( dst , mode )
parser . delete first token ( )
filename = filename [ : - NUM_ ]
def render ( self , name , value , attrs = None , choices = ( ) ) :
try :
from email . utils import formatdate , getaddresses , formataddr , parseaddr
raise AttributeError ( " STR_ " % self . name )
tpl = " STR_ "
return tag in self . tags available ( )
def send mail ( subject , message , from email , recipient list , fail silently = False , auth user = None , auth password = None , connection = None , html message = None ) :
if six . PY3 and is in stance ( val1 , bytes ) and is in stance ( val2 , bytes ) :
data = [ ]
return data . get ( name , None )
else :
return data
def configure logging ( logging config , logging settings ) :
if not is in stance ( s , Exception ) :
def get response ( self , request ) :
def f ( self ) :
try :
attr list [ NUM_ ] |= termios . ECHO
with self . in itLock :
return form
get callable . cache clear ( )
return i18n cache key suffix ( request , cache key )
return trim whitespace re . sub ( , s . strip ( ) )
@ register ( Tags . compatibility )
return form
return
self . pointer = i
if lang code is not None :
from django . conf import settings
import logging
raise ValueError ( " STR_ " )
from os import path
from django . core import signals
raise AttributeError ( " STR_ " )
def getitem ( self , key ) :
sql statements = executor . collect sql ( plan )
os . rename ( old file name , new file name )
pass
if not is shorthand ip ( ip str ) :
return value and value [ NUM_ ] . upper ( ) + value [ NUM_ : ]
url fields [ NUM_ ] = STR_
return result
def repr ( self ) :
MONTHS = STR_ . split ( )
self . proxy = False
from django . conf import settings
k , v = x , True
return self
def set post ( self , post ) :
except ( AttributeError , TypeError ) :
if option in options :
for match in tag re . finditer ( self . template string ) :
def repr ( self ) :
except ( DatabaseError , IntegrityError ) as e :
self . charset = charset
val2 = self . var2 . resolve ( context , True )
except KeyError :
with self . mutex :
except KeyError :
return neg , res
request = record . request
except KeyError :
except GeneratorExit :
return datetime . time ( ** kw )
builtins = [ ]
if bit :
if self . validate domain part ( domain part ) :
v ( value )
self . callback = callback
self . setup environ ( )
def path ( self , name ) :
if field . rel . to . meta . pk . rel :
if line [ - NUM_ : ] in ( b STR_ , b STR_ ) :
kwargs [ STR_ ] = min ( in t ( cc [ STR_ ] ) , kwargs [ STR_ ] )
RESET = STR_
from django . core . management . base import BaseCommand
if field value is not None :
sys . stdout . close ( )
else :
default = translation ( settings . LANGUAGE CODE )
obj pk = field . rel . to . default manager . db manager ( self . db ) . get by natural key ( * field value ) . pk
self . file . seek ( NUM_ , os . SEEK END )
if token . token type == TOKEN BLOCK and token . contents == endtag :
raise SerializerDoesNotExist ( format )
if status ! = STATUS OK :
json . dump ( self . get dump object ( obj ) , self . stream , cls = DjangoJSONEncoder , ** self . json kwargs )
from django . db import connections , DEFAULT DB ALIAS
token = parser . next token ( )
if len ( self . cache ) >= self . max entries :
def get renderer ( self , name , value , attrs = None , choices = ( ) ) :
return base64 . urlsafe b64decode ( s . ljust ( len ( s ) + len ( s ) % NUM_ , b = ) )
msg = SafeMIMEMultipart ( subtype = self . alternative subtype , encoding = encoding )
return [ format html ( STR_ , self . absolute path ( path ) ) for path in self . js ]
def contains ( self , item ) :
pass
chars = STR_
file path = os . path . normpath ( os . path . join ( dirpath , filename ) )
day = in t ( m . group ( STR_ ) )
from in spect import getargspec , getcallargs
if not is in stance ( candidate , six . string types ) :
return get supported language variant ( accept lang )
assert rawdata [ i : i + NUM_ ] == " STR_ " , " STR_ "
def upper ( value ) :
yield safe join ( template dir , template name )
field notes . append ( " STR_ " )
super ( CommandParser , self ) . error ( message )
@ stringfilter
break
if bcc :
dig1 . update ( u )
url = value
if name :
from django . template . base import TemplateDoesNotExist
self . dicts = dicts
try :
trail = closing + trail
parts = fixture name . rsplit ( STR_ , NUM_ )
def python reloader ( main func , args , kwargs ) :
from django . conf import settings
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
raise TemplateSyntaxError ( STR_ % filter name )
os . makedirs ( dirname )
return supported
self . default timeout = timeout
iter = iterkeys
for migration in merge migrations :
def init ( self , attrs = None , check test = None ) :
return no
except IndexError :
elif options [ STR_ ] :
global serializers
self . active writers -= NUM_
return self . file . close ( )
nodes . append ( self )
cache = DefaultCacheProxy ( )
or igin = StringOrigin ( template string )
self . paths to remove . append ( tempdir )
if base . lower ( ) . endswith ( STR_ ) :
class SimpleLazyObject ( LazyObject ) :
if palette == PALETTES [ NOCOLOR PALETTE ] :
html4 singlets = ( STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ )
from future import absolute import
if is in stance ( message , ValidationError ) :
usage . append ( style . NOTICE ( " STR_ " " STR_ " % self . settings exception ) )
if old field name :
allow cascade = options . get ( STR_ , False )
if hasattr ( field . rel . to . default manager , STR_ ) :
return form . save ( commit = commit )
token = parser . next token ( )
m2m value = lambda value : value . natural key ( )
try :
touch import ( STR_ , STR_ , decorated )
params = { STR_ : self . max length , STR_ : len ( file name ) }
except AttributeError :
self . catalog = translation . catalog . copy ( )
from django . utils . six . moves import copyreg
yield STR_
if conflicts :
pass
try :
def parse datetime ( value ) :
return RegexURLResolver ( r STR_ , urlconf )
def file complete ( self , file size ) :
def getattr ( self , attr ) :
label =
return mark safe ( message )
elif i < list length - NUM_ :
def write ( self , outfile , encoding ) :
sql , references = connection . creation . sql create model ( model , no style ( ) , seen models )
self . filters = { }
url = hashlib . md5 ( force bytes ( iri to uri ( request . build absolute uri ( ) ) ) )
from django . conf import settings
return [ first item , second item ] , old style list
def smart text ( s , encoding = STR_ , strings only = False , errors = STR_ ) :
def nodelist ( self ) :
self . stdout . write ( " STR_ " )
def deepcopy ( self , memo ) :
self . archive = self . archive cls ( file ) ( file )
return type ( self ) . bool ( self )
result args = new args
self . exclude = getattr ( options , STR_ , None )
if response is None :
caches = CacheHandler ( )
potfile = os . path . join ( self . locale dir , STR_ % str ( domain ) )
if loader is not None :
self . template = template
callable = callable
class Error ( CheckMessage ) :
fixture files = [ ]
piece += elt [ NUM_ ]
def resolve ( self ) :
except self . LibraryValueNotFoundException :
locks = { }
try :
def close caches ( ** kwargs ) :
from django . conf import settings
value , sig = signed value . rsplit ( self . sep , NUM_ )
cache timeout = settings . CACHE MIDDLEWARE SECONDS
return " STR_ " % ( STR_ . join ( self . loopvars ) , self . sequence , len ( self . nodelist loop ) , reversed text )
def str ( self ) :
if table name filter is not None and callable ( table name filter ) :
def init ( self , loaders ) :
close = self . closed
self . errors = None
viewname = parser . compile filter ( bits [ NUM_ ] )
self . stream = open ( self . get filename ( ) , STR_ )
def deepcopy ( self , memo ) :
class BadSignature ( Exception ) :
def get queryset ( self ) :
self . delete ( self . key to file ( key , version ) )
Meta = type ( str ( STR_ ) , parent , attrs )
callback ( self )
attrs [ STR_ ] = error messages
def findall ( text , substr ) :
except ValueError :
if not match :
bits . append ( in t ( x ) )
else :
def encoding ( self ) :
if hasattr ( base , STR_ ) :
def force bytes ( s , encoding = STR_ , strings only = False , errors = STR_ ) :
return self . data . hour - NUM_
except KeyError :
import ( name )
self . new objects . append ( self . save new ( form , commit = commit ) )
class Serializer ( PythonSerializer ) :
class SafeMIMEText ( MIMEMixin , MIMEText ) :
self . dict [ STR_ ] = func
DIGIT PATTERN = re . compile ( r STR_ )
cached modules = cached modules . union ( new modules )
year val , month val , day val = [ in t ( v ) for v in match . groups ( ) ]
if not url fields [ NUM_ ] :
if is in stance ( end , unicode ) :
class NodeList ( list ) :
def prepare value ( self , value ) :
raise CommandError ( " STR_ " % ( os . path . basename ( sys . argv [ NUM_ ] ) , sys . argv [ NUM_ ] ) )
if is in stance ( rhs , dict ) and number :
if r . endswith ( STR_ ) :
data [ field . attname ] = None
from django . utils . safestring import SafeData , EscapeData
field notes . append ( STR_ )
name = self . path ( name )
else :
if getattr ( func , STR_ , False ) and is in stance ( obj , SafeData ) :
if primary keys :
else :
if self . varlist :
link = cache get ( key )
from django . utils import six
return [ None , None ]
callback , param dict = resolver . resolve error handler ( status code )
all = [ STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ ]
except ( KeyError , TypeError ) :
self . check ( app configs = app configs , tags = tags , display num errors = True )
def H ( self ) :
while True :
from django . utils . timezone import template localtime
return plural suffix
become daemon ( our home dir = options [ " STR_ " ] , ** daemon kwargs )
raise ValidationError ( error message , code = STR_ )
if not value :
super ( QueryDict , self ) . setitem ( key , value )
for path in gen filenames ( only new = True ) :
else :
return STR_ . join ( output )
key = self . make key ( key , version = version )
return self . limit choices to ( )
if resource string is not None :
return str ( major + sub )
parser . add argument ( STR_ , STR_ , dest = STR_ , action = STR_ , default = [ ] , help = STR_ STR_ )
duplicate . render context = copy ( self . render context )
global localtime
for key in self . keyOrder :
del bits [ : NUM_ ]
global in valid var format string
try :
if self . can delete and self . should delete form ( form ) :
return escape ( value )
fail message = STR_
pieces . append ( force text ( getattr ( self , piece ) ( ) ) )
@ register ( Tags . models )
return token
def eval ( self , context ) :
import binascii
offset = - offset
if close :
parse until = [ ]
str = new method proxy ( str )
return nodelist . render ( context )
table = connections [ db ] . ops . quote name ( self . table )
def itervalues ( self ) :
deps . append ( rel model )
from django . core . management . base import BaseCommand , CommandError
try :
value = field . clean ( value , in itial )
return value or arg
msgs = msgs . replace ( " STR_ " % self . domain , " " )
language code = get language ( )
from django . conf import settings
return self . DSTOFFSET
if func is None :
def str ( self ) :
from django . utils . deprecation import RemovedInDjango19Warning
return avoid wrapping ( value )
try :
os . remove ( name )
if value ! = value or value in ( Decimal ( STR_ ) , Decimal ( STR_ ) ) :
var obj = Variable ( var )
response = wrapped callback ( request , * callback args , ** callback kwargs )
format key =
return forms
return in t ( calendar . timegm ( self . data . utctimetuple ( ) ) )
def deepcopy ( self , memo ) :
raise CommandError ( " STR_ " % app label )
def init ( self ) :
template string = force text ( template string )
if register to :
self . language = language
return phone2numeric ( value )
used += STR_ + frag
return format html ( STR_ , flatatt ( final attrs ) )
except ImportError :
if in itial is not None :
re tag = re . compile ( r STR_ , re . S )
self . state = state
from django . db . migrations import Migration
if options . settings :
def colorize ( text = , opts = ( ) , ** kwargs ) :
class EscapeBytes ( bytes , EscapeData ) :
self . run shell ( shell = options [ STR_ ] )
def close ( self ) :
value = force str ( value )
fn = code changed
return new context
not ifier . read events ( )
class Enclosure ( object ) :
if logging config :
else :
return self . field . widget . is hidden
import datetime
if not last row . endswith ( row ender ) :
attrs [ STR_ ] = OrderedDict ( current fields )
def init ( self , regex , urlconf name , default kwargs = None , app name = None , namespace = None ) :
except smtplib . SMTPException :
if os . path . is dir ( entry ) :
try :
def build request repr ( request , path override = None , GET override = None , POST override = None , COOKIES override = None , META override = None ) :
meth func = " STR_ "
result . setFormatter ( formatter )
obj = field . rel . to . default manager . db manager ( self . db ) . get by natural key ( * field value )
doublecolon len += NUM_
key = self . make key ( key , version = version )
BASE64 DECODE ERROR = TypeError if six . PY2 else binascii . Error
version = " STR_ "
lead , middle , trail = , word ,
assert content is None
comment = [ ]
if ( middle . endswith ( closing ) and middle . count ( closing ) == middle . count ( opening ) + NUM_ ) :
if not data :
tzinfo = utc
if not formset . is valid ( ) :
from django . utils . text import unescape entities
def repr ( self ) :
context [ self . var name ] = [ ]
def Z ( self ) :
else :
else :
return errors
if ch == STR_ :
class CheckboxSelectMultiple ( RendererMixin , SelectMultiple ) :
result = self . nodelist . render ( context )
from django . utils import six
if not self . allow multiple selected :
value = value . decode ( charset )
vary headers = cc delim re . split ( response [ STR_ ] )
return singular
raise CommandError ( " STR_ " % self . port )
return STR_ . join ( ret ip )
if callable ( key func ) :
self . extend nodelist ( nodelist , TextNode ( token . contents ) , token )
mail . attach alternative ( html message , STR_ )
self . stream = LimitedStream ( self . environ [ STR_ ] , content length )
return Operator
self . to language = to language ( language )
boundary = self . find boundary ( chunk , len ( chunk ) < self . rollback )
walk to end ( ch , pattern iter )
raise
if six . PY3 :
new class . media = media property ( new class )
if len ( bits ) < NUM_ :
try :
elif ch in " STR_ " :
def id for label ( self ) :
for message in message :
self . remove potfiles ( )
@ total ordering
for key value in natural :
@ wraps ( fset )
def urlize ( text , trim url limit = None , nofollow = False , autoescape = False ) :
return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get accessor name ( ) . replace ( + , )
elif k == STR_ :
except NotImplementedError :
if self . is rendered :
return False
filelist = cached filenames + new filenames + error files
if error messages is not None :
import string ( backend )
if hasattr ( file , STR_ ) :
if value == k or text value == force text ( k ) :
if verbosity >= NUM_ :
def load ( parser , token ) :
return False
from django . forms . widgets import HiddenInput
raise
match = datetime re . match ( value )
last bit = self . template string [ upto : ]
def errors ( self ) :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = DEFAULT DB ALIAS , help = STR_ STR_ )
if settings . TEMPLATE DEBUG :
import argparse
try :
return s
if field . has changed ( in itial value , data value ) :
super ( LoaderOrigin , self ) . init ( display name )
self . style func = None
self . waiting readers += NUM_
self . stream . write ( message . message ( ) . as bytes ( ) + b STR_ )
encoding = None
runfastcgi ( sys . argv [ NUM_ : ] )
try :
apps . get app config ( app label )
raise TemplateSyntaxError ( " STR_ " % ( name , param ) )
mail . mail admins ( subject , message , fail silently = True , html message = html message , connection = self . connection ( ) )
return [ super ( ModelMultipleChoiceField , self ) . prepare value ( v ) for v in value ]
continue
def value from datadict ( self , data , files , name ) :
def loads ( s , key = None , salt = STR_ , serializer = JSONSerializer , max age = None ) :
if self . stream is None :
import os
return super ( type ( dt ) , dt ) . strftime ( fmt )
value = request . META . get ( header , None )
try :
HTMLParser . init ( self , strict = False )
def urlunquote plus ( quoted url ) :
if os . name == STR_ :
self . stdout . write ( " STR_ " % migration , ending = " " )
else :
elif self . meta . exclude and field in self . meta . exclude :
from django . utils . encoding import force bytes
self . active readers = NUM_
def filter ( self , record ) :
if app config . models module is None :
else :
self . regex = regex
ignored . append ( f . name )
from django . core . exceptions import DisallowedHost , ImproperlyConfigured
mapping = { STR_ : STR_ , STR_ : STR_ , STR_ : STR_ }
loop dict [ STR_ ] = ( i == NUM_ )
row data = ( form . cleaned data [ field ] for field in unique check if field in form . cleaned data )
continue
help = " STR_ "
import warnings
if extend :
if lang is None :
errors . update ( kwargs [ STR_ ] )
from django . http . cookie import SimpleCookie , parse cookie
pieces . append ( re escaped . sub ( r STR_ , piece ) )
frame = sys . getframe ( NUM_ )
elif name == STR_ :
return True
full statement = [ " STR_ " % qn ( tablename ) ]
step = STR_
from django . utils import six
self . connector = conn type
deactivate all ( )
self . translate = False
for middleware method in self . template response middleware :
return m + Media ( definition )
references to delete . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) )
field notes = [ ]
super ( IncludeNode , self ) . init ( * args , ** kwargs )
qs = qs . or der by ( self . model . meta . pk . name )
value , timestamp = result . rsplit ( self . sep , NUM_ )
if k [ NUM_ ] is None :
return False
safe = is in stance ( value , SafeData )
return self . value == self . choice value
self . load post and files ( )
self . in itial = in itial
template tuple = self . template cache . get ( key )
help = ( " STR_ " " STR_ " " STR_ " )
return timesince ( d , now , reversed = True )
try :
import stat
return smart text ( value )
return STR_ % ( key prefix , version , key )
try :
import re
try :
empty value = [ ]
year += NUM_
self . args check ( filter name , filter func , args )
if not serializers :
else :
reloader thread ( )
template dir = self . handle template ( options [ STR_ ] , base subdir )
super ( MovedModule , self ) . init ( name )
self . stream = BytesIO ( self . body )
def get system encoding ( ) :
import threading
for relobj in getattr ( obj , field . name ) . iterator ( ) :
else :
if self . activated :
@ property
help = ( " STR_ " " STR_ " )
return self . changed data
return in ner
def scheme ( self ) :
self . rollback = len ( boundary ) + NUM_
return False
current timezone = timezone . get current timezone ( )
from django . utils import six
j = day of year + ( NUM_ - weekday ) + ( jan1 weekday - NUM_ )
return o . is oformat ( )
self . set cdata mode ( tag )
return NUM_
if path is not None :
in index = - NUM_ if is reversed else - NUM_
if new name [ NUM_ ] . is digit ( ) :
class MultiValueField ( Field ) :
if self . read started and not hasattr ( self , STR_ ) :
if pks :
def repr ( self ) :
if not settings . configured :
if code is None :
text = match . group ( NUM_ )
try :
self . pubid = pubid
run checks = registry . run checks
def new date ( d ) :
key = self . make key ( key , version = version )
raise NotImplementedError ( STR_ )
def empty block tag ( self , token ) :
for middleware method in self . response middleware :
super ( QueryDict , self ) . appendlist ( key , value )
if self . cull frequency == NUM_ :
from collections import OrderedDict
def root attributes ( self ) :
def become daemon ( our home dir = STR_ , out log = STR_ , err log = STR_ , umask = NUM_ o022 ) :
if compress :
if self . wrapped is empty :
ret =
filepath = self . filepath . resolve ( context )
result = STR_ . join ( hextets [ NUM_ : NUM_ ] )
existing headers = set ( header . lower ( ) for header in vary headers )
loaded objects in fixture += NUM_
for format in BUILTIN SERIALIZERS :
import django
with open ( filepath , STR_ ) as fp :
if is in stance ( file , six . string types ) :
return context
raise AttributeError
return super ( classonlymethod , self ) . get ( in stance , owner )
def dictsortreversed ( value , arg ) :
return lazy number ( npgettext , six . text type , context = context , singular = singular , plural = plural , number = number )
exec = getattr ( moves . builtins , " STR_ " )
hidden widget = HiddenInput
stream . unget ( chunk [ header end + NUM_ : ] )
self . error dict [ field ] = messages . error list
return value
raise SerializerDoesNotExist ( format )
def str ( self ) :
if s len > length :
self . callback str = prefix + STR_ + self . callback str
if ch not in ( < , = ) :
def loads ( self , data ) :
else :
else :
return self . html output ( normal row = STR_ , error row = STR_ , row ender = STR_ , help text html = STR_ , errors on separate row = False )
code = STR_
if is aware ( o ) :
cls . str = cls . bytes cast
INDEX PATTERN = re . compile ( r STR_ )
self . handle endtag ( tag . lower ( ) )
if name is None and compile function is None :
attrs [ STR_ ] = help texts
raise TemplateSyntaxError ( " STR_ " )
if year < NUM_ :
retval = handler . upload complete ( )
return files . get ( name , None )
def run checks ( self , app configs = None , tags = None ) :
data = self
unique checks , date checks = form . in stance . get unique checks ( exclude = exclude )
value = super ( IntegerField , self ) . to python ( value )
def next page number ( self ) :
for sql in custom sql :
for x in range ( level , NUM_ , - NUM_ ) :
except ValidationError as e :
attrs = super ( CharField , self ) . widget attrs ( widget )
class FileBasedCache ( BaseCache ) :
created models . add ( model )
elif is in stance ( obj , EscapeData ) :
class Serializer ( PythonSerializer ) :
self . verbatim = False
max width = min ( ( line . endswith ( STR_ ) and width + NUM_ or width ) , width )
else :
try :
except ImportError :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
assert mimetype is None
continue
if not data and in itial :
if not prefix . endswith ( / ) :
msg = self . create message ( msg )
if not os . path . is dir ( directory ) :
sql . extend ( connection . creation . sql for pending references ( model , no style ( ) , pending references ) )
except :
kw = dict ( ( k , in t ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
self . open ( )
return self . nodelist . render ( context )
from django . conf import settings
return TemplateSyntaxError ( msg )
def init ( self ) :
class VariableDoesNotExist ( Exception ) :
raise StopIteration
checkbox name = self . clear checkbox name ( name )
else :
class MemcachedCache ( BaseMemcachedCache ) :
key = self . make key ( key , version = version )
cache choices = False
style = dummy ( )
self . ordering . sort ( key = compare ordering key )
data = str ( data )
answer = answer [ NUM_ ] . lower ( )
sys . stdout . write ( self . main help text ( commands only = True ) + STR_ )
self . current token = self . next token ( )
from django import VERSION as version
try :
def check migrations ( self ) :
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
for choice in value :
pass
return wrapper
return self . text chars ( length , truncate , text , truncate len )
if since <= NUM_ :
if commit and hasattr ( form , STR_ ) :
from yaml import SafeLoader , SafeDumper
self . raw ipv6 = True
try :
if ttl is not None :
if self . in teractive :
def construct form ( self , i , ** kwargs ) :
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning )
raise CommandError ( " STR_ " % message )
def escape filter ( value ) :
return nodes
pot path = os . path . join ( path , STR_ % str ( self . domain ) )
use natural foreign keys = options . get ( STR_ ) or use natural keys
raise CommandError ( " STR_ " )
from functools import update wrapper
if nodelist . contains nontext :
if is in stance ( rhs , SafeData ) :
os . kill ( os . getpid ( ) , - exit code )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " )
else :
m = html parser . attrfind . match ( rawdata , k )
pass
def generate cache header key ( key prefix , request ) :
from django . utils import formats , six
self . message = message
raise TemplateSyntaxError ( " STR_ " " STR_ " % name )
if in dex is not None and in dex < self . in itial form count ( ) :
return [ Warning ( " STR_ " , hint = ( " STR_ " " STR_ " " STR_ " " STR_ " " STR_ " ) , obj = None , id = STR_ , ) ]
return t . render ( context )
if name in lib . filters :
ser fmt = None
def add arguments ( self , parser ) :
if is in stance ( message , dict ) :
value = value . replace ( arg , )
if is in stance ( other , Promise ) :
response = self . handle uncaught exception ( request , resolver , sys . exc info ( ) )
if formfield :
if max age is not None :
class InclusionNode ( TagHelperNode ) :
return self . errors
self . max value , self . min value = max value , min value
raise CommandError ( msg )
else :
current = current ( )
if value is not result :
def eq ( self , other ) :
elif is in stance ( value , datetime . date ) :
with open ( fn , STR_ ) as f :
return endpos
from django . utils import six
local attrs = self . build attrs ( id = field % id )
except IOError as e :
def check model signals ( app configs = None , ** kwargs ) :
@ register . filter ( is safe = False )
else :
while i < len ( subject ) and subject [ i ] in ( , STR_ ) :
valid forms = [ form for form in self . forms if form . is valid ( ) and form not in forms to delete ]
final attrs [ STR_ ] = STR_
from django . utils . encoding import force str
from django . utils . six . moves . urllib . parse import urljoin
def bool ( self ) :
return super ( BaseInlineFormSet , self ) . in itial form count ( )
from django . core . management . templates import TemplateCommand
if key not in self :
if errors :
return True
self . can write = threading . Semaphore ( NUM_ )
def is silenced ( self ) :
@ register . tag ( STR_ )
var obj = None
def validate ( self , value ) :
else :
from django . utils . text import Truncator , wrap , phone2numeric
from future import unicode literals
return getattr ( active , " STR_ " , get default timezone ( ) )
return cls
from itertools import chain
def clear cdata mode ( self ) :
import sys
def handle m2m ( value ) :
for ( k , v ) in type . dict . items ( ) :
self . or phans = in t ( or phans )
self . wrapped = get storage class ( ) ( )
elif is in stance ( value , six . string types ) :
if refto in seen models :
def isdst ( self , dt ) :
if not func . is usable :
def resolve ( self , context , ignore failures = False ) :
del prefixes . value
from django . utils . timezone import is aware
return lookup view
if not self . timezone :
netloc = netloc . encode ( STR_ ) . decode ( STR_ )
for regex in RFC1123 DATE , RFC850 DATE , ASCTIME DATE :
@ wraps ( func )
return bool ( self . dict )
file name = data . name
if globs is None :
return self
if defaults is not None :
for obj in queryset :
i = NUM_
self . resolver match = None
if field . widget . needs multipart form :
tpl = " STR_ "
dict . setitem ( self , key , http cookies . Morsel ( ) )
if response :
return self . streaming content
class Debug ( CheckMessage ) :
val2 = parser . compile filter ( bits [ NUM_ ] )
host = STR_ % ( host , server port )
if is in stance ( message , SafeData ) :
format = force str ( default or get format ( STR_ ) [ NUM_ ] )
over chunk = field stream . read ( NUM_ - over bytes )
final path = abspathu ( join ( base , * paths ) )
message = . join ( tokens )
for format in settings . SERIALIZATION MODULES :
if name == STR_ :
if field . rel is None :
except IOError as e :
if STR_ in cc and STR_ in kwargs :
return self
return render value in context ( value , context )
if i >= self . in itial form count ( ) and self . in itial extra :
value = value . astimezone ( timezone )
nodelist empty = parser . parse ( ( STR_ , ) )
from django . core import signals
references to delete = { }
self . code = code
condition = TemplateIfParser ( parser , bits ) . parse ( )
hextet = ip str . split ( STR_ )
def handle ( self , ** options ) :
raise
return tpl . format ( self . sysid , self . pubid )
if safe :
except ValueError :
def tag ( self ) :
path = os . path . join ( app config . path , STR_ )
if self . errors is None :
pass
def resolve ( self , path ) :
def reset cache ( ** kwargs ) :
return FixedOffset ( offset , name )
offset = ( len ( self . starttag text ) - self . starttag text . rfind ( " STR_ " ) )
import tempfile
current = settings . TEMPLATE STRING IF INVALID
elif self . use ipv6 and not fqdn :
return
stream . close ( )
return trans . npgettext ( context , singular , plural , number )
from future import absolute import
def close ( self ) :
loop dict [ STR_ ] = i
opt label += =
def assignment tag ( self , func = None , takes context = None , name = None ) :
def or dered forms ( self ) :
for widget in self . get renderer ( name , value , attrs , choices ) :
def temporary file path ( self ) :
return datetime . fromtimestamp ( os . path . getctime ( self . path ( name ) ) )
result . pop ( )
def get choices ( self ) :
self . app or project = app or project
try :
except ValueError :
def exec ( code , globs = None , locs = None ) :
def error ( self , token , msg ) :
continue
self . files . appendlist ( force text ( old field name , self . encoding , errors = STR_ ) , file obj )
self . negated = negated
delitem = complain
if field . serialize :
class TypedMultipleChoiceField ( MultipleChoiceField ) :
return [ ( k , self [ k ] ) for k in self . keyOrder ]
except ValueError :
e . django template source = node . source
from django . utils . html import avoid wrapping
from django . core . files . base import File
in dex output . append ( " STR_ " % ( unique , qn ( STR_ % ( tablename , f . name ) ) , qn ( tablename ) , qn ( f . name ) ) )
overlapped = OVERLAPPED ( )
def getitem ( self , alias ) :
def render ( self , name , value , attrs = None ) :
def str ( self ) :
def deepcopy ( self , memo ) :
chunk size *= NUM_
help = ( " STR_ " " STR_ " " STR_ " )
self . DSTOFFSET = timedelta ( seconds = - time . altzone )
timeout = NUM_
else :
cleaned data = form . cleaned data
def get resolved arguments ( self , context ) :
def set ( self , key , value , timeout = DEFAULT TIMEOUT ) :
except Exception :
if STR_ in kwargs :
return " "
return zipfile . ZipFile . read ( self , self . namelist ( ) [ NUM_ ] )
class URLNode ( Node ) :
if six . PY3 :
subcommands = list ( get commands ( ) ) + [ STR_ ]
lang = get language ( )
self . m2m data = None
else :
self . paths to remove . append ( tempdir )
parser = CommandParser ( self , prog = " STR_ " % ( os . path . basename ( prog name ) , subcommand ) , description = self . help or None )
if is in stance ( boundary , six . text type ) :
message context = context match . group ( NUM_ )
if is in stance ( timezone , tzinfo ) :
@ register . filter ( is safe = True )
if not path . exists ( target dir ) :
from django . utils . module loading import import string
if not hasattr ( self , STR_ ) :
m = self . DOT PATTERN . match ( rest )
break
root [ KEY ] = root [ RESULT ] = None
def init ( self , obj ) :
conflicts = loader . detect conflicts ( )
pass
if not self . use argparse :
def get language bidi ( ) :
return attrs
return True
self . endElement ( name )
var obj = Variable ( constant ) . resolve ( { } )
if ipv6 :
try :
if i >= len ( subject ) :
import re
self . month none value = self . none value
from django . db import models , router
def clean ( self , value ) :
parts = config string . lower ( ) . split ( STR_ )
chunk size = NUM_
return ( self . data . weekday ( ) + NUM_ ) % NUM_
timeout = - NUM_
self . loaded object count = NUM_
self . boundary = boundary
append = complain
errors = [ ]
args = ( )
kwargs [ " STR_ " ] = getattr ( self . parent instance , self . to field )
return compiled parent . render ( context )
return in stance
if sub tried is not None :
return mark safe ( value )
def repr ( self ) :
if decimal pos is not None :
@ python 2 unicode compatible
return node
return unbound . im func
def get language info ( lang code ) :
os . makedirs ( basedir )
new obj = func ( obj , autoescape = context . autoescape , * arg vals )
self . verbosity = options . get ( STR_ )
m = getattr ( lookup view , STR_ , None )
i += NUM_
self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )
else :
builtin context processors = ( STR_ , )
for model in app models :
def get ( self , key , otherwise = None ) :
class InputStreamExhausted ( Exception ) :
weight += NUM_
self . write migration files ( changes )
lib = libraries . get ( library name , None )
else :
self . fed = [ ]
def to python ( self , value ) :
name , val = forbid multi line headers ( name , val , STR_ )
if field ! = NON FIELD ERRORS and field not in self . fields :
except KeyError :
self . parent name = parent name
return self . get page ( self . object list [ bottom : top ] , number , self )
setattr ( base , old method name , wrapper ( old method ) )
re chars = re . compile ( r STR_ , re . U | re . S )
BLOCK CONTEXT KEY = STR_
if now and not is in stance ( now , datetime . datetime ) :
app list = resolver . app dict [ ns ]
if remaining is None :
return cache
if not hasattr ( values , STR_ ) :
continue
i = NUM_
class MovedModule ( LazyDescr ) :
class EscapeText ( six . text type , EscapeData ) :
class OVERLAPPED ( Structure ) :
self . class name = class name
match = self . regex . search ( path )
return d ( stream or string , ** options )
if f . db index :
except KeyError :
def deepcopy ( self , memo ) :
return True
sys . stderr . write ( " STR_ " )
table = connections [ db ] . ops . quote name ( self . table )
if is in stance ( receiver , types . FunctionType ) :
return Page ( * args , ** kwargs )
handler . addQuickElement ( " STR_ " , item [ STR_ ] )
if not match :
date = datetime safe . new datetime ( date )
return id
out . write ( STR_ % p . split ( STR_ , NUM_ ) [ NUM_ ] )
using sysrandom = False
recipients = [ sanitize address ( addr , email message . encoding ) for addr in email message . recipients ( ) ]
if in stance is None :
neg = NUM_
for key value in related :
return { f : e . as data ( ) for f , e in self . items ( ) }
def init ( self , * args , ** kwargs ) :
from django . utils . six . moves import cPickle as pickle
else :
bad app labels = set ( )
self . cmd = cmd
data [ " STR_ " ] = smart text ( obj . get pk val ( ) , strings only = True )
self . container . append ( self . make bytes ( content ) )
return SafeBytes ( t )
def value ( self ) :
if path is None :
elif msg and visible issue count :
import sys
self . can read . acquire ( )
try :
FormSet . fk = fk
class IntegerField ( Field ) :
raise base . DeserializationError ( " STR_ " )
elif args [ NUM_ ] == STR_ :
contains nontext = False
continue
for ext in extensions :
if options . get ( " STR_ " , False ) :
if i >= len ( subject ) :
def import string ( dotted path ) :
name , val = forbid multi line headers ( name , val , self . encoding )
self . namespace dict [ language code ] = namespaces
return self . forms [ NUM_ ] . is multipart ( )
in itial value = in itial if in itial is not None else
else :
from django . utils . translation import ugettext lazy as , pgettext lazy
def needs multipart form ( self ) :
self . stdout . write ( " STR_ " % line )
count , ch = get quantifier ( ch , pattern iter )
save . alters data = True
self . stream . flush ( )
self . raw ipv6 = False
for f in chain . from iterable ( l [ NUM_ ] for l in self . files . lists ( ) ) :
class CacheKeyWarning ( DjangoRuntimeWarning ) :
self . args = args
import errno
try :
return force text ( quote plus ( force str ( url ) , force str ( safe ) ) )
result = block . nodelist . render ( context )
from django . utils . safestring import mark safe
return
result |= or d ( x ) ^ or d ( y )
continue
from django . utils . deprecation import RemovedInDjango19Warning
else :
pass
form = self . form ( ** defaults )
@ property
def find commands ( management dir ) :
yield subnode
else :
admin = STR_
s = StringIO ( )
content = force bytes ( content )
if plan node in loader . applied migrations :
def init ( self , parent widget , name , value , attrs , choices ) :
if not qs . or dered :
def get scheme ( self ) :
end tag = STR_ + bits [ NUM_ ]
return len ( value ) == in t ( arg )
base directory = STR_ % app or project
if not self . is required and CheckboxInput ( ) . value from datadict ( data , files , self . clear checkbox name ( name ) ) :
return ip str
self . choices = choices
if value ! = value or value == Decimal ( " STR_ " ) or value == Decimal ( " STR_ " ) :
for o in opts :
rv = level
if is o input not in val :
missing fields = ( set ( none model fields ) - set ( new class . declared fields . keys ( ) ) )
if dklen > ( NUM_ ** NUM_ - NUM_ ) * hlen :
qs = self . queryset . filter ( ** { STR_ % key : value } )
self . stdout . write ( " STR_ " % ( app name , model . meta . object name ) )
if not os . path . exists ( self . default locale path ) :
six . reraise ( CommandError , CommandError ( new msg ) , sys . exc info ( ) [ NUM_ ] )
class EscapeData ( object ) :
def custom sql for model ( model , style , connection ) :
if translators comment start is not None and lineno >= translators comment start :
if self . verbosity > NUM_ :
@ register . filter ( is safe = True )
self . post , self . files = QueryDict ( , encoding = self . encoding ) , MultiValueDict ( )
def accessed time ( self , name ) :
except Exception as e :
from django . utils . html import conditional escape , format html
from lib2to3 . fixer util import find indentation , Name , syms , touch import
path info = /
self . start object ( obj )
self . stdout . write ( " STR_ " % writer . as string ( ) )
elif self . waiting readers ! = NUM_ :
self . can read . release ( )
fields = [ ( STR_ , ULONG PTR ) , ( STR_ , ULONG PTR ) , ( STR_ , OFFSET UNION ) , ( STR_ , HANDLE ) ]
return cookiedict
import os
must be first = True
if in dex is not None :
slugify = allow lazy ( slugify , six . text type )
from logging . config import dictConfig
def content ( self , value ) :
if hasattr ( TemplateLoader , STR_ ) :
self . verbosity = options . get ( STR_ )
if app config . models module is None :
try :
self . cached loaders = cached loaders
if m :
for pk in value :
exit code = restart with reloader ( )
raise TemplateSyntaxError ( " STR_ " % ( bits [ NUM_ ] , block name ) )
from django . utils . six . moves import map
return ( fp . read ( ) . decode ( settings . FILE CHARSET ) , filepath )
return { STR_ : settings . STATIC URL }
self . lookups = None
return view func
id = widget . attrs . get ( STR_ ) or self . auto id
else :
self . name , self . value = name , value
failures = test runner . run tests ( test labels )
def to locale ( language ) :
cur lineno = t . lineno + t . contents . count ( STR_ )
model list . append ( model )
for attr in urllib request moved attributes :
if not pythonrc :
return self . extract ( absolute path )
super ( MemcachedCache , self ) . init ( server , params , library = memcache , value not found exception = ValueError )
pid = os . getpid ( )
return STR_ % ( self . number , self . paginator . num pages )
attrs = [ ]
raise NotImplementedError ( STR_ )
handler . startElement ( " STR_ " , self . rss attributes ( ) )
assert len ( version ) == NUM_
words [ i ] = escape ( word )
if self . verbosity >= NUM_ :
return decorator
reporter = ExceptionReporter ( request , is email = True , * exc info )
path rest = root [ prefix length : ]
for i in range ( NUM_ , self . total form count ( ) ) :
def pbkdf2 ( password , salt , iterations , dklen = NUM_ , digest = None ) :
model list = app config . get models ( )
self . wrapped = self . setupfunc ( )
command . stdout . write ( STR_ % ( self . file , self . dirpath ) )
if PY3 :
return False
def render ( self , context ) :
v = ValueError ( STR_ % ( s , e ) )
from datetime import datetime
return timezone . localize ( value , is dst = None )
return self . filter function ( func , ** flags )
except KeyError :
if options . traceback or not is in stance ( e , CommandError ) :
def to python ( self , value ) :
args = [ ]
for i , piece in enumerate ( re formatchars . split ( force text ( formatstr ) ) ) :
from django . core . wsgi import get wsgi application
from django . test . utils import get runner
def get media ( self ) :
return in stance
self . changed objects . append ( ( obj , form . changed data ) )
return res
try :
if not is in stance ( item , ( list , tuple ) ) :
if not serializers :
for bit in self . lookups :
values = itervalues
return value
return func
try :
try :
if not os . path . is file ( in it path ) :
def get queryset ( self ) :
def validate ( self , value ) :
obj = settings . TEMPLATE STRING IF INVALID
attrs = { STR_ : model }
try :
try :
def init ( self , form , field , name ) :
if not check for language ( lang ) :
def set queryset ( self , queryset ) :
def load template source ( self , template name , template dirs = None ) :
elif not options [ " STR_ " ] and not options [ " STR_ " ] and not options [ " STR_ " ] :
self . response middleware = [ ]
kwargs [ STR_ ] = number
def configure formatter ( self , config ) :
os . makedirs ( dirname )
if not model identifier :
func ( path )
error text = str ( e )
t = self . current token
return lang code
def wordwrap ( value , arg ) :
nm = Header ( nm , encoding ) . encode ( )
with open ( pythonrc ) as handle :
none model fields = [ k for k , v in six . iteritems ( fields ) if not v ]
for basedir in basedirs :
else :
field type = connection . in trospection . get field type ( row [ NUM_ ] , row )
try :
load serializers ( )
from django . core . cache . backends . base import ( InvalidCacheBackendError , CacheKeyWarning , BaseCache )
@ python 2 unicode compatible
import random
return self . path < other . path
if float ( value ) ! = NUM_ :
value = converter ( suffix )
return d
self . content type = content type
result = datetime . datetime ( year , month , day , hour , min , sec )
try :
if name == STR_ :
if id :
return NUM_
return parse http date ( date )
def get full path ( self ) :
return force text ( ngettext ( singular , plural , number ) )
for name in loggers :
available shells = [ shell ] if shell else self . shells
except LookupError :
if PY3 :
value = formats . sanitize separators ( value )
if not self . closed :
def iterkeys ( d , ** kw ) :
raise TypeError ( " STR_ " )
construct instance exclude . append ( name )
def to bytes ( val , encoding ) :
def str ( self ) :
for attr in urllib robotparser moved attributes :
value = ugettext ( " STR_ " ) % filesize number format ( bytes / KB )
return False
if hasattr ( mw instance , STR_ ) :
elif field in self . fields :
def end serialization ( self ) :
os . environ [ STR_ ] = options [ STR_ ]
else :
self . error class = error class
self . tags = { }
non capturing groups = [ ]
elif ( attrvalue [ : NUM_ ] == STR_ == attrvalue [ - NUM_ : ] or attrvalue [ : NUM_ ] == STR_ == attrvalue [ - NUM_ : ] ) :
del error files [ error files . in dex ( filename ) ]
COMMENT TAG END = STR_
if not dklen :
if i :
field name = force text ( field name , encoding , errors = STR_ )
from unittest import *
cls . dispatch = { }
filename = file . name
self . var name = var name
sys . stdout . write ( self . main help text ( ) + STR_ )
SafeString = SafeText
def safe ( value ) :
except StandardError as e :
pass
cache . set ( cache key , [ ] , cache timeout )
if six . PY2 :
def init ( self , var1 , var2 , nodelist true , nodelist false , negate ) :
def init ( self , loopvars , sequence , is reversed , nodelist loop , nodelist empty = None ) :
qs = self . queryset
from django . db import connections , router , transaction , models , DEFAULT DB ALIAS
if self . wrapped is empty :
repr attr = self . setupfunc
can import settings = True
extra classes . add ( self . form . required css class )
self . choices = list ( choices )
else :
LOCK EX = NUM_ x2
if is in stance ( other , Promise ) :
language code = get language ( )
object data . update ( in itial )
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc info ( ) [ NUM_ ] )
return self . class ( [ ( key , copy . deepcopy ( value , memo ) ) for key , value in self . items ( ) ] )
return b64 encode ( salted hmac ( salt , value , key ) . digest ( ) )
if is in stance ( other dict , MultiValueDict ) :
else :
plural forms re = re . compile ( r STR_ , re . MULTILINE | re . DOTALL )
return NUM_
return path . split ( / , NUM_ )
def format subject ( self , subject ) :
for field in unique check :
token = parser . next token ( )
sys . stderr . close ( )
def is hidden ( self ) :
if six . PY2 and value > sys . maxint :
super ( BaseTemporalField , self ) . init ( * args , ** kwargs )
def wrapper ( self , * args , ** kwargs ) :
if self . load initial data :
def flush ( self ) :
self . filters = filters
return result
self . connection = get connection ( fail silently = fail silently )
def format value ( self , value ) :
except serializers . SerializerDoesNotExist :
forms valid &= form . is valid ( )
try :
if in put val in special floats :
return [ self . forms [ i [ NUM_ ] ] for i in self . ordering ]
model dependencies . reverse ( )
locales = set ( locales ) - set ( exclude )
else :
processors = tuple ( processors )
else :
return d
if ret :
msg += " STR_ "
from django . utils . deconstruct import deconstructible
from collections import namedtuple
return
obj = base . build instance ( Model , data , self . db )
def set signed cookie ( self , key , value , salt = , ** kwargs ) :
def boolean check ( v ) :
self . stdout . write ( " STR_ " )
yield ( " " , self . field . empty label )
self . stdout . write ( " STR_ " )
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
importer = import
parsed = False
try :
return " STR_ " % ( obj , id , self . msg , hint )
dir name , file name = os . path . split ( name )
elif len ( options . args ) < NUM_ :
self . clear cdata mode ( )
def new file ( self , * args , ** kwargs ) :
max num = NUM_
def decorator ( view func ) :
return chunk [ : - rollback ]
self . pubid = pubid
if filepath . startswith ( root ) :
if old attr is None :
if bmatch . group ( NUM_ ) :
except StandardError as e :
else :
res =
in dent = self . options . get ( " STR_ " )
self . base = base
raise NotImplementedError ( STR_ )
pass
self . setlist ( k , v )
from django . core . exceptions import DisallowedRedirect
field params [ STR_ ] = row [ NUM_ ]
elif not self . required and not value :
del active . value
if csrf token is not None :
return yes
return self . cast ( ) ! = other
import types
now = now . replace ( tzinfo = None )
if not support legacy :
from datetime import datetime
if hasattr ( middleware , STR_ ) :
else :
substitutions [ STR_ ] = conditional escape ( checkbox id )
return data
@ streaming content . setter
elif ch == STR_ :
year = year + off
self . xml = SimplerXMLGenerator ( self . stream , self . options . get ( " STR_ " , settings . DEFAULT CHARSET ) )
return force text ( quote ( force str ( url ) , force str ( safe ) ) )
return self . tokens . pop ( NUM_ )
for module in get format modules ( lang ) :
except UnicodeEncodeError :
def init ( self , * args , ** kwargs ) :
return render value in context ( value , context )
if localized fields is not None :
used column names = [ ]
termios = None
else :
elif not is in stance ( file name , six . string types ) and is iterable ( file name ) :
handler . addQuickElement ( " STR_ " , item [ STR_ ] , { " STR_ " : " STR_ " } )
self . in stance = self . fk . rel . to ( )
class HttpResponseNotModified ( HttpResponse ) :
httpd . serve forever ( )
has new option = hasattr ( self , STR_ )
or iginal lookup = lookup view
for entry in package path :
if escaped :
if finder . find module ( name ) :
def exit command ( self ) :
def to tuple ( s ) :
break
class SkipFile ( UploadFileException ) :
return data . get ( name , None )
self . stdout . write ( " STR_ " % ( " STR_ " . join ( app labels ) ) )
w = self . choice input class ( self . name , self . value , self . attrs . copy ( ) , choice , i )
for meta line in self . get meta ( table name ) :
if url . endswith ( / ) :
return - . join ( [ template name , hashlib . sha1 ( force bytes ( | . join ( template dirs ) ) ) . hexdigest ( ) ] )
def reload ( self ) :
pks = set ( force text ( getattr ( o , key ) ) for o in qs )
if timeout > NUM_ :
continue
url = unquote ( force str ( url ) )
def iter ( self ) :
@ register . tag
class ExtendsError ( Exception ) :
if is in stance ( pk , OneToOneField ) or is in stance ( pk , ForeignKey ) :
key salt = force bytes ( key salt )
key = hashlib . sha1 ( key salt + secret ) . digest ( )
migration . merged operations . extend ( loader . get migration ( node app , node name ) . operations )
else :
if not kwarg format :
try :
super ( CharField , self ) . init ( * args , ** kwargs )
sortable virtual fields = [ f for f in opts . virtual fields if is in stance ( f , ModelField ) ]
callback = getattr ( self . urlconf module , STR_ % view type , None )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = STR_ )
for form in self . in itial forms :
self . done = False
MIMEMultipart . setitem ( self , name , val )
host = self . META [ STR_ ]
help text =
new name , num repl = re . subn ( r STR_ , STR_ , new name )
def ext convert ( self , value ) :
return self . empty value
try :
return [ source [ NUM_ ] ] , [ params ]
exctype , value = exc info [ : NUM_ ]
def load template ( self , template name , template dirs = None ) :
field desc += STR_ + . join ( comment notes )
naiveip re = re . compile ( r " " " STR_ " " " , re . X )
self . buf size = buf size
@ register . tag
def error ( self , token , msg ) :
string types = basestring ,
mime type = STR_
return
if keys :
if extra attrs :
self . stdout . write ( " STR_ " % tablename )
return None
def modified time ( self , name ) :
return datetime . datetime ( ** kw )
root = logging . getLogger ( )
self . verbosity = options . get ( STR_ )
help = ( " STR_ " " STR_ " " STR_ " )
key prefix = settings . CACHE MIDDLEWARE KEY PREFIX
if find command ( self . program ) is None :
from django . core . servers . basehttp import get internal wsgi application
attrs . append ( ( attrname . lower ( ) , attrvalue ) )
if path not in self . js :
@ property
def tokenize ( self ) :
flup module += STR_
LANGUAGE SESSION KEY = STR_
iteritems = iteritems
related = getattr ( obj , field . name )
try :
import io
status code = NUM_
return self . forms [ self . in itial form count ( ) : ]
def add post render callback ( self , callback ) :
def convert ( self , number , from digits , to digits , sign ) :
host validation re = re . compile ( r " STR_ " )
else :
def str ( self ) :
self . cc = list ( cc )
raise e
return result
compile func = self . tags [ command ]
else :
else :
ext = base [ - NUM_ : ] + ext
import warnings
get method function = operator . attrgetter ( meth func )
request = sys . modules [ name + " STR_ " ]
content subtype = STR_
from django . core . management . sql import sql flush
for opt in [ STR_ , STR_ , STR_ ] :
for node in self :
def handle ( self , * fixture labels , ** options ) :
if len ( bits ) < NUM_ :
LocaleRegexProvider . init ( self , regex )
def get ( self , key , default = None , version = None ) :
def clean ( self ) :
field = Model . meta . get field ( field name )
if propagate is not None :
pass
@ wraps ( view func , assigned = available attrs ( view func ) )
setattr ( self . wrapped , name , value )
return mail . send ( )
format modules cache = { }
if os . fork ( ) > NUM_ :
iterlists = " STR_ "
if len ( unique check ) == NUM_ :
raise CommandError ( STR_ % in valid tag )
truncate = property ( lambda self : self . file . truncate )
UnlockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , LPOVERLAPPED ]
def wordcount ( value ) :
from decimal import Decimal , DecimalException
from django . test . utils import get runner
kwargs = kwargs or { }
if decompress :
def in ner ( self , * args ) :
return ZERO
def cut ( value , arg ) :
def add arguments ( self , parser ) :
try :
args =
stream = self . stream
from django . http . response import ( HttpResponse , StreamingHttpResponse , HttpResponseRedirect , HttpResponsePermanentRedirect , HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden , HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone , HttpResponseServerError , Http404 , BadHeaderError , JsonResponse )
def urlquote plus ( url , safe = ) :
self . file = BytesIO ( )
def init ( self , * args , ** kwargs ) :
if settings . DEBUG :
self . num pages = in t ( ceil ( hits / float ( self . per page ) ) )
return None
self . can read . release ( )
msgs = fp . read ( )
def get width ( self ) :
clean data = [ ]
import bpython
return self . as widget ( ) + self . as hidden ( only initial = True )
return
if STR_ in cc and STR_ in kwargs :
register serializer ( format , BUILTIN SERIALIZERS [ format ] , serializers )
attrs [ STR_ ] = exclude
def cull ( self ) :
except KeyError :
return not ( ( converter ( opts . db table ) in tables ) or ( opts . auto created and converter ( opts . auto created . meta . db table ) in tables ) )
if not self . is rendered :
file move safe ( tmp path , fname , allow overwrite = True )
return { }
if STR_ not in template :
return Truncator ( value ) . chars ( length )
def render ( self , name = None , value = None , attrs = None , choices = ( ) ) :
field params [ STR_ ] = row [ NUM_ ]
import module ( STR_ , app config . name )
def n ( self ) :
if safe input :
return list ( self . iteritems ( ) )
def urlconf module ( self ) :
if self . field . required and hasattr ( self . form , STR_ ) :
or ig vars . pop ( slots var )
result . parent = self
def wrapped ( * args , ** kwargs ) :
raise NotImplementedError ( " STR_ " " STR_ " )
attrs [ STR_ ] = labels
constant re = re . compile ( r " " " STR_ " . * ? " STR_ " " " )
root = config . get ( STR_ , None )
elif is in stance ( value , datetime . time ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
form . fields [ DELETION FIELD NAME ] = BooleanField ( label = ( STR_ ) , required = False )
from django . utils . deprecation import RemovedInDjango19Warning
def as tuple ( self , value ) :
try :
from django . template . loader import get template , select template
raise CommandError ( " STR_ " " STR_ " )
if settings . configured :
addr = parseaddr ( force text ( addr ) )
result = SimpleLazyObject ( self . setupfunc )
if self . is url ( template ) :
return len ( self . content )
if hasattr ( signal , STR_ ) :
if not plan :
repr attr = self . wrapped
def archive cls ( file ) :
return self . g ( )
return form
return trans . activate ( language )
from . import Error , Tags , register
else :
def init ( self , template string , or igin ) :
handler . addQuickElement ( " STR_ " , item [ " STR_ " ] , { " STR_ " : " STR_ " } )
self . xml . characters ( smart text ( key value ) )
def widget attrs ( self , widget ) :
output . append ( STR_ )
self . cookies [ key ] [ STR_ ] = max age
if not lookup :
@ property
response = response . render ( )
if self . save as new :
if status ! = STATUS OK :
for dict in self . dicts :
forms = . join ( form . as table ( ) for form in self )
class EntitiesForbidden ( DefusedXmlException ) :
super ( Command , self ) . execute ( * args , ** options )
self . location = abspathu ( self . base location )
if compare to ! = state frame [ self ] :
if colors and colors [ - NUM_ ] in color names :
self . style = no style ( )
for loc in locales :
self . content type extra = content type extra
return value
for type in reversed ( resultclass . mro ( ) ) :
location = urljoin ( current uri , location )
file . close ( )
return datetime . datetime . strptime ( force str ( value ) , format )
state = self . dict . copy ( )
d =
if row is None :
super ( MultiValueDict , self ) . setitem ( key , [ value ] )
self . current [ field . name ] = value
def add arguments ( self , parser ) :
normalize newlines = allow lazy ( normalize newlines , six . text type )
class ImproperlyConfigured ( Exception ) :
self . seek ( NUM_ )
autoreload . main ( self . in ner run , None , options )
from django . core . servers . fastcgi import FASTCGI HELP
if row [ NUM_ ] :
return data . getlist ( name )
super ( QueryDict , self ) . delitem ( key )
add to builtins ( STR_ )
replaces . append ( ( migration . app label , migration . name ) )
raise ImproperlyConfigured ( msg . format ( name = self . urlconf name ) )
widget = widget ( )
if " STR_ " in self . starttag text :
os . rmdir ( or iginal path )
if i < NUM_ ** factor :
result = [ ]
root = logging . root
disable existing = config . pop ( STR_ , True )
f . save form data ( in stance , cleaned data [ f . name ] )
errors = [ ]
syear = " STR_ " % ( dt . year , )
self . test runner = arg [ len ( option ) : ]
else :
def get ( self , key , default = None ) :
server address = ( addr , port )
def upath ( path ) :
self . use tz = use tz
output transaction = True
if self . verbosity > NUM_ :
db = router . db for read ( self . cache model class )
class DjangoRuntimeWarning ( RuntimeWarning ) :
items = iteritems
from django . utils . html import ( conditional escape , escapejs , escape , urlize as urlize , linebreaks , strip tags , avoid wrapping , remove tags )
def repr ( self ) :
self . common logger config ( logger , config , in cremental )
warnings . warn ( STR_ STR_ )
help = STR_
return get connection ( backend = self . email backend , fail silently = True )
return STR_ . join ( statements )
else :
import sys
def init ( self , attrs = None , choices = ( ) ) :
def decorator ( klass ) :
endtag re = re . compile ( STR_ % tags re )
r = o . is oformat ( )
def closed ( self ) :
if NUM_ <= response . status code < NUM_ or response . status code in ( NUM_ , NUM_ ) :
return flat
else :
if t in self . dispatch :
activate ( self . timezone )
st = os . stat ( filename )
def parse ( self ) :
from unittest2 import *
else :
bits = token . split contents ( )
def deconstruct ( obj ) :
obj dict = super ( SimpleTemplateResponse , self ) . getstate ( )
p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
t = re . sub ( " STR_ " , lambda m : m . group ( NUM_ ) . lower ( ) , value . title ( ) )
def load template ( self , template name , template dirs = None ) :
data = json . dumps ( data , cls = encoder )
def conditional escape ( text ) :
klass = load command class ( app name , subcommand )
else :
if self . domain regex . match ( domain part ) :
except ImportError :
e . args = ( " STR_ " % ( fixture file , e ) , )
if saved locale is not None :
reason phrase = None
import readline
def parse name ( self , fixture name ) :
def download ( self , url ) :
module = import module ( module path )
if f . name in cleaned data :
if filters :
pass
if charset == STR_ :
return [ etag str ]
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
return self . callback
response = self . get exception response ( request , resolver , NUM_ )
seconds = abs ( seconds )
class BaseHandler ( object ) :
django dir = os . path . normpath ( os . path . join ( os . path . dirname ( django . file ) ) )
connections [ self . using ] . close ( )
if value is None :
raise TemplateSyntaxError ( " STR_ " " STR_ " % subject )
parser . add argument ( STR_ , action = STR_ , dest = STR_ , default = True , help = " STR_ " )
token = get token ( request )
illegal formatting = re . compile ( r " STR_ " )
return
return tpl . format ( self . name , self . sysid , self . pubid )
return pickle . loads ( zlib . decompress ( f . read ( ) ) )
return mark safe ( helper ( value ) )
self . length , self . mime type = length , mime type
try :
if STR_ not in config :
serializers . get serializer ( format )
try :
data = [ ]
class EmailBackend ( BaseEmailBackend ) :
response = http . HttpResponseBadRequest ( )
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = False , help = " STR_ " " STR_ " )
seen models . add ( model )
in trans = False
raise CommandError ( " STR_ " " STR_ " % self . program )
delattr ( obj . class , self . name )
request started = Signal ( )
def proxy method ( self , * args , ** kwargs ) :
return in put val
raise TemplateSyntaxError ( " STR_ " )
self . stdout . write ( errors )
def get parent ( self , context ) :
return import string ( import path or settings . DEFAULT FILE STORAGE )
if use func :
raise TypeError
def value from datadict ( self , data , files , name ) :
opts = self . meta
if not f . blank and not form field . required and field value in form field . empty values :
cache key = STR_ % ( key prefix , url . hexdigest ( ) )
not ifier . check events ( timeout = None )
resolved kwargs = dict ( ( k , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
write ( arg )
return t [ NUM_ ] . lower ( ) , t [ NUM_ ]
elif item [ " STR_ " ] :
mode = STR_ if is in stance ( chunk , bytes ) else STR_
definition = { }
callback = callback . func
try :
return mark safe ( force text ( value ) . translate ( js escapes ) )
if bit . startswith ( STR_ ) or bit . startswith ( " STR_ " ) :
trimmed = trim url ( middle )
for path in paths :
if error . params :
def next ( self ) :
if empty label is not None :
self . assert mutable ( )
non atomic requests = getattr ( view , STR_ , set ( ) )
self . waiting readers = NUM_
opts = model . meta
requires system checks = False
for model in app models :
def O ( self ) :
result = getattr ( default , translation function ) ( eol message )
return self . non form errors
def delete many ( self , keys , version = None ) :
from future import unicode literals
hour , minute = divmod ( timezone , NUM_ )
return nodelist
if settings . USE TZ and value is not None and timezone . is naive ( value ) :
self . stdout . write ( STR_ + self . style . SQL KEYWORD ( connection . ops . end transaction sql ( ) ) )
pass
return self . filter expr . resolve ( context )
def get many ( self , keys , version = None ) :
try :
from future import unicode literals
for entry in os . listdir ( path ) :
def b64 decode ( s ) :
@ cached property
self . autoescape = autoescape
from django . core . management . sql import check for migrations
@ property
from django . core . servers . fastcgi import runfastcgi
from subprocess import PIPE , Popen
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango20Warning )
def clean ( self , data , in itial = None ) :
break
use natural keys = options . get ( STR_ )
from django . utils . timezone import is aware , utc
class IfChangedNode ( Node ) :
super = super
@ property
elif ch == STR_ :
raise TemplateDoesNotExist
return self . environ . get ( STR_ )
locks . lock ( fd , locks . LOCK EX )
raise TemplateSyntaxError ( " STR_ " " STR_ " % bits [ NUM_ ] )
self . compression formats = { None : ( open , STR_ ) , STR_ : ( gzip . GzipFile , STR_ ) , STR_ : ( SingleZipReader , STR_ ) , }
setattr ( base , old method name , wrapper ( new method ) )
new path = path [ match . end ( ) : ]
return result [ NUM_ ] , result [ NUM_ ]
new permissions = stat . S IMODE ( st . st mode ) | stat . S IWUSR
return token
return result
for i , item in enumerate ( values ) :
class RemovedInDjango19Warning ( DeprecationWarning ) :
return trans . ngettext ( singular , plural , number )
class TarArchive ( BaseArchive ) :
natural = value . natural key ( )
cookie allows colon in names = False
memoryview = memoryview
converter = getattr ( self , converter )
def GET ( self ) :
class metaclass ( meta ) :
def ngettext ( singular , plural , number ) :
def lists ( self ) :
def handle ( self , ** options ) :
parser . add argument ( STR_ , STR_ , action = STR_ , dest = STR_ , default = False , help = STR_ )
return repr ( list ( self ) )
del cache [ oldkey ]
self . done = True
class SuspiciousFileOperation ( SuspiciousOperation ) :
def app dict ( self ) :
except ImportError as e :
regexes = self . regexes
os . umask ( umask )
if formfield callback is None :
renamed = True
if latest date is None or item date > latest date :
import os
return value . date ( )
fields = [ ( field name , attrs . pop ( field name ) ) for field name , obj in list ( six . iteritems ( attrs ) ) if is in stance ( obj , Field ) ]
import errno
import types
output . append ( label output )
allow multiple selected = True
link [ NEXT ] = root
return valid
cmp fmts = list ( self . compression formats . keys ( ) ) if cmp fmt is None else [ cmp fmt ]
return filter func
import sys
else :
class Page ( collections . Sequence ) :
self . kwargs = kwargs
update wrapper ( wrapper , func )
return chain ( * [ [ format html ( STR_ , self . absolute path ( path ) , medium ) for path in self . css [ medium ] ] for medium in media ] )
return result
class PermissionDenied ( Exception ) :
opts = new class . meta = ModelFormOptions ( getattr ( new class , STR_ , None ) )
for d in self . dicts [ - NUM_ ] :
return hmac . compare digest ( force bytes ( val1 ) , force bytes ( val2 ) )
def merge ( self , other ) :
@ register . filter ( is safe = True )
else :
self . blocks = defaultdict ( list )
y = data . get ( self . year field % name )
filelist = self . list cache files ( )
return self . dt ,
def render ( self , name , value , attrs = None ) :
import logging . handlers
def get nodes by type ( self , nodetype ) :
filename = ( STR_ , , filename )
class CheckboxChoiceInput ( ChoiceInput ) :
from django . utils import six
while True :
encoding = None
from django . utils . six . moves import xrange
else :
return not ( v is False or v is None or v == )
def url ( self , name ) :
def tzname ( self , dt ) :
def translate token ( self , token ) :
def bound func ( * args2 , ** kwargs2 ) :
if is in stance ( value , six . string types ) :
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
def init ( self , class name , old method name , new method name , deprecation warning ) :
result = self . configurator . convert ( value )
import mimetypes
pass
else :
yield base . DeserializedObject ( obj , m2m data )
if STR_ not in var and STR_ not in var . lower ( ) :
from future import unicode literals
for table name in connection . in trospection . table names ( cursor ) :
def render ( self , context ) :
backend cls = import string ( backend )
def parse time ( value ) :
except smtplib . SMTPException :
self . is bound = data is not None or files is not None
with lock :
def len ( self ) :
from lib2to3 . pgen2 import token
self . xml . startElement ( " STR_ " , { } )
self . file . write ( raw data )
else :
if template tuple is TemplateDoesNotExist :
from django . utils . functional import allow lazy , SimpleLazyObject
def widget attrs ( self , widget ) :
output = [ ]
self . validate key ( key )
if not self . user regex . match ( user part ) :
memoryview = memoryview
opts = model . meta
j = match . end ( )
else :
if not serializers :
try :
for d in reversed ( self . dicts ) :
for path to remove in self . paths to remove :
self . stream . write ( " STR_ " )
args . append ( ( True , Variable ( var arg ) ) )
class ExternalReferenceForbidden ( DefusedXmlException ) :
yield " STR_ "
else :
if data list :
class CheckboxInput ( Widget ) :
if options [ STR_ ] :
return self . set cookie ( key , value , ** kwargs )
flags = ( os . O WRONLY | os . O CREAT | os . O EXCL | getattr ( os , STR_ , NUM_ ) )
changes = autodetector . changes ( graph = executor . loader . graph )
def render ( self , context ) :
self . setup ( )
else :
def npath ( path ) :
def explode shorthand ip string ( ip str ) :
prefix = settings . MEDIA URL
field list = [ ]
errors . extend ( check middleware classes ( ** kwargs ) )
self . validate name ( app name , " STR_ " )
def check programs ( * programs ) :
return format html ( STR_ , flatatt ( final attrs ) )
raise NotImplementedError ( STR_ )
yield
fp = six . BytesIO ( )
msg += STR_
def add arguments ( self , parser ) :
return None
self . extra context [ name ] = var
else :
except AmbiguityError :
def get library ( library name ) :
def repr ( self ) :
try :
existing headers = set ( header . lower ( ) for header in vary headers )
def make writeable ( self , filename ) :
@ register . filter ( is safe = True , needs autoescape = True )
if self . to field :
return result
raise ImproperlyConfigured ( STR_ % self . file path )
use base manager = options . get ( STR_ )
if last == NUM_ :
except ValueError :
threading = options . get ( STR_ )
d = self . config [ m . groups ( ) [ NUM_ ] ]
if not hasattr ( e , STR_ ) :
def template localtime ( value , use tz = None ) :
if args :
status code = NUM_
class Deserializer ( six . Iterator ) :
def sync apps ( self , connection , app labels ) :
week number -= NUM_
return self . form . errors . get ( self . name , self . form . error class ( ) )
ending = self . ending if ending is None else ending
class Literal ( TokenBase ) :
stream . unget ( chunk )
process all = options . get ( STR_ )
if fd . is atty ( ) :
all = [ STR_ ]
if size :
self . stdout . write ( self . style . MIGRATE SUCCESS ( " STR_ " ) )
if location is None :
if weight >= NUM_ :
except KeyError :
def read ( self , size = None ) :
if response . streaming :
def exit ( self , * args , ** kwargs ) :
def render ( self , name , value , attrs = None , choices = ( ) ) :
else :
else :
for name in MEDIA TYPES :
token = parser . next token ( )
def expression ( self , rbp = NUM_ ) :
self . allow files , self . allow folders = allow files , allow folders
raise TemplateSyntaxError ( " STR_ " " STR_ " % node )
self . changed objects = [ ]
else :
warnings . warn ( " STR_ " " STR_ " , RemovedInDjango19Warning , stacklevel = NUM_ )
if key func is not None :
def update error dict ( self , error dict ) :
app = TerminalIPythonApp . in stance ( )
except ImportError :
self . base fields [ MIN NUM FORM COUNT ] = IntegerField ( required = False , widget = HiddenInput )
if opts . model :
output . extend ( connection . ops . prepare sql script ( fp . read ( ) , allow fallback = True ) )
simple url 2 re = re . compile ( r STR_ , re . IGNORECASE )
return self . expression . resolve ( context , True )
if file :
error dict . setdefault ( NON FIELD ERRORS , [ ] ) . extend ( self . error list )
if path . exists ( absolute path ) :
val = None
encoding = property ( lambda self : self . file . encoding )
processors = [ ]
if is in stance ( s , Promise ) :
return default key func
return SafeBytes ( s )
def get connection ( self , fail silently = False ) :
except AttributeError :
def init ( self , in put formats = None , * args , ** kwargs ) :
raise ValueError ( " STR_ " )
klass . unicode = klass . str
description = " STR_ " % receiver . class . name
import warnings
else :
else :
statements = sql custom ( app config , self . style , connection )
return
@ register . filter ( is safe = False )
def iter ( self ) :
connection . close ( )
def init ( self , args , kw ) :
safe input = is in stance ( text , SafeData )
for item in elt :
if self . require all fields :
return True
context [ self . asvar ] = url
if field is not None :
ALLOWED VARIABLE CHARS = ( STR_ STR_ )
self . close called = True
def read ( self , size = None ) :
try :
length = in t ( arg )
class DebugVariableNode ( VariableNode ) :
def repr ( self ) :
value = super ( IntegerField , self ) . to python ( value )
clear checkbox label = ugettext lazy ( STR_ )
absolute path = self . download ( template )
return found
if e . errno ! = errno . ENOENT :
class DeserializationError ( Exception ) :
except ( ValueError , TypeError , OverflowError ) :
exclude . append ( f . name )
return self . as table ( )
quit command = STR_ if sys . platform == STR_ else STR_
ch , escaped = next ( pattern iter )
from django . utils import formats
self . name = name
def dec ( * args , ** kwargs ) :
html [ STR_ ] = self . create select ( name , self . month field , value , month val , choices , self . month none value )
msg data = msg . as bytes ( )
stream created = self . open ( )
return self . dicts [ - NUM_ ] . get ( key , otherwise )
reverse = complain
def add arguments ( self , parser ) :
builtins . append ( import library ( module ) )
except Exception :
in itial set = set ( force text ( value ) for value in self . prepare value ( in itial ) )
reset sequences = options . get ( STR_ , True )
value = getattr ( self , STR_ % name ) ( )
self . verbosity = options . get ( STR_ )
self . number = number
class ErrorDict ( dict ) :
lead , trail = escape ( lead ) , escape ( trail )
var obj = None
def validate ( self , app config = None , display num errors = False ) :
for app name , model list in manifest . items ( ) :
all issues = checks . run checks ( app configs = app configs , tags = tags )
options [ option ] = value
@ register . filter ( is safe = False )
def init ( self , level , msg , hint = None , obj = None , id = None ) :
self . xml . endDocument ( )
if not sys . warnoptions :
def init ( self , request , template , context = None , content type = None , status = None , current app = None ) :
def serialize ( self , queryset , ** options ) :
parts = parts [ : - NUM_ ]
kw = dict ( ( k , in t ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
urlunquote = allow lazy ( urlunquote , six . text type )
def populate ( self ) :
pass
raise v
@ stringfilter
post = STR_
self . backout = [ ]
name = self . format ( STR_ )
loop dict [ STR_ ] = len values - i
class CacheHandler ( object ) :
def get major version ( version = None ) :
if f . rel and f . rel . to not in to delete :
add doc ( reraise , " " " STR_ " " " )
def timesince filter ( value , arg = None ) :
if sender and getattr ( sender , STR_ , False ) :
errors = [ e for e in all issues if checks . ERROR <= e . level < checks . CRITICAL ]
loop dict [ STR_ ] = i + NUM_
try :
cycle iter = context . render context [ self ]
try :
if not self :
class MediaDefiningClass ( type ) :
if is protected type ( value ) :
from django . utils . safestring import mark safe
result . append ( " STR_ " )
version = self . version
return six . text type ( s , encoding , STR_ )
value = value . encode ( charset )
if is in stance ( app name , BaseCommand ) :
return s [ NUM_ : - NUM_ ] . replace ( r STR_ % quote , quote ) . replace ( r STR_ \ \ )
if errors :
if bits and not kwarg format :
class MaxLengthValidator ( BaseValidator ) :
if self . verbosity > NUM_ or self . in teractive :
bits = list ( token . split contents ( ) )
if self . locale paths :
not ifier . process events ( )
from django . utils . six . moves import html parser as html parser
return field . to python
while new name . find ( STR_ ) >= NUM_ :
if STR_ in kwargs :
else :
raise
if varargs is None :
else :
tried . extend ( [ pattern ] + t for t in sub tried )
key = self . make key ( key , version = version )
return File ( open ( self . path ( name ) , mode ) )
return
template = get template from string ( template , or igin , template name )
if " STR_ " ) :
return STR_ % self . data . month
return get template ( template name , dirs )
from django . db . migrations . loader import AmbiguityError
tried . append ( [ pattern ] )
return self . truncate html ( length , truncate , self . wrapped , length , True )
return result
import warnings
self . paginator = paginator
except ImportError :
forms to delete = self . deleted forms
def init ( self , key = None , sep = STR_ , salt = None ) :
def run validators ( self , value ) :
raise self . error ( token , " STR_ " )
key = self . cache key ( name , dirs )
return str ( STR_ ) % ( value , self . sep , self . signature ( value ) )
from django . utils import datastructures
dirnames . remove ( dirname )
raise CommandError ( " STR_ " " STR_ " " STR_ " " STR_ " % new path )
return self . tag function ( name )
if ch2 == STR_ :
try :
def init ( self ) :
token = self . next token ( )
return dec
return [ smart text ( val ) for val in value ]
if kwargs :
self . configure logger ( name , loggers [ name ] , True )
output transaction = True
def get serializer formats ( ) :
attrs = { }
if settings . USE L10N and is in stance ( value , six . string types ) :
memo [ id ( self ) ] = obj
import sys
data = raw data
pass
cookie encodes correctly = http cookies . SimpleCookie ( ) . value encode ( STR_ ) == ( STR_ , STR_ )
raise CommandError ( " STR_ " % ( migration name , app label ) )
if self . verbosity >= NUM_ :
if not is in stance ( list , ( tuple , list ) ) or len ( list ) ! = NUM_ :
def cast ( self ) :
if not chunks :
chunk size = NUM_ * NUM_ ** NUM_
final attrs = self . build attrs ( attrs , name = name )
if not is in stance ( i , six . in teger types ) :
else :
if year < NUM_ :
return super ( SimpleTemplateResponse , self ) . iter ( )
key += tuple ( type ( v ) for k , v in sorted items )
compiled result = compile func ( self , token )
return None
if type ( s ) == bytes :
return [ ]
self . toks = { }
if media :
self . version = params . get ( STR_ , NUM_ )
unicode value = force text ( value , strings only = True )
class ModelFormOptions ( object ) :
attrs = [ " STR_ " , " STR_ " ]
try :
import django . core . checks . compatibility . django 1 6 0
try :
def get filename ( self ) :
result = cursor . fetchone ( )
return proxy ( args , kw )
continue
super ( TemporaryFileUploadHandler , self ) . new file ( file name , * args , ** kwargs )
callback = pattern . callback
class MinValueValidator ( BaseValidator ) :
doublecolon len = NUM_
def translation ( language ) :
for app label in app labels :
if escaped :
for dirpath , dirnames , filenames in os . walk ( root , topdown = True , followlinks = self . symlinks ) :
smart unicode = smart text
setattr ( Module six moves urllib request , attr . name , attr )
from django . utils import lru cache
from logging import checkLevel
cached = format cache [ cache key ]
super ( IntegerField , self ) . init ( * args , ** kwargs )
from django . db import models
except Exception as e :
self . choice value = force text ( choice [ NUM_ ] )
raise NotImplementedError ( STR_ )
def in dexbytes ( buf , i ) :
pass
def get str from wsgi ( environ , key , default ) :
return self . format ( STR_ )
candidate subs = dict ( ( k , urlquote ( v ) ) for ( k , v ) in candidate subs . items ( ) )
def repr ( self ) :
for part in parts :
continue
except ImportError :
from collections import OrderedDict
def get fixed timezone ( offset ) :
def send messages ( self , email messages ) :
return default
return in put val
s len = NUM_
self . registered checks . append ( check )
obj . save ( using = self . using )
if comment lineno cache == cur lineno :
new value . append ( self . coerce ( choice ) )
help = " STR_ "
if self . setting :
from django . db import models
if level not in logging . levelNames :
def init ( self , server , params ) :
return True
os . makedirs ( directory , self . directory permissions mode )
handler . addQuickElement ( " STR_ " , self . feed [ STR_ ] )
return
return generate cache key ( request , request . method , [ ] , key prefix )
self . flags = flags
for app name in app names :
def split statements ( content ) :
return
return value
@ stringfilter
self . months = MONTHS
if settings . USE ETAGS and not response . has header ( STR_ ) :
checks = [ check for check in self . registered checks if hasattr ( check , STR_ ) and set ( check . tags ) & set ( tags ) ]
from django . utils import six
try :
if default list is None :
r = dklen - ( l - NUM_ ) * hlen
def urlencode ( self , safe = None ) :
return WithNode ( None , None , nodelist , extra context = extra context )
upto = NUM_
from functools import total ordering
with connections [ db ] . cursor ( ) as cursor :
import datetime
def get wsgi application ( ) :
model identifier = node . getAttribute ( attr )
parsed = True
self . default args = default args or { }
continue
FILTER ARGUMENT SEPARATOR = STR_
else :
want unicode = True
Y2 = r STR_
for localedir in reversed ( settings . LOCALE PATHS ) :
self . caches . caches = { }
requires system checks = False
old umask = os . umask ( NUM_ )
if jan1 weekday > NUM_ :
if self . verbosity >= NUM_ :
pass
return [ ]
expires = timezone . make naive ( expires , timezone . utc )
def content ( self , value ) :
src data = prepare js for gettext ( src data )
pass
try :
raise DisallowedHost ( msg )
if obj list is None :
return number format ( value )
if len ( s ) > NUM_ :
exec ( " " " STR_ " " " )
if hasattr ( pattern , STR_ ) :
if self . validate unique :
if hasattr ( content , STR_ ) :
from django . utils import six
from future import unicode literals
raise ValidationError ( self . error messages [ STR_ ] , code = STR_ )
targets = [ ( app label , migration . name ) ]
self . urlconf name = urlconf name
if name in MEDIA TYPES :
return self . encoding
class RenameMethodsBase ( type ) :
if language code not in self . reverse dict :
try :
output . append ( STR_ % field )
if self . domain == STR_ :
else :
def validate ipv46 address ( value ) :
key = self . make key ( key , version = version )
self . choices = choices
formatters [ name ] = self . configure formatter ( formatters [ name ] )
if not e . connection reset :
try :
super ( ManagementForm , self ) . init ( * args , ** kwargs )
extra files = [ ]
return os . path . join ( self . dir , . join ( [ hashlib . md5 ( force bytes ( key ) ) . hexdigest ( ) , self . cache suffix ] ) )
utf8 charset . body encoding = None
COMMENT TAG START = STR_
ensure echo on ( )
related = related . natural key ( )
if response . has header ( STR_ ) :
@ register . filter ( " STR_ " , is safe = True )
return cache [ mem args ]
parser . add argument ( STR_ , action = STR_ , dest = STR_ , help = STR_ )
from django . apps import apps
return path
self . delete ( f . name )
for app config in apps . get app configs ( ) :
if ( i - day of year ) < ( NUM_ - weekday ) :
class HashedSeq ( list ) :
self . connection = connection
def find boundary ( self , data , eof = False ) :
self . render context = RenderContext ( )
u = salt + struct . pack ( b STR_ , i )
class Node ( object ) :
except Exception as e :
format key = STR_
neg = NUM_
except ValueError :
all = ( STR_ , STR_ , STR_ , STR_ )
self . view name = STR_ . join ( self . namespaces + [ view path ] )
super ( URLValidator , self ) . call ( url )
from django . core . management . base import BaseCommand , CommandError
with open ( writer . path , " STR_ " ) as fh :
raise TemplateDoesNotExist ( name )
continue
self . stdout . write ( STR_ . join ( sorted ( registry . tags available ( ) ) ) )
if not is in stance ( message , ValidationError ) :
def getitem ( self , idx ) :
while i < len ( subject ) and subject [ i ] not in ( , STR_ ) :
slots = STR_
parser . delete first token ( )
for filename in gen filenames ( ) :
blocks = dict ( ( n . name , n ) for n in compiled parent . nodelist . get nodes by type ( BlockNode ) )
@ python 2 unicode compatible
def assertRegex ( self , * args , ** kwargs ) :
except ImproperlyConfigured :
return encoding
continue
latest date = None
none value = ( NUM_ , STR_ )
if o . microsecond :
if self . is olated context :
def i ( self ) :
parts . reverse ( )
cache [ key ] = result
def init ( self , template string , or igin = None , name = None ) :
sublist = helper ( sublist item , tabs + NUM_ )
def contains ( self , item ) :
@ register . filter ( is safe = True )
i += NUM_
def get template ( template name , dirs = None ) :
nodelist . append ( node . render ( context ) )
def get many ( self , keys , version = None ) :
for field in concrete model . meta . local fields :
if t is not None :
global default
return self . offset
if ( is in stance ( fp , file ) and is in stance ( data , unicode ) and fp . encoding is not None ) :
REQUEST = property ( get request )
except OSError as e :
try :
return lookup view
return False
token . lineno = self . lineno
def content ( self , value ) :
def render ( self , context ) :
timezone = get current timezone ( )
result args [ i ] . append ( param )
elif not is in stance ( sep , str ) :
return trans . ugettext ( message )
return self . as table ( )
if self . META . get ( STR_ , ) . startswith ( STR_ ) :
user part , domain part = value . rsplit ( STR_ , NUM_ )
else :
import sys
except AttributeError :
if six . PY2 :
return ipv4 unpacked
supported = None
def create variable node ( self , filter expression ) :
except :
class ModelChoiceIterator ( object ) :
class DebugNode ( Node ) :
if app config . models module is None :
result . key = key
def with metaclass ( meta , * bases ) :
if hasattr ( message , STR_ ) :
self . empty value = kwargs . pop ( STR_ , [ ] )
content = token string [ NUM_ : - NUM_ ] . strip ( )
from future import unicode literals
elif ch == " ^ " :
def sql delete ( app config , style , connection , close connection = True ) :
def parse bits ( parser , bits , params , varargs , varkw , defaults , takes context , name ) :
class StreamingBuffer ( object ) :
from django . forms . widgets import *
def escape ( text ) :
if definition :
if self . field . choice cache is None :
child nodelists = ( STR_ , STR_ )
try :
if not is in stance ( value , ( list , tuple ) ) :
help = " STR_ "
from django . core import mail
self . name = " STR_ " % ( sign , abs ( offset ) / NUM_ , abs ( offset ) % NUM_ )
self . content type = None
now = datetime . utcnow ( )
def copy ( self ) :
break
assert token . contents == STR_
raise ImproperlyConfigured ( " STR_ " % loader )
def init ( self , lexer ) :
self . asvar = asvar
if six . PY3 :
raise AttributeError ( " STR_ " )
app label = options [ STR_ ]
if not self . fail silently :
def created time ( self , name ) :
return [ ]
self . active readers -= NUM_
return number
if name . lower ( ) in ( from , STR_ ) :
BASE16 ALPHABET = STR_
if response :
time str = date . strftime ( STR_ % ( dow , month ) )
confirm = in put ( " " " STR_ " " " % connection . settings dict [ STR_ ] )
if value in self . empty values :
if self . connector == conn type :
def get connection ( backend = None , fail silently = False , ** kwds ) :
while i < list length :
return datetime . date ( ** kw )
cursor = connection . cursor ( )
end = kwargs . pop ( " STR_ " , None )
raise CommandError ( " STR_ " % ( url , filename , e ) )
else :
from importlib import import module
return
cookie allows colon in names = True
except Exception as e :
format locations . append ( STR_ )
self . to field = kwargs . pop ( " STR_ " , None )
return s . getvalue ( )
def new ( cls , * args , ** kwargs ) :
for name , app in six . iteritems ( get commands ( ) ) :
raise MultiPartParserError ( STR_ )
self . new objects = [ ]
else :
return klass
curr =
self . object list = list ( self . object list )
def get language from request ( request , check path = False ) :
counters = [ NUM_ ] * len ( handlers )
except KeyError :
return it . next ( )
if self . verbosity > NUM_ :
output . append ( widget . render ( name + STR_ % i , widget value , final attrs ) )
scheme = template . split ( STR_ , NUM_ ) [ NUM_ ] . lower ( )
if buffer :
warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = NUM_ )
return mark safe ( urlize ( value , trim url limit = in t ( limit ) , nofollow = True , autoescape = autoescape ) )
continue
if str ( STR_ ) in value or str ( STR_ ) in value :
current = getattr ( current , bit )
def media ( request ) :
return
def getitem ( self , key ) :
if hasattr ( self , STR_ ) :
from django . utils . translation import ugettext lazy , pgettext lazy
from django . template . base import TemplateDoesNotExist
def del ( self ) :
if not f . editable or is in stance ( f , models . AutoField ) or f . name not in cleaned data :
def content ( self ) :
if settings . USE L10N :
wsgi opts [ STR_ ] = options [ " STR_ " ]
tables = connection . in trospection . django table names ( only existing = True )
self . extensions = handle extensions ( exts )
self . app name = app name
def as ul ( self ) :
def post clean ( self ) :
class HttpResponseNotFound ( HttpResponse ) :
kwargs = { }
try :
return code
try :
import datetime
def load handler ( path , * args , ** kwargs ) :
self . stdout . write ( " STR_ " % ( len ( operations ) , len ( new operations ) ) )
if args [ - NUM_ ] == " as " :
def pop ( self , k , * args ) :
def write ( data ) :
for c in response . cookies . values ( ) :
except ( ValueError , TypeError ) :
if has bz2 :
super ( RadioChoiceInput , self ) . init ( * args , ** kwargs )
while rest :
return data
value = STR_ . join ( reversed ( parts ) )
app template dirs = calculate app template dirs ( )
in ner . update ( password . translate ( hmac . trans 36 ) )
try :
if attrs is not None :
D = r STR_
@ property
try :
