declare string variable s
declare short int sz
declare boolean called flag = false
read s
for integer i = length of s - 1 to 0 inclusive counting down
if s [ i ] ! = ' / '
sz = i
break the loop
for i = 0 to sz inclusive
if flag = false and s [ i ] = ' / '
set flag to true
print s [ i ]
else if s [ i ] ! = ' / '
set flag to false
print s [ i ]
print ' \ n '
let a be array of chars of length 110
len , i , j = integers
read a
len = length of a
for i = 0 to len exclusive
if a [ j ] ! = ' / ' or a [ i ] ! = ' / ' increment j and set a [ j ] to a [ i ]
decrement j while j > 0 and a [ j ] = = ' / '
set a [ j + 1 ] to " \ 0 "
print a [ i ] in the loop from 0 while a [ i ] is not equal to " \ 0 "
print end of line
let eps be constant long double = 1e - 7
set constant integer inf to 1000000010
set constant integer mod to 1000000007
set constant integer MAXN to 100010
declare strings called s and t
read input into s
set value of t to s [ 0 ]
for integer i = 1 to length of s exclusive
if s [ i ] = = ' / ' and s [ i - 1 ] is equal to ' / ' continue the loop
increase t by s [ i ]
if last element of t is equal to ' / ' , set t to t . substr ( 0 , t . size ( ) - 1 )
if t is an empty string set t to " / "
print t and a new line
create constant long double eps with eps = 1e - 7
creat constant integer inf with inf = 1000000010
create constant integer mod with mod = 1000000007
create constant integer MAXN with MAXN = 100010
create strings s , t
read line from cin to s
set t to s [ 0 ]
for i = 1 to size of s
if s [ i ] is ' / ' and s [ i - 1 ] is ' / ' , break current loop iteration
increment t by s [ i ]
if t [ size of t - 1 ] is ' / ' , set t to substring of t starting at 0 to size of t - 1
if t is " " , set t to " / "
print t print newline
declare string variable str
read str
ans is vector of characters
assign value false to the boolean flag
for long long i from 0 to length of str exclusive
if str [ i ] is ' / '
if flag is true , continue
set flag to true
else
set flag to false
push str [ i ] into ans
for i = 0 to length of ans exclusive
if length of ans > 1 and i = length of ans - and ans [ i ] = ' / ' , continue the loop
print ans [ i ]
print new line
create string str
read str
create character vector ans
create boolean flag with flag = false
for i = 0 to size of str exclusive
if str [ i ] is ' / '
if flag is true , break current loop iteration
set flag to true
else
set flag to false
add element str [ i ] to end of ans
for i = 0 to size of ans exclusive
if size of ans is greater than 1 and i is size of ans - 1 and ans [ i ] is ' / ' , break current loop iteration
print ans [ i ]
print newline
s = string
read s
create integer t with value 2
declare empty strings ans and temps
set value of booleans chk and lol to false
for integer i = 0 to size of s exclusive
if isalpha ( s [ i ] )
increase temps by s [ i ]
set chk to true
else
if chk is true
append string " / " + temps to ans
set value of temps to an empty string
set chk to false
set lol to true
if temps is not empty attach " / " and temps to ans
if and is empty and lol is true append character " / " to ans
print ans and a new line
let s be string
read s
Let l be the size of string s
let n = 0
for i = 0 to n exclusive
if s [ i ] is not equal to s [ i - 1 ] and s [ i ] is equal to /
increment n
print s [ i - 1 ]
if s [ i - 1 ] is not equal to / or n = 0
end of the line
create string s
read s
create integer l with l = size of s
create integer n with n = 0
for i = 1 to l exclusive
if ( s [ i ] is s [ i - 1 ] and s [ i ] is ' / ' ) is false
increment n
print s [ i - 1 ]
if s [ l - 1 ] is not ' / ' or n is 0 , print s [ l - 1 ]
print newline
create constant integer maxn with maxn = 200005
create constant integer mod with mod = 1e9 + 7
create constant double eps with eps = 1e - 8
create constant double PI with PI = acosign of - 1
declare judge with doubles x1 , x2 , x3 , y1 , y2 , y3 as arguments , returning double
if x1 is x2 and y1 is y2 or x2 is x3 and y2 is y3 or x3 is x1 and y3 is y1 , return 0 from function
create double array a with size 3
set a [ 0 ] to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )
set a [ 1 ] to ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 )
set a [ 2 ] to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 )
sort elements from a to a + 3
if a [ 0 ] + a [ 1 ] is a [ 2 ] , return 1 from function
create integer array dx with dx = { 0 , 0 , 1 , - 1 }
create integer array dy with dy = { 1 , - 1 , 0 , 0 }
create doubles x1 , x2 , x3 , y1 , y2 , y3
while read x1 read y1 read x2 read y2 read x3 read y3 is true
if result of run judge with arguments x1 , x2 , x3 , y1 , y2 , y3 is true
print " RIGHT " print newline
else
create integer flag with flag = 0
for i = 0 to 4 exclusive
create doubles xx , yy with xx = x1 + dx [ i ] , yy = y1 + dy [ i ]
if result of run judge with arguments xx , x2 , x3 , yy , y2 , y3 is true
set flag to 1
print " ALMOST " print newline
break loop
if flag is true , break current loop iteration
for i = 0 to 4 exclusive
create doubles xx , yy , with xx = x2 + dx [ i ] , yy = y2 + dy [ i ]
if result of run judge with arguments x1 , xx , x3 , y1 , yy , y3 is true
set flag to 1
print " ALMOST " print newline
break loop
if flag is true , break current loop iteration
for i = 0 to 4 exclusive
create double xx , yy with xx = x3 + dx [ i ] , yy = y3 + dy [ i ]
if result of run judge with x1 , x2 , xx , y1 , y2 , yy is true
set flag to 1
print " ALMOST " print newline
break loop
if not flag , print " NEITHER " print newline
let s be string
while can read input into s
integer sz = size of s
ns = empty string
create integer flag with value 0
for i = 0 to sz exclusive
if s [ i ] is equal to ' / '
increase flag
else
set flag to 0
if flag and 0 or flag is equal to 1 increase ns by s [ i ]
if length of ns is equal to 1
print ns and a new line
else if last element of ns is ' / '
print ns without last symbol and a new line
else
print ns and a new line
create string s
while read s is true
create integer sz with sz = size of s
create string ns with ns = " "
create integer flag with flag = 0
for i = 0 to sz exclusive
if s [ i ] is ' / '
increment flag
else
set flag to 0
if flag is 0 or flag is 1 , increment ns by s [ i ]
if size of ns is 1
print ns print newline
else if ns [ size of ns - 1 ] is ' / '
print substring of ns from 0 to size of ns - 1 , print newline
else
print ns print newline
declare string variable s
read s
let vv be a vector of strings
create integers i and j
n = length of s
str is an empty string , temp is string
set temp to str
if s [ 0 ] is equal to ' / '
push " / " into vv
set value of i to 0
for j = i to n exclusive
if s [ j ] ! = ' / ' , break the loop
set value of i to j
loop while i < n incrementing i
if s [ i ] is equal to ' / '
if temp ! = str , push str into vv
str = " "
for j = i to n exclusive
if s [ j ] is not ' / ' , break
i = j - 1
if i ! = n - 1 , push " / " into vv
else
increase str by s [ i ]
if str ! = temp , push str into vv
print all elements of vv one by one
print ' \ n '
create string s
read s
create string vector vv
create integers i , j
create integer n with n = size of s
create strings str , temp with str = " " ,
set temp to str
if s [ 0 ] is /
add element / to end of vv
set i to 0
for j = i + 1 to n exclusive
if s [ j ] is not / , break loop
set i to j
for i to n exclusive
set s [ i ] to /
if temp is not str , add element str to end of vv
set str to " "
for j = i + 1 to n exclusive
if s [ j ] is not / , break loop
set i to j - 1
if i is not n - 1 , add element / to end of vv
else
increment str by s [ i ]
if str is not temp , add element str to end of vv
for i = 0 to size of vv , print vv [ i ]
print \ n
create constant integer maxn with maxn = 200005
create constant integer mod with mod = 1e9 + 7
create constant double eps with eps = 1e - 8
create constant double PI with PI = acosign of - 1 . 0
declare judge with doubles x1 , x2 , x3 , y1 , y2 , y3 as arguments , returning double
if x1 is x2 and y1 is y2 or x2 is x3 and y2 is y3 or x3 is x1 and y3 is y1 , return 0 from function
create double array a of size 3
set a [ 0 ] to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )
set a [ 1 ] to ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 )
set a [ 2 ] to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 )
sort elements from a to a + 3
if a [ 0 ] + a [ 1 ] is a [ 2 ] , return 1 from function
create integer array dx with dx = { 0 , 0 , 1 , - 1 }
create integer array dy with dy = { 1 , - 1 , 0 , 0 }
create doubles x1 , x2 , x3 , y1 , y2 , y3
while read x1 read y1 read x2 read y2 read x3 read y3 is true
if result of run judge with x1 , x2 , x3 , y1 , y2 , y3 as arguments is true
print " RIGHT " print newline
else
create integer flag with flag = 0
for i = 0 to 4 exclusive
create double xx with xx = x1 + dx [ i ] , yy = y1 + dy [ i ]
if result of run judge with xx , x2 , x3 , yy , y2 , y3 as arguments is true
set flag to 1
print " ALMOST " print newline
break loop
if flag is true , break current loop iteration
for i = 0 to 4 exclusive
create doubles xx , yy with xx = x2 + dx [ i ] , yy = y2 + dy [ i ]
if run judge with arguments x1 , xx , x3 , y1 , yy , y3 is true
set flag to 1
print " ALMOST " print newline
break loop
if flag is true , break current loop iteration
for i = 0 to 4 exclusive
create doubles xx , yy , with xx = x3 + dx [ i ] , yy = y3 + dy [ i ]
if result of run judge with arguments x1 , x2 , xx , y1 , y2 , yy is true
set flag to 1
print " ALMOST " print newline
break loop
if not flag , print " NEITHER " print newline
create constant integer size with size = 101
create character array str with size size
read line from str to size
create boolean flag with flag = false
create character pointer start with start = str
create character pointer s with s = start
create character pointer p with p = start
while value of s is not ' \ 0 '
if value of is is ' / '
if not flag
set flag to true
else
increment s
break current loop iteration
else
set flag to false
set value of p to value of s
increment p
increment s
set value of p to ' \ 0 '
create size_t len with len = string length of str
if len is greater than 1 and str [ len - 1 ] is ' / ' , set str [ len - 1 ] to ' \ 0 '
copy string to str from start
print str
create constant integer size with value 101
create char array str with size size
read line from the input into size
bool flag is false
char pointer start = str
char pointer s = start
char pointer p = start
while * s ! = ' \ 0 '
if * s is equal to ' / '
if flag is false
set value of flag to true
else
increment s
skip the rest of the loop
else
set flag to false
* p = * s
increment p
increment s
* p = ' \ 0 '
len is size_t with value = length of str
if len > 1 & & str [ len - 1 ] is ' / ' , set last symbol of str to ' \ 0 '
copy start to str
print str and a new line
create integers l1 , l2 , l3
create integer arrays a , b , c , d , with a size 5 , b size 5 , c size 5 , d size 5 , create integers j , i
create integer array dix with dix = { 1 , 0 , - 1 , 0 }
create integer array diy with diy = { 0 , 1 , 0 , - 1 }
for i = 1 to 3 inclusive , read a [ i ] read b [ i ]
if l1 + l2 is l3 or l1 + l3 is l2 or l2 + l3 is l1
if l1 is not 0 and l2 is not 0 and l3 is not 0
print " RIGHT " print newline
for i = 1 to 3 inclusive
set c [ 1 ] to a [ 1 ] , set c [ 2 ] to a [ 2 ] , set c [ 3 ] to a [ 3 ]
set d [ 1 ] to b [ 1 ] , set d [ 2 ] to b [ 2 ] , set d [ 3 ] to b [ 3 ]
for j = 0 to 4 exclusive
set c [ i ] to a [ i ] + dix [ j ]
set d [ i ] to b [ i ] + diy [ j ]
if l1 + l2 is l3 or l1 + l3 is l2 or l2 + l3 is l1
if l1 is not 0 and l2 is not 0 and l3 is not 0
print " ALMOST " print newline
print " NEITHER " print newline
create constant integer size with value 101
str = array of characters of length size
read line of length size to str
set boolean flag to false
* start is a char pointer to str
* s is a char pointer to start
* p is a char pointer to start
while value at s ! = ' \ 0 '
if value at s is equal to ' / '
if flag is false
assign value of true to the flag
else
increase s by one
skip the rest of the loop
else
set flag to false
* p = * s
increase p
increase s
* p = ' \ 0 '
len is size_t with value equal to length of str
if len > 1 and str [ len - 1 ] is equal to ' / ' , set str at len - 1 to ' \ 0 '
print start
create constant integer size with size = 101
create character array str of size size
read line into str with maximum size size
create boolean flag with flag = false
create character pointer start with start = str
create character pointer s with s = start
create character pointer p with p = start
while value of s is not \ 0
if value of s is not /
if not flag
set flag to true
else
increment s
break current loop iteration
else
set flag to false
set value of p to value of s
increment p
increment s
set value of p to \ 0
create size_t len with len = string length of str
if len is greater than 1 and str [ len - 1 ] is / , set str [ len - 1 ] to \ 0
print start
d = array of integers of size 6
define function sqr with argument n
return n * n
define function check with string argument s
a , b and c = integers
a = sqr ( d [ 0 ] - d [ 2 ] ) + sqr ( d [ 1 ] - d [ 3 ] )
b = sqr ( d [ 0 ] - d [ 4 ] ) + sqr ( d [ 1 ] - d [ 5 ] )
c = sqr ( d [ 2 ] - d [ 4 ] ) + sqr ( d [ 3 ] - d [ 5 ] )
if ( a , b and c ) are equal to 0 , return
if a + b = c or a + c = b or b + c is equal to a
print s
call exit ( 0 )
let i be integer
call function check with argument " RIGHT \ n "
for i = 0 to 6 exclusive
decrease d [ i ] by one
call function check with argument " ALMOST \ n "
increase d [ i ] by 2
call function check with argument " ALMOST \ n "
decrease d [ i ]
print " NEITHER \ n "
create integer array d with size 6
declare sqr with integer n as argument , returning integer
return n * n from function
declare check with string s as argument , return void
create integers a , b , c
set a to result of run sqr with d [ 0 ] - d [ 2 ] as arguments + result of run sqr with d [ 1 ] - d [ 3 ] as arguments
set b to result of run sqr with d [ 0 ] - d [ 4 ] as arguments + result of run sqr with d [ 1 ] - d [ 5 ] as arguments
set c to result of run sqr with d [ 2 ] - d [ 4 ] as arguments + result of run sqr with d [ 3 ] - d [ 5 ] as arguments
if a and b and c is 0 , return from function
if a + b is c or a + c is b or b + c is a
print s
exit program with code 0
create integer i
for i = 0 to 6 exclusive , read d [ i ]
run check with " RIGHT \ n " as argument
for i = 0 to 6 exclusive
decrement d [ i ]
run check with " ALMOST \ n " as argument
increment d [ i ] by 2
run check with " ALMOST \ n " as argument
decrement d [ i ]
print " NEITHER \ n "
declare check with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , returning boolean
if ( x1 is x2 and y1 is y2 ) or ( x1 is x3 and y1 is y3 ) or ( x3 is x2 and y3 is y2 ) return false from function
if ( y2 - y1 ) * ( y3 - y2 ) is ( x1 - x2 ) * ( x3 - x2 ) return true from function
if ( y3 - y2 ) * ( y1 - y3 ) is ( x2 - x3 ) * ( x1 - x3 ) return true from function
if ( y1 - y3 ) * ( y2 - y1 ) is ( x3 - x1 ) * ( x2 - x1 ) return true from function
return false from function
create integers x1 , y1 , x2 , y2 , x3 , y3
read x1 read y1 read x2 read y2 read x3 read y3
if result of run check with arguments x1 , y1 , x2 , y2 , x3 , y3 is true
print " RIGHT " print newline
if result of run check with arguments x1 - 1 , y1 , x2 , y2 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 + 1 , y1 , x2 , y2 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 - 1 , x2 , y2 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 + 1 , x2 , y2 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 - 1 , y2 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 + 1 , y2 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 , y2 - 1 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 , y2 + 1 , x3 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 , y2 , x3 - 1 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 , y2 , x3 + 1 , y3 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 , y2 , x3 , y3 - 1 is true
print " ALMOST " print newline
if result of run check with arguments x1 , y1 , x2 , y2 , x3 , y3 + 1 is true
print " ALMOST " print newline
print " NEITHER " print newline
declare check with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , returning boolean
create integers a , b , c
set a to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )
set b to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 )
set c to ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 )
if a is 0 or b is 0 or c is 0 , return 0 from function
if a + b is c or a + c is b or b + c is a
return 1 from function
else
create integer arrays x1 , y1 with x1 size 4 , y1 size 4
for i = 0 to 3 exclusive , read x1 [ i ] read y1 [ i ]
if result of run check with x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] as arguments is true
print " RIGHT " print newline
create integers tx , ty
for i = 0 to 3 inclusive
for j = 0 to 3 inclusive
set tx to x1 [ i ] + move [ j ] [ 0 ]
set ty to y1 [ i ] + move [ j ] [ 1 ]
if i is 0 and result of run check with tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] as arguments is true
print " ALMOST " print newline
if i is 1 and result of run check with x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] as arguments is true
print " ALMOST " print newline
if i is 2 and result of run check with x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty as arguments is true
print " ALMOST " print newline
if i is 3 print " NEITHER " print newline
bool function check wih integer arguments x1 , y1 , x2 , y2 , x3 and y3
a , b and c = integers
set value of a to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )
b = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 )
c = ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 )
if a = = 0 or b = = 0 or c is equal to 0 return 0
if a + b = c or a + c = b or b + c = a
return 1
else
move = 2d array of integers with values { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } }
x1 and y1 = arrays of integers of size 4
if check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) returns true
print " RIGHT " and a new line
let tx and ty be integers
for i = 0 to 3 inclusive
for integer j = 0 to 3 inclusive
set tx to x1 [ i ] + move [ j ] [ 0 ]
set ty to y1 [ i ] + move [ j ] [ 1 ]
if i is equal to 0 and check ( tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) returns true
print " ALMOST " and a new line
if i is equal to 1 & & check ( x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] ) is true
print " ALMOST " and a new line
if i is equal to 2 & & check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty ) is true
print " ALMOST " and a new line
if i is equal to 3 print " NEITHER " and a new line
declare right_tri with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , return boolean
create integer a with a = ( ( x3 - x1 ) * ( x3 - x1 ) ) + ( ( y3 - y1 ) * ( y3 - y1 ) )
create integer b with b = ( ( x2 - x1 ) * ( x2 - x1 ) ) + ( ( y2 - y1 ) * ( y2 - y1 ) )
create integer c with c = ( ( x3 - x2 ) * ( x3 - x2 ) ) + ( ( y3 - y2 ) * ( y3 - y2 ) )
create integer vector temp
add element a to end of temp , add element b to end of temp , add element c to end of temp
sort elements from reverse beginning of temp to reverse ending of temp
if temp [ 2 ] is 0 , return false from function
if temp [ 1 ] + temp [ 2 ] is temp [ 0 ] , return true from function
return false from function
create integer vector a initialized with 6
for i = 0 to 6 exclusive , read a [ i ]
if result of run right_tri with arguments a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] is true
print " RIGHT " print newline
for i = 0 to 6 exclusive
for j = 0 to 2 exclusive
create integer offset with offset = - 1 if j is 0 , else 1
increment a [ i ] by offset
if result of run right_tri with a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] as arguments is true
print " ALMOST " print newline
decrement a [ i ] by offset
print " NEITHER " print newline
bollean function right_tri with int arguments x1 , y1 , x2 , y2 , x3 and y3
a = ( ( x3 - x1 ) * ( x3 - x1 ) ) + ( ( y3 - y1 ) * ( y3 - y1 ) )
b = ( ( x2 - x1 ) * ( x2 - x1 ) ) + ( ( y2 - y1 ) * ( y2 - y1 ) )
c = ( ( x3 - x2 ) * ( x3 - x2 ) ) + ( ( y3 - y2 ) * ( y3 - y2 ) )
temp = vector of integers
push a , b and c into temp
if temp [ 2 ] is equal to 0 , return false
if temp [ 1 ] + temp [ 2 ] is equal to temp [ 0 ] , return true
return false
a = vector of integers of size 6
if right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) is true
print " RIGHT " and a new line
for i = 0 to 6 exclusive
for integer j = 0 to 2 exclusive
offset = - 1 if j is 0 and 1 otherwise
increase a [ i ] by offset
if right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) is true
print " ALMOST " and a new line
decrease a [ i ] by offset
print " NEITHER " and a new line
create character array s of size 100005
create character array revs of size 100005
create integers ln , ln1 , ln2
create character array str of size 100005
create character array src1 of size 100005
create character array src2 of size 100005
create booleans flag1 , flag2
read line into s with maximum size of 100005
set ln to string length of s
for i = 0 to ln exclusive , set revs [ i ] to s [ ln - i - 1 ]
read line into src1 with maximum size of 100005
read line into src2 with maximum size of 100005
set ln1 to string length of src1
set ln2 to string length of src2
create character pointer p with p = pointer to first occurrence of string src1 in s
if p is true
create character pointer p2 with p2 = pointer to first occurrence of src2 in p + ln1
if p2 is true , set flag1 to true
set p to first occurrence of string src1 in revs
if p is true
create character pointer p2 with p2 = first occurrence of src2 in p + ln1
if p2 is true set flag2 to true
if flag1 and flag2
print " both \ n "
else if flag1
print " forward \ n "
else if flag2
print " backward \ n "
else
print " fantasy \ n "
create strings s , a , b
read s read a read b
create boolean array isok with size 2 , with isok = { 0 , 0 }
for i = 0 to 2 exclusive
create integer idx with idx = first index of a in s
if idx is not end of string
set idx to first index of b starting at idx + size of a in s
if idx is not end of string , set isok [ i ] to 1
reverse element order from beginning of s to end of s
if isok [ 0 ] and isok [ 1 ]
print " both " print newline
else if isok [ 0 ]
print " forward " print newline
else if isok [ 1 ]
print " backward " print newline
else
print " fantasy " print newline
s , a and b = strings
while can read s , a and b
isok = array of boolean of size 2 initialized with 0
for integer i = 0 to 2 exclusive
idx = index of a in s
if idx ! = string : : npos
set idx to index of b in s looking from idx + length of a
if idx ! = string : : npos
if isok [ 0 ] and isok [ 1 ] are both true
print " both " and a new line
else if isok [ 0 ] is true
print " forward " and a new line
else if isok [ 1 ] is true
print " backward " and a new line
else
print " fantasy " and a new line
create strings s , a and b
declare booleans atob and btoa = false
read s , a and b
pos = position of a in s
if pos ! = - 1 and b can be found in s after pos , set atob to true
pos = position of a in s
if pos ! = - 1 and b can be found in s after pos , set btoa to true
if atob and btoa are both true
print " both " and a new line
else if atob is true
print " forward " and a new line
else if btoa is true
print " backward " and a new line
else
print " fantasy " and a new line
create strings s , a , b
create booleans atob , btoa with atob = false , btoa = false
read s read a read b
create integer pos with pos = first index of a in s
if pos is not - 1 and integer casted first index of b in s from pos + length of a is not - 1 , set atob to true
reverse order from beginning of s to end of s
set pos to first index of a in s
if pos is not - 1 and integer casted first index of b in s from pos + length of a is not - 1 , set btoa to true
if atob and btoa
print " both " print newline
else if atob
print " forward " print newline
else if btoa
print " backward " print newline
else
print " fantasy " print newline
double constant PI = acos ( - 1 . 0 )
set constant integer INF to 1000 * 1000 * 1000 + 7
long long constant LINF = INF * INF casted to long long
set constant integer MAX to 1000 + 7
declare strings called s , a and b
method can
integer p1 = - 1
for integer i from 0 to length of s exclusive
set boolean ok to true
for j = 0 to length of a exclusive
if i + j is > = length of s or s [ i + j ] ! = a [ j ]
set ok = false
stop the loop
if ok is true
set p1 to i
break the loop
return false if p1 is equal to - 1
set p2 to - 1
for i = length of s - 1 to 0 inclusive decrementing i by one
set ok to true
for j = 0 to size of b
if i + j is > = length of s or s [ i + j ] ! = b [ j ]
set ok to false
break the loop
if ok is true
set p2 to i
break the loop
if ( p1 + length of a - 1 ) is less than p2 return true
return false
read s , a and b
let boolen forward = result of can ( )
boolean backward = can ( )
if forward and backward are both true
print " both " and a new line
if forward is true
print " forward " and a new line
if backward is true
print " backward " and a new line
print " fantasy " and a new line
create character array s with size 123456
create character array a with size 128
create character array b with size 128
create integer arrays p , p2 , with p size 128 , p2 size 128
declare check with no arguments , returning boolean
set p [ 0 ] to - 1
create integer sa with sa = string length of a
create integer sb with sb = string length of b
for i = ( 1 ) , _b ( sa ) to _b exclusive
set p [ i ] to p [ i - 1 ]
while p [ i ] is not - 1 and a [ p [ i ] + 1 ] is not a [ i ] , set p [ i ] to p [ p [ i ] ]
if a [ p [ i ] + 1 ] is a [ i ] , increment p [ i ]
set p2 [ 0 ] to - 1
for i = ( 1 ) , _b ( sb ) to _b exclusive
set p2 [ i ] to p2 [ i - 1 ]
while p2 [ i ] is not - 1 and b [ p2 [ i ] + 1 ] is not b [ i ] , set p2 [ i ] to p2 [ p2 [ i ] ]
if b [ p2 [ i ] + 1 ] is b [ i ] , increment p2 [ i ]
create integer n with n = string length of s
create integer x with x = - 1
for i = ( 0 ) , _b ( n ) to _b exclusive
while x is not - 1 and a [ x + 1 ] is not s [ i ] , set x to p [ x ]
if a [ x + 1 ] is s [ i ] , increment x
if x is sa - 1
set x to - 1
for incremented i to n exclusive
while x is not - 1 and b [ x + 1 ] is not s [ i ] , set x to p2 [ x ]
if b [ x + 1 ] is s [ i ] , increment x
if x is sb - 1 , return true from function
return false from function
return false from function
read string into s
read string into a
read string into b
create boolean q with q = result of run check
reverse element order from s to s + string length of s
create boolean w with w = result of run check
if q and w , print " both \ n "
if q and not w , print " forward \ n "
if not q and w , print " backward \ n "
if not q and not w , print " fantasy \ n "
s = array of characters of size 100010
a and b = arrays of characters of size 100010
read s + 1 , a + 1 and b + 1
let ls , la and lb be integers with ls = length of s + 1 , la = length of a + 1 and lb = length of b + 1
let p1 and p2 be integers with value - 1
let f1 and f2 be booleans with value 0
for register int i = 1 to ls - la + 1 inclusive
set boolean flag to 1
for register int j = 1 , k = i to j < = la , incrementing j and k
if a [ j ] ! = s [ k ]
set value of flag to 0
stop the loop
if flag
p1 = i + la - 1
stop the loop
if p1 ! = - 1
for i = p1 + 1 to ls - lb + 1 inclusive
set f1 to 1
for j = 1 , k = i to j < = lb , incrementing k and j
if b [ j ] ! = s [ k ]
set f1 to 0
stop the loop
if f1
for register = 1 to ls - lb + 1 inclusive
create boolean flag with value 1
for j = 1 , k = i + lb - 1 to j < = lb , incrementing j and decrementing k
if b [ j ] ! = s [ k ]
set value of flag to 0
stop the loop
if flag
p2 = i + lb - 1
stop the loop
if p2 ! = - 1
for int i = p2 + 1 to ls - la + 1 inclusive
set value of f2 to 1
for int j = 1 , k = i + la - 1 to j < = la incrementing j and decrementing k
if a [ j ] ! = s [ k ]
f2 = 0
break the loop
if f2
if f1 and f2
print " both "
else if f1
print " forward "
else if f2
print " backward "
else
print " fantasy "
let s be an array of characters of length 123456
let a be an array of characters of size 128
b = array of characters of length 128
p and p2 = integer arrays of length 128
function check
set p [ 0 ] to - 1
sa = length of a
sb = length of b
for integer i = from 1 to _b exclusive call _b ( sa )
p [ i ] = p [ i - 1 ]
while p [ i ] ! = - 1 & & a [ p [ i ] + 1 ] ! = a [ i ] set p [ i ] to p [ p [ i ] ]
if a [ p [ i ] + 1 ] is equal to a [ i ] increase p [ i ] by one
set p2 [ 0 ] to - 1
for integer i = from 1 to _b exclusive call _b ( sb )
p2 [ i ] = p2 [ i - 1 ]
while p2 [ i ] ! = - 1 & & b [ p2 [ i ] + 1 ] ! = b [ i ] set p2 [ i ] to p2 [ p2 [ i ] ]
if b [ p2 [ i ] + 1 ] is equal to b [ i ] increment p2 [ i ]
integer n = length of s
integer x = - 1
for integer i = from 1 to _b exclusive call _b ( n )
while x ! = - 1 & & a [ x + 1 ] ! = s [ i ] set x to p [ x ]
if a [ x + 1 ] is equal to s [ i ] increment x
if x is equal to sa - 1
set value of x to - 1
loop from i + 1 to n exclusive
while x ! = - 1 & & b [ x + 1 ] ! = s [ i ] set x to p2 [ x ]
if b [ x + 1 ] is equal to s [ i ] increment x
if x is equal to sb - 1 return true
return false
return false
read string from the input to variable s
read string from the input to variable a
read string from the input to variable b
set q to the result of check ( )
call reverse with arguments s and s + length of s
boolean w = result of function check
if q & & w print " both \ n "
if ( q & & ! w ) " forward \ n "
if ( ! q & & w ) " backward \ n "
if ( ! q & & ! w ) " fantasy \ n "
create character array s with size 123456
create character array a with size 128
create character array b with size 128
create character arrays p , p2 with p size 128 , p2 size 128
declare check with no arguments , returning boolean
set p [ 0 ] to - 1
create integer sa with sa = string length of a
create integer sb with sb = string length of b
for i = ( 1 ) , _b ( sa ) , to _b exclusive
set p [ i ] to p [ i - 1 ]
while p [ i ] is not - 1 and a [ p [ i ] + 1 ] is not a [ i ] , set p [ i ] to p [ p [ i ] ]
if a [ p [ i ] ] + 1 is a [ i ] , increment p [ i ]
set p2 [ 0 ] to - 1
for i = ( 1 ) , _b ( sb ) to _b exclusive
set p2 [ i ] to p2 [ i - 1 ]
while p2 [ i ] is not - 1 and b [ p2 [ i ] + 1 ] is not b [ i ] , set p2 [ i ] to p2 [ p2 [ i ] ]
if b [ p2 [ i ] + 1 ] is b [ i ] , increment p2 [ i ]
create integer n with n = string length of s
create integer x with x = - 1
for i = ( 0 ) , _b ( n ) to _b exclusive
while x is not - 1 and a [ x + 1 ] is not s [ i ] , set x to p [ x ]
if a [ x + 1 ] is s [ 1 ] , increment x
if x is sa - 1
set x to - 1
for i to n exclusive
while x is not - 1 and b [ x + 1 ] is not s [ i ] , set x to p2 [ x ]
if b [ x + 1 ] is s [ i ] , increment x
if x is sb - 1 return true from function
return false from function
return false from function
read s
read a
read b
create boolean q with q = result of run check
reverse element order from s to s + string length of s
create boolean w with w = result of run check
if q and w , print " both \ n "
if q and not w , print " forward \ n "
if not q and w , print " backward \ n "
if not q and not w , print " fantasy \ n "
create character array s of size 100010
create character arrays a , b , with a size 100010 , b size 100010
read s + 1 read a + 1 read b + 1
create integers ls , la , lb with ls = string length of s + 1 , la = string length of a + 1 , lb = string length of b + 1
create integers p1 , p2 , with p1 = - 1 , p2 = - 1
create booleans f1 , f2 with f1 = 0 , f2 = 0
for i = 1 to ls - la + 1 inclusive
create boolean flag with flag = 1
for j = 1 , k = i to j less than or equal to la , incrementing j , k
if a [ j ] is not s [ k ]
set flag to 0
break loop
if flag is true
set p1 to i + la - 1
break loop
if p1 is not - 1
for i = p1 + 1 to ls - lb + 1 inclusive
set f1 to 1
for j = 1 , k = i to j less than or equal to lb , incrementing j , k
if b [ j ] is not s [ k ]
set f1 to 0
break loop
if f1 is true , break loop
for i = 1 to ls - lb + 1 inclusive
create boolean flag with flag = 1
for j = 1 , k = i + lb - 1 to j less than or equal to lb , incrementing j , decrementing k
if b [ j ] is not s [ k ]
set flag to 0
break loop
if flag is true
set p2 to i + lb - 1
break loop
if p2 is not - 1
for i = p2 + 1 to ls - la + 1 inclusive
set f2 to 1
for j = 1 , k = i + la - 1 to j less than or equal to la , incrementing j , decrementing k
if a [ j ] is not s [ k ]
set f2 to 0
break loop
if f2 is true , break loop
if f1 and f2
print " both "
else if f1 is true
print " forward "
else if f2 is true
print " backward "
else
print " fantasy "
create strings a , b and c
read a , b and c
forward and backward are booleans with value false
integer pos_1 = index of b in a
pos_2 = integer
if pos_1 ! = - 1
pos_2 = index of c in a starting from position pos_1 + length of b
if pos_2 ! = - 1 , set forward to true
pos_1 = index of b in a
if pos_1 ! = - 1
pos_2 = index of c in a starting from pos_1 + length of b
if pos_2 ! = - 1 , set backward to true
if backward = false & & forward = false , print " fantasy "
if backward = false and forward = true , print " forward "
if forward = false and backward = true , print " backward "
if backward = true & & forward = true , print " both "
create strings a , b , c
read a read b read c
create booleans forward , backward with forward = false , backward = false
create integer pos_1 with pos_1 = first index of b in a
create integer pos_2
if pos_1 is not - 1
set pos_2 to first index of c starting at pos_1 + length of b in a
if pos_2 is not - 1 , set forward to true
reverse elements from beginning of a to end of a
set pos_1 to first index of b in a
if pos_1 is not - 1
set pos_2 to first index of c starting at pos_1 + length of b in a
if pos_2 is not - 1 , set backward to true
if backward is false and forward is true , print " fantasy "
if backward is false and forward is true , print " forward "
if forward is false and backward is true , print " backward "
if backward is true and forward is true , print " both "
create strings s , a , b
while read s read a read b is true
create boolean array isok of size 2 with isok = { 0 , 0 }
for i = 0 to 2 exclusive
create integer idx with idx = first index of a in s
if idx is not end of string
set idx to first index of b starting at idx + size of a , in s
if idx is not end of string , set isok [ i ] to 1
reverse element order starting at beginning of s to end of s
if isok [ 0 ] and isok [ 1 ]
print " both " print newline
else if isok [ 0 ] is true
print " forward " print newline
else if isok [ 1 ] is true
print " backward " print newline
else
print " fantasy " print newline
declare strings called s , a and b
read s , a and b in a loop
boolean array isok with 2 elements = 0
for i = 0 to 2 exclusive
idx = index of a in the s
if idx ! = string : : npos
idx = index of b in the s , starting from idx + length of a
if idx ! = string : : npos , set isok [ i ] to 1
if isok [ 0 ] and isok [ 1 ] are true
print " both " and a new line
else if isok [ 0 ] is true
print " forward " and a new line
else if isok [ 1 ] is true
print " backward " and a new line
else
print " fantasy " and a new line
declare fill_prefix with arguments string address P , integer vector address F
resize F to fit size of P elements , copying 0 to new elements
for j , i = 1 to i is less than size of P , incrementing i
set j to F [ i - 1 ]
while j is greater than 0 and P [ i ] is not P [ j ] , set j to F [ j - 1 ]
if P [ i ] is P [ j ] , increment j
set F [ i ] to j
declare kmp with arguments string address T , string address P , integer vector address F , integers start , end , returning integer
if start is size of T , return - 1 from function
if end - start + 1 is less than size of P , return - 1 from function
create integer i with i = start
create integer j with j = 0
create integer idx with idx = - 1
while i is less than or equal to end
while j is less than size of P and i is less than or equal to end and T [ i ] is P [ j ]
increment i
increment j
if j is size of P
set idx to i - size of P
return idx from function
else
if j is 0
set i to i + 1
else
set j to F [ j - 1 ]
return idx from function
declare valid with arguments string address T , string address P1 , string address P2 , integer vector address F1 , integer vector address F2 , returning boolean
create integer i with i = result of run kmp with arguments T , P1 , F1 , 0 , size of T - 1
if i is - 1 , return false from function
increment i by size of P1
set i to result of run kmp with arguments T , P2 , F2 , i , size of T - 1
if i is - 1 , return false from function
return true from function
create strings T , P1 , P2
create integer vectors F1 , F2
read T read P1 read P2
run fill_prefix with arguments P1 , F1
run fill_prefix with arguments P2 , F2
create boolean x with x = result of run valid with arguments T , P1 , P2 , F1 , F2
reverse elements order from beginning of T to end of T
create boolean y with y = result of run valid with arguments T , P1 , P2 , F1 , F2
if not x and not y
print " fantasy \ n "
else if not x and y
print " backward \ n "
else if x and not y
print " forward \ n "
else
print " both \ n "
create integer ind
create booleans forw , backw
create strings s , a , b , tmp
declare search with integer start , string x , string y as arguments , returning integer
for i = start to length of x - length of y inclusive
for j = 0 to length of y exclusive
if x [ i + j ] is not y [ j ] break loop
if j is length of y - 1 , return i + j from function
return - 1 from function
read s read a read b
if length of a + length of b is greater than length of s
print " fantasy " print newline
set ind to result of run search with 0 , s , a as arguments
if ind is greater than or equal to 0
set ind to run search with ind + 1 , s , b as arguments
set forw to true if ind is greater than or equal to 0 , else false
set tmp to s
set s to " "
for i = length of tmp - 1 to 0 inclusive , decrementing i , increment s by tmp [ i ]
set ind to result of run search with 0 , s , a as arguments
if ind is greater than or equal to 0
set ind to result of run search with ind + 1 , s , b as arguments
set backw to true if ind is not - 1 , else false
if forw and not backw
print " forward " print newline
else if not forw and backw
print " backward " print newline
else if forw and backw
print " both " print newline
else
print " fantasy " print newline
declare integer variable ind
boolean forw , backw
create strings s , a , b and tmp
define function search with int argument start and string arguments x , y
for integer i = start to ( length of x - length of y ) inclusive
for integer j = 0 to length of y exclusive
if x [ i + j ] ! = y [ j ] break
if j is equal to length of y - 1 return i + j
return - 1
read s , a and b
if length of a + length of b is greater than length of s
print " fantasy " and a new line
set value of ind to search ( 0 , s , a )
if ind is greater than or equal to 0
ind = search ( ind + 1 , s , b )
forw = true if ind > = 0 and false otherwise
set tmp to s
s = emtpy string
loop i from length of tmp - 1 to 0 inclusive decrementing by 1 , add tmp [ i ] to s on each loop
set ind to search ( 0 , s , a )
if ind is greater than or equal to 0
ind = search ( ind + 1 , s , b )
set backw to true of ind ! = - 1 and false otherwise
if forw is true and backw is false
print " forward " and a new line
else if forw is false and backw is true
print " backward " and a new line
else if forw and backw are both true
print " both " and a new line
else
print " fantasy " and a new line
create strings colors , round1 , round2
read colors read round1 read round2
create string colors_rev initialized with arguments reverse beginning to reverse end
create boolean forwards with forwards = function address of colors , address of round1 , address of round2
create size_t match1 with match1 = first index of round1 in colors
if match1 is end of string , return false from function
create size_t match2 with match2 = first index of round2 starting at match1 + length of round1
if match2 is end of strong , return false from function
return true from function
end function
create boolean backwards with backwards = function with arguments address of colors_rev , address of round1 , address of round2
create size_t match1 with match1 = first index of round1 in colors_rev
if match1 is end of string , return false from function
create size_t match2 with match2 = first index of round2 starting at match1 + length of round1 in colors_rev
if match2 is end of string , return false from function
return true from function
end function
if forwards and backwards is true
print " both "
else if forwards is true
print " forward "
else if backwards is true
print " backward "
else
print " fantasy "
print ' \ n '
declare strings called s , a and b
while can read s , a and b
bool array isok with size 2 initialized with 0
for integer i = 0 to 2 exclusive
idx = index of a in s
if idx ! = string : : npos
idx = index of b in s starting from idx + length of a
if idx ! = string : : npos set isok [ i ] to 1
if isok [ 0 ] and isok [ 1 ] are both true
print " both " and a new line
else if isok [ 0 ] is true
print " forward " and a new line
else if isok [ 1 ] is true
print " backward " and a new line
else
print " fantasy " and a new line
create strings s , a , b
while read s read a read b is true
create boolean array isok with size 2 , with isok = { 0 , 0 }
for i = 0 to 2 exclusive
create integer idx with idx = first index of a in s
if idx is not end of string
set idx to first index of b after idx + size of a in s
if idx is not end of string , set isok [ i ] to 1
reverse element order from beginning of s to end of s
if isok [ 0 ] and isok [ 1 ]
print " both " print newline
else if isok [ 0 ] is true
print " forward " print newline
else if isok [ 1 ] is true
print " backward " print newline
else
print " fantasy " print newline
n , c , a and counter are integers with a and counter = 0 , arr is array of integers of size 101
boolean flag = true
read n
if n is equal to 1
print " NO " and a new line
set c to arr [ 0 ]
for x = n to 0 decreasing x
if arr [ x ] is equal to arr [ x - 1 ]
flag = false
increment counter
if flag is false and counter is equal to n - 1
print " NO " and a new line
while true
if arr [ a ] ! = arr [ a + 1 ]
set value of c to arr [ a + 1 ]
break the loop
increase a by one
print c and a new line
create integers n , c , a , counter with a = 0 , counter = 0 , create integer array arr of size 101
create boolean flag with flag = true
read n
if n is 1
print " NO " print newline
for x = 0 to n exclusive , read arr [ x ]
sort elements from arr to arr + n
set c to arr [ 0 ]
for x = n to 0 exclusive , decrementing x
if arr [ x ] is arr [ x - 1 ]
set flag to false
increment counter
if flag is false and counter is n - 1
print " NO " print newline
while true
if arr [ a ] is not arr [ a + 1 ]
set c to arr [ a + 1 ]
break loop
increment a
print c print newline
declare an integer t
read a value into t
declare a set of integers called st
declare an integer n
do the following t times :
read a value into n
insert the value n into the set st
declare a set iterator it
declare a value l which is equal to the size of st
If l is 1
output NO and a newline
set it equal to an iterator
add one to it
output the values of the set
create integer t
read t
create integer set st
create integer n
for i = 0 to t exclusive
read n
insert n into st
create integer set iterator it
create integer l with l = size of st
if l is 1
print " NO " print newline
else
set it to beginning of st
increment it
print value of it print newline
create integer n
read n
create integer set s
for i = 0 to n exclusive
create integer b
read b
insert b into s
if size of s is 1
print " NO " print newline
create integer set iterator rit with rit = beginning of s
remove value of rit from s
print value of beginning of s print newline
n = integer
read n
s = set of integers
for integer i = 0 to n exclusive
let b be integer
read b
insert b into s
if length of s is 1
print " NO " and a new line
rit = set iterator pointing at the first element of s
erase element of s at rit
print first element of s and a new line
create integers n , i , k
create integer array a with size 105
read n
for i = 0 to n exclusive , read a [ i ]
sort elements from a to a + n
set k to 1
for i = 1 to n exclusive
if a [ i ] is not a [ i - 1 ] , increment k
if k is 2
print a [ i ] print newline
print " NO " print newline
create integers n , i and k
a = array of integers of length 105
read n
read n values into array a
set k to 1
for i = 1 to n exclusive
if a [ i ] ! = a [ i - 1 ] increment k
if k is equal to 2
print a [ i ] and a new line
print " NO " and a new line
create integers n , a , cnr , with cnr = 0 , create integer array p of size 201
read n
while decrementing n is true
read a
increment p [ a + 100 ]
for i = 0 to 200 inclusive
if p [ i ] is true , increment cnr
if cnr is 2
print i - 100 print newline
print " NO " print newline
end statement
n , a and cnr are integers with cnt = 0 , p = array of integers with size 201
read n
while n - -
read a
increment p [ a + 100 ]
for i = 0 to 200 inclusive
if p [ i ] is true , increment cnr
if cnr is equal to 2
print i - 100 and a new line
print " NO " and a new line
;
x = integer
read x
num = integer
let arr be an array of integers of size 201
for integer i = 0 to 201 exclusive arr [ i ] = 900
create integer count with value 0
for i = 0 to x exclusive
read num
if arr [ num + 100 ] is 900 increment count
arr [ num + 100 ] = num
if count is < = 1
print " NO " and a new line
else
create integer cursor with value 1
for integer i = 0 to 201 exclusive
if cursor is 2 and arr [ i ] is not 900
print arr [ i ] and a new line
else if arr [ i ] ! = 900
increase cursor
create integer x
read x
create integer num
create integer array arr of size 201
for i = 0 to 201 exclusive , set arr [ i ] to 900
create integer count with count = 0
for i = 0 to x exclusive
read num
if arr [ num + 100 ] is 900 , increment count
set arr [ num + 100 ] to num
if count is less than or equal to 1
print " NO " print newline
else
create integer cursor with cursor = 1
for i = 0 to 201 exclusive
if cursor is 2 and arr [ i ] is not 900
print arr [ i ] print newline
else if arr [ i ] is not 900
increment cursor
let s be a unique set of integers
let itr be set iterator
declare integer variable n
read n
for i = 0 to n exclusive
let x be integer
read x
insert x into s
if length of s is equal to 1
print " NO " and a new line
set itr to the beginning of s
increase itr
print * itr and a new line
create integers n , i , j
while read n is true
for i = 0 to n exclusive , read a [ i ]
for i = 0 to n exclusive
if a [ i ] is a [ 0 ]
set flog to flog
else
set flog to flag + 1
if flog is 0
print " NO " print newline
else
for i = 0 to n exclusive
for j = 1 to n - i exclusive
if a [ j ] is less than a [ j - 1 ]
set e to a [ j - 1 ]
set a [ j - 1 ] to a [ j ]
set a [ j ] to e
for i = 0 to n - 1 exclusive
for f = i + 1 to n exclusive
if a [ f ] is a [ i ]
for k = i to n exclusive , set a [ k ] to a [ k + 1 ]
decrement n
decrement f
if n is 2
print a [ 1 ] print newline
else
print a [ 1 ] print newline
create integer n
create integer array a with size 110
read n
for i = 1 to n inclusive , read a [ i ]
for i = 1 to n exclusive
for j = i + 1 to n inclusive
if a [ i ] is greater than a [ j ] , swap values of a [ i ] and a [ j ]
for i = 2 to n inclusive
if a [ i ] is not a [ i - 1 ]
print a [ i ] print newline
print " NO " print newline
declare integer variable n
let a be an array of integers of size 110
read n
for i = 1 to n inclusive read a [ i ]
for i = 1 to n exclusive
for j = i + 1 to n inclusive
if a [ i ] is greater than a [ j ] , swap a [ i ] and a [ j ]
for integer i = 2 to n inclusive
if a [ i ] ! = a [ i - 1 ]
print a [ i ] and a new line
print " NO " and a new line
create integers a and cnr
let p be an array of booleans of size 201
let n be integer
read n
while n - -
read a
increment p [ a + 100 ]
for i = 0 to 200 inclusive
if p [ i ] is true , increment cnr
if cnr is 2
print i - 100 and a new line
print " NO " and a new line
;
create integers a , cnr
create boolean array p of size 201
create integer n
read n
while decrementing n
read a
increment p [ a + 100 ]
for i = 0 to 200 inclusive
if p [ i ] is true , increment cnr
if cnr is 2
print i - 100 print newline
print " NO " print newline
end statement
let a be an array of booleans of size 205
define function solve
declare integer variable n
read n
v = vector of integers
for integer i = 0 to n exclusive
declare integer variable x
read x
increase x by 100
if a [ x ] is false
add x to the end of v
set a [ x ] to true
if size of v is 1
print " NO " and a new line
return
else
print v [ 1 ] - 100 and a new line
invoke function solve
create boolean array a with size 205
declare solve with no arguments , returning void
create integer n
read n
create integer vector v
for i = 0 to n exclusive
create integer x
read x
increment x b y 100
if a [ x ] is false
add element x to end of v
set a [ x ] to true
sort elements from beginning of v to end of v
if size of v is 1
print " NO " print newline
return from function
else
print v [ 1 ] - 100 print newline
run solve
create integers n , x
create integer set s
read n
for i = 1 to n inclusive
read x
insert x into s
remove beginning of s from s
if s is empty
print " NO "
else
print value of beginning of s print newline
n and i are integers , arr is an array of integers of size 100
read n
sort array arr
if arr [ 0 ] = arr [ n - 1 ] or n is equal to 1
print " NO \ n "
i = 1
while arr [ i ] is equal to arr [ 0 ]
print arr [ i ] and " \ n "
create integers n , i , create integer array arr with size 100
read n
for i = 0 to n exclusive , read arr [ i ]
sort elements from arr to arr + n
if arr [ 0 ] is arr [ n - 1 ] or n is 1
print " NO \ n "
set i to 1
while arr [ i ] is arr [ 0 ] , increment i
print arr [ i ] print " \ n "
declare integer variable n
ns = array of integers of size 100
read n
i and ans are integers with i = 0 and ans = ns [ 0 ]
while i is less than n
if ns [ i ] ! = ns [ 0 ]
assign value of ns [ i ] to the ans
break the loop
else
increase i
if ans ! = ns [ 0 ]
print ans and a new line
else
print " NO " and a new line
create integer set s
create integer n
read n
for i = 0 to n exclusive
create integer k
read k
insert k into s
remove beginning of s from s
if s is empty
print " NO " print newline
else
print value of beginning of s print newline
let n be integer
read n
x = integer
let v be a vector of integers
let m be a map from integer to boolean
for integer i = 1 to n inclusive
read x
if m [ x ] is false
push x to the end of v
assign value of 1 to the m [ x ]
if length of v is greater than 1
print v [ 1 ] and a new line
else
print " NO " and a new line
create integers n , x
read n
create integer arr [ n ]
for i = 0 to n exclusive , read arr [ i ]
create integer set s initialized with arr , arr + n
create integer set iterator
set it to beginning of s
if increment it is end of s
print " NO " print newline
else
print value of it print newline
create integers n and x
read n
arr = array of integers of length n
s = set of integers
let it = set iterator
set it = to the beginning of s
if incremented it is at the end of s
print " NO " and a new line
else
print value at the it and a new line
create doubles x and y
read x and y
assign square root of x * x + y * y to the double variable raw
let int p_sign be 1 if x * y > 0 , or 0 if it is not
set integer d_raw to square root of x * x + y * y
integer color = ( d_raw % 2 ) + p_sign
if raw is a whole number
print " black " and a new line
else
print " white " if color is even , " black " if color is odd , and a new line
create doubles x , y
read x read y
create double raw with raw = square root of ( x * x + y * y )
create integer p_sign with p_sign = 1 if x * y is greater than 0 , else 0
create integer d_raw with d_raw = integer casted square root of ( x * x + y * y )
create integer color with color = ( d_raw % 2 ) + p_sign
if raw - integer casted raw is 0
print " black " print newline
else
print " white " if color % 2 is 0 , else " black " , print newline
declare int_64_t x and y
read x and y
set int64_t rs to x * x + y * y
set int64_t r to the square root of rs
if r * r = rs | | x = 0 | | y = 0
print " black \ n "
else
integer parity = r % 2
if x * y > = 0
if parity is 1
print " white \ n "
else
print " black \ n "
else
if parity is 1
print " black \ n "
else
print " white \ n "
create integers x and y
read x and y
create double r with value x * x + y * y
set r to square root of r
intpart = double
if modf ( r , & intpart ) is equal to 0 . 0
print " black " and a new line
else
create integer int_r = floor of r
if ( x > 0 and y > 0 ) and ( int_r is even ) print " black " and a new line
if ( x < 0 and y < 0 ) and ( int_r is even )
print " black " and a new line
else if ( x < 0 and y > 0 ) and ( int_r is even )
print " white " and a new line
else if ( x > 0 and y < 0 ) and ( int_r is even )
print " white " and a new line
else if ( x > 0 & & y is greater than 0 ) & & ( int_r is odd )
print " white " and a new line
else if ( x < 0 & & y is less than 0 ) & & ( int_r is odd )
print " white " and a new line
else if ( x > 0 and y is less than 0 ) and ( int_r is odd )
print " black " and a new line
else if ( x < 0 & & y is greater than 0 ) & & ( int_r is odd )
print " black " and a new line
create integers x , y
read x read y
create double r with r = x * x + y * y
set r to square root of r
create double intpart
if result of break r into integer and fraction , storing integer in address of intpart is 0 . 0
print " black " print newline
else
create integer int_r with int_r = static casted integer rounded down r
if ( x is greater than 0 and y is greater than 0 ) and ( int_r % 2 is 0 ) , print " black " print newline
if ( x is less than 0 and y is less than 0 ) and ( int_r % 2 ) is 0
print " black " print newline
else if ( x is less than 0 and y is greater than 0 ) and ( int_r % 2 is 0 )
print " white " print newline
else if ( x is greater than 0 and y is less than 0 ) and ( int_r % 2 is 0 )
print " white " print newline
else if ( x is greater than 0 and y is greater than 0 ) and ( int_r % 2 is not 0 )
print " white " print newline
else if ( x is less than 0 and y is less than 0 ) and ( int_r % 2 is not 0 )
print " white " print newline
else if ( x is greater than 0 and y is less than 0 ) and ( int_r % 2 is not 0 )
print " black " print newline
else if ( x is less than 0 and y is greater than 0 ) and ( int_r % 2 is not 0 )
print " black " print newline
create constant integer M with value 1000 + 5
x and y = integers
read x and y
assign value 0 to the integer r
increment r while x * x + y * y is greater than r * r
if x or y are equal to 0
print " black " and a new line
else
if x * x + y * y is equal to r * r
print " black " and a new line
else
if r is even
if x * y is greater than 0
print " white " and a new line
else
print " black " and a new line
else
if x * y is greater than 0
print " black " and a new line
else
print " white " and a new line
create constant integer M with M = 1000 + 5
create integers x , y
read x read y
create integer r with r = 0
while x * x + y * y is greater than r * r , increment r
if x is 0 or y is 0
print " black " print newline
else
if x * x + y * y is r * r
print " black " print newline
else
if r % 2 is 0
if x * y is greater than 0
print " white " print newline
else
print " black " print newline
else
if x * y is greater than 0
print " black " print newline
else
print " white " print newline
create integers x and y
read x and y
set integer d to x * x + y * y
assign square root of d to the new integer sq
if sq * sq = d
print " black " and a new line
else if ( x > 0 and y > 0 ) or ( x < 0 and y is less than 0 )
if sq & 1
print " white " and a new line
else
print " black " and a new line
else
if sq & 1
print " black " and a new line
else
print " white " and a new line
function f that returns boolean
declare integers called x and y
read x and y
if x or y = 0 return true
assign value of square root of x * x + y * y to the integer s
if s * s = x * x + y * y return true
if ( x * y > 0 ) = ( s % 2 = 0 ) return true
return false
if f ( ) is true
print " black " and a new line
else
print " white " and a new line
declare f with no arguments , returning boolean
create integers x , y
read x read y
if x is 0 or y is 0 , return true from function
create integer s with s = square root of ( x * x + y * y )
if s * s is x * x + y * y , return true from function
if ( x * y is greater than 0 ) or ( s % 2 is 0 ) , return true from function
return false from function
if result of run f is true
print " black " print newline
else
print " white " print newline
create integers x and y
let n be double
read x and y
n = square root of x * x + y * y
if ceil ( n ) > n
if x * y > 0 is equal to ceil ( n ) casted to integer & 1
print " black " and a new line
else
print " white " and a new line
else
print " black " and a new line
let x and y be integers
read x and y
assign square root of x * x + y * y to the integer r
if r * r = x * x + y * y
print " black \ n "
if ( x > 0 and y > 0 ) or ( x < 0 and y is less than 0 )
if r is odd
print " white \ n "
else
print " black \ n "
else
if r is odd
print " black \ n "
else
print " white \ n "
declare integers called a and b
read a and b
integer cnt = ( ( a > 0 ) + ( b > 0 ) ) % 2
integer d = a * a + b * b
for int i = 1 to infinity , increment i
if i * i is equal to d
print " black \ n "
if i * i is greater than d
integer ans = ( cnt + i ) % 2
print " black \ n " if ans is 1 and " white \ n " otherwise
let x and y be integers
read x and y
double r = square root of 1 . 0 * x * x + y * y
assign value of r casted to int to the integer a
let b be integer
if r - a is greater than 0
b = a + 1
else
b = a
if x * y is greater than 0
if b = a or a is even
print " black " and a new line
else
print " white " and a new line
else
if b = a or a is odd
print " black " and a new line
else
print " white " and a new line
let x and y be doubles
read x and y
create double r with value of square root of x * x + y * y
set double s to floor of r
if absolute value of s - r is less than 1e - 6
print " black " and a new line
if x = 0 | | y = 0
print " black " and a new line
if ( x > 0 & & y > 0 ) or ( x < 0 & & y < 0 )
int a = r % 2
if a is not 0
print " white " and a new line
else
print " black " and a new line
else
int a = r % 2
if a = 0
print " white " and a new line
else
print " black " and a new line
create doubles x and y
create double d
read x and y
d = square root of x * x + y * y
integer es = d / 1
if ( es = d ) or ( x * y = 0 )
print " black " and a new line
else if x * y is less than 0
if es is even
print " white " and a new line
else
print " black " and a new line
else if x * y is greater than 0
if es is odd
print " white " and a new line
else
print " black " and a new line
long doubles x , y and dist
boolean function Greater with integer arguments x
return ( ( long double ) x > = dist )
boolean function eq with long arguments double , x , double and y
if x > = 0 and y > = 0 return 1
if x < = 0 and y < = 0 return 1
read x and y
set dist to square root of x * x + y * y
r and pas are integers with r = 0 and pas = ( 1 < < 30 )
while pas
if Greater ( r + pas ) = 0 , add pas to r
divide pas by 2
increase r
if r = dist
print " black \ n "
if eq ( x , y )
if r is odd
print " black \ n "
else
print " white \ n "
else
if r % 2 is even
print " black \ n "
else
print " white \ n "
create integers i , j , x and y
read x and y
if x = 0 or y is equal to 0
print " black \ n "
if x < 0 and y is less than 0
invert sign of x
invert sign of y
assign value x * x + y * y to the integer dist
for i = 2000 to 1 inclusive decrementing i
if i * i > = dist and ( i - 1 ) * ( i - 1 ) is less than dist , break
if i * i is equal to dist
print " black \ n "
if x * y is greater than 0
if i is odd
print " black \ n "
else
print " white \ n "
else
if i is even
print " black \ n "
else
print " white \ n "
create maps f , g from string to integer
create string array s of size 1005
create integer array c with size 1005
create integers n , m with m = 0
read n
for i = 0 to n exclusive , read s [ i ] read c [ i ] , increment f [ s [ i ] ] by c [ i ]
for i = 0 to n exclusive
if m is less than f [ s [ i ] ] set m to f [ s [ i ] ]
create integer i
for i = 0 to f [ s [ i ] ] is less than m or ( g [ s [ i ] ] incremented by c [ i ] ) is less than m , incrementing i
end statement
return result of ( print s [ i ] print newline ) and 0
let f and g be maps of string to integer
let s be an array of strings of length 1005
c = array of integers of length 1005
integers n and m with m = 0
read n
for i = 0 to n exclusive , read s [ i ] and c [ i ] , then increase f [ s [ i ] ] by c [ i ]
for integer i = 0 to n exclusive
if m is less than f [ s [ i ] ] , set m to f [ s [ i ] ]
declare integer variable i
loop through i from 0 while f [ s [ i ] ] < m or ( g [ s [ i ] ] + = c [ i ] ) < m
;
return ( cout < < s [ i ] < < endl ) & & 0
n = integer
read n
mmp and fq are maps of string to integer
max = - 20000000
name = array of strings of size 1005
sc = array of integers of size 1005
for integer i = 0 to n exclusive
read name [ i ] and sc [ i ]
increase mmp [ name [ i ] ] by sc [ i ]
for integer i = 0 to n exclusive
if max is less than mmp [ name [ i ] ] , set max to mmp [ name [ i ] ]
for integer i = 0 to n exclusive
increase fq [ name [ i ] ] by sc [ i ]
if fq [ name [ i ] ] > = max and mmp [ name [ i ] ] > = max
print name [ i ] and a new line
create maps name , name2 from string to integer
create integer n
read n
create string tempname with size 1010
create integer score with size 1010
create integer mx with mx = 0
for i = 0 to n exclusive
read tempname [ i ] read score [ i ]
increment name [ tempname [ i ] ] by score [ i ]
for i = 0 to n exclusive
if name [ tempname [ i ] ] is greater than mx , set mx to name [ tempname [ i ] ]
for i = 0 to n exclusive
if name [ tempname [ i ] ] is mx
set name2 [ tempname [ i ] ] by score [ i ]
if name2 [ tempname [ i ] ] is greater than or equal to mx
print tempname [ i ] print ' \ n '
break loop
let II be an array of integers of size 100007
let SS be an array of strings of length 100007
SC1 and SC2 are map of string to integer
let n and mx be integers
mx = - 1000000007
read n
for i = 0 to n exclusive
read SS [ i ] and II [ i ]
increase SC1 [ SS [ i ] ] by II [ i ]
create map iterator it and set it to the first element of SC1
move it through SC1 , setting mx to max of max and value at the iterator
for i = 0 to n exclusive
increase SC2 [ SS [ i ] ] by II [ i ]
if SC1 [ SS [ i ] ] > = mx and mx < = SC2 [ SS [ i ] ]
print SS [ i ] and a new line
integers n , maxn = - 1000 and sc is an array of integers with size 1009
stu = array of strings of size 1009
m and m1 are maps of string to integers
read n
for i = 1 to n inclusive
read stu [ i ] and sc [ i ]
increase m [ stu [ i ] ] by sc [ i ]
for integer i = 1 to n inclusive
if m [ stu [ i ] ] is greater than maxn set maxn to m [ stu [ i ] ]
for i = 1 to n inclusive
increase m1 [ stu [ i ] ] by sc [ i ]
if m1 [ stu [ i ] ] > = maxn and m [ stu [ i ] ] is equal to maxn
print stu [ i ] and a new line
stop the loop
create integers n , maxn with maxn = - 1000 , create integer array sc with size 1009
create string array stu with size 1009
create maps m , m1 from string to integer
read n
for i = 1 to n inclusive
read stu [ i ] read sc [ i ]
increment m [ stu [ i ] ] by sc [ i ]
for i = 1 to n inclusive
if m [ stu [ i ] ] is greater than maxn , set maxn to m [ stu [ i ] ]
for i = 1 to n inclusive
increment m1 [ stu [ i ] ] by sc [ i ]
if m1 [ stu [ i ] ] is greater than or equal to maxn and m [ stu [ i ] ] is maxn
print stu [ i ] print newline
break loop
create 2d integer array a with size 1005 by 1005
create integers n , i , j , k , x , with k = 0 , create integer array b with size 1005
create boolean f
create string array name with size 1005 , create strings ans , s
read n
for i = 0 to n exclusive
set f to 0
read s read x
for j = 0 to k exclusive
if s is name [ j ]
set a [ i ] [ j ] to a [ i - 1 ] [ j ] + x
end statement
set f to 1
else
set a [ i ] [ j ] to a [ i - 1 ] [ j ]
if f is 0
set name [ k ] to s
set a [ i ] [ k ] to x
increment k
for j = 0 to k exclusive , set b [ j ] to a [ n - 1 ] [ j ]
sort elements from b to b + k
if b [ k - 1 ] is b [ k - 2 ]
for i = 0 to n exclusive
for j = 0 to k exclusive
if a [ i ] [ j ] is greater than or equal to b [ k - 1 ] and a [ n - 1 ] [ j ] is b [ k - 1 ]
set ans to name [ j ]
set i to n
break loop
else
for j = 0 to k exclusive
if a [ n - 1 ] [ j ] is b [ k - 1 ]
set ans to name [ j ]
break loop
print ans print newline
a is an array of integers with size 1005 by 1005
declare integers n , i , j , k and x , with k = 0 , b is an array of integers with size 1005
declare boolean variable f
let ans and s be strings , name is an array of strings with 1005 elements
read n
for i = 0 to n exclusive
set f to 0
read s and x
for j = 0 to k exclusive
if s = name [ j ]
a [ i ] [ j ] = a [ i - 1 ] [ j ] + x
;
assign value of 1 to the f
else
a [ i ] [ j ] = a [ i - 1 ] [ j ]
if f = 0
assign value of s to the name [ k ]
a [ i ] [ k ] = x
increase k by one
for j = 0 to k exclusive , set value of b [ j ] to a [ n - 1 ] [ j ]
sort array b from the start to k
if b [ k - 1 ] = b [ k - 2 ]
for i = 0 to n exclusive
for j = 0 to k exclusive
if a [ i ] [ j ] > = b [ k - 1 ] & & a [ n - 1 ] [ j ] = b [ k - 1 ]
set ans to name [ j ]
assign value of n to the i
break the loop
else
for j = 0 to k exclusive
if a [ n - 1 ] [ j ] = b [ k - 1 ]
set value of ans to name [ j ]
stop the loop
print ans and a new line
create integers t , x and y
read t
let s be an array of strings of size t
create a map from strings to integers called m
declare vector of strings called v
declare vector of integers called v1
create a map from strings to integers called m1
for integer i = 0 to t exclusive
read s [ i ] and x
push s [ i ] into v
push x into v1
if s [ i ] is the last element in m
assign value of x to the m [ s [ i ] ]
else
increase m [ s [ i ] ] by x
create iterator of map from string to int , called it
if it is at the first element of m
y = it - > second
else
if it - > second is greater than y , y = it - > second
if it - > second = y , set m1 [ it - > first ] = 1
clear m
for i = 0 to t exclusive
if v [ i ] is the last element of m1
go to the start of the loop
else
if v [ i ] is the last element of m
set value of m [ v [ i ] ] to v1 [ i ]
if m [ v [ i ] ] > = y
print v [ i ] and a new line
break the loop
else
increase m [ v [ i ] ] by v1 [ i ]
if m [ v [ i ] ] > = y
print v [ i ] and a new line
break the loop
create integers t , x , y
read t
create string s [ t ]
create map m from string to integer
create string vector v
create integer vector v1
create map m1 from string to integer
for i = 0 to t exclusive
read s [ i ] read x
add element s [ i ] to end of v
add element x to end of v1
if first index of s [ i ] in m is end of m
set m [ s [ i ] ] to x
else
increment m [ s [ i ] ] by x
create map iterator it from string to integer
for it = beginning of m to it is not end of m , incrementing it
if it is beginning of m
set y to second element of it
else
if second element of it is greater than y , set y to second element of it
for it = beginning of m to end of m , incrementing it
if second element of it is y , set m1 [ first element of it ] to 1
remove all elements from m
for i = 0 to t exclusive
if first index of v [ i ] in m1 is end of m1
break current loop iteration
else
if first index of v [ i ] in m is end of m
set m [ v [ i ] ] to v1 [ i ]
if m [ v [ i ] ] is greater than or equal to y
print v [ i ] print newline
break loop
else
increment m [ v [ i ] ] by v1 [ i ]
if m [ v [ i ] ] is greater than or equal to y
print v [ i ] print newline
break loop
set constant integer maxn to 128
mp1 and mp2 are maps of string to integer
let name be an array of strings of size 1010
let score be an array of integers of length 1010
declare integer variable n
read n
for i = 0 to n exclusive
read name [ i ] and score [ i ]
increase mp1 [ name [ i ] ] by score [ i ]
set integer maxnum to 0
for integer i = 0 to n exclusive
if mp1 [ name [ i ] ] is greater than maxnum , set maxnum value to mp1 [ name [ i ] ]
for integer i = 0 to n exclusive
increase mp2 [ name [ i ] ] by score [ i ]
if mp2 [ name [ i ] ] > = maxnum & & mp1 [ name [ i ] ] > = maxnum
print name [ i ] and a new line
stop the loop
create integer T
read T
create string array a with size 1000 , create string max1
create integer array b with size 1000 , create integer max with max = - 2000
create map mp from string to int
for i = 0 to T exclusive
read a [ i ] read b [ i ]
increment mp [ a [ i ] ] by b [ i ]
for it = beginning of mp to it is not end of mp , incrementing it
if max is less than second element of it
set max to second element of it
set max1 to first element of it
create map mm from string to int
for i = 0 to T exclusive
increment mm [ a [ i ] ] by b [ i ]
if mm [ a [ i ] ] is greater than or equal to maxn and mp [ a [ i ] ] is max
print a [ i ] print newline
break loop
declare integer variable T
read T
a is an array of strings with size 1000 , max1 is string
b is an array of ints with size 1000 , max is int = - 2000
mp = map from string to integer
for i = 0 to T exclusive
read a [ i ] and b [ i ]
increase mp [ a [ i ] ] by b [ i ]
create map iterator it and move it in the loop through mp
if max is less than it - > second
max = it - > second
max1 = it - > first
mm = map from string to integer
for integer i = 0 to T exclusive
increase mm [ a [ i ] ] by b [ i ]
if mm [ a [ i ] ] > = max and mp [ a [ i ] ] = max
print a [ i ] and a new line
stop the loop
declare integers called t , x and y
read t
s = array of strings of size t
create a map from strings to integers with name m
v = vector of strings
declare vector of integers called v1
let m1 be a map from string to integer
for integer i = 0 to t exclusive
read s [ i ] and x
push s [ i ] into v
push x into v1
if s [ i ] is the last element in m
m [ s [ i ] ] = x
else
increase m [ s [ i ] ] by x
let it be an iterator through a map of string to int
if it is at the start of the m
y = it - > second
else
if it - > second is greater than y , set y to it - > second
if it - > second is equal to y , set m1 [ it - > first ] to 1
clear m
for integer i = 0 to t exclusive
if v [ i ] is the last element in m1
skip the rest of the loop
else
if v [ i ] is the last element in m
m [ v [ i ] ] = v1 [ i ]
if m [ v [ i ] ] > = y
print v [ i ] and a new line
stop the loop
else
increase m [ v [ i ] ] by v1 [ i ]
if m [ v [ i ] ] > = y
print v [ i ] and a new line
stop the loop
n , t , cnt0 , cnt5 = integers with cnt0 = 0 and cnt5 = 0
read n
for i = 0 to n exclusive
read t
if t equals 0
add 1 to cnt0
else
add 1 to cnt5
set x to cnt5 / 9
ans = string
if cnt0 equals 0
set ans to " - 1 "
else
if x equals 0
set ans to " 0 "
else
for i = 0 to x exclusive add " 555555555 " to ans
for i = 0 to cnt0 exclusive add " 0 " to ans
print ans
let v be a vector of long longs
read n
for i = 0 to n exclusive
read a
push a in vector v
if a is greater than f , set f to a
increase s by a
a = n - 1
c = s / a
if s % a , increment c
if f is less than c , set f to c
print f and a new line
set refused to 0
create integers n , a , client
create float b , c = 0
read n , a and b
for i = 0 to n exclusive
read client
if client = 1
if a > 0
decrement a
else if b greater than 0
set b to b - 1
c = c + 0 . 5
else if c > 0
assign c - 0 . 5 to c
other
increment refused
else
if b > = 1
decrement b
otherwise
refused = refused + 2
print refused
create integers n , m , c
read n read m read c
for i = 0 to 10 exclusive
if ( n * 10 + 1 ) % m is 0
print n * 10 + 1
create string x initialized with size c - 1 filled with ' 0 '
print x print newline
set n to 0
break loop
if n is true , print - 1 print newline
create integer array n with size 20
create integer array m with size 20
create integer n1
create integer sumn
create boolean p
declare findn with integer ti as argument , returning integer
if ti is 1 , return 3 from function
if ti is 2 , return 3 from function
if ti is 3 , return 3 from function
if ti is 4 , return 2 from function
if ti is 5 , return 2 from function
if ti is 6 , return 2 from function
if ti is 7 , return 1 from function
if ti is 8 , return 1 from function
if ti is 9 , return 1 from function
if ti is 0 , return 0 from function
declare findm with integer ti as argument , returning integer
if ti is 1 , return 1 from function
if ti is 2 , return 2 from function
if ti is 3 , return 3 from function
if ti is 4 , return 1 from function
if ti is 5 , return 2 from function
if ti is 6 , return 3 from function
if ti is 7 , return 1 from function
if ti is 8 , return 2 from function
if ti is 9 , return 3 from function
if ti is 0 , return 2 from function
declare readin with no arguments , returning void
create character c with c = read character
while c is not a digit , set c to read c
set n [ 1 ] to result of run findn with c - ' 0 ' as argument
set m [ 1 ] to result of run findm with c - ' 0 ' as argument
for i = 2 to n1 inclusive
set c to read character
set n [ 1 ] to result of run findn with c - ' 0 ' as argument
set m [ i ] to result of run findm with c - ' 0 ' as argument
for i = n1 to 1 inclusive , decrementing i
set n [ i ] to n [ i - 1 ]
set m [ i ] to m [ i - 1 ]
declare dfs with integers ni , mi , tip as arguments , returning void
if tip is n1
increment sumn
return from function
create integer ui with ui = ni incremented by n [ tip + 1 ]
create integer vi with vi = mi incremented by m [ tip + 1 ]
read n1
run readin
for i = 0 to 9 inclusive , run dfs with ( result of run findn with i as argument , result of run findm with i as argument , 1 ) as arguments
if sum1 is 1
print " YES " print newline
else
print " NO " print newline
declare integers n , a , b , t , x and s with t and s = 0
read n , a and b
for integer i = 0 to n exclusive
read x
if x = 1
if a is greater than 0
decrease a by one
else if b is greater than 0
decrease b
increase s by one
else if s ! = 0
decrease s by one
else
increment t
else
if b is greater than 0
decrease b
else
set value of t to t + 2
print t
create long long n
read n in a loop
create integers z , f and ans = 0
for i = 0 to n exclusive
declare integer tmp
read tmp
if tmp = 5 increment f
if tmp = 0 increment z
if f % 9 = 0 , set ans to f
if z is 0
print - 1 and a new line
else if f is less than 9
print 0 and a new line
else
print new line
a , b , n = int
read a , b , n
let ans = a
let flag = 0
for i = 0 to 9 inclusive
multiply and by a * 10 + i
if ans module b is 0
flag = 1
print ans
for j = 1 to n exclusive print " 0 "
print newline
if flag is 0 print " - 1 "
declare inline read with no arguments , returning integer
create integer x with x = 0
create character c with c = read character
create boolean flag with flag = 0
while c is less than ' 0 ' or c is greater than ' 9 '
if c is ' - ' , set flag to 1
set c to read character
while c is greater than or equal to ' 0 ' and c is less than or equal to ' 9 '
set x to ( x + ( x bitshift left 2 ) bitshift left 1 ) + c - ' 0 '
set c to read character
return - x is flag is true , else x
create integer array a of size 100010 , create integer n
declare cmp with integers a , b as arguments
return ( if a is greater than b )
set n to result of run read
for i = 0 to n exclusive , set a [ i ] to result of run read
sort elements from a to a + n using cmp to compare
create long longs r , l , ans with r = 100000000000 , l = 0 , ans = ( l + r ) / 2
while l is less than r
create long longs left , i with left = ans
for i = 0 to n exclusive
if a [ i ] is greater than ans
set l to ans + 1
set ans to ( r + 1 ) / 2
break loop
else
set left to left - ( ans - a [ i ] )
if left is less than or equal to 0
set r to ans
set ans to ( r + 1 ) / 2
break loop
if i is n and left is greater than 0
set l to ans + 1
set ans to ( r + 1 ) / 2
print ans print newline
a , b and n = integers
read a , b and n
multiply a by 10
create integer flag with value 0
assign value 0 to the integer ans
for i = 0 to 9 inclusive
set integer x to a + i
if x % b = 0
ans = x
set flag to 1
stop the loop
else
set flag to 0
if flag = 1
print ans
for i = 0 to n - 1 exclusive
print new line
else
print - 1 and a new line
create integers i , j , k
create integer array fr with fr = { 0 , 0 , 1 , - 1 , - 1 , 1 , - 1 , 1 }
create integer array fc with fc = { - 1 , 1 , 0 , 0 , 1 , 1 , - 1 , - 1 }
create long longs n , m , k , mx , mn , sum , sum2 with sum = 0
read n read m read k
set mx to maximum of n and m
set mn to minimum of n and m
if k is greater than ( m + n - 2 )
print - 1 print newline
else
if k is less than or equal to mn - 1
set sum to ( mn / ( k + 1 ) ) , set sum to sum * mx
set sum2 to ( mx / ( k + 1 ) ) , set sum2 to sum2 * mn
set sum to maximum of sum and sum2
else if k is less than or equal to mx - 1
set sum to ( mx / ( k + 1 ) ) , set sum to sum * mn
else
set sum to mn / ( k - mx + 2 )
print sum print newline
declare long long integer variable n
read n
create long long integers fives , tmp and zeroes = 0
while n > 0 , decrement it in a loop
read tmp
if tmp = 5
increase fives by 1
else
increase zeroes by 1
divide fives by 9
if fives and zeroes
while fives > 0 , decrement it in a loop and print " 555555555 "
while zeroes > 0 , decrement it in a loop and print " 0 "
print new line
else if zeroes is not 0
print " 0 "
else
print " - 1 "
create long longs x , y , z , a , b
create deque q with long long
read x
for i = 0 to x exclusive
read y
set b to maximum of b and y
increment a by y
decrement x
print maximum of ( b and long long casted rounded up ( long double casted a / long double casted x ) ) print newline
arrays of integers posy and posx with size 10
array of integers valid with size 5 by 5
s is string
function calc with integer arguments y , x and id that returns boolean
if id + 1 = length of s return true
integer variable dy = y + posy [ s [ id + 1 ] - ' 0 ' ] - posy [ s [ id ] - ' 0 ' ]
integer variable dx = x + posx [ s [ id + 1 ] - ' 0 ' ] - posx [ s [ id ] - ' 0 ' ]
return false if dy < 0 | | dx < 0 | | dy > 4 | | dx > 4 | | valid [ dy ] [ dx ] = 0
return calc ( dy , dx , id + 1 )
for integer i = 1 to 9 inclusive
declare integer called x = i - 1
posy [ i ] = x / 3
posx [ i ] = x % 3
valid [ x / 3 ] [ x % 3 ] = 1
assign value of 3 to posy [ 0 ]
posx [ 0 ] = 1
set valid [ 3 ] [ 1 ] to 1
create integer n
read n
read s
tot is integer = 0
for i = 0 to 10 exclusive
if calc ( posy [ i ] , posx [ i ] , 0 ) returns true , increment tot
if tot = 1
print " YES " and a new line
else
print " NO " and a new line
declare integer n
read n
create integer array a with 3 elements
read a [ 1 ] and a [ 2 ]
put 0 to a [ 0 ]
declare integer inp
create unsigned integer left_out = 0
for i = 0 to n exclusive
read inp
if a [ inp ] is greater than 0
decrement a [ inp ]
else if a [ 2 ] > 0 & & inp = 1
decrement a [ 2 ]
increase a [ 0 ] by one
else if a [ 0 ] > 0 & & inp = 1
decrement a [ 0 ]
else
increase left_out by inp
print left_out
create integer test with test = 1
while decrement test is true
create integers n , m , i , j , x , y , s , k , q , a , b , c with c = 0
create long long integer sum with sum = 0
read n
for i = 0 to n exclusive
read k
increment sum by k
set c to maximum of c and k
set j to 1 if sum % ( n - 1 ) is greater than 0 , else 0
set sum to sum / ( n - 1 ) + j
set sum to sum if sum is greater than c , else c
print sum print " \ n "
num is an integer array with 30 elements and vis is an integer array with 1010 elements
str and ans are character arrays with size 1010
declare integer variables t , q , i , j , k , len , t1 and mx , with mx = 0
read str + 1
len = length of ( str + 1 )
for i = 1 to len inclusive
t = str [ i ] - ' a ' + 1
increase num [ t ] by one
if num [ t ] is greater than num [ mx ] set mx to t
let cur = 1 and nf = 0 be integers
for i = 2 to len inclusive
continue the loop if vis [ i ] is not 0
if i * 2 < = len
for j = i to len inclusive incrementing j by i
continue if vis [ j ] is not 0
if num [ mx ] < = 0
assign value of 1 to nf
stop the loop
ans [ j ] = mx - 1 + ' a '
decrease num [ mx ]
set vis [ j ] to 1
if nf is not 0 , break
for i = 1 to len while - < = len and ! nf
continue if vis [ i ] is not 0
while num [ cur ] < = 0 & & cur < = 26 increment cur
if cur is greater than 26
assign value of 1 to nf
stop the loop
ans [ i ] = cur - 1 + ' a '
decrease num [ cur ] by one
if nf is not 0
print " NO \ n "
else
print " YES \ n " , ans + 1 and a new line
declare integer variables n , left , right , up and down
str is string
read n
read str
left , right , up and down = 1
for integer i = 0 to n exclusive
if str [ i ] = ' 1 ' | | str [ i ] = ' 2 ' | | str [ i ] = ' 3 ' , set up to 0
if str [ i ] = ' 7 ' | | str [ i ] = ' 9 ' | | str [ i ] = ' 0 ' , set down to 0
if down = 1 | | up = 1 | | left = 1 | | right = 1
print " NO " and a new line
else
print " YES " and a new line
declare fastIo with no arguments , returning void
run fastIo
create long longs n , m
read n read m
create long long sum with sum = 0
for i = 0 to n exclusive
create long long temp
read temp
increment sum by temp
if m - sum is less than 10 * ( n - 1 )
print " - 1 " print newline
else
set sum to m - sum - 10 * ( n - 1 )
create long long cnt with cnt = ( n - 1 ) * 2
increment cnt by sum / 5
print cnt print newline
create long longs n , i , ans , m , sol with ans = 0 , m = - 1
read n
create long long array ar with size n
for i = 0 to n exclusive
read ar [ i ]
set ans to ans + ar [ i ]
set m to maximum of m and ar [ i ]
set sol to ans / ( n - 1 )
if sol * ( n - 1 ) is not ans , increment sol
print maximum of m and sol , print " \ n "
hy , ay , dy , hm , am , dm , h , a , d = int
read hy then ay then dy
read hm then am then dm
read h then a then d
minbitcoins = int with minbitcoins = INT_MAX
for t = 1 to 201
defcos = int with defcos = 0
if hy is less or equal to am * t - dy * t then set defcos to ( am * t - dy * t - hy + 1 ) * h
if dy * t is greater than am * t - hy
set defcos to 0
else
set defcos to min of defcos and ( ( am * t - hy ) / t - dy + 1 ) * d
atcos = int with atcos = 0
set minbitcoins to min of minbitcoins and atcos + defcos
declare integer called n
read n
let f and z be integers = 0
for integer i = 0 to n exclusive
declare integer a
read a
if a = 5
increase f by 1
else
increase z by 1
f = f / 9 * 9
if z = 0
print - 1 and a new line
print string ( f , ' 5 ' ) , " 0 " if f = 0 or string ( z , ' 0 ' ) , and a new line
create integer n , create integer array a with size 11 , with a = { 0 }
read n
create string s
read s
for i = 0 to n exclusive , set a [ s [ i ] - ' 0 ' ] to 1
create integers flag_u , flag_d , flag_l , flag_r , set flag_u to 1 , set flag_d to 1 , set flag_l to 1 , set flag_r to 1
if a [ 0 ]
set flag_d to 0
set flag_l to 0
set flag_r to 0
if a [ 0 ] or ( a [ 0 ] is false and a [ 7 ] or a [ 9 ] ) set flag_d to 0
if a [ 1 ] or a [ 2 ] or a [ 3 ] , set flag_u to 0
if a [ 1 ] or a [ 4 ] or a [ 7 ] , set flag_l to 0
if a [ 3 ] or a [ 6 ] or a [ 9 ] , set flag_r to 0
if not flag_u and not flag_d and not flag_l and not flag_r
print " YES " print newline
else
print " NO " print newline
create integers i , j , n , count
create 2d character array a with size 1001 by 5
read n
for i = 0 to n exclusive
for j = 0 to 5 exclusive , read a [ i ] [ j ]
for x = 0 to n exclusive
for y = 0 to 5 exclusive
if a [ x ] [ y ] is ' O ' and a [ x ] [ y + 1 ] is ' O '
set count to 0
print " YES " print newline
set a [ x ] [ y ] to ' + '
set a [ x ] [ y + 1 ] to ' + '
break loop
else
increment y by 2
set count to 1
if count is 0 , break loop
if count is 1 , print " NO " print newline
if count is 0
for k = 0 to n exclusive
for l = 0 to 5 exclusive , print a [ k ] [ l ]
print newline
k = array of ints of length 10000000
create integers a , b , p , m , j with m and j set to 0
read p , a and b
for i = 1 to p inclusive read k [ i ]
for i = 1 to p inclusive
if k [ i ] is 1
if a is greater than 0
set a to a - 1
continue
else if b is greater than 0
set b to b - 1
assign m + 1 to m
continue
else if m is greater than 0
set m to m - 1
continue
assign j + 1 to j
continue
if b is greater than 0
set b to b - 1
continue
assign j + 2 to j
continue
print j
create long long n
cad is string
declare boolean variable called power
read n
read cad
set value of power to true
for integer i = 0 to n exclusive
declare integer called x = cad [ i ] - ' 0 '
if x = 0 , set x to 1
if x = 1 or x = 4 or x = 7 , set power to false
if power is true
print " NO \ n "
power = true
for integer i = 0 to n exclusive
declare integer variable called x = cad [ i ] - ' 0 '
if x = 0 set x to 9
if x = 3 or x = 6 or x = 9 , set power to false
if power = true
print " NO \ n "
assign value of true to power
for integer i = 0 to n exclusive
declare integer called x = cad [ i ] - ' 0 '
if x = 0 , set x = 11
if x - 3 is less than 1 , set power to false
if power is true
print " NO \ n "
assign value of true to power
for i = 0 to n exclusive
create integer x = cad [ i ] - ' 0 '
if x = 8
if x = 0
if x + 3 is greater than 9 , set power to false
if power is true
print " NO \ n "
print " YES \ n "
let n be integer
m = long long
s = long long
read n in a loop
s = 0
for integer i = 0 to n exclusive
t = integer
read t
increase s by t
if i = 0
set m to t
else
if m is less than t
long long x = s / ( n - 1 )
if s % ( n - 1 ) is not 0 , increment x
if m is greater than x set x to the value of m
print x and a new line
let n , d , t , aux be integers with aux is equal to 0
read n and d
for i = 0 to n exclusive
read t
aux is equal to ( aux + t )
if ( aux + ( n - 1 ) * 10 is greater than d )
print - 1 and newline
print ( d - aux ) / 5 and newline
create integer n
declare boolean check = false
read n
declare string variable input = " "
declare vector of characters result
read and discard current input
for integer i = 0 to n exclusive
read input into input
if ( input [ 0 ] = ' O ' ) & & ( input [ 1 ] = ' O ' ) & & check is false
assign value of true to check
push " + " to result
push " + " to result
else
push input [ 0 ] to result
push input [ 1 ] to result
push input [ 2 ] to result
if ( input [ 3 ] = ' O ' ) & & ( input [ 4 ] = ' O ' ) & & check is false
set value of check to true
push " + " to result
push " + " to result
push " \ n " to result
else
push input [ 3 ] to result
push input [ 4 ] to result
push " \ n " to result
print " YES " is check is true or " NO " if it false , and a new line
for integer i = 0 to length of result exclusive , while check is true , print result [ i ]
let n , m , p , a and b be integers
void function solve
read a , b and n
let tmp be integer = a * 10
for i = 0 to 10 exclusive
if tmp % b = 0
print tmp
print " 0 " n - 1 times
print new line
return
increase tmp
print - 1 and a new line
;
declare integer variable T = 1
call solve ( ) T times
long long integer n , and an array a of long long integers with size 100010
boolean function check with long long int argument x
tmp and i are long long integers , with tmp = 0
for i = 0 to n exclusive , increment tmp by x - a [ i ]
return ( tmp > = x )
long long int function binSearch with long long integer arguments low and high
while low is less than high
long long int mid = low + ( high - low ) / 2
if check ( mid ) returns true
assign value of mid to high
else
assign value of mid + 1 to low
return low
t is long long integer = 1
decrement t in a loop
ans and i are long long integers , with ans = 0
read n
set ans to binSearch ( a [ n - 1 ] , 1e14 )
print ans and " \ n "
pi = const double with pi = acos of - 1
MODPRIMA = const long long with MODPRIMA = 1e9 + 7
MAXX = const long long with MAXX = 1e18
MINN = const long long with MINN = - 1e18
EPS = const double with EPS = 1e - 9
N , M , K = long long
read N then M then K
if K is greater than N - 1 + M - 1
print - 1
else
ans = long long with ans = 0
if K is less than N then set ans to ( N / ( K + 1 ) ) * M
if K is less than M then set ans to max of ans and ( M / ( K + 1 ) ) * N
if K is greater or equal to N then set ans to max of ans and ( M / ( K - ( N - 1 ) + 1 ) )
if K is greater or equal to M then set ans to max of ans and ( N / ( K - ( M - 1 ) + 1 ) )
n , m , k , ans = integers with ans = 0
Read n , m , k
if n is greater than m
t = integer , set to n
set n to m
set m to t
if k is greater than n + m - 2
print - 1 and a new line
if k is less than m
print maximum value of m / ( k + 1 ) * n and n / ( k + 1 ) * m and a new line
print n / ( k + 2 - m ) and new line
declare long longs called n , maxn , sum , tot and ans
long long integer method read
X and w are long longs = 0
set character ch to 0
while isdigit ( ch ) is false , w | = ch = ' - ' , ch = char from the input
while isdigit ( ch ) is true , X = ( X < < 3 ) + ( X < < 1 ) + ( ch ^ 48 ) , ch = char from the input
return - X is w , or X
in the method write with long long argument x
create long long num with value 0
let ch be an array of characters of size 20
if x is 0 , increment num and set ch [ num ] to ' 0 '
while x is 1 , increment num and set ch [ num ] to ( x % 10 ) + 48 , x / = 10
while num is 1 putchar ( ch [ num - - ] )
call function puts with arguments " "
n = read ( )
for i = 1 to n inclusive
assign result of the read ( ) to the long long x
decrease sum by x
set maxn to max of maxn and x
tot = maxn * n + sum
if tot > = maxn
invoke function write with arguments maxn
else
ans = maxn + ceil ( ( maxn - tot ) / ( n - 1 . 0 ) )
call function write with arguments ans
create integer n
create booleans z , y , x , with z = 1 , y = 1 , x = 0
create 2d character array arr with size 1069 by 1069
read n
for i = 1 to n inclusive
for j = 1 to 5 inclusive , read arr [ i ] [ j ]
for i = 1 to n inclusive
for j = 1 to 5 inclusive
if arr [ i ] [ j ] is arr [ i ] [ j + 1 ] and arr [ i ] [ j ] is ' O ' , set x to 1
if x is true
print " YES \ n "
else
print " NO \ n "
for i = 1 to n inclusive
for j = 1 to 5 inclusive
if arr [ i ] [ j ] is arr [ i ] [ j + 1 ] and arr [ i ] [ j ] is ' O ' and z is 1
print " + "
set z to false
else if arr [ i ] [ j ] is arr [ i ] [ j - 1 ] and arr [ i ] [ j ] is ' O ' and y is 1
print ' + '
set y to 0
else
print arr [ i ] [ j ]
print newline
n , temp = integers
zeros , fives = integers with zeros = 0 and fives = 0
read n
for i = 0 to n exclusive
read temp
if temp = 5
increment fives
else
increment zeros
if zeros > 0 and fives > 9
i = 0
for i = 1 to ( fives - fives remainder 9 ) inclusive print 5
while decrement zeros print 0
print newline
else if zeros < = 0
print - 1
else
print 0
let n , a , b , sum , ans and s be integers where sum and s = 0
read n , a and b
for integer i = 0 to n exclusive
read ans
if ans = 1
if a is greater than 0
decrement a
else if b is greater than 0
decrement b
increase s
else if s ! = 0
decrease s
else
increase sum
else
if b is greater than 0
decrease b
else
assign value of sum + 2 to sum
print sum
the integer value of long is sum
let mx , n be integers
read the value of n
for i = 0 to n exclusive
let x be a integer
read the value of x
sum is equal to sum + x
mx is equal to maximum of mx and x
printout max ( 1LL * mx , ( sum + n - 2 ) / ( n - 1 ) ) and newline
s = array of 1001 strings
x = string
n = int
read n
for i = 0 to n exclusive read s [ i ]
for i = 0 to n exclusive
if first char of s [ i ] is ' O ' and is equal to second char
first and second chars of s [ i ] = ' + '
print " YES "
for i = 0 to n exclusive read s [ i ]
if fourth char of s [ i ] is ' O ' and is equal to fifth char
fourth and fifth chars of s [ i ] = ' + '
print " YES "
for i = 0 to n exclusive read s [ i ]
print " NO "
create integer arrays num , vis with num size 30 , vis size 1010
create character arrays str , ans , with str size 1010 , ans size 1010
create integers t , q , i , j , k , len , mx , mp , with mx = 0
create character mw
read str + 1
set len to string length of ( str + 1 )
for i = 1 to len inclusive
set t to str [ i ] - ' a ' + 1
increment num [ t ]
if num [ t ] is greater than mx
set mx to num [ t ]
set mp to t
create integers cur , nf with cur = 1 , nf = 0
for i = 2 to len inclusive
if vis [ i ] is true , break current loop iteration
if i * 2 is less than or equal to len
for j = i to len inclusive , increment j by i
if vis [ j ] is true , break current loop iteration
if num [ mp ] is less than or equal to 0
set nf to 1
break loop
set ans [ j ] to mp - 1 + ' a '
decrement num [ mp ]
set vis [ j ] to 1
if nf is true , break loop
for i = 1 to len inclusive
if vis [ i ] is true , break current loop iteration
while num [ cur ] is lesser than or equal to 0 and cur is lesser than or equal to 26 , increment cur
if cur is greater than 26
set nf to 1
break loop
set ans [ i ] to cur - 1 + ' a '
decrement num [ cur ]
if nf is true
print " NO \ n "
else
print " YES \ n " print ans + 1 print newline
create integer n
read n
create integers cf , cz with cf = 0 , cz = 0
for i = 0 to n exclusive
create integer t
read t
if t is 5
increment cf
else
increment cz
if cz is 0
print - 1 print newline
for i = 0 to cf / 9 * 9 exclusive , print " 5 "
if cf is greater than or equal to 9
for i = 0 to cz exclusive , print " 0 "
else
print " 0 "
print newline
declare long integers a , b , c , d , i , j , k , l , n and m with b = 0
read n and m
assign value of m to d
for i = 0 to n exclusive
read a
increase b by a
decrease m by b
c = m / 10
if c > = ( n - 1 ) and ( b < = d )
print m / 5
else
print " - 1 "
set ng , a , b , h to 0
read ng , a and b
assign 0 to ans
create int k
for i = 0 to ng exclusive
read k
if k = 1
if a is greater than 0
decrement a
else if b > 0
decrement b
increment h
otherwise if h > 0
decrement h
else
add 1 to ans
else
if b is greater than 0
decrement b
other
ans = ans + 2
print ans
create long long b , n , a , s , e , g , h , i , t
read n , a , b
for i = 0 to n exclusive
read t
if t = 1
if a > 0
decrement a
else
if b > 0
decrement b
increment h
otherwise
if h > 0
decrement h
else
increment g
if t = 2
if b > 0
decrement b
else
g = g + 2
print g
h1 , h2 , a1 , a2 , d1 , d2 , hc , dc , ac = integers
in the function win that takes integers h1 , h2 , a1 , a2 , d1 , d2 , hc , dc , ac and returns integer
x1 , x2 = integer with x1 = max ( 0 , a2 - d1 ) , x2 = max ( 0 , a1 - d2 )
if x1 is 0 and x2 is not 0 , return 1
if x2 is 0 , return 0
k1 , k2 = integers with k1 = ceil of ( double ) h1 / x1 ) , k2 = ceil of ( double ) h2 / x2 )
if k1 > k2 , return 1
read h1 , a1 , d1
read h2 , a2 , d2
read hc , ac , dc
ans = integer with ans = 1000000
if win takes h1 , h2 , a1 , d1 , a2 , d2
print 0
k = integer
if max of a2 - d1 and 0 is 0
print ( d2 + 1 - a1 ) * ac
k = ceil of ( double ) h1 / ( a2 - d1 )
for d = 0 to a2
for a = 0 to 200
if win takes h1 , h2 , a1 + a , d1 + d , a2 , d2
ans = min of ans and a * ac + d * dc
continue next iteration
for i = k + 1 to 100
h = integer with h = ( i - 1 ) * ( a2 - d1 ) + 1 - h1
if win takes h1 + h , h2 , a1 + a , d1 + d , a2 , d2
ans = min of ans and h * hc + a * ac + d * dc
continue next iteration
print ans
declare prime with integer x as argument , returning integer
for i = 2 to x exclusive
if x % i is 0 , return false from function
return true from function
create string s
read s
create integer comp with comp = length of s - 1
for i = 2 to length of s inclusive
if 2 * i is greater than length of s and result of run prime with i as argument , decrement comp
create integer vector letters initialized with 26 , 0
for i = 0 to length of s exclusive , increment letter [ s [ i ] - ' a ' ]
create boolean ok with ok = false
create integer let
for i = 0 to 26 exclusive
if letters [ i ] is greater than or equal to comp
set let to i , set ok to true
break loop
create integer cur with cur = 0
if not ok
print " NO \ n "
decrement letters [ let ] by comp
print " YES \ n "
create string t with t = " "
for i = 1 to length of s inclusive
if i is 1 or ( 2 * i is greater than length of s and result of run prime with i as argument )
while letters [ cur ] is 0 , increment cur
increment to by character casted ( ' a ' + cur )
decrement letters [ cur ]
else
increment t by character casted ( ' a ' + let )
print t print newline
declare integer variables n , a and b
read n , a and b
create integer i
declare vector of integers variable gp
for i = 0 to n exclusive
declare integer g
read g
push g to gp
create integers count and seat = 0
for i = 0 to n exclusive
if gp [ i ] = 1
if a is greater than 0
set a to a - 1
else
if b is greater than 0
decrement b
increment seat
else if seat is greater than 0
decrement seat
else
increase count
else
if b is greater than 0
decrement b
else
set count to count + 2
print count
create integer numPeople
read numPeople
create long long sum with sum = 0
create long long maxVal with maxVal = 0
for i = 0 to numPeople exclusive
create long long person
read person
set maxVal to maximum of maxVal and person
increment sum by person
while maxVal * ( numPeople - 1 ) is less than sum , increment maxVal
print maxVal print " \ n "
declare sum_mod with long longs a , b as arguments , returning long long
return ( a + b ) % 1000000007 from function
declare subtract mod with long longs a , b as arguments , returning long long
return ( a % 1000000007 - b % 1000000007 + 1000000007 ) % 1000000007 from function
declare multiply_mod with long longs a , b as arguments returning long long
return ( a % 1000000007 * b % 1000000007 ) % 1000000007 from function
declare modInverse with long longs x , y as arguments , returning long long
declare long long res with res = 1
set x to x % 1000000007
while y is greater than 0
if y bitwise and 1 , set res to ( res * x ) % 1000000007
set y to y bitshift right 1
set x to ( x * x ) % 1000000007
return res from function
declare divide_mod with long longs a , b as arguments , returning long long
return ( a * modInverse ( b , 1000000007 - 2 ) ) % 1000000007 from function
declare gcd with long longs a , b as arguments , returning long long
while b is true , swap values between ( set a to a % b ) and b
return a from function
create long longs n , d
read n read d
create long long vector nums initialized with n
create long longs cnt , t , with cnt = 0 , t = 0
end statement
for i = 0 to n exclusive
read nums [ i ]
increment t by nums [ i ]
if i is less than n - 1 , increment t by 10
increment cnt by nums [ i ]
if t is greater than d
print - 1 print newline
else
print ( d - cnt ) / 5 print newline
create integers n , a , denied , client , single with denied = 0 , single = 0
create integer b
read n read a read b
for i = 0 to n exclusive
read client
if client is 1
if a is greater than 0
decrement a
else if b is greater than 0
decrement b
increment single
else if single is greater than 0
decrement single
else
increment denied
else if b is greater than 0
decrement b
else
increment denied by 2
print denied print newline
n , m , k = long long
read n , m , k
if n - 1 + 1 - 1 < k
print - 1
if n < m swap ( n , m )
maxx = 0
maxx = max ( maxx , n / ( k + 1 ) * m )
maxx = max ( maxx , m / ( k + 1 ) * n )
if maxx is not zero
print maxx
subtract n - 1 from k
print m / ( k + 1 )
create 2d integer array a with size 5 by 5
create integer arrays b , c , with b size 10 , c size 10
create integer x with x = 1
create integer n
read n
set bytes from a to size of a to - 1
for i = 1 to 4 exclusive
for j = 1 to 4 exclusive , set a [ i ] [ j ] to increment x
set a [ 4 ] [ 2 ] to 0
create string s
read s
create integers last , coun with last = s [ 0 ] - ' 0 ' , coun = 0
for i = 1 to size of s exclusive
create integers y , now , with y = 0 , now = s [ i ] - ' 0 '
if last is 0 , set last to 11
if now is 0 , set now to 11
set x to ( now + 2 ) / 3 - ( last + 2 ) / 3
set y to now - x * 3 - last
set b [ i ] to x
set c [ i ] to y
set last to now
for i = 1 to 5 exclusive
for j = 1 to 5 exclusive
if a [ i ] [ j ] is - 1 , break current loop iteration
create integer k with k = 1
create integers newX , newY
set newX to i , set newY to j
for k = 1 to n exclusive
increment newX by b [ x ] , increment newY by c [ k ]
if newX is less than 0 or newX is greater than 4 or newY is less than 0 or new Y is greater than 4 or a [ newX ] [ newY ] is - 1 , break loop
if k is n , increment coun
if coun is greater than 1
print " NO " print newline
else
print " YES " print newline
in the function power with arguments long long int x , long long int n , long long int m and return long long int
if n is 0 , then return 1
if n is 1 , then return x
x is assigned x mod m
if n mod 2 is true , then return ( x * ( power ( ( x * x ) % m , n / 2 , m ) % m ) ) % m
return power ( ( x * x ) % m , n / 2 , m ) mod m
make long long integers hy , ay , dy , hm , am , dm , h , a , d
read hy , ay , dy , hm , am , dm , h , a , d
make long long integer ans with ans = 1000000000000000
for long long integer atk = ay to 200 inclusive
for long long integer def = dy to 100 inclusive
if atk is less than or equal to dm , then continue
make long long integer t with t = hm / ( atk - dm )
if hm modulo ( atk - dm ) is not 0 , then increment t
make long long integer hr with hr = t * ( max ( 0LL , am - def ) ) + 1
make long long integer cost with cost = 0
if hr is greater than hy , then add ( ( hr - hy ) * h ) to cost
if atk is greater than ay , then add ( ( atk - ay ) * a ) to cost
if def is greater than dy , then add ( ( def - dy ) * d ) to cost
if ans is greater than cost , set ans to cost
output ans
create integers h , a , d , hp1 , atk1 , def1 , hp2 , atk2 , def2
create integers i , j , k , diff , res
while read hp1 read atk1 read def1
read hp2 read atk2 read def2
read h read a read d
create integer temp
set res to 100000000
for i = 0 to 1001 exclusive
for j = 0 to 1001 exclusive
set k to 0
set temp to hp1 + i
set diff to ( atk1 + j ) - def2
if diff is less than or equal to 0 , break current loop iteration
if diff is greater than hp2
set k to temp - 1
else
set k to hp2 / diff
set k to temp / k
while 1 is true
if k is less than or equal to 0
break loop
else if ( temp / k ) + ( temp % k is greater than 0 ) is greater than ( hp2 / diff ) + ( hp2 % diff is greater than 0 )
break loop
decrement k
set temp to atk2 - def1 if 0 is less than atk2 - def1 , else 0
if k is less than temp
set k to temp - k
else
set k to 0
set res to i * h + j * a + k * d if res is greater than i * h + j * a + k * d , else res
print res print newline
create long long integers i , n , m , j , a , count , c , last , have , sum , rest with count = 0 , c = 0 , sum = 0
read n
for i = 0 to n exclusive
read a
end statement
if a is 0
increment c
else
increment count
increment sum by a
if count / 9 is not 0 and c is greater than 0
set have to sum / 9
set rest to have / 5
for i = 0 to 9 * rest exclusive , print 5
for i = 0 to c exclusive , print 0
print newline
else if c is greater than 0
print 0 print newline
else
print - 1 print newline
declare long long integers n , m , k , mn and mm
read n , m and k
if n - 1 + m - 1 is less than k
print - 1
else
if k is greater than n - 1
mm = m / ( k - ( n - 1 ) + 1 )
else
mm = m * ( n / ( k + 1 ) )
if k is greater than m - 1
mn = n / ( k - ( m - 1 ) + 1 )
else
mn = n * ( m / ( k + 1 ) )
print max of mn and mm
let n and check be integers with check = 0
create string array s with 1000 elements
read n
for i = 0 to n exclusive
for integer j = 0 to length of s [ i ] - 1 exclusive
if s [ i ] [ j ] = ' O ' & & s [ i ] [ j + 1 ] = ' O '
s [ i ] [ j ] = ' + '
s [ i ] [ j + 1 ] = ' + '
set check to 1
break the loop
if check is not 0 , break
if check is not 0
print " YES \ n "
print n elements of array s
else
print " NO \ n "
create constant integer maxn with maxn = 5005
create integers n , flag1 , flag2 , flag3 , flag4
read n
create string str
read str
set flag1 to flag2 to flag3 to flag4 to j
for i = 0 to n exclusive
ir str [ i ] is ' 1 ' or str [ i ] is ' 2 ' or str [ i ] is ' 3 ' , set flag1 to 0
if str [ i ] is ' 7 ' or str [ i ] is ' 9 ' or str [ i ] is ' 0 ' , set flag3 to 0
if flag1 or flag2 or flag3 or flag4
print " NO " print newline
else
print " YES " print newline
declare constant integer N = 101010
declare integers hp , atk and def
declare integer variables hp1 , atk1 and def1
declare integers a , b and c
read hp , atk and def
read hp1 , atk1 and def1
read a , b and c
declare integer cost = 99999999
for j = 0 to 100 + 100 + 1 exclusive
for k = 0 to 100 + 1 exclusive
if atk1 - def - k < = 0
if atk + j - def1 is greater than 0
cost = min of b * j + c * k and cost
else
go to the start of the loop
else
create integer time = hp1 * 1 . / ( 1 . * ( atk + j - def1 ) ) rounded up
create integer time2 = hp / ( atk1 - def - k ) rounded up
if time is less than 0 , continue the loop
if time2 is greater than time
cost = min of b * j + c * k and cost
else
set integer addhp to max of 0 and ( time * ( atk1 - def - k ) ) + 1 - hp
cost = min of cost and addhp * a + j * b + c * k
print cost
create integer n
while read n is true
create string s
read s
create booleans left , right , up , down
set left to right to up to down to false
for i = 0 to length of s exclusive
if s [ i ] is ' 1 ' or s [ i ] is ' 2 ' or s [ i ] is ' 3 ' , set up to true
if s [ i ] is ' 7 ' or s [ i ] is ' 0 ' or s [ i ] is ' 9 ' , set down to true
if up and down and left and right
print " YES " print newline
else
print " NO " print newline
declare solve with no arguments , returning void
create integer n
read n
create integer vector v
for i = 0 to n exclusive
create integer x
read x
add element x to end of v
sort elements from beginning of v to end of v
create integer i with i = 0
create integer j with j = n - 1
create integer ans with ans = 0
while 2 * v [ i ] is less than v [ j ]
if 2 * v [ i + 1 ] is greater than or equal to v [ j ]
increment i
increment ans
else if 2 * v [ i ] is greater than or equal to v [ j - 1 ]
decrement j
increment ans
else
increment ans by 2
increment i
decrement j
print ans print newline
declare solve2
create integers a , b , n
read a read b read n
if a % b is 0
print a
for i = 0 to n exclusive , print 0
print newline
return from function
create boolean c with c = false
for i = 0 to 9 inclusive
if ( a * 10 + i ) % b is 0
print a print i
set c to true
break loop
if c is true
for i = 0 to n - 1 exclusive , print 0
print newline
else
print - 1 print newline
run solve2
declare unsigned long longs n , m and k
read n , m and k
if n is greater than m , swap n and m
if k is less than m
print max of ( n / ( k + 1 ) ) * m and n * ( m / ( k + 1 ) )
else if k < = n + m - 2
print ( n / ( k + 2 - m ) )
else
print - 1
declare character array ch with size 1009 by 200
let n , flag , i and j be integers with flag = 0
read n
for i = 1 to n inclusive
for j = 1 to 5 inclusive read ch [ i ] [ j ]
for i = 1 to n inclusive
for j = 1 to 5 exclusive
if ch [ i ] [ j ] = ' O ' and ch [ i ] [ j + 1 ] = ' O '
ch [ i ] [ j ] = ' + '
ch [ i ] [ j + 1 ] = ' + '
set flag to 1
stop the loop
if flag = 1 , break
if flag = 1
print " YES "
for i = 1 to n inclusive
for j = 1 to 5 inclusive print ch [ i ] [ j ]
print new line
else
print " NO "
n , a , b , x , sum , c = int with sum = 0 and c = 0
read n then a then b
for i = 0 to n
read x
if x equals 1
if a is not 0
decrement a
else if b is not 0
decrement b
increment c
else if c is not zero
decrement c
else
increment sum
else
if b is not zero
decrement b
else
add 2 to sum
print sum
mpu = map from character to character
vec is vector of long longs of size 1000006
let b and a be empty integer arrays of size 1000006
let visit be empty boolean array of size 1000006
declare string variable s
read s
n and sum are long longs with sum = 0
n = size of s
declare vector of long longs called v
for i = 2 to n inclusive
set boolean t to 0
for integer j = 2 to i exclusive
if i % j = 0
assign value of 1 to the t
stop the loop
if t = 0 , push i into v
w is an empty array of integers with size 26
for i = 0 to length of s exclusive
integer t = s [ i ] - ' a ' casted to int
increase w [ t ]
for integer i = 0 to length of v exclusive
if v [ i ] * 2 is greater than n , break
for k = v [ i ] to length of s inclusive incrementing by v [ i ]
if visit [ k - 1 ] = 1 , continue
increment sum
visit [ k - 1 ] = 1
if sum = 0
print " YES \ n " , s and a new line
assign value - 1 to the integer p
for integer i = 0 to 26 exclusive
if w [ i ] > = sum , set p to i
if p = - 1
print " NO \ n "
print " YES \ n "
for i = 0 to n exclusive
if visit [ i ] = 1
s [ i ] = char ( p ) + ' a '
decrease w [ p ]
for integer i = 0 to n exclusive
if visit [ i ] = 1 , continue
for integer j = 0 to 26 exclusive
if w [ j ] is greater than 0
s [ i ] = char ( j ) + ' a '
decrease w [ j ]
stop the loop
print s and a new line
create integer a
read a
create string s
create string sum
create string vector v2
create boolean check with check = false
for i = 0 to a exclusive
read s
for j = 0 to length of s exclusive
if s [ j ] is ' O ' and s [ j + 1 ] is ' O ' and check is false
set s [ j ] to ' + '
set s [ j + 1 ] to ' + '
set check to true
if check is true
set sum to " YES "
else
set sum to " NO "
add element s to end of v2
print sum print newline
for i = 0 to a exclusive
if sum is " YES " print v2 [ i ] print newline
create integer N
read N
declare character array mat with size N + 1 by N + 1
let rows and columns be arrays of integer vectors with size N + 1
for integer i = 1 to N inclusive
for integer j = 1 to N inclusive
read mat [ i ] [ j ]
if mat [ i ] [ j ] ! = ' E '
push j to the end of rows [ i ]
push i to the end of columns [ j ]
create booleans rowFull and columnFull = false
for i = 1 to N inclusive
if size of rows [ i ] is 0 , set rowFull to true
if size of columns [ i ] is 0 , set columnFull to true
if rowFull & & columnFull
print " - 1 "
else if rowFull
for i = 1 to N inclusive print columns [ i ] [ 0 ] , " " and i
else
for integer i = 1 to N inclusive print i , " " and rows [ i ] [ 0 ]
create integer n
read n
create a char str with lenght of 10000
for i = 0 to n * 5 exclusive read str [ i ]
create integer c with c = 0
for i = 0 to n * 5 exclusive
if str [ i ] is equal ' O ' and str [ i + 1 ] is equal ' O '
if i + 1 module 5
set c to 1
set str [ i ] to ' + '
set str [ i + 1 ] to ' + '
stop loop
if c equal to 1
print " YES " and new line
for i = 0 to n * 5 exclusive
print str [ i ]
if i + 1 module 5 equal to 0 print new line
else
print " NO " and new line
create integer n
create boolean ok with ok = false
read n
create 2d character array seat with size n by 5
for i = 0 to n exclusive
read seat [ i ]
if not ok
for j = 0 to 5 exclusive
if seat [ i ] [ j ] is ' O ' and seat [ i ] [ j + 1 ] is ' O '
set ok to true
set seat [ i ] [ j ] to seat [ i ] [ j + 1 ] to ' + '
set ok to true
go to jump label l
create jump label l
create jump label end
if ok is true
print " YES " print newline
for i = 0 to n exclusive
for j = 0 to 5 exclusive , print seat [ i ] [ j ]
print newline
else
print " NO " print newline
hp_y , atk_y , def_y = int
hp_m , atk_m , def_m = int
h , a , d = int
read hp_y , atk_y , def_y
read hp_m , atk_m , def_m
read h , a , d
ans = INT_MAX
for i = atk_y to 200 inclusive
for j = def_y to 200 inclusive
damage_y = max ( 0 , i - def_m )
damage_m = max ( 0 , atk_m - j )
if damage_y is zero continue
turn = hp_m / damage_y
if hp_m modulo damage_y is not zero increment turn
hp_needed = max ( 0 , 1 - ( hp_y - damage_m * turn ) )
ans = min ( ans , ( i - atk_y ) * a + ( j - def_y ) * d + hp_needed * h )
hy , ay , dy , hm , am , dm , h , a , d = long long int , cost = 10 ^ 12
read hy , ay , dy , hm , am , dm , h , a , d
q = hm , z = ay , n = dm
temp = q / ( z - n )
for i = max ( dm - ay + 1 , 0 ) to 200 inclusive
for j = 0 to 200 inclusive
v = ( ( hm - 1 ) / ( ay - dm + i ) ) + 1
p = max ( 0 , am - dy - j )
req = max ( v * p + 1 - hy , 0 )
cost = min ( cost , req * h + i * a + j * d )
print cost
create long longs n , m , k
create long longs ans , a , b
read n read m read k
set ans to 0
if k is greater than n + m - 2
print " - 1 "
for i = 1 to i is less than or equal to squre root of n and i is less than or equal to k + 1
if n % i is 0
set a to i - 1
set b to k - a
set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) )
set a to ( n / i ) - 1
if a is greater than k , break current loop iteration
set b to k - a
set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) )
for i = 1 to i is less than or equal to square root of m and i is less then or equal to k + 1
if n % i is 0
set b to i - 1
set a to k - b
set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) )
set b to ( m / i ) - 1
if b is greater than k , break current loop iteration
set a to k - b
set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) )
print ans print newline
create integers n , i , c with c = 0
create string s , create string array ch with size 1001
read n
for i = 0 to n exclusive
read s
if s [ 0 ] is ' O ' and s [ 1 ] is ' O ' and c is 0
set s [ 0 ] to ' + '
set s [ 1 ] to ' + '
set c to 1
else if s [ 3 ] is ' O ' and s [ 4 ] is ' O ' and c is 0
set s [ 3 ] to ' + '
set s [ 4 ] to ' + '
set c to 1
set ch [ i ] to s
if c is 1
print " YES " print newline
for i = 0 to n exclusive , print ch [ i ] print newline
else
print " NO " print newline
integer array x of size 10 with values 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2
integer array y of size 10 with values 1 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2
p is an integer array with size 4 by 3
let n be integer
read n
a is string
read a
declare integer variable called check = 0
for integer i = 0 to n exclusive
let z be integer = a [ i ] - 48
create integer xx = x [ z ]
let yy be integer = y [ z ]
set value of p [ xx ] [ yy ] to 1
let ans be integer = 1
integer array xxx of size 4 with values 1 , - 1 , 0 , 0
integer array yyy of size 4 with values 0 , 0 , 1 , - 1
for integer i = 0 to 4 exclusive
declare integer variable called check = 0
for j = 0 to 4 exclusive
for integer k = 0 to 3 exclusive
if p [ j ] [ k ] = 1
if j = 2 and k = 1 and i = 0
else
check = 1
else if j < 3 or ( j = 3 and k = 1 )
else
set check to 1
if check = 0 , set ans to 0
if ans = 0
print " NO " and a new line
else
print " YES " and a new line
let y , m and s be integer arrays with size 5
create integers ans , atkm , atky , mm , my , j , i and sum
for i = 1 to 3 inclusive , read y [ i ]
for i = 1 to 3 inclusive , read m [ i ]
for i = 1 to 3 inclusive , read s [ i ]
ans = 999999
for i = 0 to 200 inclusive
for j = 0 to 200 inclusive
sum = s [ 3 ] * j + s [ 2 ] * i
atky = i + y [ 2 ] - m [ 3 ]
atkm = m [ 2 ] - j - y [ 3 ]
skip the rest of the loop if atky < = 0
if atkm < = 0
ans = min of ans and sum
skip the rest of the loop
if m [ 1 ] modulo atky ! = 0
mm = m [ 1 ] / atky + 1
else
mm = m [ 1 ] / atky
if y [ 1 ] modulo atkm ! = 0
my = y [ 1 ] / atkm + 1
else
my = y [ 1 ] / atkm
if my < = mm , increase sum by ( mm * atkm + 1 - y [ 1 ] ) * s [ 1 ]
set ans to min of ans and sum
print ans
power is a function that get two ints and return an int
if x is 0 return 1
if x is 1 return a
return power ( a , x / 2 ) * power ( a , x / 2 ) * power ( a , x % 2 )
digitLen is a function that get an int and return an int
if x is 0 return 1
set cnt to 0
while x
divide x by 10
increment cnt
return cnt
generate is a function that get an int and return a string
s = empty string
while a
concatenate s with a modulo 10 and ' 0 '
divide a by 10
return s
a , b , n = int
read a , b , n
let string s = generate ( a )
let can = false
for i = 0 to 9 inclusive
if ( a * power ( 10 , 1 ) + i ) modulo b is 0
concatenate s with 1 and i + ' 0 '
let can = true
break
if not can
print - 1
for i = 0 to n - 1 exclusive concatenate s with " 0 "
print s
n , d , i , sum , l = integers with sum , l set to 0
Read n and d
a = array of n integers
for i = 0 to n exclusive
Read a [ i ]
set sum to sum + a [ i ]
if sum + 10 * ( n - 1 ) is greater than d
print - 1 and a new line
print ( d - sum ) / 5 and a new line
a = array of characters of size 105
n = integer
declare check which returns an integer
set up , left , down , right to 0
read a
for i = 0 to n exclusive
if a [ i ] is 1 , 2 or 3 set up to 1
if a [ i ] is 7 , 9 or 0 set down to 1
if up , down , left and right are 1 return 1
read n
if check returns 1 do the following
create constant long long N with value 1001
create integer n
create array of strings with size N called s
read n
let ok be boolean = 0
for integer i = 0 to n exclusive
read s [ i ]
if ok is false and s [ i ] [ 0 ] = s [ i ] [ 1 ] and s [ i ] [ 0 ] = ' O '
set value of ok to 1
s [ i ] [ 0 ] = ' + '
s [ i ] [ 1 ] = ' + '
if ok is false and s [ i ] [ 3 ] = s [ i ] [ 4 ] and s [ i ] [ 3 ] = ' O '
set value of ok to 1
s [ i ] [ 3 ] = ' + '
s [ i ] [ 4 ] = ' + '
if ok is true
print " YES " and a new line
print n elements of s and a new line after each one
else
print " NO " and a new line
create long long int p = 998244353
create long long int ans = 0
in the function read that returns an integer
create integer x = 0 and f = 1
read c
while c < 0 or c > 9 do the following
if c = - then set f to - 1
read c
return x * f
in the function main
create long long int n and m
read n and m
create integers dig_n = 0 and dig_m = 0
create integer arrays count_n and count_m of size 7 each
create integer ans = 0
call memset of count_n , 0 and sizeof ( count_n )
call memset of count_m , 0 and sizeof ( count_m )
while a is not 0
set a = a / 7
increment dig_n
while b is not 0
set b = b / 7
increment dig_m
if n = 1 then set dig_n to 1
if m = 1 then set dig_m to 1
if dig ) _n + dig_m > 7
print 0
for i = 0 to n - 1 inclusive
call memset of count_n , 0 and sizeof ( count_n )
set a = i
create integer ch = 0
let count be an integer with count = 0
while count is less than dig_n
create integer r = a mod 7
set a = a / 7
if count_n [ r ] is not 0
then set ch = 1
break
set count_n [ r ] = 1
add 1 to count
if ch is 1 then continue
for j = 0 to m - 1 inclusive
call memset of count_m , 0 and sizeof ( count_m )
set b = j
create integer ch = 0
let count be an integer with count = 0
while count is less than dig_m
create integer r = b mod 7
set b = b / 7
if count_n [ r ] is not 0 or count_m [ r ] is not 0
set ch to 1
break
set count_m [ r ] = 1
add 1 to count
if ch is 1
then continue
add 1 to ans
print ans
create constant integer M with M = 1e9 + 7
declare solve with long longs n , m , k as arguments , returning long long
if k is greater than m + n - 2
return - 1 from function
else if k is less than n
return n / ( k + 1 ) * m from function
else
decrement k by n - 1
return m / ( k + 1 ) from function
create long longs n , m , k
create string a
read a
create integer n with n = integer casted size of a
if n is less than or equal to 3
print " YES " print ' \ n '
print a print ' \ n '
create integer vector f initialized with 26
for i = 0 to n exclusive , increment f [ a [ i ] - ' a ' ]
create character vector ans initialized with n + 1
create boolean vector flags initialized with n + 1
for i = 2 to n inclusive , incrementing i by 2 , set flags [ i ] to true
for i = 3 to n inclusive
if not flags [ i ] and i * 2 is less than or equal to n
for j = i to n inclusive , incrementing j by i , set flags [ j ] to true
create integer cont with cont = 0
for i = 1 to n inclusive , increment cont by flags [ i ]
create integers most , pos with most = - 1 , pos = - 1
for i = 0 to 26 exclusive
if f [ i ] is greater than most
set most to f [ i ]
set pos to i
if most is less than cont
print " NO " print ' \ n '
decrement f [ pos ] by cont
for i = 1 to n inclusive
if flags [ i ] is true , set ans [ i ] to character casted ( pos + ' a ' )
for i = 1 to n inclusive
if flags [ i ] is false
for j = 0 to 26 exclusive
if f [ j ] is greater than 0
decrement f [ j ]
set ans [ i ] to character casted ( j + ' a ' )
set flags [ i ] to true
break loop
for i = 1 to n inclusive
if flags [ i ] is false
print " NO " print ' \ n '
print " YES " print ' \ n '
for i = 1 to n inclusive , print ans [ i ]
print ' \ n '
h1 , a1 , d1 , h2 , a2 , d2 , h , a , d = integer
read h1 , a1 , d1 , h2 , a2 , d2 , h , a , d
min_val = integer with min_val = 1000000000
for i = 0 to 200
for j = 0 to 100
a_n = integer with a_n = a1 + i
d_n = integer with d_n = d1 + j
if a_n < = d2 , continue
t = ( h2 - ( d2 - a_n + 1 ) ) / ( a_n - d2 )
new_pwr = integer with new_pwr = t * max ( 0 , a2 - d_n ) + 1
min_val = min ( min_val , i * a + j * d + max ( 0 , new_pwr - h1 ) * h )
print min_val
declare solve with no arguments , returning void
create integer n
read n
create integer vector v
for i = 0 to n exclusive
create integer x
read x
add element x to end of v
sort elements from beginning of v to end of v
create integer i with i = 0
create integer j with j = n - 1
create integer ans with ans = 0
while 2 * v [ i ] is less than v [ j ]
if 2 * v [ i + 1 ] is greater than or equal to v [ j ]
increment i
increment ans
else if 2 * v [ i ] is greater than or equal to v [ j - 1 ]
decrement j
increment ans
else
increment ans by 2
increment i
decrement j
print ans print newline
declare solve2 with no arguments , returning void
create integers a , b , n
read a read b read n
if a % b is 0
print a
for i = 0 to n exclusive , print 0
print newline
return from function
create boolean c with c = false
for i = 0 to 9 inclusive
if a * 10 + i % b is 0
print a print i
set c to true
break loop
if c is true
for i = 0 to n - 1 exclusive , print 0
print newline
else
print - 1 print newline
run solve2
declare integers n , a , b and p
loop , reading n , a and b from the input
create integers r1 and r2 = 0
for integer i = 0 to n exclusive
read p
if p is 1
if a is greater than 0
decrement a
else
if b is greater than 0
decrease b by one
increase r1 by one
else if r1 is greater than 0
decrement r1
else
increment r2
else
if b is greater than 0
decrease b
else
increase r2 by 2
print r2
create integer n
read n
create 2d character array s with size 1000 by 20
for i = 0 to n exclusive
for j = 0 to 5 exclusive , read s [ i ] [ j ]
for i = 0 to n exclusive
if s [ i ] [ 0 ] is ' O ' and s [ i ] [ 1 ] is ' O '
set s [ i ] [ 0 ] to ' + '
set s [ i ] [ 1 ] to ' + '
print " YES \ n "
for j = 0 to n exclusive
for k = 0 to 5 exclusive , print s [ j ] [ k ]
print newline
if s [ i ] [ 3 ] is ' O ' and s [ i ] [ 4 ] is ' O '
set s [ i ] [ 3 ] is ' + '
set s [ i ] [ 4 ] is ' + '
print " YES \ n "
for j = 0 to n exclusive
for k = 0 to 5 exclusive , print s [ j ] [ k ]
print newline
print " NO \ n "
create integer n
let a be integer array with size 1005
declare integer variables num5 , num0 and flag
read n in a loop
set value of num5 to 0
set value of num0 to 0
for integer i = 0 to n exclusive
read a [ i ]
if a [ i ] = 5
increment num5
else if a [ i ] = 0
increase num0
flag = num5 / 9
if num0 is 0
print " - 1 "
else
if flag is not 0
for integer i = 0 to flag * 9 exclusive print " 5 "
for integer i = 0 to num0 exclusive print " 0 "
else
print " 0 "
print new line
a , b , n , k and i are integers where k = 0
read a , b and n
create string s with length n - 1 filled with character ' 0 '
for i = 0 to 10 exclusive
if ( a * 10 + i ) % b = 0
set k to 1
stop the loop
if k ! = 1
print - 1
else
print a * 10 + i
print s
create constant integer MAXN with value 1001
declare integer called n
let s be an array of characters of length MAXN
c is an array of integers with size 256 filled with 0
f is an array of booleans with size MAXN
read input to s
assign length of s to n
memset with arguments c , sizeof ( c ) and 0
for i = 0 to n exclusive incremen c [ s [ i ] ]
k is integer = 0
for i = 0 to 256 exclusive
if c [ i ] is greater than c [ k ] set k to i
memset with arguments f , true and sizeof ( f )
for integer i = 2 to i * i < = n
if f [ i ] is true
for integer j = i * i to n inclusive with step of i , set f [ j ] to false
set value of f [ 1 ] to true
for integer i = 2 to i + i < = n , set f [ j ] to false
for i = 1 to n inclusive
if f [ i ] is false
if c [ k ] = 0
print " NO " and a new line
decrease c [ s [ i - 1 ] = k ] by one
assign value of 0 to k
for integer i = 1 to n inclusive
if f [ i ] is true
increment k while c [ k ] = 0
decrease c [ s [ i - 1 ] = k ] by one
print " YES " and a new line
print s and a new line
create integers n , d , t
create integer array a with size 1000
read n read d
create integer jokes with jokes = 0
create integer mint with mint = 0
create integer restBetween with restBetween = ( n - 1 ) * 10
for i = 0 to n exclusive
read a [ i ]
increment mint by a [ i ]
if mint + restBetween is less than or equal to d
create integer rem with rem = d - ( mint + restBetween )
print restBetween / 5 + rem / 5 print newline
else
print - 1 print newline
create integer n
read n
a = matrix of [ n + 10 ] x [ 10 ] char
for i = 0 to n exclusive
for j = 0 to 5 exclusive read a [ i ] [ j ]
create integer flag with flag = 0
for i = 0 to n exclusive
if a [ i ] [ 0 ] is O and a [ i ] [ 1 ] is O
a [ i ] [ 0 ] = +
a [ i ] [ 1 ] = +
flag = 1
stop loop
else if a [ i ] [ 3 ] is O and a [ i ] [ 4 ] is O
a [ i ] [ 3 ] = +
a [ i ] [ 4 ] = +
flag = 1
stop loop
if flag is 1
print YES and new line
for i = 0 to n exclusive
for j = 0 to 5 exlusive print a [ i ] [ j ]
print new line
else
print NO and new line
inf = const int with value 0x3f3f3f3f
pi = const double with value result of acos called with - 1
a , b , c = long long
input a , b and c
if a + b - 2 < c then
print - 1
else
if a > b call swap with a and b
if a mod c + 1 is zero or b % c + 1 is zero
print a * b / ( c + 1 )
else
if b - 1 greater than or equal to c
if a - 1 greater than or equal c
print max ( b / ( c + 1 ) * a , a / ( c + 1 ) * b )
else
print b / ( c + 1 ) * a
else
print a / ( c - b + 1 + 1 )
n , i and ct are integers , with ct = 0
ch = array of characters of length 100
read n
arr is an array of strings with size 1010
for i = 0 to n exclusive
read ch
if ct = 0
if ch [ 0 ] = ' O ' and ch [ 1 ] = ' O '
ch [ 0 ] = ' + '
ch [ 1 ] = ' + '
set value of ct to 1
if ct = 0
if ch [ 3 ] = ' O ' and ch [ 4 ] = ' O '
ch [ 3 ] = ' + '
ch [ 4 ] = ' + '
set ct to 1
set arr [ i ] to ch
if ct = 1
print " YES " and a new line
print n elements of arr with new line after each one
else
print " NO " and a new line
y , m and s = arrays of length 5
ans , atkm , atky , mm , my , j , i , sum = integers
for i = 1 to 3 inclusive , read index i of y
for i = 1 to 3 inclusive , read index i of m
for i = 1 to 3 inclusive , read index i of s
set ans = 999999
for i = 0 to 200 inclusive
for j = 0 j to 200 inclusive
set sum = index 3 of s * j + index 2 of s * i
set atky = i + index 2 of y - index 3 of m
set atkm = index 2 of m - j - index 3 of y
if atky is less than or equal to 0 , continue
if atkm is less than or equal to 0
set ans = the smaller number between ans and sum
continue
if index 1 of m modulo atky doesn ' t = 0
set mm = index 1 of m / atky + 1
else
set mm = index 1 of m / atky
if index 1 of y modulo atkm doesn ' t = 0
set my = index 1 of y / atkm + 1
else
set my = index 1 of y / atkm
if my is less than = mm , increment sum by ( mm * atkm + 1 - index 1 of y ) * index 1 of s
set ans = the smaller number between ans and sum
print ans
create constant integer MAXN with MAXN = 1001
create integer n
create character array s with size MAXN
create integer array c with size 256
declare boolean array f with size MAXN
read string into s
set n to string length of s
for i = 0 to n exclusive , increment c [ s [ i ] ]
create integer k with k = 0
for i = 0 to 256 exclusive
if c [ i ] is greater than c [ k ] , set k to i
set bytes from f to size of f to true
for i = 2 to i * i is less than or equal to n , incrementing i
if f [ i ] is true
for j = i * i to n inclusive , incrementing j by i , set f [ j ] to false
set f [ 1 ] to true
for i = 2 to i + i is less than or equal to n , incrementing i , set f [ i ] to false
for i = 1 to n inclusive
if not f [ i ]
if c [ k ] is 0
print " NO "
decrement c [ set s [ i - 1 ] to k ]
set k to 0
for i = 1 to n inclusive
if f [ i ] is true
while c [ k ] is 0 , increment k
decrement c [ set s [ i - 1 ] to k ]
print " YES "
print s
declare integer variables n and temp
read n
declare integer variables cont1 and cont2 = 0
for i = 0 to n exclusive
read temp
if temp = 5
increase cont1 by one
else
increase cont2 by one
if cont2 = 0
print " - 1 \ n "
else
declare integer variable ans = 0
temp = 0
for i = 1 to cont1 inclusive
temp = temp * 10 + 5
temp % = 9
if temp = 0 assign i to ans
if ans = 0
print " 0 \ n "
else
print " 5 " ans times
print " 0 " cont2 times
print ' \ n '
declare integer variable zeroes = 0
declare integer variable fives = 0
declare integer variable n
read n
declare integer variable temp
for integer i = 0 to n exclusive
read temp
if temp = 0 increment zeroes
if temp = 5 increment fives
if zeroes and fives > = 9
for integer i = 0 to fives / 9 * 9 exclusive print " 5 "
for i = 0 to zeroes exclusive print " 0 "
print " \ n "
else if zeroes is not 0
print " 0 \ n "
else
print " - 1 \ n "
n is integer
s is an character array with 10000 elements
read n and s in a loop
let be integers U , D , L and R = 0
for i = 0 to n exclusive
if s [ i ] = ' 0 ' , set D , R and L to 1
if s [ i ] = ' 1 ' | | s [ i ] = ' 2 ' | | s [ i ] = ' 3 ' , set U to 1
if s [ i ] = ' 1 ' | | s [ i ] = ' 4 ' | | s [ i ] = ' 7 ' , set L to 1
if s [ i ] = ' 3 ' | | s [ i ] = ' 6 ' | | s [ i ] = ' 9 ' , set R to 1
if s [ i ] = ' 7 ' | | s [ i ] = ' 9 ' , set D to 1
if U , D , R and L are all equal to 1
print " YES " and a new line
else
print " NO " and a new line
create integers a , b and n
declare integer called flag = 0
create long long integer bb
read a , b and n
for i = 0 to 9 inclusive
bb = ( a * 10 ) + i
if bb % b = 0
print bb
flag = 1
print 0 n - 1 times
stop the loop
if flag = 1
print new line
else
print " - 1 " and a new line
n , a , b , x , y , z = integers with y = 0 and z = 0
Read n , a , b
while n is not equal to 0
Read x
if x is equal to 1
if a is not equal to 0
decrement a
else if b is not equal to 0
decrement b
increment z
else if z is not equal to 0
decrement z
increment y
if b is not equal to 0
decrement b
increment y
increment y
print y and a new line
create integer n
read n
create integer maxn with maxn = 0
create long long sum with sum = 0
for i = 1 to n inclusive
create integer x
read x
increment sum by x
set maxn to maximum of maxn and x
create long long ans with ans = ( sum + n - 2 ) / ( n - 1 )
set ans to maximum of ans and 1LL * maxn
print ans print newline
create long longs s , x , n , mx with s = 0 , mx = INT_MIN
read n
for i = 1 to n inclusive
read x
increment x by x
set mx to maximum of x and mx
print maximum of ( mx and ( s - 1 ) / ( n - 1 ) + 1 ) print newline
declare integers a , b and n
read a , b and n
boolean exist = false
for integer i = 0 to 10 exclusive
if ( a * 10 + i ) % b = 0
print a * 10 + i
create string s with length n - 1 filled with ' 0 '
print s and a new line
assign value of true to exist
stop the loop
if exist is false , print - 1 and a new line
let n , m be integers
used = bool array of size 7
counter , digitn , digitm = integers with counter = 0 , digitn = 0 , and digitm = 0
in the function checkh that takes integer x and return bool
if x is greater than or equal to 0 and x is less than n , then return true
return false
in the function checkm that takes integer x and return bool
if x is greater than or equal to 0 and x is less than m , then return true
return false
in the function permutem that takes integers a , number
if number is equal to digitm
if call checkm with argument a is true , then increment counter
return
for i = 0 to 7 exclusive
if not used [ i ]
set used [ i ] to true
call permutem with arguments a * 7 + i , number + 1
set used [ i ] to false
in the function permuteh that takes integers a , number
if number is equal to digitn
if call checkh with argument a is true , then call permutem with arguments 0 , 0
return
for i = 0 to 7 exclusive
if not used [ i ]
set used [ i ] to true
call permuteh with arguments a * 7 + i , number + 1
set used [ i ] to false
read n , m
faken = integer = n - 1 , fakem = integer = m - 1
if n is equal to 1 , then assign 1 to faken
if m is equal to 1 , then assign 1 to fakem
while faken is greater than 0
assign faken / 7 to faken
increment digitn
while fakem is greater than 0
assign fakem / 7 to fakem
increment digitm
if the sum of digitn and digitm is greater than 7
else
call permuteh with arguments 0 , 0
unsigned long long integer n and array a [ 100010 ]
check is a boolean function with unsigned long long integer argument x
unsigned long long int tmp = 0 , i
for i = 0 to n exclusive , increase tmp by x - a [ i ]
return ( tmp > = x )
unsigned long long int function binSearch with arguments called low and high
while low is less than high
mid = ( low + high ) / 2
if check ( mid ) is true
high = mid
else
low = mid + 1
return low
unsigned long long int t = 1
decrement t while it is > 0
unsigned long long integers ans = 0 and i
read n
for i = 0 to n exclusive read a [ i ]
set value of ans to binSearch ( a [ n - 1 ] , 1e15 )
print ans and " \ n "
create integers n , x , num1 , num2 , ans
while read n is true
set num1 to 0
set num2 to 0
for i = 0 to n exclusive
read x
if x is 0
increment num1
else if x is 5
increment num2
if num1 is 0
print " - 1 " print newline
else
set ans to num2 / 9
if ans and num1
for i = 0 to ans * 9 exclusive , print " 5 "
for i = 0 to num1 exclusive , print " 0 "
else
print " 0 "
print newline
let songs be integer array with size 100001
declare integers n and d
read n and d
for integer i = 0 to n exclusive
declare integer replica = d
declare integer availabletime = d
for i = 0 to n exclusive
decrease replica by songs [ i ]
decrease replica by 10
decrease availabletime by songs [ i ]
increase replica by 10
if replica is less than 0
print - 1
else
print availabletime / 5
let a , b , c and flag be unsigned long longs where flag = 1
read a , b and c
for i = 0 to 10 exclusive
create long long integer p
p = 10 * a + i
if p modulo b is 0
flag = 0
print a and i
for integer j = 1 to c exclusive print 0
stop the loop
if flag = 0 , print a new line
if flag print - 1
round , num , sum and max are long longs , with sum = 0 and max = - 1 , a is an array of long longs with size 100005
read num
for i = 0 to num exclusive
read a [ i ]
increase sum by a [ i ]
if a [ i ] is greater than max set max to a [ i ]
round = sum / ( num - 1 . 0 ) rounded up
if round is less than max set round to max
print round and a new line
declare integers n , d and a
read n and d
create integer s = 0
for integer i = 0 to n exclusive
read a
increase s by a
declare integer variable x = d - s
if s + ( n - 1 ) * 10 is greater than d
print " - 1 "
else
print x / 5
n = int
read n
a = array of n by 5 char
i , j , c = 0
for i = 0 to n exclusive
for j = 0 to 5 exclusive read a [ i ] [ j ]
for i = 0 to n exclusive
for j = 0 to 4 exclusive
if a [ i ] [ j ] and a [ i ] [ j + 1 ] are ' O '
a [ i ] [ j ] = ' + '
a [ i ] [ j + 1 ] = ' + '
c = 1
goto end
end label
if c is 1
print " YES "
else
print " NO "
goto end1
for i = 0 to n exclusive
for j = 0 to 5 exclusive print a [ i ] [ j ]
print a newline
end1 label
n is integer
read n
c is an character array with size 1000 by 1000
let flag be boolean = 0
for integer i = 0 to n exclusive
for integer j = 0 to 5 exclusive
read c [ i ] [ j ]
if c [ i ] [ 0 ] = ' O ' & & c [ i ] [ 1 ] = ' O ' & & flag = 0
set value of flag to 1
c [ i ] [ 0 ] = ' + '
c [ i ] [ 1 ] = ' + '
if c [ i ] [ 3 ] = ' O ' & & c [ i ] [ 4 ] = ' O ' & & flag = 0
flag = 1
c [ i ] [ 3 ] = ' + '
c [ i ] [ 4 ] = ' + '
print " YES " if flag = 1 , else print " NO " ; print new line
if flag = 1
for integer i = 0 to n exclusive
for integer j = 0 to 5 exclusive print c [ i ] [ j ]
print ' \ n '
a [ 100010 ] , n be of type long long int
boolean check ( long long int x )
let long long int tmp = 0 , i
for i = o to n exclusive , tmp + = ( x - a [ i ] )
return value of ( tmp > = x )
let long long int binSearch ( long long int low , long long int high )
while low is less than high
long long int mid is equal to low + ( high - low ) / 2
if ( check of mid )
high is equal to mid ;
else
low is equal to mid + 1 ;
return value low
let long long int t is equal to 1 ;
while t value is decremented by 1
let long long int ans = 0 , i
read n
for i = 0 to n exclusive , read a [ i ]
sort ( a , a + n )
ans is equal to binSearch ( a [ n - 1 ] , 1e12 )
print ans and newline
create constant integer maxn with maxn = 105
create integers n , sum with sum = 0
create character array a with size 12
read n
for i = 0 to n exclusive , read a [ i ]
create integers t , d , r , l , with t = 1 , d = 1 , r = 1 , l = 1
for i = 0 to n exclusive
if a [ i ] is ' 1 ' or a [ i ] is ' 2 ' or a [ i ] is ' 3 ' , set t to 0
if a [ i ] is ' 7 ' or a [ i ] is ' 0 ' or a [ i ] is ' 9 ' , set d to 0
if t or l or r or d
print " NO " print newline
else
print " YES " print newline
let n , a , b be long integers
read n , a , b
let bb be a integer with value 0
let ans be a long integer with value 0
for ( integer i = 0 to n exclusive )
let tmp be a integer
read tmp
if ( tmp is equal to 2 and b )
decrease b by 1
else if ( tmp is equal to 1 and a )
decrease a by 1
else if ( tmp is equal to 1 and b )
decrease b by 1 , increase bb by 1
else if ( tmp is equal to 1 and bb )
decrease bb by 1
let the value of ans is equal to ans + tmp
print ans and new line
n = integer
s = string
h = 2D array in boolean with 10 rows and 4 columns
Read n and s
for i = 0 to 4 exclusive
set h [ 5 ] [ i ] to true
set h [ 8 ] [ i ] to true
set h [ 2 ] [ 0 ] to true
set h [ 3 ] [ 0 ] to true
set h [ 6 ] [ 0 ] to true
set h [ 9 ] [ 0 ] to true
set h [ 1 ] [ 1 ] to true
set h [ 4 ] [ 1 ] to true
set h [ 7 ] [ 1 ] to true
set h [ 2 ] [ 1 ] to true
set h [ 4 ] [ 2 ] to true
set h [ 6 ] [ 2 ] to true
set h [ 7 ] [ 2 ] to true
set h [ 9 ] [ 2 ] to true
set h [ 0 ] [ 2 ] to true
set h [ 1 ] [ 3 ] to true
set h [ 2 ] [ 3 ] to true
set h [ 3 ] [ 3 ] to true
set h [ 4 ] [ 3 ] to true
set h [ 6 ] [ 3 ] to true
for j = 0 to 4 exclusive
done = boolean , set to true
for i = 0 to n exclusive
if h [ s [ i ] - ' 0 ' ] [ j ] is false , then set done to false
if done is true
print NO and a new line
print YES and a new line
create long integers n , m , x , y , z , i , with z = 9 , i = 0
read x read y read m
while i is less than or equal to z
if ( x * 10 + i ) % y is 0
set z to 10
break loop
increment i
decrement m
if z is 10
print x * 10 + i
while decrement m is true , print " 0 "
else
print " - 1 "
print newline
n , d = integer
read n and d
arr = array of n integers
set sum to 0
for i = 0 to n exclusive
read arr [ i ]
sum = sum + arr [ i ]
set T to sum + ( n - 1 ) * 10
if T > d
print - 1
d = d - sum
d = d / 5
print d
declare integers n and d and an array of integers arr with size 105
read n and d
create integer sum = 0
sum n elements from arr and put them into variable sum
create integer x = sum + ( n - 1 ) * 10
if x < = d
print ( d - sum ) / 5
else
print - 1
n = integer
read n
arr = long long array of size n
sum , n = long long with sum = 0 and x = INT_MIN
for i = 0 to n exclusive
read arr [ i ]
increase sum by arr [ i ]
set x to the max of x and arr [ i ]
set x to the max of x and ( sum + n - 2 ) / ( n - 1 )
print x
let n be a integer
read n
let count5 be a integer with value 0
let count0 be a integer with value 0
for integer i = 0 to n exclusive
let temp be a integer with value 0
read temp
if ( temp is equal to 0 )
increase count0 by 1
increase count5 by 1
let a be an integer with value count5 / 9
let b be an integer with value count0
if ( b is equal to 0 )
print - 1 and newline
else if ( a is equal to 0 )
print 0 and newline
for ( integer i = 0 to a exclusive ) , print 555555555
for ( integer i = 0 to b exclusive ) , print 0
print newline
n , i , j , c , flg = integers set c , flg = 0
read n
s = array of strings of size n
for i = 0 to n exclusive
read into array s
if s [ i ] [ 0 ] = O and s [ i ] [ 1 ] = O
if c = 0
s [ i ] [ 0 ] = +
s [ i ] [ 1 ] = +
flg = 1
increment c
else if s [ i ] [ 3 ] = O and s [ i ] [ 4 ] = O
if c = 0
s [ i ] [ 3 ] = +
s [ i ] [ 4 ] = +
flg = 1
increment c
if lfg = 1
for i = 0 to n exclusive print s [ i ]
else
declare integer variable ans = INT_MAX
declare integer variables hy , ay , dy , hm , am , dm , h , a , d , xh , xa and xd
read hy , ay , dy , hm , am , dm , h , a and d
for xh = 0 to 1000 inclusive
for xa = 0 to 200 inclusive
for xd = 0 to 100 inclusive
create integers ll = 1 and hh = 1000
while ll < = hh
declare integer m = ( ll + hh ) / 2
set integer l to ( hy + xh ) - m * max of 0 and am - ( dy + xd )
set integer r to hm - m * max of 0 and ay + xa - dm
create integer val = h * xh + xa * a + xd * d
if l > 0 and r < = 0
set ans to min of ans and h * xh + xa * a + xd * d
stop the loop
else if l < = 0 and r < = 0
hh = m - 1
else if l < = 0 and r is greater than 0
break the loop
else if l > 0 and r is greater than 0
assign value of m + 1 to ll
print ans
create vector integer digit
create vector integer iterator it
create unsigned long longs a , b , n
read a read b read n
add element a to end of digit
for i = 1 to n inclusive
create integer flag with flag = 0
for j = 0 to 9 inclusive
if ( ( a * 10 ) + j ) % b is 0
add element j to end of digit
set a to ( ( a * 10 ) + j ) % b
set flag to 1
break loop
if flag is 0
print " - 1 " print newline
for it = beginning of digit to it is not end of digit , print value of it
print newline
assign value 100005 to constant integer MAX
arr is an array of integers of size MAX
long long function divc with long long arguments a and b
if a % b = 0 return a / b
return ( a / b + 1 )
let n be integer
read n
let sum and mx be long longs , with sum = 0 and mx = - 1
for i = 0 to n exclusive
read arr [ i ]
increase sum by arr [ i ]
set mx to max of mx and arr [ i ]
long long ans with value divc ( sum , n - 1 )
set value of ans to max of ans and mx
print ans and " \ n "
declare integer variables n , a , i , j , num5 , num0 and r
while reading n in a loop
set value of num5 to 0
set value of num0 to 0
for i = 0 to n exclusive
read a
if a = 5
increase num5 by one
else if a = 0
increase num0 by one
r = num5 / 9
if num0 is 0
print " - 1 "
else
if r & & num0 are both not 0
for i = 0 to r * 9 exclusive print " 5 "
for i = 0 to num0 exclusive print " 0 "
else
print " 0 "
print " "
declare integer variable n
read n
declare string variable s
read s
declare boolean c1 = false
declare boolean c3 = false
declare boolean l1 = false
declare boolean l3 = false
declare boolean t0 = false
for integer i = 0 to n exclusive
set l1 to true if s [ i ] - ' 0 ' = 1 | | s [ i ] - ' 0 ' = 2 | | s [ i ] - ' 0 ' = 3
set l3 to true if s [ i ] - ' 0 ' = 7 | | s [ i ] - ' 0 ' = 9
set c1 to true if s [ i ] - ' 0 ' = 1 | | s [ i ] - ' 0 ' = 4 | | s [ i ] - ' 0 ' = 7
set c3 to true if s [ i ] - ' 0 ' = 3 | | s [ i ] - ' 0 ' = 6 | | s [ i ] - ' 0 ' = 9
set t0 to true if s [ i ] - ' 0 ' = 0
if l1 = true & & l3 = true & & c1 = true & & c3 = true
print " YES "
if t0 = true & & l1 = true
print " YES "
print " NO "
declare long integer variables n , d and i
read n and d
create long integer array arr with n elements
read input into arr n times
declare long integer o = sizeof ( arr ) / sizeof ( arr [ 0 ] )
declare integer variables initial_sum and flag = 0
sum all elements of arr , add it to initial_sum and put it to y
create long integers p and count = 0
for i = 0 to n exclusive
if p + arr [ i ] < = d
if i = n - 1
flag = 1
set value of p to p + arr [ i ]
else
set value of p to p + arr [ i ]
if p < = d - 5
set value of p to p + 5
increase count
else
stop the loop
if p < = d - 5
set value of p to p + 5
increase count by one
else
break the loop
if flag = 1
if p > = d - 5
print count
else
while p < = d - 5
increment count
set value of p to p + 5
print count
else
print " - 1 "
n , m , k = long long
while reading n then m then k
ans = long long with ans = 0
if k is greater than n + m - 2
set ans to - 1
else
Max = long long with Max = max of n - 1 and m - 1
Min = long long with Min = min of n - 1 and m - 1
if k is greater than Max
yu = long long with yu = k - Max
set ans to ( Min + 1 ) / ( yu + 1 )
else
a = long long with a = ( n / ( k + 1 ) ) * m
b = long long with b = ( m / ( k + 1 ) ) * n
set ans to max of a and b
print ans
create long long c , n , a , b , i , x , y and z
read a , b , c
while decremen a
read x
if x equal to 1
if b = true
decrement b
other if c is true
decrement c and increment y
else if y is true
decrement y
else
decrement z
if x = 2
if c is true
decrement c
otherwise
set z = z + 2
print z
;
const int64_t infint64_t = 9223372036854775807LL
define function solve
declare int64_t variables n , a , b
read n , a and b
declare int64_t variable c = 0
declare int64_t variable denied = 0
for 64_t = 0 to n exclusive
declare int64_t variable t
read t
if t = 1
if a is greater than 0
decrement a
else if b is greater than 0
decrement b
increment c
else if c is greater than 0
decrease c
else
increment denied
else
if b is greater than 0
decrease b
else
increase denied by 2
print denied
call function solve
create integer n
read n
create string y with y = " NO "
create string s
for i = 0 to n exclusive
create string s1
read s1
for j = 0 to j is less than 5 and y is " NO " , increment j
if s1 [ j ] is ' O ' and s1 [ j + 1 ] is ' O '
set y to " YES "
set s1 [ j ] to ' + '
set s1 [ j + 1 ] to ' + '
set s to s + s1 + ' \ n '
if y is " YES "
print y print newline print s
else
print y print newline
a , b , n = integer
read a , b , n
let d = - 1
for i = 0 to 10 exclusive
if ( a * 10 + 1 ) remainder b = 0
d = i
exit for
if d = - 1
print - 1
else
print a and d
for i = 0 to n - 1 exclusive print 0
print newline
create integer n
read n
create integer array arr with size n , create integers number_of_5 , number_of_0 , with number_of_5 = 0 , number_of_0 = 0
end statement
for i = 0 to n exclusive
read arr [ i ]
if arr [ i ] is 5
increment number_of_5
else
increment number_of_0
if number_of_0 is 0
print " - 1 \ n "
else
set number_of_5 to round up ( number_of_5 / 9 )
create string answer with answer = " "
for i = 0 to number_of_5 exclusive , increment answer by " 555555555 "
for i = 1 to number_of_0 inclusive
if length of answer is 0
increment answer by " 0 "
break loop
else
increment answer by " 0 "
print answer print newline
declare integers n and d
create integer total = 0
create integer ans = 0
read n and d
while n > 0 , decrement it and continue the loop
create integer tmp
read tmp
increase total by tmp
increase total by 10
increase ans by 2
decrease total by 10
decrease ans by 2
if total is greater than d
assign value of - 1 to ans
else
increase ans by ( d - total ) / 5
print ans
declare integer variables n and m
read n and m
declare integer vector v
for integer i = 0 to n exclusive
declare integer x
read x
add x into v
declare integer sum = 0
declare integer variable a = sum + ( ( n - 1 ) * 10 )
if a < = m
declare integer variable b = m - a
print ( ( n - 1 ) * 2 ) + ( m - a ) / 5
else
print " - 1 "
declare long long integer variables n , i , sum and a , where sum and a = 0
create long long integer array ar with 100000 elements
read n
for i = 0 to n exclusive
read ar [ i ]
increase sum by ar [ i ]
set value of a to max of a and ar [ i ]
decrease n by one
print max of a and sum / n rounded up
create integers n , d , sum , ans
read n read d
for i = 0 to n exclusive
create integer x
read x
increment sum by x
increment sum by ( n - 1 ) * 10
if sum is greater than d
print - 1 print newline
else
increment ans by ( n - 1 ) * 2
if ( d - sum ) / 5 is greater than or equal to 1 , increment ans by ( d - sum ) / 5
print ans print newline
create character array a with 20 elements
declare integer variable n
read n
read a
declare integer x = length of a
declare integers temp1 , temp2 , temp3 and temp4 = 1
for i = 0 to x exclusive
if a [ i ] - 48 > = 1 & & a [ i ] - 48 < = 3 , set temp1 to 0
if a [ i ] - 48 = 7 | | a [ i ] - 48 = 9 | | a [ i ] - 48 = 0 , set temp2 to 0
if temp1 = 0 & & temp2 = 0 & & temp3 = 0 & & temp4 = 0
print " YES "
else
print " NO "
declare integer variables a , b , n , k and i where k = 0
read a , b and n
create string s of length n - 1 , filled with ' 0 '
for i = 0 to 10 exclusive
if ( a * 10 + i ) % b = 0
assign value of 1 to k
stop the loop
if k ! = 1
print - 1 and a new line
else
print a * 10 + i
print s and a new line
let pal be an array of characters of size 1100
declare array of integers qtd with size 1100
declare array of integers d with size 1100
primo is a boolean function with integer argument n
return 0 if n = 1
for i = 2 while i squared < = n
return 0 if n % i = 0
return 1
res = array of characters of length 1100
declare integer called i
declare string called a
read a
declare integer variable called n = length of s
for i = 0 to length of a exclusive increment qtd [ a [ i ] ]
declare integer called dois = 0
for i = 2 to length of a casted to integer inclusive
if primo ( i ) & & i * 2 is greater than n
d [ i ] = 0
else
d [ i ] = 1
increase dois by one
assign value 0 to character l
for i = ' a ' to ' z ' inclusive
if qtd [ i ] > = dois
set l to i
decrease qtd [ i ] by dois
break the loop
declare integer called j = ' a '
if l ! = 0
print " YES " and a new line
for i = 1 to n inclusive
if d [ i ] = 1
print l
else
increment j while qtd [ j ] = 0
decrease qtd [ j ] by one
print j casted to char
print new line
else
print " NO " and a new line
create clock_ts t1 , t2
set t1 to processor time
create integers d , time
read d read time
create integer sum with sum = 0
for i = 0 to d exclusive
create integer x
read x
increment sum by x
create integer rem with rem = time - sum
create integer rest with rest = ( d - 1 ) * 10
if rest is greater than rem
print " - 1 "
print " \ n "
else
print ( rem - rest ) / 5 + rest / 5 print " \ n "
set t2 to processor time
create float diff with diff = float casted t2 - float casted t1
create float execution_time with execution_time = diff / CLOCKS_PER_SEC
n , a , b , sum , ans and s are integers where sum and s = 0
read n , a and b
for integer i = 0 to n exclusive
read ans
if ans = 1
if a is greater than 0
decrease a
else if b is greater than 0
decrement b
increase s
else if s ! = 0
decrease s by one
else
increase sum by one
else
if b is greater than 0
decrement b
else
set value of sum to sum + 2
print sum
create 2d character array cd with size 1009 by 200
create integers n , flag , i , j , with flag = 0
read n
for i = 1 to n inclusive
for j = 1 to 5 inclusive , read ch [ i ] [ j ]
for i = 1 to n inclusive
for j = 1 to 5 exclusive
if ch [ i ] [ j ] is ' O ' and ch [ i ] [ j + 1 ] is ' O '
set ch [ i ] [ j ] to ' + '
set ch [ i ] [ j + 1 ] to ' + '
set flag to 1
break loop
if flag is 1 , break loop
if flag is 1
print " YES " print newline
for i = 1 to n inclusive
for j = 1 to 5 inclusive , print ch [ i ] [ j ]
print newline
else
print " NO " print newline
declare integers hy , ay , dy , hm , am , dm , h , a and d
read hy , ay and dy
read hm , am and dm
read h , a and d
declare integer variable n = 300
create integer ans = 1e9
for integer j = 0 to n exclusive
for integer k = 0 to n exclusive
declare integer variable cay = ay + j
declare integer variable cdy = dy + k
assign value max of cay - dm and 0 to integer damageY
set integer damageM to max of 0 and am - cdy
if damageY is 0 , skip the rest of the loop
create integer hits = hm / damageY + ( hm % damageY ! = 0 )
create integer hp = damageM * hits
assign value max of 0 and hp - hy + 1 to integer toBuy
ans = min of ans and j * a + d * k + toBuy * h
print ans and " \ n "
let N = 1e5 + 5 be a const integer
let n , sum , Max , res , a [ N ] be of type long long
void Input ( ) be a non returning function
read n
int i = 1 to n exclusive
read a [ i ]
sum + = a [ i ] , set Max to max of Max and a [ i ]
void Solve ( ) be a non returning function
set values long long l = 1 , r = 1e14 ;
while l is less than or equals to r
set value long long mid to ( l + r ) / 2
set value long long c_games to ( mid * n ) - sum ;
if c_games is greater than or equal to mid
res is equal to mid , r is equal to mid - 1
else
l is equal to mid + 1 ;
printout max ( res , Max ) and newline
let Input ( ) is a function
let Solve ( ) is a function
create integers x , y , songs , sum with sum = 0
read x read y
for i = 0 to x exclusive
read songs
increment sum by songs
if sum + ( x - 1 ) * 10 is greater than y
print - 1 print newline
else
print ( y - sum ) / 5 print newline
function soshu ( get _n long long , return long long )
n = _n
for i = 2 to square root of n inclusive
if n modulo i is zero return n / i
return 1
function cnt ( get three long long n , m , t , return long long )
ans = - 1
if n - 1 > t
ans = max ( n / ( t + 1 ) * m , ans )
else
ans = max ( m / ( t - n + 1 + 1 ) ans )
t1 = soshu ( n )
if t > t1
decrement t by t1 - 1
tt = ceil ( ( t - m + 1 ) / t1 )
_n = n / t1
if m - 1 > = t
ans = max ( ans , ( m / ( t + 1 ) ) * _n )
else if tt not equal 0
ans = max ( ans , _n / ( tt + 1 ) )
return ans
n , m , t = long long
read n , m , t
maxt = ( n - 1 ) + ( m - 1 )
if maxt < t
print - 1
else
ans = - 1
ans = max ( cnt ( n , m , t ) , cnt ( m , n , t ) )
print ans
n = long long
read n
a , b , c , d , suma , sumAux = long long
read a then b then c then d
cont = long long with cont = 1
set suma to a + b + c + d
for i = 0 to n - 1
read a then b then c then d
set sumAux to a + b + c + d
if sumAux > suma increment cont
print cont
create long long n , a , b , c , remaind , t1 , set c1 = 0 , c2 = 0
read n , a , b and c
if n is less than a and b
if n > = a
c1 = n / a
set remaind to n mod a
if remaind > = b
set remaind to remaind - c
assign c1 + ( remaind / ( b - c ) ) to c1
t1 = c1 * ( b - c )
set t1 = remaind - t1
set t1 to t1 + c
if t1 > = b , increment c1
if n > = b
n = n - c
set c2 = n / ( b - c )
set t1 = c2 * ( b - c )
set t1 to n - t1
assign t1 + c to t1
if t1 > = b
increment c2
set t1 to t1 - b - c
if t1 > = a , set c2 to c2 + t1 / a
c1 = max of c1 and c2
print c1
test_case = integer
A = character array of size [ 100 ] [ 100 ]
B = integer array of size [ 100 ] [ 100 ]
read test_case
while decrement test_case
for i = 1 to 9 , read A [ i ] + 1
a , b , c , d = integers with a = 0 , b = 0 , c = 0 , d = 0
for i = 1 to 8
for j = 1 to 8
if ( A [ i ] [ j ] is K )
if ( a is 0 )
a = i
b = j
else
c = i
d = j
if ( ( a + b ) modulo 4 is ( c + d ) modulo 4 and a modulo 4 is c modulo 4 )
else
declare constant integer variable called maxn = 3e5 + 5
new constant double pi with value 3 . 1415926535
create constant long long with name mod and value 1e9 + 7
declare an arrays of ints a and b with size maxn
declare integer variable n
loop , reading n from the input
set values of first sizeof ( a ) bytes at the pointer a to 0
create long longs ans , k and pos = 0
in a for loop , change i from 1 to n inclusive incrementing i
read input to a [ i ]
for integer j = 1 to a [ i ] inclusive
x is a new integer variable
read x
set b [ i ] to x if b [ i ] is less than x
if k is less than b [ i ]
change k to b [ i ]
set pos to i
in a for loop , change i from 1 to n inclusive
if i is equal to pos
skip the rest of the loop
else
change ans to ans + a [ i ] * ( b [ pos ] - b [ i ] )
print ans
hor = integer array of size 100
ver = integer array of size 100
hasil = vector of integer
set all contents of hor to 0
set all contents of ver to 0
n = integer
read n
for i = 1 to pow of n and 2
h , v = integers
read h , v
if hor [ h ] is 0 and ver [ v ] is 0
hor [ h ] = 1
ver [ v ] = 1
append i to hasil
for i = 0 to hasil . size ( ) - 1 exclusive , print hasil [ i ]
print hasil [ hasil . size ( ) - 1 ]
create int a , b , c , d
while read a , b , c , d
set i and j to 0 , flag to 233
for i = 0 to 10000 inclusive
for j = 0 to 10000 inclusive
if b + a * i = d + c * j
print b + a * i
set flag to 1
break
if b + a * i = d + c * j , break
if flag = 233 , print - 1
create ints n , m , i , j and k
define an arrays of integers a , b and c with 15 elements
read n and m from the input
read n elements from the input to consecutive items of array a
read m elements from the input stream into b
assign 0 to k
in a for loop , change i from 0 to n exclusive
in a for loop , change j from 0 to m exclusive incrementing j
if a [ i ] = b [ j ]
assign the new value = a [ i ] to c [ k ]
increment k
break the loop
if k is equal to 0
print new line
else
for i = 0 to k - 1 exclusive , print c [ i ] and " "
print c [ k - 1 ] to the standard output
create map m using string and integer
a , b = string array
integer as s
set m [ saturday ] to 1
set m [ sunday ] to 2
set m [ monday ] to 3
set m [ tuesday ] to 4
set m [ wednesday ] to 5
set m [ thursday ] to 6
set m [ friday ] to 7
read a , b
set s to ( ( m [ b ] + 7 ) - m [ a ] ) modulo 7
if s is 0 , 2 or 3 then do the following
else
let long long int mod = 1000000007
create long long integer MOD = 998244353
create string s
read s
let int len = s . size ( )
let ints a = 0 , b = 0 , c = 0
for i = 0 to len exclusive
if s [ i ] is equal to ' ( '
increment a
else if s [ i ] is equal to ' ) '
increment b
else
increase c by 1
create int vector A
let ints x = 0 and y = 0
if b is greater than a or b is equal to a and c is greater than 0
print - 1
let integer cnt = ( a - b )
create string ans = " "
for i = 0 to len exclusive
if s [ i ] is equal to ' ( ' or s [ i ] is equal to ' ) '
set ans to ans + s [ i ]
else if c is greater than 1
set ans to ans + " ) "
decrease c by 1
reduce cnt by 1
append 1 to A
else
append cnt to vector A
for j = 0 to cnt exclusive
reduce c by 1
for i = 0 to the size of ans exclusive
if ans [ i ] is equal to ' ( '
increase x by 1
else
increment y
if x is less than y
print - 1
for i = 0 to size of A exclusive , print A [ i ]
in function check taking int x1 , int y1 , int x2 , int y2 , int x3 , int y3 and returning bool
a , b , c = int
set a to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )
set b to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 )
set c to ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 )
if a or b or c is 0 return 0
if a + b is c or a + c is b or b + c is a
return 1
else
move = two dimensional array of sizes 4 and 2 with the values { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 }
x1 , y1 = int array of size 4 each
for i = 0 to 3 read x1 [ i ] then y1 [ i ]
if check of x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ]
print " RIGHT "
tx , ty = int
for i = 0 to 3 inclusive
for j = 0 to 3 inclusive
set tx to x1 [ i ] + move [ j ] [ 0 ]
set ty to y1 [ i ] + move [ j ] [ 1 ]
if i is 0 and check of tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ]
print " ALMOST "
if i is 1 and check of x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ]
print " ALMOST "
if i = 2 and check of x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty
print " ALMOST "
if i is 3 print " NEITHER "
maxn = 4000000
prime = array of maxn int
vis = array of maxn bool
ans = vector of long long
cnt = 0
function Prime ( no args , no return value )
fill vis with false
for i = 2 to maxn exclusive
if not vis [ i ] prime [ cnt ] = i , increment cnt
for j = 0 to cnt exclusive while i * prime [ j ] < maxn
vis [ i * prime [ j ] ] = true
if i modulo prime [ j ] is 0 break
n = long long
read n
for i = 2 to sqrt ( n ) inclusive
if n modulo i is 0
while n modulo i is 0
divide n by i
put i at end of ans
if n is not 1 put n at end of ans
if size of ans is 0 or 1 or is > = 3
print 1
if size of ans is 0 or 1
print 0
else
print ans [ 0 ] * ans [ 1 ]
else
print 2
n , x , y , i , len are integers , a = integer array of size 100005
s = string
read s
set len to size of s
for i = 0 to len exclusive
if s [ i ] isn ' t the character a
set x to i
break
if i equals len
assign the character z to s [ len - 1 ]
else
for i = x + 1 to len exclusive
if s [ i ] is the character a
set y to i - 1
break
if i equals len , set y to len - 1
for i = 1 to y inclusive , subtract 1 from s [ i ]
output s
create string a
read a and while a is truthy
create bool flag = true
make integer array num of size 3 containing { 0 }
for i = 0 to a . size ( ) exclusive
increase num [ a [ i ] - ' a ' ] by 1
if i is not equal to 0 and a [ i ] is less than a [ i - 1 ]
set flag to false
break loop
if num [ 2 ] is not num [ 1 ] and num [ 2 ] is not num [ 0 ] , set flag to false
if num [ 0 ] is equal to 0 or num [ 1 ] is equal to 0 , set flag to false
if flag is true
display " YES "
else do
show " NO "
create constant integer inf = 0x3f3f3f3f
make constant long long integer linf = 0x3f3f3f3fLL
create constant integer EPS = 1e - 6
make const long long int mod = 1000000007
create string exp
read exp
make ints a = 0 , b = 0 , and c = 0
make integer t = 0
let integer ind_s = 0
create integer ind_e = 0
for i = 0 to exp . size ( ) exclusive
if exp [ i ] is equal to ' + ' or exp [ i ] is equal to ' = '
increase t by 1
if exp [ i ] is equal to ' + '
set ind_s to i
else do
set ind_e to i
continue to next loop iteration
if t is 0
increment a
else if t is equal to 1
increase b by 1
else if t is equal to 2
increase c by 1
create string str
output " Impossible "
else
if a + b is c
print exp
else if ( a + b ) - 1 is equal to c + 1
if a is equal to 1
create string s1 = exp . substr ( 0 , ind_s + 1 )
make string s2 = exp . substr ( ind_s + 2 , ( ind_e - 1 ) - ind_s )
let string s2 = exp . substr ( ind_e + 1 , ( exp . size ( ) - 1 ) - ind_e ) + " | "
print s1 + s2 + s3
else do
set str to exp . substr ( 1 , exp . size ( ) - 1 ) + " | "
output str
else
set str to " | " + exp . substr ( 0 , exp . size ( ) - 1 )
display str
create long long ints n , m , k and ans
loop , reading n , m and k from the input
change ans to 0
if n + m - 2 is less than k
print - 1
else
if n is greater than k
set ans to n / ( k + 1 ) * m
else
assign m / ( k - n + 2 ) to ans
if m is greater than k
assign max of m / ( k + 1 ) * n and ans to ans
else
change ans to max of n / ( k - m + 2 ) and ans
print ans
MAXN = const int with MAXN = 100000 + 7
mod = const int with mod = 23333333
l , r , ans , n = long long with ans = 0
a = int array of size 20
in function Solve taking a long long n and returning a long long
if n is less than 10 return n
x , y = int with x = n mod 10
tmp = long long with tmp = n
loop while tmp is greater than 9 set tmp to tmp / 10
set y to tmp
if x is greater or equal to y
return n / 10 + 9
else
return n / 10 + 8
L , R = long long
read l then r
set ans to Solve of r - Solve of l - 1
print ans
n = integer
read n
v = vector of integer with v = n
for i = 0 to n exclusive , read v [ i ]
a , b = integers with a = 0 , b = 0
for i = 0 to n exclusive
if ( v [ i ] is 25 )
increment a
else if ( v [ i ] is 50 and a > = 1 )
decrement a , increment b
else if ( v [ i ] is 100 and b > = 1 and a > = 1 )
decrement b , a
else if ( v [ i ] is 100 and a > = 3 )
a = a - 3
else
print NO
print YES
declare new long long called n
declare vector of long longs vct
read n from the input
create long long x with value n
start for loop from i = 2 to n inclusive incrementing i
while n % i = 0
push i to the end of vector vct
set value of n to n divided by i
if x ! = n and n ! = 1 , push i to the vector vct
if length of vct is greater than 2
print " 1 " and vct [ 0 ] * vct [ 1 ]
else if length of vct is equal to 2
print " 2 " to the standard output
else
print " 1 " and " 0 " to the standard output
c = array of 200200 char
ic = int
function check ( get char c , return int )
s = string
read s
for i = 0 to length of s exclusive
if s [ i ] is an uppercase letter add 32 to s [ i ]
c [ ic ] = s [ i ] , increment ic
for i = 0 to ic exclusive
ch = c [ i ]
if check ( ch )
for j = i to ic - 1 exclusive c [ j ] = c [ j + 1 ]
decrement ic
decrement i
else
for j = ic down to i + 1 inclusive c [ j ] = c [ j - 1 ]
increment ic
c [ i ] = ' . '
increment i
for i = 0 to ic exclusive print c [ i ]
print newline
trees = pair of int and int array of size 105
n = int
read n
sum , sum_pos , sum_neg = int with sum = 0 and sum_pos = 0 and sum_neg = 0
for i = 0 to n
read trees [ i ] . first then trees [ i ] . second
increment sum by trees [ i ] . second
if trees [ i ] . first is less than 0 then increment sum_neg by trees [ i ] . second
if trees [ i ] . first is greater than 0 then increment sum_pos by trees [ i ] . second
pos , neg , center = int with pos = 0 and neg = 0 and center = - 1
for i = 0 to n
if trees [ i ] . first is greater than 0 then increment pos
if trees [ i ] . first is greater than 0 and center is - 1 then set center to i
if pos is 0 then set center to n
set neg to n - pos
if absolute of pos - neg is less than 2
print sum
else
if neg is greater than pos
set sum to sum_pos
else
set sum to sum_neg
print sum
n , s = int
a , b = int
maxn = - 9999
x , y = long long
read n , s
y = s * 100
for i = 0 to n exclusive
read a , b
x = a * 100 + b
if x < = y
if x modulo 100 is 0
if 0 > maxn maxn = 0
else if ( 100 - x modulo 100 ) > maxn
maxn = 100 - x modulo 100
if maxn < 0
print - 1
else
print maxn
integer as n
read n
integer as k = ( n / 2 ) if ( n & 1 ) is true else ( n - ( int ) pow ( 2 , ( int ) log2 ( n ) ) ) / 2
output k
mod = 998244353
maxn = 2e5
create int t
create long long n , a , b , c
read n
read a , b and c
one = a , two = b - c
set sum1 = n / one , yu1 = n % one , create long long c1
while yu1 / b > 0
set ci = ( yu1 - b ) / two
if ci = 0 and yu1 > = b
if yu1 / a > 0 and yu1 / a * a < yu1 / b * two
set yu1 to yu1 - yu1 / a * a
assign sum1 + yu1 / a to sum1
else
yu1 = yu1 - two
increment sum1
else
yu1 = yu1 - ci * two
set sum1 to sum1 + ci
set yu2 = n , sum2 = 0 , ans = 0
while yu2 / b > 0
assign ( yu2 - b ) / two to ci
if ci = 0 and yu2 > = b
if yu2 / a > 0 and yu2 / a * a < yu2 / b * two
set yu2 to yu2 - yu2 / a * a
sum2 = sum2 + yu2 / a
else
set yu2 to yu2 - two
add 1 to sum2
else
yu2 = yu2 - ci * two
assign sum2 + ci to sum2
set sum2 to sum2 + yu2 / one
yu2 = yu2 % one
ans = max ( ans , sum2 )
ans = max of sum1 and ans
print ans
create integer n
read n
create boolean array horizontal with size n + 1 with horizontal = { }
create boolean array vertikal with size n + 1 with vertikal = { }
create boolean array theyareworking with size n * n + 1 with theyareworking = { }
for i = 1 to n * n inclusive
create integers v , h
read h read v
if horizontal [ h ] is false and vertikal [ v ] is false
set theyareworking [ i ] to true
set horizontal [ h ] to true
set vertikal [ v ] to true
create boolean hihi with hihi = false
for i = 1 to n * n inclusive
if theyareworking [ i ] is true
if hihi is false
print i
set hihi to true
else
print " " print i
print newline
let n = integer and ts = array of integers size 26
let s = string
read n , s
if n is 1 do the following
set sizeof ( ts ) bytes starting at ts to 0
for integer i = 0 to n exclusive increment ts [ s [ i ] - a ]
call sort on ts and ts + 26
if ts [ 25 ] is less than 2
else
read variable n from the input
in a for loop , change i from 0 to n exclusive incrementing i
read variable p from the input
if p is equal to 25 , increment j by one
if p = 50
decrement j
increment k by one
if j is less than 0 , change temp to 1
else if p is equal to 100
if k ! = 0 & j ! = 0
decrement k by one
substract 1 from j
else
decrease j by 3
if j is less than 0 , assign 1 to temp
if temp = 0
print " YES "
else
print " NO "
declare long longs n , r , c , w = 0 , b = 0
read n , r , c
if r is 1 , let w be c - 1
if c is 1 , let w be r - 1
if w is 0 , let w be minimum of ( r and c ) - 1 + maximum of ( r and c ) - minimum of ( r and c )
if r is n , let b be absolute value of ( c - n )
if c is n , let b be absolute value of ( r - n )
if b is 0 , let b be n - maximum of ( r and c ) + absolute value of ( minimum of ( r and c ) - maximum of ( r and c ) )
if w is less than or equal to b
print " White "
print " \ n "
else
print " Black "
print " \ n "
nums is a integer array
divisors is a ineger array
get_gcd is a function
while ( a % = b ) and ( b % = a ) is true
end statement
return a + b
primes is an ineger array
get_prime is a function
for integer i = 0 to end - begin + 1 exclusive ,
if primes [ i ] = 0 or primes [ i ] = 1
primes [ i ] equals 0
continue
else
appear_ctr is an integer equals 0
if nums [ i ] is not equal to 0 , increase appear_ctr by nums [ i ]
for integer j = i + primes [ i ] to end - begin + 1
primes [ j ] equals 0
if nums [ j ] is not equal to 0 , increase appear_ctr by nums [ j ]
divisors [ i ] equals appear_ctr
let n be an integer
let gcd be an integer and equals 1
read n
is_first is a boolean value true
let first_ctr is an integer 0
let max_num is an integer 0
let first be an integer
for integer currnum = 1 to n inclusive
let temp be an integer
read temp
let max_num equal max ( max_num , temp )
increase nums [ temp ] by 1
if is_first is true
first equals temp
gcd equals temp
is_first equals false
else if nums [ temp ] equals 1
gcd equals get_gcd ( gcd , temp )
if temp equals first , increase first_ctr by 1
if first_ctr equals n
print - 1 and endline
if gcd is not equal to 1 ,
for integer currnum = 1 to max_num inclusive
if nums [ currnum ] is not equal to 0
integer appear equals nums [ currnum ]
nums [ currnum ] equals 0
nums [ currnum / gcd ] equals appear
for integer currnum = 1 to max_num inclusive , primes [ currnum ] = currnum
call function get_prime
integer max_appear equals 0
for integer currdiv = 1 to max_num inclusive , max_appear = max ( max_appear , divisors [ currdiv ]
print n - max_appear and endline
integers = presub ( string s )
integers = aux
for pos = 1 to less than ( int ) s . size ( ) do the following
set aux to 0
if aux + pos is less than ( integer then do the following s . size (
if aux + pos is ( integer then do the following s . size (
return ( int ) s . size ( )
s , t = string array
integers = n , k , pos
read input n , k
read in t
set pos to n - presub ( t )
set s to t
for i = 0 to less than k - 1 do the following
for j = pos to less than n then add t [ j ] to s
output s
a , b , l , r , ans , T = int
s = char array of size 200
vis = bool array of size 27
in function dfs taking char cp and returning int
count = int with count = 0
for i = 0 to a set s [ i ] to ' a ' + i
for i = a to a + b set s [ i ] to cp
set all values of vis to false
for i = b to a + b set vis [ s [ i ] - ' a ' ] to true
sta , ed = int with sta = a + b and ed = 0
loop while sta < 2 * a + b
loop while vis [ ed ] increment ed
set s [ sta ] to ed + ' a '
increment both sta and ed
for i = 2 * a + b to T set s [ i ] to s [ i - 1 ]
set all values of vis to false
if l < = r
for i = l to r inclusive
if not vis [ s [ i ] - ' a ' ] increment count then set vis [ s [ i ] - ' a ' ] to true
else
for i = 0 to r inclusive
if not vis [ s [ i ] - ' a ' ] increment count then set vis [ s [ i ] - ' a ' ] to true
for i = l to T
if not vis [ s [ i ] - ' a ' ] increment count then set vis [ s [ i ] - ' a ' ] to true
return count
read a then b then l then r
decrement both l and r
if a < = b
set ans to a + 1
else
set ans to 2 * a - b
set T to 2 * ( a + b )
if r - l > = T
noop
else
set r to r mod T then set l to l mod T
for i = 0 to a set ans to min of dfs of ( ' a ' + i ) , ans
print ans
create new long long variable n
search is a bool function with long long argument t1
declare new integers l = 0 and r = ( square root of ( 8 * n + 1 ) ) / 2
declare integer variable m
create new integer called it = 0
while it < = 100
change m to ( l + r )
declare long long variable t2 = m * ( m + 1 ) / 2
if t2 = t1 when t1 ! = 0
return true
else if t2 is greater than t1
set r to m
else
assign m to l
increment it
return false
create new long long called t1 = 0
read variable n from the input
create boolean variable with name found and value = false
if n ! = 1
start for loop from i = 1 to n inclusive , while ( i * ( i + 1 ) / 2 ) < = n
assign n - ( i * ( i + 1 ) / 2 ) to t1
change found to the result of search ( t1 )
if found is true
print " YES " and ' \ n ' to the standard output
stop the loop
if found is false , print " NO " and ' \ n '
n , m and i are integers where i = 0
declare string variables s and s1
read standard input to n and m
read user input to s and s1
if s = s1
print " YES "
while s [ i ] is s1 [ i ] and i < min of n and m
while s [ n - 1 ] is s1 [ m - 1 ] and i < min of n and m
print " YES " if s [ i ] = ' * ' and ( n - i ) = 1 or " NO " otherwise
create ints n , a = 0 , b = 0 , and c
read n
while n - - is truthy
read c
if c is equal to 25
increment a
else if c is equal to 50
add 1 to b
if a is falsy
print " NO "
decrease a by 1
else do
if a and b are truthy
decrease a and b by 1
else if a is greater than or equal to 3
set a to a - 3
else
print " NO "
print " YES "
n , m = integers
create k as double
input n , m , k
a = string
s as integer
sk = map string to double
for i = 0 to n - 1
input a , s
if s * k less than 100
do nothing
else
sk [ a ] = return value of floor called with s * k + 0 . 00001
for i = 0 to m - 1
input a
if sk [ a ] equals 0 then set sk [ a ] to 0
create an iterator for map string to double called i
print the size of sk
declare long longs n , a , b , c
while read n is true
read a , b , c
declare long long cnt = 0
if b - c is greater than or equal to a or b - c is less than a and n is less than b
increment cnt by n / a
else
increment cnt by ( n - b ) / ( b - c ) + 1
decrement n by cnt * ( b - c )
increment cnt by n / a
print cnt and newline
integer as t integer MAXN = 2e5 + 5
integer as N , L , T , H
integer as A [ MAXN ]
read N , L , T
set A [ 2 * N + 1 ] to L
for i = 1 to less than or equal to N do the following
read A [ 2 * i - 1 ] , A [ 2 * i ]
A [ 2 * i ] equals A [ 2 * i ] plus A [ 2 * i - 1 ]
for i = 0 to less than or equal to N then add ( A [ 2 * i + 1 ] - A [ 2 * i ] ) / T to H
create long long q
read q
if q = 1
print 1 \ n0 \ n and a newline
set a and b to - 1
for d = 2 to d * d < = q
if q mod d different from 0 , continue
a = d
set b to q / d
break
if a = - 1
print 1 \ n0 \ n
for d = 2 , d * d < = b
if b modulo d different from 0 , continue
print 1 \ n , a * d and a newline
print 2 \ n
create long double n
read n
if n is less than or equal to 127
print " byte "
else if n is less than or equal to 32767
display " short "
else if n is less than or equal to 2147483647
display " int "
else if n is less than or equal to 9223372036854775807
print " long "
otherwise
show " BigInteger "
create integers n and m
read n and m from the user input
dif is a new integer = 99999999
decrement m and loop further , while m ! = 0
declare ints a and b
read a and b
set dif to min of dif and abs ( a - b ) + 1
j is a new integer variable = 0
print dif
while j < n
print j modulo dif to the standard output
if j ! = n - 1 , print " " to the standard output
increment j
print new line
x , y = array of 11 by 11 char
b = array of 10 int , n = int
read n
for i = 0 to 10 exclusive b [ i ] = 1
for i = 0 to n exclusive
for j = 0 to n exclusive read x [ i ] [ j ]
for i = 0 to n exclusive
for j = 0 to n exclusive read y [ i ] [ j ]
for i = 0 to n exclusive
for j = 0 to n exclusive
if x [ i ] [ j ] is not y [ i ] [ j ] b [ 0 ] = 0
if x [ i ] [ j ] is not y [ i ] [ n - j - 1 ] b [ 1 ] = 0
if x [ i ] [ j ] is not y [ n - i - 1 ] [ j ] b [ 2 ] = 0
if x [ i ] [ j ] is not y [ n - i - 1 ] [ n - j - 1 ] b [ 3 ] = 0
if x [ i ] [ j ] is not y [ j ] [ n - i - 1 ] b [ 4 ] = 0
if x [ i ] [ j ] is not y [ n - j - 1 ] [ n - j - 1 ] b [ 5 ] = 0
if x [ i ] [ j ] is not y [ j ] [ i ] b [ 6 ] = 0
if x [ i ] [ j ] is not y [ n - j - 1 ] [ i ] b [ 7 ] = 0
for i = 0 to 8 exclusive
if b [ i ] is 1
print Yes
print No
n , a , b , num = integers with a , b = integer array of size 1001
read n
num = n
for i = 1 to n , read a [ i ] , b [ i ]
for j = 1 to n
for i = 1 to n
if ( i is j ) , continue next iteration
if ( b [ j ] is a [ i ] )
decrement num
a [ i ] = 0
print num
require fixed number of decimal digits in output
set number of decimal digits to 20
n = int
read n
s = string
read s
ans = 0
for i = 0 to n exclusive
if s [ i ] is ' < '
increment ans
else
break
for i = n - 1 down to 0 inclusive
if s [ i ] is ' > '
increment ans
else
break
M = const int with M = 100005
n , m , k = long long
a = long long array of size M
num = long long array of size M
read n then m then k
for i = 1 to n inclusive read a [ i ]
if n is even
print " 0 "
ans = long long
movs = long long with movs = n / 2 + 1
if movs > m
set ans to 0
else
minn = long long with minn = a [ 1 ]
for i = 2 to n inclusive
if i is uneven set minn to min of a [ i ] , minn
set ans to min of minn , m as long long / movs * k
print ans
let a , b , s be long long int
read a , b , s
if s < ( abs ( a ) + abs ( b ) ) OR ( ( s - abs ( a ) - abs ( b ) ) % 2 )
print No and end line
print Yes and end line
ab1 , ba1 , ab2 , ba2 = false
s = string
read s
n = size of s
for i = 0 to n - 1 exclusive
if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' and not ab1
ab1 = true
increment i
else if s [ i ] is ' B ' and s [ i + 1 ] is ' A ' and ab1
ba1 = true
increment i
for i = 0 to n - 1 exclusive
if s [ i ] is ' B ' and s [ i + 1 ] is ' A ' and not ba2
ba2 = true
increment i
else if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' and ba2
ab = true
increment i
if ab1 and ba1
print " YES "
else if ab2 and ba2
print " YES "
else
print " NO "
MAXN = constant integer = 100000
MOD = constant long long = 1000000009
in function poww_mod with arguments long long a and long long b that returns long long
ans = long long = 1
a = a modulo MOD
while b is nonzero
if b ends in a one in bits , then ans = ( a * ans ) modulo MOD
a = ( a * a ) modulo MOD
b shifted by one bit to the right
return ans modulo MOD
in function inv with arguments of long long t and long long p that returns a long long
t = t modulo p
return 1 if t is 1 else return ( p - p / t ) * ( call inv with arguments of p modulo t and p ) modulo p
n = integer = 0 , k = integer = 0 , a = integer = 0 , b = integer = 0
ans = long long array of size MAX + 5 , answer = long long = 0
s = string
read n , a , b , k
read s
pre = long long = 0
while k < 10000 and k < n
k = k * 2
s = s + s
for i = 0 to k exclusive
if s [ i ] is +
ans [ i ] = pre + ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) modulo MOD
else
ans [ i ] = pre - ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) modulo MOD
pre = ans [ i ]
if n < k
if ans [ n ] < 0 , then ans [ n ] = ans [ n ] + mod
print ans [ n ]
else
beishu = integer = n / k
save = integer = n - n / k
answer = pre
for i = 1 to beishu exclusive
pre = ( pre * mode ) modulo MOD
answer = ( answer + pre ) modulo MOD
for i = n / k * k to n inclusive
if s [ i modulo k ] is +
answer = ( answer + ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) ) modulo MOD
else
answer = ( answer - ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) ) modulo MOD
if answer < 0 , then answer = answer + MOD
print answer
create integers n , f , cnt , i1 , i2 with f = 0 , cnt = 0
create strings s , s1
read s read s1
if size of s is not size of s1
print " NO " print newline
else
for i = 0 to size of s exclusive
if s [ i ] is not s1 [ i ]
if not f
set i1 to i , set f to 1
else
set i2 to i
increment cnt
if cnt is not 2
print " NO " print newline
else
if s [ i2 ] is s1 [ i1 ] and s [ i1 ] is s1 [ i2 ]
print " YES " print newline
else
print " NO " print newline
declare integers a , b , c , d
declare check with integers t1 , t2 as arguments , returning integer
if t1 is less than t2
return 1 from function
else if t1 is greater than t2
return - 1
read a , b , c , d
declare x = 0 , y = 0 as integers
declare t1 = b , t2 = b as integers
while true
if run check ( t1 , t2 ) is 1
increment t1 by a
increment x
if run check ( t1 , t2 ) is - 1
increment t2 by c
increment y
if result of run check ( t1 , t2 ) is 0
print t1 , newline
break loop
if x is greater than 100 or y is greater than 100
print " - 1 " and newline
arr = integer array of size 100 = { 0 }
str = string array of size 6 with str = { ABC , ACB , BAC , BCA , CAB , CBA }
function CheckStr takes string s
function Grow takes string s , char c
function CheckStr takes string s
D = bool with D = false
for i = 0 to 5
if s . find ( str [ i ] ) is not string npos
D = true
print Yes
break loop
if not D , print No
function Grow takes string s , char c
s = string
while ( read s ) , call s on CheckStr
declare long long n
input n
declare char array mat with n and n indices
loop i through 0 and one less than n
loop j through 0 and 1 less than n , inputting mat at indices i and j
set bools col_x and row_x to be false
loop i between 0 and one less than n
declare long long cnt to be 0
loop j from 0 to one less than n
if mat at i and j is E then increment cnt
if cnt equals n
set row_x true
break
loop i between 0 and one less than n
declare long long cnt to be 0
loop j between 0 and one less than n
if mat at j and i is E increment cnt
if cnt equals n
set col__x to true
break
if both col_x and row_x are true
output - 1 and a newline
otherwise if row_x is true
loop i from 0 to one less than n
loop j from 0 to one less than n
if mat at j and i equals .
output j plus 1 , a space , i plus one , and a newline
break
else
loop i from 0 to one less than n
loop j from 0 to one less than n
if mat at i and j is .
output i plus 1 , a space , and j plus 1 and a newline
break
a = array of integers of size 1005
n = integer
read n
for i = 1 to n inclusive , read i values into array a
if n = 1
if a [ 1 ] is true
call puts on " YES "
else
call puts on " NO "
num = integer with num = 0
for i = 1 to n inclusive
if a [ i ] is false , increment num
if num = 1
call puts on " YES "
else
call puts on " NO "
create constant long long integer array a with size 100005
create long long integer vector v
create string s
read s
create long long integers n , l , sum , cum , x with n = length of s , sum = 0 , cum = 0
for i = 0 to n exclusive
if s [ i ] is ' ( '
set a [ i ] to - 1
else if s [ i ] is ' ) '
set a [ i ] to 1
else
set a [ i ] to 0
for i = n - 1 to 0 inclusive , decrementing i
if a [ i ] is 0
set l to i
break loop
else
increment sum by a [ i ]
for i = 0 to n exclusive
if a [ i ] is 0 and i is not l
set a [ i ] to 1 , increment cum by 1 , add element 1 to end of v
else if a [ i ] is not 0
increment cum by a [ i ]
else if a [ i ] is 0 and i is l
set x to - ( cum + sum )
if x is less than or equal to 0
print " - 1 \ n "
add element x to end of v
increment cum by x
if cum is greater than 0
print " - 1 \ n "
for i = 0 to size of v exclusive , print v [ i ] print " \ n "
create new strings s and t
declare integer variables l1 and l2
p is an 2d array of integers with size 10001 by 26
read s and t and loop further
assign length of s to l1
change l2 to the length of t
set first sizeof ( p ) bytes at the pointer p to 0
in a for loop , change i from 0 to 26 exclusive , assigning - 1 to p [ l1 ] [ i ] on each loop
start for loop from j = l1 to 1 inclusive decrementing j
for i from 0 to 26 exclusive
if s [ j ] is equal to i + ' a '
set p [ j - 1 ] [ i ] to j
else
change p [ j - 1 ] [ i ] to p [ j ] [ i ]
declare new int variables ans = 1 and l = - 2
in a for loop , change i from 0 to l2 exclusive
if l is equal to - 2
if s [ 0 ] = t [ i ]
change l to 0
else
change l to p [ 0 ] [ t [ i ] - ' a ' ]
if l = - 1
set ans to - 1
break the loop
else
assign p [ l ] [ t [ i ] - ' a ' ] to l
if l is equal to - 1
increment ans by one
set l to - 2
decrement i
print ans
declare function choose , which returns a long long integer and takes long long integers n and m
ans = long long integer set to 0
num = long long integer set to 1
den = long lon integer set to 1
for i = 0 to m exclusive
multiply num by n - i
set num to num / i + 1
return num
declare isPrime which returns a boolean and takes in an integer n
if n < = 1 return false
if n < = 3 return true
if n modulo 2 is 0 or n modulo 3 is 0 , return false
for i = 5 and i * i < = n , while incrementing by 6
if n modulo i is 0 or n modulo i + 2 is 0 , return false
return true
declare gcd returns a long long integer and takes long long integers a and b
if a is 0
return b
else
return gcd of b modulo a and a
i , j , k , n , m , t = long long integers
a , b , c , d , ans , max1 , min 2 = long long integers with ans set to 0
read a , b , c , d , k
if a > = c
set max1 to a
else
set max1 to c
if b > = d
set min2 to d
else
set min2 to b
if max1 > min2
print 0
else
if max1 < = min2
if k > min2 or k < max1
print min2 - max1 + 1
else
print min2 - max1
s1 = string
while read s1
if length of s1 < 3
print " NO "
else
a = position of " AB " in s1
b = position of " BA " in s1 starting from a + 2
c = position of " BA " in s1
d = position of " AB " in s1 starting from c + 2
if a is not - 1 and b is not - 1 or c is not - 1 and d is not - 1
print " YES "
else
print " NO "
s = 2d integer array of size [ 101 ] [ 101 ]
n , a , r = integers
read n
a = 100
while ( a * ( a - 1 ) * ( a - 2 ) / 6 > n ) decrement a
n = n - a * ( a - 1 ) * ( a - 2 ) / 6
r = a
for i = 1 to a exclusive
for j = i + 1 to a , s [ i ] [ j ] = s [ j ] [ i ] = 1
for i = a down to 2
while n > = i * ( i - 1 ) / 2
n = n - i * ( i - 1 ) / 2
increment r
for j = 1 to i , s [ r ] [ j ] = s [ j ] [ r ] = 1
print r
for i = 1 to r
for j = 1 to r , print s [ i ] [ j ]
print new line
declare constant integer max_n = 2e2
declare integer array a size max_n
declare integers n , m , cnt , mx , ans
read n , m
for i = 0 to n exclusive
read a [ i ]
let mx be maximum of mx and a [ i ]
let mx be ( mx + m - 1 ) / m
for j = 0 to mx exclusive
for i = 0 to n exclusive
if a [ i ] is greater than 0
decrement a [ i ] by m
if a [ i ] is less than or equal to 0 , let ans be i
print ans + 1 and ' \ n '
let s , t , and x be integers
read in s , t and x and continue looping
if x is less than s + t
if x is equal to s
or else
or else
if ( x - s ) % t is equal to 0 or ( x - s - 1 ) % t is equal to 0
or else
create long longs N , M and K
read N , M and K
if N - 1 + M - 1 is less than K
print - 1
declare long long variable ans = 0
if K > = M - 1
declare long long hori = K - ( M - 1 )
create long long rows = N / ( hori + 1 )
assign max of ans and rows to ans
else
set ans to max of ans and N * ( M / ( K + 1 ) )
swap N and M
if K > = M - 1
declare long long variable hori = K - ( M - 1 )
create long long rows = N / ( hori + 1 )
set ans to max of ans and rows
else
change ans to max of ans and N * ( M / ( K + 1 ) )
print ans
t1 , t2 , x1 , x2 , t0 , res_x , res_y = long long
read t1 , t2 , x1 , x2 , t0
t , ct = double with ct = 1e99
while ( x1 > = 0 and x2 > = 0 )
t = ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if ( t < t0 )
decrement x1
continue next iteration
if ( t < ct )
ct = t
res_x = x1
res_y = x2
decrement x2
print res_x , ' ' , res_y
bool function isP with int argument n
return false if n is even and n ! = 2
for i from 3 , while i * i < = n , increment i b y2
if n % i = 0 , return false
return true
create integers n , m , cn , cm and gc
read standard input to n
in a for loop , change i from 1 to 1000 inclusive incrementing i
if isP ( n * i + 1 ) returned false
print i
in function g that takes integer a and return integer
if a is negative , return - a
return a
n , x , y , xx , yy , l are integers
read n , x , y , xx , yy , and l
if x is false
if xx is false
set l to call function g with argument y - yy
else
if xx equals n
set l to call function min with arguments y + yy + n , n - y + n - yy + n
else
if yy is false
set l to y + xx
else
set l to n - y + xx
else
if y is false
if xx is false
assign yy + x to l
else
if xx is equal to n
assign yy + n - x to l
else
if yy is false
set l to call function g with argument x - xx
else
set l to call function min with arguments x + xx + n , n - x + n - xx + n
else
if x equals n
if xx is false
set l to call function min with arguments y + yy + n , n - y + n - yy + n
else
if xx equals n
set l to call function g with argument y - yy
else
if yy is false
assign n - xx + y to l
else
assign n - xx + n - y to l
else
if xx is false
assign n - yy + x to l
else
if xx equals n
assign n - x + n - yy to l
else
if yy is false
set l to call function min with arguments x + xx + n , n - x + n - xx + n
else
set l to call function g with argument xx - x
display 1
function solve with unsigned long long argument x that returns unsigned long long
new unsigned long longs ans , f , e and xx where ans = 0 and xx = x
if x is less than 10 , return x
change e to x % 10
while x ! = 0
assign x modulo 10 to f
divide x by 10
if f < = e
set ans to 9 + xx / 10
else
change ans to 8 + xx / 10
return ans
declare unsigned long longs a and b
read input to a and b
print solve ( b ) - solve ( a - 1 )
declare constant integer maxn = 110
declare integer arrays a size maxn , b size maxn
declare integer array vis size 1010
declare integer n
declare integer cnt = 0
read n
set bytes from vis to size of vis to value 0
for i = 0 to n exclusive , read a [ i ] and b [ i ]
for i = 0 to n exclusive
for j = 0 to n exclusive
if i is j , end current loop iteration
if a [ i ] is b [ j ] , let vis [ i ] be 1
for i = 0 to n exclusive
if vis [ i ] is 1 , increment cnt
print n - cnt and newline
declare integers a , b , c , d , e , f
read a and b and c and d and e and f
if a * c * e is 0 and b * d * f is 0
if d is 0
print " Hermione \ n "
else if b is 0
if c is 0
print " Ron \ n "
else
print " Hermione \ n "
else
if a is 0 or c is 0
print " Ron \ n "
else
print " Hermione \ n "
else
if b * d * f is greater than a * c * e
print " Ron \ n "
else
print " Hermione \ n "
M = const integer with M = 500010
a = string array of size M
dp = integer array of size [ 26 ] [ 26 ]
n = integer
read n
for i = 1 to n , read s [ i ]
for i = 1 to n
t = string with t = s [ i ]
tlen = integer with tlen = t . length ( )
s1 = integer with s1 = t [ 0 ] - a
e1 = integer with e1 = t [ tlen - 1 ] - a
for j = 0 to 25
if ( tlen > dp [ s1 ] [ e1 ] ) , dp [ s1 ] [ e1 ] = tlen
ans = integer with ans = 0
for i = 0 to 25 , ans = max of ans and dp [ i ] [ i ]
print ans
maxn = const int with maxn = 10005
n , m , k , minn = long long with minn = 1e8 and arr = long long array of size maxn
read n then m then k
for i = 0 to n
read arr [ i ]
if not ( i bitwise - and 1 ) set minn to min of minn , arr [ i ]
if not ( n bitwise - and 1 ) or m < ( n / 2 + 1 )
print " 0 "
print min of minn , m / ( n / 2 + 1 ) * k
create string a
make long long ints b , t , and c = 0
read a
set b to a . find ( ' = ' )
set t to b
set b to b + 2
set b to a . size ( ) - b + 1
for i = 0 to t exclusive
if a [ i ] is equal to ' | ' , increment c
if c + 1 is equal to b - 1
print ' | '
for i = 0 to size of a - 1 exclusive , print a [ i ]
print new line
else if c is equal to b
display a
else if c is equal to b + 2
create long long z = a . find ( ' + '
if z is greater than 1
for i = 1 to size of a exclusive , display a [ i ]
print ' | '
else do
for i = 0 to a . size ( ) exclusive
if i is equal to z + 1 , continue loop
print a [ i ]
show ' | '
else do
print " Impossible "
n , t = int , cnt = 0
read n
v = vector of int
q = queue of int
for i = 0 to n exclusive
read t
add t at end of v
for i = 0 to size of v - 1 exclusive
push v [ i ] into q
if q is not empty and first item of q > v [ i + 1 ]
pop first item of q
increment cnt
print cnt
let n , count , ret be long integers with count = 0 , ret = 0
read n
vector < tuple < long long , long long , long long > > data be a vectoe
for i = 0 to n exclusive
let k , a0 , x , y , m , t , a be long integers with t = 0 , a = 0
read k , a0 , x , y , m
for j = 0 to k exclusive
push_back the value of make_tuple ( t , a0 , i ) into data
a is equal to ( a0 * x + y ) modulo m
if a is less than a0 and j is not equal to k - 1 , increment t by 1
a0 is equal to a
ret is equal to maximum of ret and t
print ret and newline
sort the values of data from beginning to end
create string s
read s
for i = 1 to size of s - 1 exclusive
create integers a , b , c , with a = 0 , b = 0 , c = 0
if s [ i ] is ' A ' , increment a
if s [ i ] is ' B ' , increment b
if s [ i ] is ' C ' , increment c
if s [ i - 1 ] is ' A ' , increment a
if s [ i - 1 ] is ' B ' , increment b
if s [ i - 1 ] is ' C ' , increment c
if s [ i + 1 ] is ' A ' , increment a
if s [ i + 1 ] is ' B ' , increment b
if s [ i + 1 ] is ' C ' , increment c
if a is 1 and b is 1 and c is 1
print " Yes " print newline
print " No " print newline
create long doubles a and b
display fixed and setprecision ( 12 )
read a and b
if b is greater than a
print - 1
if a is equal to b
print a
create long double x1 = ( ( ( a - b ) * 0 . 5 ) ) / floor ( ( ( a - b ) * 0 . 5 ) / b )
make long double x2 = ( ( ( a + b ) * 0 . 5 ) ) / floor ( ( ( a + b ) * 0 . 5 ) / b )
show min of x1 and x2
declare new long longs ans and n
read n and loop further
if n < = 2
set ans to n
else if n is odd
change the value of ans to n * ( n - 1 ) * ( n - 2 )
else
if n cannot be divided by 3 without a remainder
change ans to n * ( n - 1 ) * ( n - 3 )
else
assign ( n - 1 ) * ( n - 2 ) * ( n - 3 ) to ans
print ans
SevenPows = integer array which includes = 0 , 7 , 49 , 343 , 2401 , 16807 , 117649
visited = bool array of size 8
N , M , dh , dm = integers
in the function Judge that includes integers h and m and returns bool
fill from visited to visited + 8 with false
for i = 0 to dm exclusive
if visited [ m modulo 7 ] , return false
visited [ m modulo 7 ] = true
m = m / 7
for i = 0 to dh exclusiv
if visited [ h modulo 7 ] , return false
visited [ h modulo 7 ] = true
h = h / 7
return true
i , j = integer
read N , M
for i = 0 to 6
if N < = SevenPows [ i ]
dh = i
break loop
if i is 7
print 0
for i = 0 to 6
if M < = SevenPows [ i ]
dm = i
break loop
if i is 7
print 0
ans = integer with ans = 0
for i = 0 to N exclusive
for j = 0 to M exclusive
if Judge ( i , j ) , increment ans
print ans
x , t , a , b , da , db are integers
sum = integer
read x , t , a , b , da , db
if x is 0
for i = 0 to t exclusive
for j = 0 to t exclusive
sum1 = integer = a - ( da * i )
sum2 = integer = b - ( db * j )
if sum1 is x or sum2 is x or sum1 + sum2 is x
create int t
read t
let int array x of size 1000020
for i = 0 to 1000020 exclusive , set x [ i ] to 0
for i = 0 to t exclusive
make int temp
read temp
increment x [ temp ]
let int sum = 0
for i = 0 to 1000020 exclusive
set x [ i + 1 ] to x [ i + 1 ] + ( x [ i ] > > 1 )
set x [ i ] to ( x [ i ] & 1 )
for i = 0 to 1000020 exclusive , set sum to sum + x [ i ]
print sum
declare long long integer mod = 1000000007
declare long long integers x1 , y1 , x2 , y2 , a , b , c
declare integers n , ans = 0
read x1 , y1 , x2 , y2 , n
for i = 0 to n exclusive
read a , b , c
declare long long integer val1 = a * x1 + b * y1 + c
declare long long integer val2 = a * x2 + b * y2 + c
if ( val1 is less than 0 and val2 is greater than 0 ) or ( val1 is greater than 0 and val2 is less than 0 ) , increment ans
print ans and newline
constant integer INF = 1 < < 29
create int arrays l , s , r and p with 4 elements
for i from 0 to 4 exclusive , read input to l [ i ] , s [ i ] , r [ i ] and p [ i ]
for i from 0 to 4 exclusive
if p [ i ] is not 0
if l [ ( i + 1 ) % 4 ] , r [ ( i - 1 + 4 ) % 4 ] or s [ ( i + 2 ) % 4 ] is not 0
print " YES \ n "
if l [ i ] , r [ i ] or s [ i ] is not 0
print " YES \ n "
print " NO \ n "
a = int array of size 30
n = int
read n
if n is 1
print " Yes "
loop n times
s = char
read s
increment a [ s - 96 ]
flag = int with flag = 0
for i = 1 to 26 inclusive
if a [ i ] > = 2 increment flag
if flag is 0
print " No "
else
print " Yes "
declare long long array a size 100005 , long longs n , k , m , minn , s , x
read n and m and k
for i = 0 to n exclusive , read a [ i ]
if not n % 2
print 0 and newline
else
let minn be 0
let s be n / 2 + 1
if s is greater than m
let minn be 0
else
let minn be a [ 0 ]
for i = 0 to n inclusive , incrementing i by 2 , let minn be minimum of minn and a [ i ]
let x be m / s * k
let minn be minn and x
print minn and newline
define function solve which takes in an array of long long integers dif and integer n as arguments
let current_max and max_so_far be integers , set current_max and max_so_far to dif [ 0 ]
for i = 1 to n
set current_max to the max of current_max + dif [ i ] and dif [ i ]
set max_so_far to the min of current_max and max_so_far
return the value of max_so_far from the function
let n be an integer
read in n
let arr and dif be arrays of integers , arr has a size of n and dif has a size of n - 1
read in n values into array arr
let ans be a long long integer and set its value to - 1e18
set ans to the max of ans and solve ( dif , n - 1 )
iterate for n - 1 times , set dif [ i ] to dif * - 1
set ans to the max of ans and solve ( dif , n - 1 )
print ans and a newline
n = integer
read n
a = integer array of size n
banyakyangmilihini = array of vector of integer of size 2001
inilahhasilnya = integer array of size n = { }
for i = 0 to n exclusive
read a [ i ]
append i in banyakyangmilihini [ a [ i ] ]
i = integer with i = 1
for k = 2000 down to 0 exclusive
if ( banyakyangmilihini [ k ] . size ( ) > 0 )
for m = 0 to banyakyangmilihini [ k ] . size ( ) exclusive , inilahhasilnya [ banyakyangmilihini [ k ] [ m ] ] = i
i = i + banyakyangmilihini [ k ] . size ( )
for k = 0 to n exclusive
if ( k is 0 )
print inilahhasilnya [ k ]
else
print inilahhasilnya [ k ]
print new line
s = integer array of size 35
in the function to_int that takes character pointer a , b and returns long long
res = long long with res = 0
if ( pointer a is 0 and a is not b ) , return - 1
while ( a is not b + 1 )
res = ( res * 10 ) + ( a [ 0 ] - 0 )
if ( res > 1000000 ) , return - 1
increment a
return res
read s
pointer nd = s + strlen ( s ) - 1
res = long long with res = - 1
for pointer p1 = s to p1 [ 2 ]
for pointer p2 = p1 + 1 to p2 [ 1 ]
a , b , c = long long with a = to_int ( s , p1 ) , b = to_int ( p1 + 1 , p2 ) , c = to_int ( p2 + 1 , nd )
if ( a is - 1 or b is - 1 or c is - 1 ) , continue next iteration
res = max of res and a + b + c
print res
let gcd be a function which accepts long integers x and y and returns a long integer value
return y if x modulo y = 0 else return gcd of y and x modulo y
let lcm be a function that accepts int x , int y , int z and returns a long integer value
the long integer value of a = ( long long ) x * y / gcd of x and y
a is equal to a * z / gcd of a and z
return the value of a
let n be a integer
read n
the long integer value of ans = 0
for integer i = max ( 1 , n - 100 ) to n inclusive , increment i by 1
for integer j = max ( 1 , n - 100 ) to n inclusive , increment j by 1
for integer k = max ( 1 , n - 100 ) to n inclusive , increment k by 1 , ans is equal to maximum of ans and lcm ( i , j , k )
print ans and newline
create integers m , h , h2 , a , a2 , x , x2 , y , y2
declare get with integers s , e as arguments , returning integer
for i = 0 to m exclusive
set s to ( 1ll * s * x + y ) % m
if s is e , return i + 1
return - 1 from function
declare get2 with integers s , e as arguments , returning integer
for i = 0 to m exclusive
set s to ( 1ll * s * x2 + y2 ) % m
if s is e , return i + 1 from function
return - 1 from function
read m read h read a read x read y read h2 read a2 read x2 read y2
create integers t , t2 with t = result of run get with h , a as arguments , t2 = result of run get2 with h2 , a2 as arguments
if t is - 1 or t2 is - 1 , return print " - 1 \ n " , 0 from function
if t is t2 , return print t print ' \ n ' , 0 from function
create integers l , l2 with l = result of run get with a , a as arguments , l2 = result of run get2 with a2 , a2 , as arguments
if bitwise not l and t - t2 is greater than or equal to 0 and not ( ( t - t2 ) % l2 ) , return print t print ' \ n ' , 0 from function
if bitwise not l2 and t - t2 is greater than or equal to 0 and not ( ( t - t2 ) % l2 ) , return print t print ' \ n ' , 0 from function
if l is - 1 or l2 is - 1 , return print " - 1 \ n " , 0
create integer val with val = t2 - t
for i = 1 , lim = m bitshift left 1 to i is less than or equal to lim , incrementing i
print " - 1 \ n "
N = 1e2 + 10 = const int
n = int
k = int
let a be an NxN integer matrix
now = int
in void function PRINT that takes n = int
print n
for i = 1 till i < = n
for j = 1 to n inclusive then print a [ i ] [ j ]
print new line
read k
reset a to all 0
for i = 2 to N inclusive
if ( i * ( i - 1 ) * ( i - 2 ) ) / 6 > k ) then
set n to i - 1
exit loop
for i = 1 to n inclusive
for j = 1 to n inclusive
if i isn ' t j then set a [ i ] [ j ] to 1
if ( n * ( n - 1 ) * ( n - 2 ) ) / 6 = k )
call PRINT on n
set now to k - ( n * ( n - 1 ) * ( n - 2 ) ) / 6
while now
lo , hi , mid , tmp = int
set lo = 1
make hi = 100
while lo < hi inclusive
set mi to ( lo + hi ) bitwiser right shit 1
if mid * ( mid - 1 ) bitwise right shift < = now
set tmp to mid
make lo = mid + 1
else
set hi = mid - 1
decrement now by tmp * ( tmp - 1 ) bitwise right 1
increment n
for i = 1 to tmp inclusive , set a [ i ] [ n ] = a [ n ] [ i ] = 1
call PRINT on n
let vis be array of integers of size 105
let n , k be integers
read n and k
let num be integer with num = 0
for i = 0 to n exclusive
let x be integer
read x
if vis [ x ] is equal to 0
set vis [ x ] to i + 1
increment num by 1
if num is less than k
print NO with newline
else
print YES with newline
let j be integer with j = 0
call sort with vis and vis + 101
for i = 0 to 100 inclusive
if vis [ i ] is equal to zero
if k is equal to 1
print vis [ i ] with newline
else if k is greater than 1
print out vis [ i ] + one empty space
else
break
decrement k by 1
create integer N , create integer array arr with size 100001
create 3d long long array dp with size 100001 by 201 by 2
read N
for i = 1 to N inclusive , read arr [ i ]
for i = 1 to N inclusive
if arr [ i ] is not - 1
if i is 1
set dp [ i ] [ arr [ i ] ] [ 0 ] to 1
else
for j = 1 to arr [ i ] exclusive
set dp [ i ] [ arr [ i ] ] [ 0 ] to dp [ i ] [ arr [ i ] ] [ 0 ] % 998244353
increment dp [ i ] [ arr [ i ] ] [ 1 ] by dp [ i - 1 ] [ arr [ i ] ] [ 0 ]
set dp [ i ] [ arr [ i ] ] [ 1 ] to dp [ i ] [ arr [ i ] ] [ 1 ] % 998244353
for j = arr [ i ] to 200 inclusive
increment dp [ i ] [ arr [ i ] ] [ 1 ] by dp [ i - 1 ] [ j ] [ 1 ]
set dp [ i ] [ arr [ i ] ] [ 1 ] to dp [ i ] [ arr [ i ] ] [ 1 ] % 998244353
else
if i is 1
for j = 1 to 200 inclusive , set dp [ i ] [ j ] [ 0 ] to 1
else
create long long temp with temp = 0
for j = 1 to 200 inclusive
increment dp [ i ] [ j ] [ 1 ] by dp [ i - 1 ] [ j ] [ 0 ]
set dp [ i ] [ j ] [ 1 ] to dp [ i ] [ j ] [ 1 ] % 998244353
increment dp [ i ] [ j ] [ 0 ] by temp
set dp [ i ] [ j ] [ 0 ] to dp [ i ] [ j ] [ 0 ] % 998244353
increment temp by dp [ i - 1 ] [ j ] [ 0 ]
set temp to temp % 998244353
set temp to 0
for j = 200 to 1 inclusive , decrementing i
increment temp by dp [ i - 1 ] [ j ] [ 1 ]
set temp to temp % 998244353
increment dp [ i ] [ j ] [ 1 ] by temp
set dp [ i ] [ j ] [ 1 ] to dp [ i ] [ j ] [ 1 ] % 998244353
set temp to 0
for j = 1 to 200 inclusive
increment dp [ i ] [ j ] [ 0 ] by temp
set dp [ i ] [ j ] [ 0 ] to dp [ i ] [ j ] [ 0 ] % 998244353
increment temp by dp [ i - 1 ] [ j ] [ 1 ]
set temp to temp % 998244353
create long long ans with ans = 0
for i = 1 to 200 inclusive , set ans to ( ans + dp [ N ] [ i ] [ 1 ] ) % 998244353
print ans print ' \ n '
i , j = long longs , cnt = long long = 0
ar = array of size 100050
a , b , c , d = integers
read a , b , c , d
for i = b to 1e4 inclusive , i = i + a , then increase ar [ i ] by 1
for i = d to 1e4 inclusive , i = i + c , then increase ar [ i ] by 1
tp = integer = larger value between ar and ar + 10001 - ar
of ar [ tp ] is 2 , then print tp and end the program
print - 1
MaxN = 1E5 + 10
create int int a [ MaxN ]
create int n
read n
for i = 0 to n exclusive , read a [ i ]
ans = 0
for i = 0 to n - 1 exclusive
lg = log2 ( n - i - 1 )
set ans to ans + a [ i ]
a [ i + ( 1 < < lg ) ] = a [ i + ( 1 < < lg ) ] + a [ i ]
print ans
create integers n , x1 , y1 , x2 , y2
create integer l
read n read x1 read y1 read x2 read y2
if absolute value of ( x1 - x2 ) is n
set l to n + y1 + y2
else if absolute value of ( y1 - y2 ) is n
set l to n + x1 + x2
else
set l to absolute value of ( x1 - x2 ) + absolute value of ( y1 - y2 )
print minimum of ( l and 4 * n - l ) print newline
f = array of 200005 characters
n = integer
Read n
Read f
sum1 , sum2 = integers , both set to 0
for i = 0 to n exclusive
if f [ i ] is <
increment sum1
Terminate the loop
for i = n - 1 to 0 exclusive
if f [ i ] is >
increment sum2
Terminate the loop
print sum1 + sum2 and a new line
n is an integer
read n
print n / 2 and endline
for integer i = 1 to n / 2 exclusive , print 2and space
if n % 2 is true
print 3 and newline
else
print 2 and newline
n , k , ans = long long and arr = long long array of size 100005
ada = map of long long and bool
read n then k
set ans to 0
for i = 1 to n inclusive read arr [ i ]
sort arr from position 1 to n + 1
for i = 1 to n inclusive
if ada [ arr [ i ] ] is false
increment ans
set ada [ arr [ i ] * k ] to true
let maxn be const integer with maxn = 1e5 + 10
let arr be array of booleans of size maxn
let s be string and ss be array of strings of size maxn
let c be char
let n be integer
in function input
read n
for i = 0 to n exclusive , read ss [ i ]
read s , c
in function low which takes char x and returns char
if x is greater than or equal to A and x is less than or equal to Z , update x to x - ' A ' + ' a '
return x
call input
let w be integer with w = size of s
for i = 0 to n exclusive
for wi = 0 to till wi + size of ss [ i ] - 1 is less than w
let b be boolean with b = true
for ssj = wi to till ssj is less than wi + size of ss [ i ]
if low of s [ ssj ] is not equal to low of ss [ i ] [ ssj - wi ]
set b to false
break
if b is not false
for ssj = wi to till ssj is less than wi + size of ss [ i ] , set arr [ ssj ] to true
for i = 0 to w exclusive
if arr [ i ] is not zero
if low of s [ i ] is equal to c
if c is equal to ' a '
update s [ i ] to s [ i ] + ( ' b ' - low of s [ i ] )
else
update s [ i ] to s [ i ] + ( ' a ' - low of s [ i ] )
else
update s [ i ] to s [ i ] + ( c - low of s [ i ] )
print out s with newline
create integers n , a , b , c d
read n read a read b read c read d
create integers p1 , p2 , with p1 = 0 , p2 = 0
if a is 0 and b is greater than 0 , set p1 to n * 4 - b
if a is greater than 0 and b is 0 , set p1 to a
if a is n and b is greater than 0 , set p1 to n + b
if is greater than or equal to 0 and b is n , set p1 to n * 3 - a
if c is 0 and d is greater than 0 , set p2 to n * 4 - d
if c is greater than 0 and d is 0 , set p2 to c
if c is n and d is greater than or equal to 0 , set p2 to n + d
if c is greater than 0 and d is n , set p2 to n * 3 - c
if p1 is less than p2 , swap values between p1 and p2
if p1 - p2 is greater than 4 * n - p1 + p2
print 4 * n - p1 + p2 print newline
else
print p1 - p2 print newline
create long long int array a of size 1005
create long long int vector ad of size 1005
create long long int stack s
create long long int array visited of size 1005
create long long int done of size 1005
create long long int ans = 0
create long long int k = 0
create long long int vector cycles
declare dfs taking in long long int x and returning long long int
insert x to stack s
increment k
set done [ x ] to k
set visited [ x ] to 1
create long long int i
for i = 0 to the size of ad [ x ] exclusive
if done [ ad [ x ] [ i ] ] is truthy
set ans to ans + k + 1 - done [ ad [ x ] [ i ] ]
if ( k + 1 - done [ ad [ x ] [ i ] ] ) modulo 2 is equal to 0
append ( k + 1 - done [ ad [ x ] [ i ] ] ) / 2 to cycles
else
append k + 1 - done [ ad [ x ] [ i ] ] to cycles
if ! visited [ ad [ x ] [ i ] ] is truthy , call dfs ( ad [ x ] [ i ] )
remove the top element of s
set done [ x ] to 0
create long long ints n , i , and j
create long long int to u and v
read n
for i = 1 to n
read a [ i ]
append a [ i ] to a [ i ]
for i = 1 to n
if a [ i ] is equal to i
for j = 1 to n
if a [ j ] is equal to i and j is not equal to i
print - 1
for i = 1 to n
if ! visited [ i ] is truthy
set k to 0
call dfs ( i )
if ans is not equal to n
print - 1
create long long int lcm = cycles [ 0 ]
print lcm
let v be vector of long lon
define function Power which takes integer n and with return type long long
let ans be long long with ans = 1
for i = 1 to n , ans = ans * 10
return ans
let l and r be integers
for k = 1 to 10
for i = 0 to 1 < < k exclusive
let arr be long long array of size k + 2
for j = 0 to k - 1 , set arr [ j ] to 4
for j = 0 to k exclusive
if i & 1 < < j is not zero , set arr [ j ] to 7
let num be long long with num = 0
for j = 0 to k - 1 , add arr [ j ] * ( Power of j )
add num to the end of v
read l and r
let lIdx be integer with lIdx = lower_bound of v . begin ( ) , v . end ( ) , l - v . begin ( )
let lIdx be integer with rIdx = lower_bound of v . begin ( ) , v . end ( ) , r - v . begin ( )
let sum be long long with sum = ( v [ lIdx ] - l + 1 ) * v [ lIdx ]
for i = lIdx + 1 to rIdx , add ( v [ i ] - v [ i - 1 ] ) * v [ i ] to sum
add ( r - v [ rIdx ] ) * v [ rIdx ] to sum
print out sum with newline
create long long x , y , m , n , i , j
read n
read x and y
if x + y > n + 1
else
in the function meow
mp = string array of size 8
for i = 0 to 7 , read mp [ i ]
dp = integer array of size [ 8 ] [ 8 ] = { 0 } , n = integer with n = 8
set all contents of dp to - 1
for i = 0 , _dwj = 0 to 7
for j = 0 to 7
if ( mp [ i ] [ j ] is K and not _dwj )
_dwj = 1
dp [ i ] [ j ] = 0
q = queue of integer
push i to q
push j to q
while ( q . size ( ) )
x = integer with x = q . front ( )
pop q
y = integer with y = q . front ( )
pop q
if ( x > 1 )
if ( y > 1 and dp [ x - 2 ] [ y - 2 ] is - 1 )
dp [ x - 2 ] [ y - 2 ] = dp [ x ] [ y ] + 1
push x - 2 in q
push y - 2 in q
if ( y < n - 2 and dp [ x - 2 ] [ y + 2 ] is - 1 )
dp [ x - 2 ] [ y + 2 ] = dp [ x ] [ y ] + 1
push x - 2 in q
push y + 2 in q
if ( x < n - 2 )
if ( y > 1 and dp [ x + 2 ] [ y - 2 ] is - 1 )
dp [ x + 2 ] [ y - 2 ] = dp [ x ] [ y ] + 1
push x + 2 in q
push y - 2 in q
if ( y < n - 2 and dp [ x + 2 ] [ y + 2 ] is - 1 )
dp [ x + 2 ] [ y + 2 ] = dp [ x ] [ y ] + 1
push x + 2 in q
push y + 2 in q
for i = 0 to 7
for j = 0 to 7
if ( mp [ i ] [ j ] is K and dp [ i ] [ j ] )
if ( dp [ i ] [ j ] is - 1 ) , return print NO
if ( dp [ i ] [ j ] bitwise and 1 ) , return print NO
return print YES , 0
t = integer
read t
while decrement t , call meow
n = int
read n
let num = 0 , chr = 0 , CHR = 0 be ints
str = string
for i = 0 to n exclusvie
read str
for j = 0 to length of str exclusive
if str at j is between ' a ' and ' z ' both inclusive
increment chr
else if str at j is between ' A ' and ' Z ' both inclusive
increment CHR
else
increment num
if chr = and CHR = 0
insert " aA " int str at 0
call erase on str with args 2 , 2
else if chr and num are both = 0
insert " a1 " into str [ 0 ]
call erase on str with args 2 , 2
else if CHR and num are both = 0
insert " A1 " into str [ 0 ]
erase 2 , 2 form str
else if chr = 0
for j = 0 to length of str
if str at j > = ' A ' bit and str [ j ] < = ' Z ' bit and CHR > 1
insert " a " in str at j
erase j + 1 , 1 form str
exit loop
else if str [ j ] is > = ' 0 ' bit and str [ j ] < = ' 9 ' bit and num > 1
insert " a " , j into str
erase j + 1 , 1 from str
exit loop
else if CHR = 0
for j = 0 to length of str
if str at j > = ' a ' bit and str [ j ] < = ' z ' bit and chr > 1
call insert on str with args j , " A "
erase j + 1 , 1 from str
exit loop
else if str at j > = ' a ' bit and str [ j ] < = ' z ' bit and num > 1
call insert on str with args j , " A "
erase j + 1 , 1 from str
exit loop
else if num = 0
for j = 0 to length of str
if str at j > = ' a ' bit and str [ j ] < = ' z ' bit and chr > 1
insert j , " 1 " into str
erase j + 1 , 1 from str
exit loop
else if str at j > = ' A ' bit and str [ j ] < = ' Z ' bit and CHR > 1
insert j , " 1 " into str
erase j + 1 , 1 from str
exit loop
print str
set num to 0
set chr to 0
set CHR to 0
s = string
read s
nC , iC , eC , tC , disC = integers with nC = 0 , iC = 0 , eC = 0 , tC = 0 , disC = 0
for c = 0 to s . length ( ) exclusive
if s [ c ] is n
increment nC
else if s [ c ] is i
increment iC
else if s [ c ] is e
increment eC
else if s [ c ] is t
increment tC
while nC > 0 and eC > 0 and iC > 0 and tC > 0
nC = nC - 3
decrement iC
eC = eC - 3
decrement tC
if nC > = 0 and eC > = 0 and iC > = 0 and tC > = 0 , increment disC
increment nC
print disC
n = integer
Read n
x , y = integers
Read x , y
set white to maximum value of n - x and n - y
set black to maximum value of x - 1 and y - 1
if black is greater than white
print Black and a new line
print White and a new line
a , b , l , r , ans , T = int
s = array of 200 char
vis = array of 27 bool
function dfs ( get char cp , return int )
count = 0
for i = 0 to a exclusive s [ i ] = ' a ' + i
for i = a to a + b exclusive s [ i ] = cp
fill vis with valse
for i = b to a + b exclusive vis [ s [ i ] - ' a ' ] = true
sta = a + b , ed = 0
while sta < 2 * a + b
while vis [ ed ] increment ed
s [ sta ] = ed + ' a '
increment sta and ed
for i = 2 * a + b to T exclusive s [ i ] = s [ i - 1 ]
fill vis with false
if l < = r
for i = l to r inclusive
if not vis [ s [ i ] - ' a ' ] increment count , vis [ s [ i ] - ' a ' ] = true
else
for i = 0 to r inclusive
if not vis [ s [ i ] - ' a ' ] increment count , vis [ s [ i ] - ' a ' ] = true
for i = l to T exclusive
if not vis [ s [ i ] - ' a ' ] increment count , vis [ s [ i ] - ' a ' ] = true
return count
read a , b , l , r
decrement l and r
if a < = b
ans = a + 1
else
ans = 2 * a - b
T = 2 * ( a + b )
if r - l > = T
do nothing
else
r = r modulo T , l = l modulo T
for i = 0 to a exclusive ans = min ( dfs ( ' a ' + i ) , ans )
print ans
N is a new constant integer variable = 505
str is a new array of characters with N elements
declare integer variables a , b , c and s
judge is a boolean function
i is a new integer variable with value 0
if a + b - c is equal to 2
increment c
if a ! = 1
decrement a by one
else if b ! = 1
decrement b
else if a + b - c = - 2
decrement c
increment a by one
if a + b = c
print " | " to the standard output a times
if i = a , print " + " to the standard output
print " | " b times
if i is equal to b , print " = "
print " | " to the stdout c times
print a new line
return true
return false
read new line into str in a loop
set s , a , b and c values to 0
declare new integer variable len with value = length of str
in a for loop , change i from 0 to len exclusive incrementing i
if str [ i ] = ' | '
if s is equal to 0
increment a by one
else if s = 1
increment b by one
else
increment c
else
increment s by one
if judge ( ) returned false , print " Impossible "
declare int n , m , s
declare double k
read n , m , k
declare string a
declare map myMap with string keys and int values
declare myMap iterator i
for i = 0 to n exclusive
read a , s
if s * k is less than 100
continue
else
set myMap [ a ] to s * k + 1e - 6
for i = 0 to m exclusive
read a
if myMap [ a ] equals 0 : set myMap [ a ] to 0
print length of myMap with newline
create integers n , k , x , cnt = 0 and integer array a of size 100
create integer sets s and t
read n and k
for i = 0 to n exclusive , read a [ i ]
for i = 0 to n exclusive
set x to a [ i ]
if x is at the end of set s
increment cnt
insert x into set s
if the size of set s if equal to k + 1
set t to s
erase x from set t
for j = i + 1 to n exclusive
if the size of set t is 1 , break loop
erase a [ j ] from set t
erase * ( t . begin ( ) ) from set s
print cnt
q , ok , c = long long with c = 1
read q
u = long long with u = q
for j = 2 to sqrt of q + 1 inclusive
if q is a multiple of j
loop while q is a multiple of j
set q to q / j
increment ok
if ok < = 2 set c to c * j
if ok is 2 break
if q > 1 increment ok
if ok < = 1 print " 1 " and " 0 "
if ok is 2 print " 2 "
if ok > = 3 print " 1 " and c
declare new integer n
read user input to n
if n is even , change n to n - ( 1 < < ( int ) log2 ( n ) ) - 1
print n / 2 to the standard output
let N be a constant integer with N = 1e5 + 5
let MXN be a constant long integer with MXN = 1e18
str = array of characters of length 1005
let n be a integer
read n
read str
if n is equal to 1 and str [ 0 ] is equal to 0
print No and newline
let cnt0 , cnt1 be integers with cnt0 = 0 , cnt1 = 0
let f be a boolean value with f = true
for i = 0 to n exclusive
if str [ i ] is equal to 0
cnt1 is equal to 0
increment cnt0 by 1
cnt0 is equal to 0
increment cnt1 by 1
if cnt0 > = 3 or cnt1 > = 2
f is equal to false
stop
if the condition is true
let cnt be a integer with cnt = 0
for i = 0 to n exclusive
if str [ i ] is equal to 1 , stop
increment cnt by 1
if cnt > = 2 , f is equal to false
cnt is equal to 0
for integer i is equal to n - 1 , i > = 0 , decrement i by 1
if str [ i ] is equal to 1 , stop
increment cnt by 1
if cnt > = 2 , f is equal to false
if f is true
print Yes and newline
print No and newline
print No and newline
assign - 1 to ind
create string s and ans
read s
for i = size of s to 0 inclusive
if s [ i ] = 0 , set ind to i
for i = 0 to size of s exclusive
if ind = - 1 and i = 0 or i = ind , continue
set ans to ans + s [ i ]
print ans
n = integer
read n
forbid = vector of string
for i = 0 to n exclusive
s = string
read s
s1 = string with s1 = " "
for j = 0 to s . size ( ) exclusive
a = character with a = s [ j ]
if ( a < = Z ) , a = a - A + a
s1 = s1 + a
append s1 to forbid
occur = vector integer array of size 100
s = string
read s
s1 = string with s1 = " "
for j = 0 to s . size ( ) exclusive
a = character with a = s [ j ]
if ( a < = Z ) , a = a - A + a
s1 = s1 + a
for i = 0 to n exclusive
copy = string with copy = s1
pre = integer with pre = 0
while ( copy . size ( ) > 0 and copy . find ( forbid [ i ] ) is not npos string )
append copy . find ( forbid [ i ] ) + pre to occur [ i ]
pre = pre + copy . find ( forbid [ i ] ) + 1
copy = copy . substr ( copy . find ( forbid [ i ] ) + 1 )
letter = character
read letter
first = bool array of size 100
important = integer array of size 100
set all contents of first to true
set all contents of important to 0
for i = 0 to n exclusive
for j = 0 to occur [ i ] . size ( ) exclusive
for k = 0 to occur [ i ] [ j ] + k < s . size ( ) and k < forbid [ i ] . size ( )
if ( first [ occur [ i ] [ j ] + k ] )
first [ occur [ i ] [ j ] + k ] = false
if ( s [ occur [ i ] [ j ] + k ] is letter )
important [ occur [ i ] [ j ] + k ] = 1
else if ( s [ occur [ i ] [ j ] + k ] is letter - a + A )
important [ occur [ i ] [ j ] + k ] = 2
if ( s [ occur [ i ] [ j ] + k ] < = Z )
s [ occur [ i ] [ j ] + k ] = letter - a + A
else
s [ occur [ i ] [ j ] + k ] = letter
for i = 0 to s . size ( ) exclusive
c1 = character with c1 = a
if ( letter is a ) , c1 = b
if ( important [ i ] is 1 )
s [ i ] = c1
else if ( important [ i ] is 2 )
s [ i ] = c1 - a + A
print s
define arrays of shorts X and Y with size 105
bin is a new array of shorts with size 15
create constant integer variable C with value 5
create a map from characters to integers called M
void function trans with int argument x
create new integer variable ind with value 0
set first 12 elements of bin to 0
while x > 0
change the value of bin [ ind ] to x modulo 2 and increment ind
change the value of s quared divided by 2
create new character called ch
define new integer n
read n from the user input
assign 0 to M [ ' R ' ]
assign 1 to M [ ' G ' ]
change the value of M [ ' B ' ] to 2
assign 3 to M [ ' Y ' ]
assign the new value = 4 to M [ ' W ' ]
for i = 0 to n exclusive
read standard input to ch
change the value of X [ i ] to M [ ch ]
read ch
assign the new value = ch - ' 1 ' to Y [ i ]
define integers ans and anst with ans = 20
declare boolean variable all
new boolean ones = true
if ones is false
for integer i = 1 to 1023 inclusive incrementing i
call trans of i
change the value of anst to 0
assign the new value = true to all
increment k in a loop from 0 to n - 1 exclusive
for integer l = k + 1 to n exclusive
if X [ k ] ! = X [ l ] and ( bin [ X [ k ] ] or bin [ X [ l ] ] = 1 )
change the value of all to true
change the value of all to true
else if X [ l ] = X [ k ] and Y [ l ] = Y [ k ]
assign true to all
else
assign false to all
if all is false , break
if all is false , break the loop
if all is true
for i = 0 to 12 exclusive
if bin [ i ] is equal to 1 , increment anst by one
change the value of ans to anst of ans > anst
else
print 0
if ones is false , print ans
create int vector vetor
create ints n , i , and colunas
read n
for i = 0 to n exclusive
read colunas
append colunas to vetor
for i = 0 to n - 1 exclusive , print vetor [ i ]
print vetor [ n - 1 ]
in function tri taking long long k and returning long long
return k * ( k + 1 ) / 2
n = long long
read n
flag = bool with flag = false
for i = 1 to sqrt of 2 * n inclusive
k = long long with k = n - tri of i
l = long long with l = i
r = long long with r = sqrt of n * 2
loop while l < = r
m = long long with m = ( l + r ) bitshift right by 1
if tri of m < k
set l to m + 1
else if tri of m > k
set r to m - 1
else
set flag to true
break
if flag break
if flag
print " YES "
else
print " NO "
let cycles be an integer
input cycles
a is a boolean array of sizes 100 and 100 with a = 0
point is an integer set to 1
i is an integer set to 0
while cycles is positive
if cycles is less than i
set i to 0
increment point
assign 1 to a [ i ] [ point ]
assign 1 to a [ point ] [ 1 ]
subtract i from cycles
increment i
if i is at least point and cycles is positive
set i to 0
increment point
display point + 1
for i = 0 to point inclusive
for j = 0 to point inclusive , display a [ i ] [ j ]
display newline
declare constant integer N = 100010
declare constant integer mod = 1e9 + 7
declare add with integers x , y as arguments , returning integer
declare integer res = ( x + y ) % mod
return res + mod if res is less than 0 , else res
declare mul with integers x , y as arguments , returning integer
declare integer res = ( x * 1LL * y ) % mod
return res + mod if res is less than 0 , else res
declare integers a , b , x
read a and b and x
declare boolean ok = 1
declare integer cur = - ( absolute value of a + absolute value of b ) + x
if cur is less than 0
let ok be 0
else
let ok be not ( cur bitwise and 1 )
print " Yes " if ok is true , else print " No "
aa , bb , flag = int with flag = 0
noop
a = char array of size 15
b = char array of size 15
month = int array of size 12 with values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31
read a
read b
if a is " monday "
set aa to 1
else if a is " tuesday "
set aa to 2
else if a is " wednesday "
set aa to 3
else if a is " thursday "
set aa to 4
else if a is " friday "
set aa to 5
else if a is " saturday "
set aa to 6
else if a is " sunday "
set aa to 7
if b is " monday "
set bb to 1
else if b is " tuesday "
set bb to 2
else if b is " wednesday "
set bb to 3
else if b is " thursday "
set bb to 4
else if b is " friday "
set bb to 5
else if b is " saturday "
set bb to 6
else if b is " sunday "
set bb to 0
for i = 0 to 12
if ( aa + month [ i ] ) mod 7 is bb
set flag to 1
break
if flag is 1
print " YES "
else
print " NO "
a = integer array of length 110
b = integer array of length 110
s = string
read one line into s
num , ten = integers with num value of 0 and ten value of 1
for i = size of s - 1 to 0 inclusive descending
if s [ i ] equals = then break
if s [ i ] is less than ' 9 ' and greater than ' 0 '
x = integer with value of s [ i ] - ' 0 '
increase num by x * ten
set ten to ten * 10
cnt = integer with value of 0
set a [ 0 ] to 1
for i = 0 to size of s exclusive
if s [ i ] equals ' + '
increase cnt by 1 and set a [ cnt ] to 1
else if s [ i ] equals ' - '
increase cnt by 1 and set a [ cnt ] to 0
x = integer with value of 0
for i = 0 to cnt inclusive
set b [ i ] to 1
if a [ i ]
increase x by b [ i ]
else
decrease x by b [ i ]
set x to num - x
for i = 0 to cnt inclusive
if x is less than 0
if a [ i ] equals 0 and b [ i ] is less than num
k = integer with value of the minimum of num - b [ i ] and negative x
increase b [ i ] by k
increase x by k
else if x is greater than 0
if a [ i ] equals 1 and b [ i ] is less than num
k = integer with value of the minimum of num - b [ i ] and x
increase b [ i ] by k
decrease x by b [ i ]
else
break
set x to 0
for i = 0 to count inclusive
if a [ i ]
increase x by b [ i ]
else
decrease x by b [ i ]
if x does not equal num
set cnt to 0
for i = 0 to size of s exclusive
print num
function gcd with int arguments x and y that returns integer
return x if y is 0 , or else gcd ( y , x % y )
create new constant long double eps = 1e - 8
create new long longs a and b
declare int variables t1 , t2 , x1 , x2 and t0
read variables t1 , t2 , x1 , x2 and t0 from the input
if t1 = t2
print x1 , ' ' and x2 to the standard output
if t0 is equal to t1
print x1 , ' ' and 0
if t0 is equal to t2
print 0 , ' ' and x2
declare integer variables y1 with value t2 - t0 and y2 = t0 - t1
declare integer g with value gcd ( y1 , y2 )
set y1 to y1 divided by g
change the value of y2 to y2 divided by g
start for loop from k = 1 to x2 inclusive incrementing k
create new long long variable l = ( k * y1 ) / y2
set value of l to min of l and x1
if a and b are both equal to 0
set a to l
change b to k
skip the rest of the loop
if l * b > = a * k
change the value of a to l
set b to k
print a , ' ' and b
declare constant integer P = 1e9 + 7
declare gcd with long longs a , b as arguments , returning long long
return b if result of run gcd ( b , a % b ) is true else a
declare qpow with long longs a , n as arguments , returning long long
declare long long r = 1 % P
for let a be a % P , n , let a be a * a % P , setting n to n bitshift right 1
if n bitwise and 1 , let r be r * a % P
return r from function
declare inv with long long x as argument , returning long long
returnn 1 if x is less than or equal to 1 else result of run inv ( P % x ) * ( P - P / x ) % P
declare constant integer N = 2e5 + 10
declare integer arrays a size N , b size N , f size N , integers n , m , k
declare long longs x1 , y1 , x2 , y2
read x1 , y1 , x2 y2
declare integer ans = 0
read n
for i = 1 to n inclusive
declare long longs a , b , c
read a , b , c
declare long long x = ( a * x1 + b * y1 + c )
declare long long y = ( a * x2 + b * y2 + c )
if x is greater than 0 and y is less than 0 or x is less than 0 and y is greater than 0 , increment ans
print ans and newline
make static int mod = 1e9 + 7
make int n , m , array row of size 105 , array col of size 105 , multidimensional array table of size 105x105 , minn , and flag
while read n and m
set flag to 0
set row elements to 0
set col elements to 0
for i = 1 to n inclusive
for j = 1 to m inclusive , read table [ i ] [ j ]
if m greater than or equal to n
for i = 1 to n inclusive
set minn to 0x3f3f3f3f
for j = 1 to m inclusive
if table [ i ] [ j ] less than minn , set minn to table [ i ] [ j ]
if minn
set row [ i ] to minn
for j = 1 to m inclusive , subtract minn from table [ i ] [ j ]
for j = 1 to m inclusive
set minn to 0x3f3f3f3f
for i = 1 to n inclusive
if table [ i ] [ j ] less than minn , set minn to table [ i ] j ]
if minn
set col [ j ] to minn
for i = 1 to n inclusive , subtract minn from table [ i ] [ j ]
else
for j = 1 to m inclusive
set minn to 0x3f3f3f3f
for i = 1 to n inclusive
if table [ i ] [ j ] less than minn , set minn to table [ i ] [ j ]
if minn
set col [ j ] to minn
for i = 1 to n inclusive , subtract minn from table [ i ] [ j ]
for i = 1 to n inclusive
set minn to 0x3f3f3f3f
for j = 1 to m inclusive
if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ]
if minn
set row [ i ] to minn
for j = 1 to m inclusive , decrease table [ i ] [ j ] by minn
set flag to 1
for i = 1 to n inclusive
for j = 1 to m inclusive
if table [ i ] [ j ]
set flag to 0
break
if flag
make int tmp = 0
for i = 1 to n inclusive , increase tmp by row [ i ]
for j = 1 to m inclusive , increase tmp by col [ j ]
for i = 1 to n inclusive
for k = 1 to row [ i ] inclusive , print " row " i
for j = 1 to m inclusive
for k = 1 to col [ j ] inclusive , print " col " j
else
print " - 1 \ n "
let x , t , a , b , Da , Db , total be integers with total = 0
initialize boolean value right to false
let aa , bb be integers
read x , t , a , b , Da , Db
aa is equal to 0
bb is equal to 0
for i = 0 to t inclusive
for i = 0 to t inclusive
total is equal to aa + bb
if total is equal to x
right is equal to true
stop
bb is equal to b - Db * ( i )
if right is true , stop
aa is equal to a - Da * ( i )
bb is equal to 0
if right is true
print YES and newline
print NO and new line
declare constant integer INF = 1e9 + 10
declare map from integer to character rep
declare integer arrays cnt size 3 , tp size 110
declare con with character ch as argument , returning integer
if ' a ' is less than or equal to ch and ch is less than or equal to ' z ' , return 0 from function
if ' A ' is less than or equal to ch and ch is less than or equal to ' Z ' , return 1 from function
return 2
let rep [ 1 ] be ' a '
let rep [ 2 ] be ' A '
let rep [ 4 ] be ' 1 '
declare integer Tst
read Tst
while decrement Tst is true
declare string s
read s
declare integer msk = 0
let cnt [ 0 ] be cnt [ 1 ] be cnt [ 2 ] be 0
for i = 0 to integer casted size of s exclusive
let tp [ i ] be result of run con ( s [ i ] )
let msk be msk bitwise or ( 1 bitshift left tp [ i ] )
increment cnt [ tp [ i ] ]
if msk is 7
print s , ' \ n '
else if result of run __builtin_popcount ( msk ) is 2
for i = 0 to integer casted size of s exclusive
if cnt [ tp [ i ] ] is greater than 1
let s [ i ] be rep [ 7 bitwise xor msk ]
end loop
print s , ' \ n '
else
declare integer M = 7 bitwise xor msk
declare integer t = result of run __builtin_ctz ( M )
let M be M bitwise xor ( 1 bitshift left t )
let s [ 0 ] be rep [ 1 bitshift left t ]
let s [ 1 ] be rep [ 1 bitshift left result of run __builtin_ctz ( M ) ]
print s , ' \ n '
oo , MN = const int with oo = 1e9 and MN = 100010
par , cnt = int array of size MN each
in function findSet taking an int and returning an int
return i if par [ i ] is i else set par [ i ] to findSet of par [ i ] and return it
in function unionSet taking two ints i and j
set par [ findSet of i ] to findSet of j
n = int
read n
k = long long
read k
a = long long vector of size n
for i = 0 to n set par [ i ] to i
for i = n - 1 to 0 inclusive decrementing i
p = int with p = lower_bounds of begin of a , end of a and a [ i ] * k - begin of a
if a [ p ] is a [ i ] * k then call unionSet on i and p
for i = 0 to n increment cnt [ findSet of i ]
ans = int with ans = 0
for i = 0 to n increment ans by ( cnt [ i ] + 1 ) /
constant integer variable maxn = 4 + 3
new array of integers a with size maxn
read input to a [ 1 ] and a [ 2 ]
declare integer d with value a [ 2 ] - a [ 1 ]
create double variable with name q = a [ 2 ] * 1 . 0 / a [ 1 ]
declare bools flag1 and flag2 = 1
in a for loop , change i from 3 to 4 inclusive incrementing i
read user input to a [ i ]
if flag1 is true and a [ i ] - a [ i - 1 ] ! = d , assign the new value = 0 to flag1
if flag2 is true and fabs ( a [ i ] * 1 . 0 / a [ i - 1 ] - q ) > 1e - 7 , change the value of flag2 to 0
if flag1 is true
print a [ 4 ] + d
else if flag2 is true and fabs ( a [ 4 ] * q - int ( a [ 4 ] * q + 0 . 5 ) < 1e - 7
print a [ 4 ] * q + 0 . 5 casted to integer and a new line
else
print 42
n = int
read n
while decremented value of n is not 0
f = 1
c = char
x1 , y1 , x2 , y2 = int
for i = 0 to 8 exclusive
for j = 0 to 8 exclusive
read c
if c is ' K ' and f
x1 = i
y1 = j
f = 0
else if c is ' K '
x2 = i
y2 = j
if ( x2 - x1 ) and ( y2 - y1 ) are multiple of 4
else
create doubles a , b , c , d and k
read user input to a , b , c and d
if a - b = b - c and b - c = c - d
print d + b - a
else
if b / a = c / b and c / b = d / c
assign d * ( b / a ) to k
if k = k casted to integer
print k to the standard output
else
print 42
else
print 42
long long function gcd1 with long long arguments a and b
return b if a = 0
return gcd1 of b modulo a and a
long long function modx with long long arguments base and ex
declare long long variables ans = 1LL and val = base
while ex > 0LL
if ex & 1LL is true , set ans to ( ans * val ) % 1000000009LL
assign ( val * val ) % 1000000009LL to val
change ex to ex > > 1LL
return ans
declare vector of strings variables hr and mn
declare int array used with size 8
void function calc with int arguments ind , pw and ty , long long argument last and num and string argument s
if ind is equal to 0
if num > last or s is empty , return
if ty is false
push s to hr
else
push s to mn
return
loop i from 0 to 7 exclusive
if used [ i ] is false
change used [ i ] to 1
invoke function calc with arguments ind - 1 , last , num + i * pw , pw * 7 , ty and s + ( char ) ( i + ' 0 ' )
set used [ i ] to 0
declare long long variables n and m
read from the input to n and m
decrement n
decrement m
declare integers cpy = n , cnt1 = 0 and cnt2 = 0
while cpy ! = 0
divide cpy by 7
increment cnt1 by one
set cnt1 to max of 1 and cnt1
set cpy to m
while cpy ! = 0
divide cpy by 7
increment cnt2 by one
set cnt2 to max of 1 and cnt2
if cnt1 + cnt2 is greater than 7
print " 0 "
call function calc with arguments cnt1 , n , 0 , 1 , 0 and " "
call function calc with arguments cnt2 , m , 0 , 1 , 1 and " "
create int ans = 0
for integer i = 0 to length of hr exclusive
set sizeof ( used ) bytes at the pointer used to 0
declare integer l
for l from 0 to length of hr [ i ] exclusive , change used [ hr [ i ] [ l ] - ' 0 ' ] to 1
for j from 0 to length of mn exclusive
for l from 0 to length of mn [ j ] exclusive
if used [ mn [ j ] [ l ] - ' 0 ' ] ! = 0 , break
if l is equal to length of mn [ j ] , increment ans by one
print ans
create new sets of unique integers s1 and s2
create integer set iterator it
create a map from integers to integers with name mp
n , i , j , x , a , m , ans , p and ne are integer variables with ans , p and ne = 0
read from the input to n
for i = 0 to n exclusive incrementing i
read x and a
if x is greater than 0
insert x into s1
increase p by a
else
insert x into set s2
add a to ne
change mp [ x ] to a
set m to the length of s2 if length of s1 > length of s2 , or length of s1 otherwise
if length of s1 = length of s2
print p + ne to the standard output
else if length of s1 is greater than length of s2
set it to the start of s1
assign 0 to i
while i < = m
change ans to sum of ans and mp [ * it ]
increment i
increment it
print ans + ne
else
set it to the end of s2
decrement it
assign 0 to i
while i < = m
add mp [ * it ] to ans
increment i
decrement it
print ans + p
create new constant integer called maxn = 1100
declare new constant integer called inf with value 0x3f3f3f3f
create new array of characters a with maxn elements
declare new integer variable n
read input to n
for i from 1 to n inclusive , read a [ i ] from the input
if n = 1 and a [ 1 ] is equal to ' 0 '
print " No "
if a [ 1 ] is equal to ' 0 ' and a [ 2 ] is equal to ' 0 '
print " No " to the standard output
if a [ n ] and a [ n - 1 ] are both ' 0 '
print " No " to the standard output
in a for loop , change i from 1 to n inclusive
if a [ i ] and a [ i + 1 ] are both equal to ' 1 '
print " No " to the standard output
if a [ i ] = a [ i + 1 ] and a [ i ] = a [ i - 1 ]
print " No "
print " Yes "
let x , y be strings , s = array of strings of length 15
s [ 1 ] is equal to monday
s [ 2 ] is equal to tuesday
s [ 3 ] is equal to wednesday
s [ 4 ] is equal to thursday
s [ 5 ] is equal to friday
s [ 6 ] is equal to saturday
s [ 7 ] is equal to sunday
read x , y
let num1 , num2 be integers with num1 = 0 , num2 = 0
for integer i = 1 to 7 inclusive
if x is equal to s [ i ] , num1 is equal to i
for integer i = 1 to 7 inclusive
if y is equal to s [ i ] , num2 is equal to i
if num2 is less than num1 , increment num2 by 7
the integer value of sum = num2 - num1
if sum equals 0 or sum equals 2 or sum equals 3
print YES and newline
print NO and newline
f , g = unsigned long long array of size 19 each
in function get_f
set f [ 1 ] and f [ 2 ] to 9
for i = 3 to 18 inclusive set f [ i ] to f [ i - 1 ] * 10
in fun
set g [ 0 ] to 1
for i = 1 to 18 inclusive set g [ i ] to g [ i - 1 ] * 10
in function cal taking a string n and returning an unsigned long long
len = int with len = length of n
if len is 1 then return n [ 0 ] - ' 0 '
first = int with first = n [ 0 ] - ' 0 '
last = int with last = n [ len - 1 ] - ' 0 '
ret = unsigned long long with ret = 0
for i = 1 to len increment ret by f [ i ]
for i = 1 to first increment ret by g [ len - 2 ]
s = string with s = n without the first and last char
p = unsigned long long with p = 1 + ( 1 if length of s is 0 else the parsed long long value of s )
if first is less or equal to last
increment ret by p
else
increment ret by p - 1
return ret
call get_f
call get_g
l , r = string
read l then r
ret = unsigned long long with ret = cal of r - cal of l
if l [ 0 ] is l [ length of l - 1 ] then increment ret
print ret
N , M = int
nxt , cap = array of 1001 int
idgr , odgr = array of 1001 bool
read N , M
for i = 1 to M inclusive
a , b , c = int
read a , b , c
odgr [ a ] = 1
idgr [ b ] = 1
nxt [ a ] = b
cap [ a ] = c
cnt = 0
for i = 1 to N inclusive
if not idgr [ i ] and odgr [ i ] increment cnt
print cnt
for i = 1 to N inclusive
if not idgr [ i ] and odgr [ i ]
d = INT_MAX
n = i
while odgr [ n ]
d = min ( d , cap [ n ] )
n = nxt [ n ]
print i , space , n , space , d
declare new array of integers open with size 100005
create integer variable n
define new integer called cnt with value 0
read from the input to n
define integer arrays a , b and c with size 100005
read n elements into variables a and b
for i = 0 to n exclusive
in a for loop , increment j from 0 to n exclusive
if b [ i ] = a [ j ] and i ! = j , set c [ j ] to 1
for integer i = 0 to n exclusive incrementing i
if c [ i ] is equal to 0 , increment cnt
print cnt
declare ints n and m
create double k
create a map from strings to integers called mm
read from the input to n , m and k
declare string name
declare int level
for i = 0 to n exclusive
read input to name and level
if level * k + 1e - 4 > = 100 , set mm [ name ] to level * k + 1e - 4
loop i from 0 to m exclusive
read name
if mm is not empty , set mm [ name ] to 0
print length of mm
in function has taking char c returning int
return c - ' a '
n = int
read n
freq = int array of size 26
set all values of freq to 0
str = string
read str
flag = int with flag = 0
for i = 0 to n
index = int with index = has of str [ i ]
increment freq [ index ]
if freq [ index ] > = 2 or n is 1
set flag to 1
break
else
set flag to 0
if flag is 0
print " No "
print newline
else
print " Yes "
print newline
N = 1e5
create long long n , s , x , y , mx and c , set mx to - 1
create vector long long v
read n and s
for i = 0 to n exclusive
read x and y
if x = s and y = 0
if 0 > mx , set mx to 0
else if x < s
if y = 0
if 0 > mx , assign 0 to mx
else
set c to 100 - y
if c > mx , set mx = c
print mx
print a newline
let n , m , i be integers
while read n , m
a = array of integers of length n
let c , b be integers with c = 0 , b = 0
for i = 0 to n exclusive
read a [ i ]
if ( a [ i ] - 1 ) / m > = c
c is equal to ( a [ i ] - 1 ) / m
b is equal to i
print b + 1 and newline
declare integer n
read n
declare integer vector v initialized with n
for i = 0 to n exclusive , read v [ i ]
declare long long integer dp [ n ] [ 2 ]
for i = 0 to n exclusive
for j = 0 to 2 exclusive , let dp [ i ] [ j ] be 0
declare long long integer val = absolute value of ( v [ 1 ] - v [ 0 ] )
let dp [ 0 ] [ 0 ] be val
declare long long integer gmax = val
for i = 1 to n exclusive
declare long long integer val = absolute value of ( v [ i ] - v [ i - 1 ] )
let dp [ i ] [ 0 ] be maximum of dp [ i ] [ 0 ] and dp [ i - 1 ] [ 1 ] + val
let dp [ i ] [ 1 ] be maximum of dp [ i ] [ 0 ] and dp [ i - 1 ] [ 0 ] - val
let gmax be maximum of gmax and dp [ i ] [ 0 ]
let gmax be maximum of gmax and dp [ i ] [ 1 ]
print gmax and newline
s = string
read s
n = int with n = size of s
if s does not contain ' 0 '
erase first char from s
print s
for i = 0 to n
if s [ i ] is ' 0 '
erase char at position i from s
break
print s
make int arrays a of size 1000 and b of size 1000
create char C of size 1000
declare B taking in integer x and returning integer
create int ans = 0
for i = 0 to 10 exclusive
if ( 1 < < i ) & x is truthy , increment ans
return ans
create integer n
read n
for i = 0 to n exclusive
read C [ i ] and a [ i ]
decrease a [ i ] by 1
if C [ i ] is equal to ' R ' , set b [ i ] to 0
if C [ i ] is equal to ' Y ' , set b [ i ] to 1
if C [ i ] is equal to ' W ' , set b [ i ] to 2
if C [ i ] is equal to ' G ' , set b [ i ] to 3
if C [ i ] is equal to ' B ' , set b [ i ] to 4
make integer ans = n + 1
for i = 0 to 32 exclusive
for j = 0 to 32 exclusive
make int arrays f of size 5 and g of size 5
for k = 0 to 5 exclusive
if ( 1 < < k ) & 1 is truthy
set f [ k ] to 1
else do
set f [ k ] to 0
for k = 0 to 5 exclusive
if ( 1 < < k ) & j is truthy
set g [ k ] to 1
otherwise
set g [ k ] to 0
create integer f1 = 1
for i = 0 to n exclusive
for j = i + 1 to n exclusive
if a [ i ] is equal to a [ j ] and b [ i ] is equal to b [ i ] , continue loop
if a [ i ] is equal to a [ j ] and g [ b [ i ] ] | g [ b [ j ] ] is truthy , continue to next loop iteration
if b [ i ] is equal to b [ j ] and f [ a [ i ] ] | f [ a [ j ] ] is truthy , continue loop
set f1 to 0
if f1 is truthy , set ans to min of ans and B ( i ) + B ( j )
show ans
declare constant integer MaxN = 1E5 + 10
create array of integers a with size MaxN
create int n
read n
read n values into array a
let ans = 0 be a long long
for i = 0 to i = n - 1 exclusive
declare integer lg = log2 ( n - i - 1 )
set ans to ans + a [ i ]
a [ i + ( 1 < < lg ) ] = a [ i + ( 1 < < lg ) ] + a [ i ]
print ans
create string a
create long long tou = - 1 , wei = - 1 , mk
read a
for s = 0 to a size exclusive
if a [ s ] is not ' a '
if tou is - 1 then set tou to s
set mk to 1
else
if tou is not - 1
set wei to s - 1
break
if wei is - 1 and mk is 1 then set wei to a size - 1
if mk is 0
set a [ a size - 1 ] to ' z '
else
print a
create long long integer n
read n
make long long integers ans = 0
make long long int b = 0
let long long array a of size n
let long long sum = 0
for i = 0 to n exclusive , read a [ i ]
if a [ 0 ] is equal to 50 or a [ 0 ] is equal to 100 , print " NO " and return 0
for i = 0 to n exclusive
if a [ i ] is equal to 25
increment ans
else do
if a [ i ] is equal to 50
if ans is greater than or equal to 1
subtract 1 from ans
add 1 to sum
else do
print " NO " and return 0
otherwise
if ans is greater than or equal to 1 and sum is greater than or equal to 1
subtract 1 from ans
subtract 1 from sum
else if ans is greater than or equal to 3
set ans to ans - 3
else do
print " NO " and return 0
display " YES " and return 0
s , s1 , s2 , s3 , s4 = char array of size 20000 each
i , j , k , l1 , l2 , c = int and ans = int array of size 20000
for i = 0 to 2005 set ans [ i ] to 0
call gets of s
call gets of s4
set l1 to strlen of s4
for i = 0 to l1 set s1 [ i ] to ' '
append s to s1
set l2 to strlen of s1
for i = l2 to l1 + l2 - 1 set s1 [ i ] to ' 0 '
set c to l1
for i = 1 to l2
for k = i to i + c set s2 [ k - i ] to s1 [ k ]
for j = 0 to c
if s4 [ j ] is s2 [ j ] increment ans [ i ]
sort ans from position 0 to l2 + 1
print l1 - ans [ i ]
define new ints n , l and a
read variables n , l and a from the input
declare new integer called st = 0
create integer ans = 0
start for loop from i = 0 to n exclusive
declare new integers f and t
read user input to f and t
increase ans by ( f - st ) / a
change the value of st to f + t
add ( l - st ) / a to ans
print ans and ' \ n '
create map of strings to integers M
create 2d array of booleans like with size 7 by 7
declare strings s1 , s2 and temp
create integer n and integer array g with size 3
create an array of integers team with size 3
create an array of integers heros with size 7
create integer b1 = INT_MAX and b2 = - 1
void function back_track with int argument a
declare integers i and j
if a is equal to 7
declare an array of integers count with elements 0 , 0 , 0
create ints mx = - and mn = INT_MAX
for i = 0 to 7 exclusive increment count [ heros [ i ] ]
if count [ 0 ] , count [ 1 ] or count [ 2 ] = 0 , return
for i from 0 to 7 exclusive
declare integer temp = g [ heros [ i ] ] / count [ heros [ i ] ]
change mx to max of mx and temp
change mn to min of mn and temp
if mx - mn is greater than b1 , return
create int likeNum = 0
loop i from 0 to 7 exclusive
loop j from 0 to 7 exclusive
if heros [ i ] = heros [ j ] and like [ i ] [ j ] ! = 0 , increment likeNum by one
if mx - mn < b1 or mx - mn = b1and likeNum > b2
set b1 to mx - mn
set b2 to likeNum
return
loop i from 0 to 3 exclusive
change heros [ a ] to i
call back_track ( a + 1 )
assign 0 to M [ " Anka " ]
assign 1 to M [ " Chapay " ]
assign 2 to M [ " Cleo " ]
assign 3 to M [ " Troll " ]
assign 4 to M [ " Dracul " ]
assign 5 to M [ " Snowy " ]
assign 6 to M [ " Hexadecimal " ]
loop i from 0 to 7 exclusive
loop j from 0 to 7 exclusive , change like [ i ] [ j ] to false
read n
while n ! = 0 , decrement it and continue the loop
read input to s1 , temp and s2
set value of like [ M [ s1 ] ] [ M [ s2 ] ] to true
read g [ 0 ] , g [ 1 ] and g [ 2 ]
call back_track ( 0 )
print b1 , ' ' and b2
create integers h1 , h2 , a1 , a2 , d1 , d2
create integers m1 , m2 , m3
read h1 read a1 read d1
read h2 read a2 read d2
read m1 read m2 read m3
create integer ans with ans = 1e9 + 7
for i = 0 to 205 inclusive
for j = 0 to 105 inclusive
create integer t
if a1 + i is greater than d2
set t to h2 / ( a1 + i - d2 ) + ( 0 if h2 % ( a1 + i - d2 ) is 0 , else 1 )
create integer hp with hp = ( a2 - d1 - j ) * t
if hp is greater than or equal to h1
set ans to minimum of ans and ( hp - h1 + 1 ) * m1 + i * m2 + j * m3
else
set ans to minimum of ans and j * m3 + i * m2
print ans print newline
declare n , i as integers
declare a size 100 as integer array
read n
for i = 0 to n exclusive , read a [ i ]
sort from a to a + n
for i = 0 to n exclusive , print a [ i ] , " \ n " if i is n - 1 , else " "
g , l = vector long long array of size 105
vis = vector of bool with vis on 105 and false
in the function dfs that takes long long n
vis [ n ] = true
for i = 0 to g [ n ] . size ( ) exclusive
if not vis [ g [ n ] [ i ] ] , dfs ( g [ n ] [ i ] )
return
n , m , ans , nz = long long with ans = 0 , nz = 0
read n , m
for i = 1 to n + 1 exclusive
nl = long long
read nl
if nl is 0 , increment nz
for j = 0 to nl exclusive
lang = long long
read lang
append i in l [ lang ]
for i = 1 to m
if l [ i ] . size ( ) is 0 , continue next iteration
for j = 0 to l [ i ] . size ( ) exclusive
for k = j + 1 to l [ i ] . size ( ) exclusive
append l [ i ] [ k ] in g [ l [ i ] [ j ] ]
append l [ i ] [ j ] in g [ l [ i ] [ k ] ]
for i = 1 to n
if not vis [ i ]
increment ans
dfs on i
if nz is n
print n
else
print ans - 1
let x , t , a , b , da , db be integers
read x , t , a , b , da , db
if x is equal to 0
print YES and newline
let k , z be integers
for integer i = a , z = 0 , z is less than t , decrement i by da , increment z by 1
for integer j = b , k = 0 , k is less than t , decrement j by db , increment k by 1
if i is equal to x or j is equal to x or i + j is equal to x
print YES and newline
print NO and endline
declare integers n , o
declare string s
read n , s
if s is " 0 "
print 0 , newline
for i = 0 to n exclusive
if s [ i ] is ' 1 ' , increment o
print 1
for i = o to n exclusive , print 0
print newline
let n be a integer , x = array of integers of length 111111
let check be a function that returns boolean values
for i = 1 to n inclusive
if x [ x [ i ] ] is not equal to n - i + 1 , return 0
return 1
read n
x [ 1 ] is equal to 2
the integer value of u = 1
if n modulo 4 is equal to 0
for i = 1 to n / 4 inclusive
x [ i + i - 1 ] is equal to i * 2
x [ n - i - i + 1 ] is equal to i * 2 - 1
x [ i + i ] is equal to n + 1 - x [ n - i - i + 1 ]
x [ n - i - i + 2 ] is equal to n + 1 - x [ i + i - 1 ]
for i = 1 to n exclusive , print x [ i ] and ' '
print x [ n ] and newline
else if n modulo 4 is equal to 1
for i = 1 to n / 4 inclusive
x [ i + i - 1 ] is equal to i * 2
x [ n - i - i + 1 ] is equal to i * 2 - 1
x [ i + i ] is equal to n + 1 - x [ n - i - i + 1 ]
x [ n - i - i + 2 ] is equal to n + 1 - x [ i + i - 1 ]
x [ n / 2 + 1 ] is equal to n / 2 + 1
for i = 1 to n exclusive , print x [ i ] and ' '
print x [ n ] and newline
print - 1 and newline
mod = 1e9 + 7 = const long long
s , t = char array of length 5050
dp = int 5050x5050 int matrix
ans = long long
read ( s + 1 )
read ( t + 1 )
lens = int = length of ( s + 1 )
lent = length of ( t + 1 ) = int
for i = 1 to lens inclusive
for j = 1 to j inclusive
set dp [ i ] [ j ] to ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) % mod
for i = 1 to lens inclusive then set ans to ( ans + dp [ i ] [ lent ] ) % mod
print ans
make integer array a of size 100005
make integer n
read n
if n mod 4 is greater than or equal to 2 , return puts ( " - 1 " ) , 0
for int i = 1 ; i is less than or equal to n / 2 ; add 2 to i
set a [ i ] to i + 1
set a [ i + 1 ] to n - i + 1
set a [ n - i + 1 ] to n - i
set a [ n - i ] to i
if n is odd , set a [ n / 2 + 1 ] to n / 2 + 1
for i = 1 to n inclusive , print a [ i ] " \ n " [ i = = n ]
parrent = integer array of size 105
vis = bool array of size 105
in the function FindParrent that takes integer node and returns integer
if node is parrent [ node ] , return node
return parrent [ node ] = FindParrent ( parrent [ node ] )
in the function Union that takes integer x , y
x = FindParrent on x
y = FindParrent on y
if x is not y , parrent [ x ] = y
return
n , m , u , v , x , y = integer
read n , m
for i = 1 to m , parrent [ i ] = i
cnt = integer with cnt = 0
for i = 1 to n
read x
v = - 1
if x is 0 , increment cnt
while decrement x
read u
vis [ u ] = 1
call Union on u and if v is - 1 , u else v
v = u
st = set of integer
for i = 1 to m
if vis [ i ]
u = FindParrent ( i )
insert ( u ) in st
sz = integer with sz = st . size ( ) - 1
sz = if sz < 0 , 0 else sz
print cnt + sz
declare constant integers MAX = 12e5 + 100
declare integer arrays a size MAX , sushu size MAX , huiwen size MAX
declare init with no arguments , returning void
let a [ 1 ] be 1
let a [ 0 ] be 1
for i = 2 to 10000 inclusive
if not a [ i ]
for j = i to i * j is less than MAX , incrementing j , let a [ i * j ] be 1
declare panduan with integer x as argument , returning integer
declare integer w = x
declare integer y = 0
while w is not 0
let y be y * 10 + w % 10
let w be w / 10
if y is x
return 1
else
run init
for i = 1 to MAX exclusive
if a [ i ] is true
let sushu [ i ] be sushu [ i - 1 ]
else
let sushu [ i ] be sushu [ i - 1 ] + 1
if result of run panduan with i as argument is true
let huiwen [ i ] be huiwen [ i - 1 ] + 1
else
let huiwen [ i ] be huiwen [ i - 1 ]
declre integers p , q
read p and q
for i = MAX - 1 to 0 inclusive , decrementing i
if sushu [ i ] * q is less than or equal to huiwen [ i ] * p
if i is 0
print " Palindromic tree is better than splay tree " and newline
else
print i and newline
declare character array a size 55 by 55
declare integer array is size 55 by 55
declare integers n , m
declare integer arrays dx size 4 = { - 1 , 1 , 0 , 0 } , dy size 4 = { 0 , 0 , - 1 , 1 }
declare inline work with integers x , y as arguments , returning void
if is [ x ] [ y ] is 1 , return from function
if a [ x ] [ y ] is not ' # ' , return from function
let is [ x ] [ y ] be 1
declare integer i
for i = 0 to 4 exclusive , run work with x + dx [ i ] , y + dy [ i ] as arguments
declare inline check with integers x , y as arguments , returning boolean
let a [ x ] [ y ] be ' . '
declare integer kk = 0
set bytes from is to size of is to value 0
for i = 1 to n inclusive
for j = 1 to m inclusive
if a [ i ] [ j ] is ' # ' and is [ i ] [ j ] is 0
increment kk
run work ( i , j )
let a [ x ] [ y ] be ' # '
return kk is greater than 1
read n , m
declare integer kk = 0
for i = 1 to n inclusive
for j = 1 to m inclusive
read a [ i ] [ j ]
if a [ i ] [ j ] is ' # ' , increment kk
if kk is less than 3
print - 1 and newline
declare integer ans = 2
for i = 0 to n inclusive
for j = 1 to m inclusive
if a [ i ] [ j ] is ' # '
if result of run check ( i , j ) is true , let ans be 1
print ans and newline
declare 2d integer array arr with size 4 by 4
for i = 0 to 4 exclusive incrementing i
for j from 0 to 4 exclusive read arr [ i ] [ j ]
create int f = 0
for integer i = 0 to 4 exclusive
if arr [ i ] [ 3 ] is 1
if arr [ i ] [ 0 ] , arr [ i ] [ 1 ] or arr [ i ] [ 2 ] is 1 , set f to 1
if arr [ ( i + 1 ) % 4 ] [ 0 ] = 1 , set f to 1
if arr [ ( i + 2 ) % 4 ] [ 1 ] = 1 , set f to 1
if arr [ ( i + 3 ) % 4 ] [ 2 ] = 1 , set f to 1
if f is 1
print " YES "
else
print " NO "
print undefined
declare integer array a with size 101 and b with size 100
declare int variable n
read n and keep looping
declare int count = 0
for i from 1 to n inclusive
read input to a [ i ]
if a [ i ] is less than 0 , increment count
if count < = 2
print 1 , new line and n
go to the start of the loop
if count is odd
print count / 2 + 1
else
print count / 2
declare integer variable t = 0
create int x = 1
declare integer sum = 0
loop i from 1 to n inclusive
if t = 2 and a [ i ] < 0
print i - x and " "
add i - x to sum
assign i to x
change t to 0
decrease count by 2
if a [ i ] is less than 0 , increment t
if sum is less than n , print n - sum
print new line
create int n
read n
create int a [ n ] , maxind , minind , max , min , set max to 0 and min to 10000
for i = 0 to n exclusive
read a [ i ]
if a [ i ] > max
set max to a [ i ]
assign i to maxing
if a [ i ] < = min
min = a [ i ]
minind = i
if maxind > minind
print ( abs of minind - ( n - 1 ) + abs of maxind - 0 ) - 1 and a newline
else
print abs ( minind - ( n - 1 ) ) + abs ( maxind - 0 ) and a newline
n , m = integer
cnt1 , cnt2 = integer
read n , m
ans = integer = 0
tmp = integer = n = 1
while tmp returns true , increase cnt1 by 1 , tmp = tmp / 7
tmp = m - 1
while tmp returns true , increase cnt2 by 1 , tmp = tmp / 7
if n is 1 then increase cnt1 by 1
if m is 1 then increase cnt2 by 1
for i = 0 to n exclusive
s = integert array of size 15 , tot1 = integer = 0
tmp = i
for k - 1 to cnt1 inclusive , s [ k ] tmp modulo 7 , tmp = tmp / 7
if cnt > 7 then exit the for loop
for j = 0 to m exclusive
tmp = j
if cnt2 + cnt1 > 7 exit the for loop
d = integer array of size 10
set all the values of d to 0
for k = 1 to cnt2 inclusive , d [ tmp modulo 7 ] , tmp = tmp / 7
for k = 1 to cnt1 inclusive , increase the value of d [ s [ k ] ] by 1
for k = 0 to 6 inclusive
if d [ k ] > 1
decrease ans by 1
exit the for loop
increase ans by 1
print ans
x , y , ans = 0
read x then y
p = int
set p to max of absolute of x and absolute of y
if x is p and x is greater than 0 and x + y is greater than 1
decrement p then set ans to p
set ans to ans * 4
increment ans
else if y is p and y is greater than 0 and y - x is greater than 0
set ans to p
set ans to ans * 4
decrement ans by 2
else if x is - 1 * p and x is less than 0 and x + y is less than 0
set ans to p
set ans to ans * 4
decrement ans
else
if x + y is 1
decrement x
set ans to x
set ans to ans * 4
else
set ans to p
set ans to ans * 4
if x and y are both 0 set ans to 0
set ans to max of ans and 0
let choose be a function that accepts integers n , k and returns a long integer value
let ans be a long integer with ans = 1
if n is less than k , return 0
for i = n - k + 1 to n inclusive , ans = ans * i
if k is equal to 3
assert ( ans modulo 6 is equal to 0 )
ans is equal to ans / 6
assert ( ans modulo 2 is equal to 0 )
ans is equal to ans / 2
return the value of ans
let n , d , tmp , l be integers with l = 0
let ans be a long integer with ans is equal to 0
read n , d
points = array of integers of length n
for i = 0 to n exclusive
read tmp
points [ i ] is equal to tmp
while absolute value of ( tmp - points [ l ] ) is greater than d , increment l by 1
if ans is equal to 0
increment ans by choose ( i + 1 - l , 3 )
increment ans by choose ( i - l , 2 )
print ans and newline
declare array of integer vectors grafo with size 150150
declare ints n and m
create int array grau with 150150 elements
create int array visitado with 150150 elements
create int array grauCor with 150150 elements
dfs is a int function with int arguments v and cor
return 0 if visitado [ v ] = cor
change visitado [ v ] to cor
declare integer variable sum = 1
for i from 0 to size of grafo [ v ] exclusive incrementing i
create int u = grafo [ v ] [ i ]
add dfs of u and cor to sum
return sum
read n and m
declare integer variable i
declare int variables u and v
loop i from 1 to m inclusive incrementing i
read from the input to u and v
push v into grafo [ u ]
push u into grafo [ v ]
increment grau [ u ] by one
increment grau [ v ] by one
declare integer variable cor = 1
for i from 1 to n inclusive
if visitado [ i ] is 0
change grauCor [ cor ] to dfs of i and cor
increment cor
declare int ok = 1
loop i from 1 to n inclusive
if grau [ i ] ! = grauCor [ visitado [ i ] ] - 1 , change ok to 0
if ok is true
print " YES "
else
print " NO "
let a , b long longs
let in a string
read a , b , and in
let x , y long longs both with value 0
let len a long long with value length of in
let zx , zy long longs both with value 0
for long long i = 0 to len exclusive
if zx is a and zy is b
if in [ i ] is U , increment zy
if in [ i ] is D , decrement zy
if in [ i ] is L , decrement zx
if in [ i ] is R , increment zx
if zx and zy are 0
for i = 0 to len exclusive
if in [ i ] is U , increment y
if in [ i ] is D , decrement y
if in [ i ] is L , decrement x
if in [ i ] is R , increment x
let chax , chay long longs with chax = a - x and chay = b - y
if zx is 0
if chay mod zy is 0 and zx is chax
if chay / zy is at least 0
otherwise , if zy is 0
if chax mod zx is 0 and zy equals chay
if chax / zx is at least 0
otherwise if chax mod zx is 0 and chay mod zy is 0
if chax / zx = chay / zy and chax / zx is at least 0 and chay / zy is at least 0
let s = string
let n = integer
while ( read n ) is true do the following
read s
let cnt = integer with value = 0
for integer i = 0 to length of s exclusive do the following
if character of s at string position i is <
increment cnt
else
exit the loop
for integer i = length of s - 1 to 0 inclusive decrementing do the following
if character of s at string position i is <
increment cnt
else
exit the loop
print cnt
n , l , m , ans are integers with ans = 0
read n , l , m
a , b , c , d are integers with a and b both set to 0
if n
read a , b
add a / m to ans
for i = 1 to n exclusive
read c , d
add ( c + ( a + b ) ) / m to ans
assign c to a , assign d to b
add ( l - ( a + b ) ) / m to ans
output ans
declare boolean variable kontol = true
create string S
declare ints Q , W , E and R
declare integer variables H and U
read S
assign index of " BA " in S to Q
assign last index of " AB " in S to W
assign last index of " BA " in S to E
assign index of " AB " in S to R
if Q = - 1 or W = - 1 , set kontol to false
if abs ( Q - W ) = 1 , set H to 1
if abs ( E - R ) = 1 , set U to 1
if H = 1 and U = 1 , assign false to kontol
if kontol is true
print " YES "
else
print " NO "
function diff ( get int a and c , return int )
if a is 0 and c is 1
else if a is 1 and c is 0
else if a is 0 and c is 2
else if a is 1 and c is 2
else if a is 2 and c is 0
else if a is 2 and c is 1
else if a is 0 and c is 0
return 1
else if a is 1 and c is 1
return 1
else if a is 2 and c is 2
return 1
else
return 3
function valueArr ( get char a , return int )
if a is ' C '
else if a is ' M '
return 1
else if a is ' Y '
return 2
else if a is ' ? '
return 3
int n
read n
arr = array of n int
temp = char
read temp
arr [ 0 ] = valueArr ( temp )
for i = 1 to n exclusive
read temp
arr [ i ] = valueArr ( temp )
if arr [ i ] = = arr [ i - 1 ] and arr [ i ] not equal 3
print " No "
numWays = 1 , temp1 = int
if arr [ 0 ] is 3 or arr [ n - 1 ] is 3
print " Yes "
else if n is 1
if arr [ 0 ] is 3
print " Yes "
else
print " No "
else if n is 2
if arr [ 1 ] is 3
print " Yes "
else
print " No "
else
for i = 1 to n - 1 exclusive
if arr [ i ] is 3
temp1 = diff ( arr [ i - 1 ] , arr [ i + 1 ] )
add temp1 to numWays
if temp1 is 3 or 1 break
if numWays > 1
print " Yes "
else
print " No "
x , y = integers
s2 = character
s1 = string
read s1
iss = istringstream with call iss with s1
iss x , s2 , y
for i = 0 to ( x * 59 ) + 59
increment y
if y is ( x modulo 10 * 10 ) + ( x / 10 ) and y is not 60
if x < 10 and y < 10
print 0 , x , s2 , y , 0
new line
else if x < 10
print 0 , x , s2 , y
else if y < 10
print x , s2 , 0 , y
else
print x , s2 , y
else if y > = 59 and x is 23
y = - 1
x = 0
else if y > = 59
y = - 1
increment x
else if x is 23 and y > 32
x = 0
y = - 1
s = string
read s
started , ended are integers both set to 0
for i = 0 to size of s exclusive
if s [ i ] isn ' t the character a and ended is false
set started to 1
decrement s [ i ]
else if started
set ended to 1
if started is false , assign the character z to s [ ( size of s ) - 1 ]
output s
ar = int array of size 10000
b = int array of size 10000
in function inssort taking int array ar , int n
i , k , j , km = int
for i = 1 to n
set k to ar [ i ]
set km to b [ i ]
set j to i - 1
loop while j > = 0 and ar [ j ] > k
set ar [ j + 1 ] tp ar [ j ]
set b [ j + 1 ] to b [ j ]
set j to j - 1
set ar [ j + 1 ] to k
set b [ j + 1 ] to km
s , n , num = int with num = 0
read s then n
increment sum by s
i = int with i = 0
for i = 0 to n read ar [ i ] then b [ i ]
call inssort on ar , n
for i = 0 to n
if sum > ar [ i ]
increment sum by b [ i ]
else
print " NO "
print " YES "
create constant integer INF with INF = 1 bitshift left 29
create integer arrays l , s , r , p , with l size 4 , s size 4 , r size 4 , p size 4
for i = 0 to 4 exclusive , read l [ i ] read s [ i ] read r [ i ] read p [ i ]
for i = 0 to 4 exclusive
if p [ i ] is true
if l [ ( i + 1 ) % 4 ] or r [ ( i + 3 ) % 4 ] or s [ ( i + 2 ) % 4 ]
print " YES \ n "
if l [ i ] or r [ i ] or s [ i ]
print " YES \ n "
print " NO \ n "
create integer n
read n
print n print newline
end statement
for i = 1 to n exclusive , print 1 print " "
print 1 print newline
let n , k , x , cnt , a be integers with cnt = 0 , a = array of integers of length 100
create empty set of integers s , create empty set of integers t
read n and k
for i = 0 to n exclusive , read a [ i ]
for i = 0 to n exclusive
the value of x is equal to a [ i ]
if s . find ( x ) is equal to s . end ( )
increment cnt by 1
insert x into s
if size of s is equal to k + 1
the value of t is equal to s
erase x from t
for j = i + 1 to n exclusive
if size of t is equal to 1 , stop
erase a [ j ] from t
s . erase ( * ( t . begin ( ) ) )
print cnt and newline
maxn = const int = 200010
MAXM = const int = 500000
let in be an int priority queue array of length maxn
in int function cmp taking a = int priority queue , b = int priority queue
return weather top of a > top of b
n = int
read n
for i = 0 to n exclusive
temp , a = int
read temp
for j = 0 to temp exclusive
read a
push a into in at i
sort the first n elements of in using cmp
sum = 0 = long long
for i = 1 to n exclusive
if top of in [ i ] < top of in at 0
diff = top of in [ 0 ] - top of in [ i ] = int
while in [ i ] isn ' t empty
push itop of n [ i ] + diff into in [ 0 ]
pop in [ i ]
increment suum by diff
print sum
let N be a constant integer with N = 200000 + 10
let y , k , n be integers
let s be a string
input s
let flag be a boolean set to false
for i = 0 to length of s exclusive
if s [ i ] is the character a and flag , break
if s [ i ] is the character a , continue
subtract 1 from s [ i ]
assign true to flag
if not flag
let len be an integer with len = length of s
assign the character z to s [ len - 1 ]
output s
n = int and a = int array of size 100
s = string
in function check taking int k and returning bool
t = int with t = 0
for i = 0 to 26 increment t by ceil of a [ i ] as double / k
if t > n return 0
return 1
in function bs taking int b , int e and returning int
if e - b is 1 return b
mid = int with mid = ( b + e ) / 2
if check of mid - 1 return bs of b , mid
return bs of mid , e
read s then n
for i = 0 to size of s increment a [ s [ i ] - ' a ' ]
t = int with t = bs of 1 , 2000
ans = string with ans = " "
for i = 0 to 26
loop while size of ans < n append ' a ' to ans
if t is 1999
print - 1
else
print t and ans
let a = array of integers with size = 302000
let cnt = array of integers of size = integer 20000000
let done = array of boolean with size = integer 20000000
let m = integer constant with value 15000000
let n = integer
read n
let g = integer
for integer i = 1 to n inclusive do the following
read a [ i ]
increment cnt [ a [ i ] ]
if i is greater than 1 do the following
set g = call __gcd on a [ i ] and g
else
set g = a [ i ]
let ans = 0
for integer i = g + 1 to m inclusive do the following
if not done [ i ] do the following
let sum = integer with value = 0
for integer j = 1 to m inclusive increment step j + i do the following
set sum = sum + cnt [ j ]
set done [ j ] = true
set ans = max of ans and sum
if ans is 0 do the following
write - 1 to stdout
else
print n - ans
a , b , c = string
i = int
read a , b , c
x = int array of length 13
for i = 0 to 12 exclusive increment i first
if s at i = a or s at i = b or s at i = c then set x at i to 1
for i = 0 to 12 exclusive increment i first
if x at i = 1
if x [ ( i + 4 ) % 12 ] = 1 and x [ ( i + 7 ) % 12 ] = 1
else if x [ ( i + 3 ) % 12 ] = 1 and x [ ( i + 7 ) % 12 ] = 1
create integer n
read input to n
create an array of ints a with size n
for i = 1 to n inclusive , read a [ i ]
create integers c and t = 0
for i from 1 to n inclusive
if a [ i ] is less than 0
increment c
else
increment t
if t = n or n = 1
print " 1 " and n
if c is even
print c / 2
else
print c / 2 + 1
declare integers f and d = 0
for integer i = 1 to n exclusive
if a [ i ] is less than 0 , increment d
if d = 2 and a [ i + 1 ] < 0
print i - f and " "
assign i to f
set d to 0
print n - f
declare integers n and s
read standard input to n and s
ans is a new integer = - 1
start for loop from i = 0 to n exclusive
declare new integer variables a and b
read a and b
if s * 100 is less than a * 100 + b , go to the start of the loop
change ans to max of ( ( 100 * s ) - ( a * 100 + b ) ) % 100 and ans
print ans
create int array f of size 100 with array of size 100
make ints i , j , n , k , and m
read k and while it ' s truthy
for i = 1 to 100
for j = 1 to 100 , set f [ i ] [ j ] to 0
for i = 1 to 100
if i * ( i - 1 ) * ( i - 2 ) / 6 is greater than k , break loop
set n to i - 1
for i = 1 to n
for j = 1 to n
if i is not j , set f [ i ] [ j ] to 1
set k to k - n * ( n - 1 ) * ( n - 2 ) / 6
while k is greater than 0
for i = 1 to 100
if i * ( i - 1 ) / 2 is greater than k , break loop
set m to i - 1
for i = 1 to m , set f [ i ] [ n + 1 ] and f [ n + 1 ] [ i ] to 1
add 1 to n
set k to k - ( m - 1 ) * m / 2
print n
for i = 1 to n
for j = 1 to n , print f [ i ] [ j ]
print new line
create integers h1 , h2 , p1 , p2 , d1 , d2
read h1 read p1 read d1 read h2 read p2 read d2
create integers ph , pp , pd
read ph read pp read pd
create integer ans with ans = 1000000000
for i = 0 to maximum of ( p2 - d1 and 0 ) inclusive
for j = d2 - p1 + 1 if p1 is less than or equal to d2 , else 0 , to h2 + d2 inclusive
create integer t with t = ( h2 - 1 ) / ( p1 + j - d2 ) + 1
create integer r with r = t * ( p2 - d1 - i ) - h1 + 1
set r to 0 if r is less than 0 , else r
set ans to minimum of ans and r * ph + j * pp + i * pd
set ans to 0 if ans is 1000000000 , else ans
print ans print newline
MAXN = a constant set to 100005
MOD = and constant set to 998244353
a = an array of integers with a length of MAXN
dp = a 2 dimentional array of integers with a length of 201
newdp = a 2 dimentional array of integers with a length of 201
n = integer
read n
for i = 0 to n exclusive , read index i of a
for i = 0 to n exclusive
if i = 0
if index i of a = - 1
for x = 1 to 200 inclusive , set newdp [ x ] [ 0 ] = 1
else
newdp [ a [ i ] ] [ 0 ] = 1
else
if index i of a = - 1
flag0 = integer set to 0
flag1 = integer set to 0
for y = 1 to 200 inclusive
add dp [ y ] [ 1 ] to flag1
modulo flag1 by MOD
for x = 1 to 200 inclusive
subtract dp [ x - 1 ] [ 1 ] from flag1
add MOD to flag1
modulo flag1 by MOD
subtract dp [ x - 1 ] [ 0 ] from flag1
add MOD to flag1
modulo flag1 by MOD
add dp [ x - 1 ] [ 1 ] to flag0
modulo flag0 by MOD
add dp [ x - 1 ] [ 0 ] to flag0
modulo flag0 by MOD
add dp [ x ] [ 0 ] to flag1
modulo flag1 by MOD
set newdp [ x ] [ 0 ] to flag0
set newdp [ x ] [ 1 ] to flag1
else
x = integer set to index i of a
for y = 1 to 200 inclusive
flag = integer set to 1 if x < = y or 0
add dp [ y ] [ 1 ] to newdp [ x ] [ flag ]
modulo newdp [ x ] [ flag ] by MOD
if y < = x
add dp [ y ] [ 0 ] to newdp [ x ] [ flag ]
modulo newdp [ x ] [ flag ] by MOD
run memcpy with dp , newdp and 201 * 2 * 4 as arguments
run memset with newdp , 0 , and 201 * 2 * 4 as arguments
ans = integer set to 0
for x = 1 to 200 inclusive
add dp [ x ] [ 1 ] to ans
modulo ans by MOD
read ans
pre = array of 1005 int
function init ( no args , no return value )
i = int
for i = 1 to 100 inclusive pre [ i ] = i
function find ( get int x , return int )
t = x
while pre [ t ] is not t t = pre [ t ]
return t
function join ( get int x and y , return int )
m = find ( x )
n = find ( y )
if m is not n pre [ n ] = m
n , m = int
a , b , c , d = array of 105 int
while read n , m
init ( )
sum = 0
i , j = int , k , l = 0
fill c with 0
fill d with 0
for i = 0 to n exclusive
read a [ i ]
if a [ i ] is 0
increment sum
continue
for j = 0 to a [ i ] exclusive
pl = 0
read b [ j ]
for q = 0 to k exclusive
if c [ q ] is b [ j ] pl = 1
if pl is 0 c [ k ] = b [ j ] , increment k
sort first a [ i ] items of b
for j = 1 to a [ i ] exclusive join ( b [ j - 1 ] , b [ j ] )
for i = 0 to k exclusive
hui = find [ c [ i ] ]
d [ l ] = hui , increment l
sort first l items of d
for i = 1 to l exclusive
if d [ i ] is not d [ i - 1 ] increment sum
print sum
create long longs t1 , t2 , x1 , x2 and t0
read t1 , t2 , x1 , x2 and t0 from the user input
create new long longs x and xx
create double mn with value 1000000000000 . 00
while x1 and x2 are both > = 0
define double check with value = ( t1 * x1 * 1 . 0 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if check is less than t0
decrement x1 by one
go to the start of the loop
if check is less than mn
assign check to mn
set x to x1
change the value of xx to x2
decrement x2
print x , " " and xx
n , m = integers
la , lb = integers both with value of 1
vis = integer array of length 10
ans = integer with value o f0
in function dfs2 that returns nothing and takes arguments k , num = integers
if k equals lb
add 1 to ans
return
for i = 0 to 6 inclusive
if vis [ i ] equals 0 and num * 7 + i is less than m
set vis [ i ] to 1
call dfs2 with arguments k + 1 and num * 7 + i
set vis [ i ] to 0
in function dfs1 that returns nothing and take arguments k , num = integer
if k equals la
call dfs2 with arguments 0 and 0
return
for i = 0 to 6 inclusive
if vis [ i ] equals 0 and num * 7 + i is less than n
set vis [ i ] to 1
call dfs1 with arguments k + 1 and num * 7 + i
set vis [ i ] to 0
read n and m
fn , fm = integers with fn value of n and fm value of m
if n is greater than 0 subtract 1 from n
if m is greater than 0 subtract 1 from m
while n / 7
add 1 to la
set n to n / 7
while m / 7
add 1 to lb
set m to m / 7
set n to fn and m to fm
if la + lb is greater than 7
print 0
call dfs1 with argument of 0 and 0
print ans
create string s , t
create int n , m
create long long int mod
in function add , returning long long int and accepting long long ints x and y
return ( x % mod + y % mod ) % mod
create long long int array dp of size 5001x5001
in function rec returning long long int and accepting ints i and j
if dp [ i ] [ j ] is not equal to - 1 , return dp [ i ] [ j ]
if j equals m or i equals n , return 0
create long long int sm = 0
increase sm by rec ( i , j , + 1 )
if s [ i ] equals t [ j ] , set sm to ( sm + rec ( i + 1 , j + 1 ) + 1 ) % mod
return dp [ i ] [ j ] = sm
set mod to 1e9 + 7
read s and t
set n to size of s
set m to size of t
create long long int ans = 0
set elements of dp to - 1
for i = 0 to n exclusive , set ans to ( ans + rec ( i , 0 ) ) % mod
create constant double PI with value of acos ( - 1 )
declare new constant integer called MAX = 2e9 + 7
MOD is a new constant integer = 1000000007
m = map from integers to long longs
solve is a void function
create new integer a
read variable a from the input
declare string variable with name s
read s
declare new long long called n with value = length of s
create new long long called total with value 0
declare new array of integers p with n elements
for i = 0 to n exclusive
if i is false
change p [ i ] to s [ i ] - ' 0 ' casted to int
else
assign the new value = p [ i - 1 ] + ( s [ i ] - ' 0 ' to p [ i ] )
for len = 1 to n inclusive
loop i from 0 , while i + len - 1 < n , incrementing by 1
create integer sum = p [ i + len - 1 ]
if i ! = 0 , subtract p [ i - 1 ] from sum
increment m [ sum ] by one
increment total by one
if a = 0
print total * m [ 0 ] * 2 - m [ 0 ] * m [ 0 ]
return
declare new long long variable ans = 0
for integer i = 1 to the square root of a inclusive
if a modulo i is equal to 0
if i = square root of a
add ( ( m [ i ] * ( m [ i ] - 1 ) ) + m [ i ] ) to ans
else
change ans to ans + 2 * ( m [ i ] * m [ a / i ] )
print ans to the standard output
call function solve
str = string
read str
i = int with i = 0
loop while str [ i ] is not ' 0 ' increment i
for j = i to size of str - 1 set str [ j ] to str [ j + 1 ]
resize str to size of str - 1
print str
let a , b , c , t , l , i , k be integers with k = 0
let sum and d be double with sum = d = 0
read a and b
for i = 1 to a inclusive
read c
is sum is less than or equal to ceil of c / b
set sum to ceil of c / b
set k to i
print k with newline
let n , m , k , l be integers
read n , m , k , l
if m > n
print - 1
if k + l < = m
print 1
let a be long lon
if ( k + l ) mod m = = 0
set a to ( k + l ) / m
else
set a to ( k + l ) / m + 1
if a * m > n
print - 1
else
print a
h , m = int
read h then m
l1 , l2 = int with l1 = 1 and l2 = 1
for i = 7 to h setting i to i * 7 increment l1
for i = 7 to m setting i to i * 7 increment l2
ans = int with ans = 0
if l1 + l2 is greater than 7
print " 0 "
for i = 0 to h
for j = 0 to m
cnt = int vector of size 7 setting all values to 0
x , l = int with x = i and k = 0 loop until k is l1 setting x to x / 7 and incrementing k each time increment cnt [ x mod 7 ]
x , l = int with x = j and k = 0 loop until k is l2 setting x to x / 7 and incrementing k each time increment cnt [ x mod 7 ]
if value of max_element of begin of cnt and end of cnt is less than 2 then increment ans
create unsigned long longs n , k , ret with ret = 0 , create unsigned long long array a with size 100005
create map ok from unsigned long long to unsigned long long
read n read k
for i = 0 to n exclusive , read a [ i ]
sort elements from a to a + n
for i = 0 to n exclusive , set ok [ a [ i ] ] to 1
for i = 0 to n exclusive
if ok [ a [ i ] ] is 1
set ok [ a [ i ] ] to 0
set ok [ a [ i ] * k ] to 0
increment ret
print ret print newline
in function gcd taking int a , int b and returning int
if a < b swap a and b
if a is not a multiple of b
return gcd of b , a mod b
else
return b
a , b , c , d , e , f = int
read a then b then c then d then e then f
ok = int with ok = 0
if d is 0
set ok to 0
else if b is 0
if c is 0
set ok to 1
else
set ok to 0
else if f is 0
if a or c is 0
set ok to 1
else
set ok to 0
else
if a or c or e is 0
set ok to 1
else
x = int with x = gcd of b , c
y = int with y = gcd of d , e
aa = int with aa = a * c / x * e / y
bb = int with bb = f * d / y * b / x
if bb > aa
set ok to 1
else
set ok to 0
if ok
print " Ron "
else
print " Hermione "
create long long ints l1 , r1 , l2 , r2 , and k
read l1 , r1 , l2 , r2 , and k
make long long int in = max ( l1 , l2 )
create long long out = min ( r1 , r2 )
if in is greater than out
print 0
else if k is less than or equal to out and k is greater than or equal to in
display ( out - in )
else do
show ( out - in )
create long long ints i , j , k , l , t , n , and ans
read n and while it ' s truthy
if n is equal to 1
set ans to 1
else if n is equal to 2
set ans to 2
else if n is equal to 3
set ans to 6
else if n modulo 2 is 0
if n modulo 3 is equal to 0
set ans to ( n - 1 ) * ( n - 2 ) * ( n - 3
else do
set ans to n * ( n - 1 ) * ( n - 3 )
otherwise
set ans to n * ( n - 1 ) * ( n - 2 )
print ans
len = 1005
mod = 998244353
seed = 131
r , c = array of len int
dd = array of len by len int
num , n , m
flag = int
function solve1 ( no args , no return value )
for i = 1 to n inclusive
minx = 10 ^ 9
for j = 1 to m inclusive minx = min ( minx , dd [ i ] [ j ] )
r [ i ] = minx
if r [ i ] is not 0 add minx to num
for j = 1 to m inclusive subtract minx from dd [ i ] [ j ]
for j = 1 to m inclusive
minx = 10 ^ 9
for i = 1 to n inclusive minx = min ( minx , dd [ i ] [ j ] )
c [ j ] = minx
if minx is not 0 add minx to num
for i = 1 to n inclusive
subtract minx from dd [ i ] [ j ]
if dd [ i ] [ j ] flag = 1
function solve1 ( no args , no return value )
for j = 1 to m inclusive
minx = 10 ^ 9
for i = 1 to n inclusive minx = min ( minx , dd [ i ] [ j ] )
c [ j ] = minx
if minx is not 0 add minx to num
for i = 1 to n inclusive subtract minx from dd [ i ] [ j ]
for i = 1 to n inclusive
minx = 10 ^ 9
for j = 1 to m inclusive minx = min ( minx , dd [ i ] [ j ] )
r [ i ] = minx
if r [ i ] is not 0 add minx to num
for j = 1 to m inclusive
subtract minx from dd [ i ] [ j ]
if dd [ i ] [ j ] flag = 1
read n , m
for i = 1 to n inclusive
for j = 1 to m inclusive read dd [ i ] [ j ]
if n < = m
solve1 ( )
else
solve2 ( )
if flag print - 1 and return 0
print num
for i = 1 to n inclusive
for j = 0 to r [ i ] exclusive print " row " , i
for i = 1 to m inclusive
for j = 0 to c [ i ] exclusive print " col " , i
create long long integers x and y
declare exgcd taking in long long integers a and returning long longand b
if b is equal to 0
set x to 1
set y to 0
return a
create long long d = exgcd ( b , a % b )
create long long t = x
set x to y
set y to the result of t - a / b * y
return d
create long long integers m , h1 , al , x1 , y1 , h2 , a2 , x2 , y2
create long long integers p1 , p2 , q1 , q2
while cin > > m > > h1 > > a1 > > x1 > > y1 > > h2 > > a2 > > x2 > > y2 is truthy
set p1 , p2 , q1 , and q1 to 0
for i = 1 to 2 * m
set h1 to ( h1 * x1 + y1 ) % m
if h1 is equal to a1
if p1 is equal to 0
set p1 to i
else if q1 is equal to 0
set q1 to the result of i - p1
break loop
for i = 1 to 2 * m
set h2 to the result of ( h2 * x2 + y2 ) % m
if h2 is equal to a2
if p2 is equal to 0
set p2 to i
else if q2 is equal to 0
set q2 to the result of i - p2
break loop
create long long d = exgcd ( q1 , - q2 )
create long long c = p2 - p1
if d is equal to 0
print " - 1 "
continue to next loop iteration
if c modulo d is truthy
print " - 1 "
continue to next loop iteration
if d is less than 0 , set d to - d
if p1 is equal to 0 or p2 is equal to 0
print " - 1 "
continue to next loop iteration
if q2 is equal to 0 and q1 is equal to 0 and p1 is not equal to p2
print " - 1 "
continue to next loop iteration
if q2 is equal to 0 and p2 - p1 is less than 0 or q1 is equal to 0 and p1 - p2 is less than 0
print " - 1 "
continue to next loop iteration
create long long k = c / d
if the return value of exgcd ( q1 , - q2 ) is less than 0 , set x to - x and set y to - y
set x to the result of x * k
set y to the result of y * k
if x is less than 0 or y is less than 0
while 1 is truthy
set x to the result of x + q2 / d
set y to the result of y + q1 / d
if x is greater than or equal to 0 and y is greater than or equal to 0 , break loop
if x is greater than 0 and y is greater then 0
while 1 is truthy
set x to the result of x - q2 / d
set y to the result of y - q1 / d
if x is less than 0 or y is less than 0 , break loop
set x to the result of x + q2 / d
set y to the result of y + q1 / d
create long long ans = x * q1 + p1
print ans
declare long long MOD = 1000000009
declare pw with long longs a , b as arguments , returning long long
if b is 0 , return 1 from function
if b is 1 , return a % MOD
if b % 2
declare long long rs = result of run pw ( a , b - 1 )
return ( rs * a ) % MOD from function
declare long long rs = result of run w with a , b / 2 as arguments
return ( rs * rs ) % MOD
declare long long vector sm
declare solve with long longs a , b as arguments , returning long long
if b is 0 , return 0 from function
for i = 0 to 35 exclusive
declare long long ba = ( 1LL bitshift left i ) bitwise and b
if ba is 0 , end current loop iteration
declare long longs n , a , b , k
read n , a , b , k
declare string s
read s
declare long long X = 1 , y + 1
for i = 0 to k exclusive
let X be X * b
let X be X % MOD
for i = 0 to k exclusive
let Y be Y * a
let Y be Y % MOD
let X be X * result of run pw ( Y , MOD - 2 )
let X be X % MOD
add 1 to end of sm
for i = 0 to 40 exclusive
add ( back of sm + back of sm * result of run pw ( X , ( 1LL bitshift left i ) ) to end of sm
let back of sm be back of sm % MOD
declare long long st = result of run solve ( X , ( n + 1 ) / k )
declare long long ans = 0
for i = 0 to k exclusive
declare long long rs = ( result of run pw ( b , i ) * result of run pw ( a , n - 1 ) ) % MOD
if s [ i ] is ' - ' , let rs be rs * - 1
let rs be rs * st
increment ans by rs
let ans be ans % MOD
if ans is less than 0 , increment ans by MOD
print ans and newline
a = integer array of size 500008 , n = integer
in function slove with arguments of integer x and integer y that returns an integer
k = integer = y - x + 1
i = integer
if k is even
for i = x to x + k / 2 exclusive , then a [ i ] = a [ x ]
for i = x + k / 2 to y inclusive , then a [ i ] = a [ y ]
else
for i = x + 1 to y inclusive , then a [ i ] = a [ x ]
return ( k - 1 ) / 2
ans , l , r = integer
i = integer
read n
for i = 1 to n inclusive , then read a [ i ]
ans = 0
for i = 2 to n exclusive
if a [ i ] is not a [ i - 1 ] and a [ i ] is not a [ i + 1 ]
l = i - 1
increase i by 1
for current value of i to n exclusive
if a [ i ] is not a [ i - 1 ] and a [ i ] is not a [ i + 1 ]
continue
else
exit for loop
r = i
ans = greater value between ans and the result of calling l and r
l = 0
r = 0
print ans
for i = 1 to n exclusive , then print a [ i ]
print api [
create long long array arr with size 1000000
create new set of integers ss
create new map from strings to integers mm
create an array of chars ch with 100000 elements
declare integer variables n , k and res with res = 0
read input to n
for integer i = 0 to n exclusive
read k
if k = 0 , increment res
if n = 1
if res is equal to 0
increase res by one
else
decrement res
print " YES " if res = 1 or " NO " otherwise
create integer n
read n and loop further
declare integer arrays a with 101 and b with 100 elements , and an integer f = 0
for i from 1 to n inclusive
read a [ i ]
if a [ i ] is less than 0 , increment f by one
if f < = 2
print 1 and n
continue the loop
if f is odd
print f / 2 + 1
else
print f / 2
declare int t = 0
declare int variable x = 1
declare integer sum = 0
loop i from 1 to n inclusive
if t = 2 and a [ i ] < 0
print i - x and " "
add i - x to sum
change x to i
change t to 0
decrease f by 2
if a [ i ] is less than 0 , increment t by one
if sum is less than n , print n - sum
print new line
create long long integers n and i
read n
if n is less than or equal to 3
print " NO \ n "
else do
print " YES \ n "
if n modulo 2 is 0
print " 1 * 2 = 2 \ n2 * 3 = 6 \ n6 * 4 = 24 \ n "
for i = 5 to n , print i + 1 , " - " , i , and " = 1 \ n1 * 24 = 24 \ n "
otherwise
print " 2 - 1 = 1 \ n1 + 3 = 4 \ n4 * 5 = 20 \ n20 + 4 = 24 \ n "
for i = 6 to n , print i + 1 , " - " , i , and " = 1 \ n1 * 24 = 24 \ n "
s , n , i , j , num1 , num2 , aux1 , aux2 = long long
read s , n
x = long long array of size n , y = long long array of size n
lose = boolean = false
for i = 0 to n exclusive , read x [ i ] , y [ i ]
for i = 0 to n - 1 exclusive
for j = i + 1 to n exclusive
if x [ i ] > = x [ j ]
aux1 = x [ i ]
x [ i ] = x [ j ]
x [ j ] = aux1
aux2 = y [ i ]
y [ i ] = y [ j ]
y [ j ] = aux2
i = 0
while i < n and lose is false
if s > x [ i ]
s = s + y [ i ]
else
lose = true
increase i by 1
if lose is true
else
declare is_pal with string g as argument , returning boolean
declare integer q = size of g - 1
declare integer w = 0
while q is greater than or equal to w
if g [ w ] is not g [ q ] , return 0 from function
decrement q
increment w
return 1 from function
declare string g
read g
declare integer x
read x
declare integer w = 0
declare boolean b = 0
if size of g % x is not 0
print " NO \ n "
else
while w is less than size of g
if result of run is_pal with ( substring of g from w to size of g / x ) as argument is false
let b be 1
end loop
increment w by size of g / x
if not b
print " YES \ n "
else
print " NO \ n "
a = string
read a
n = size of a
f , j = 0
b = array of n char
if n is 1
print 0
else
for i = 0 to n exclusive
if a [ i ] is ' 0 ' and f is 0
f = 1
continue
b [ j ] = a [ i ]
increment j
if j is n
for i = 1 to j exclusive print b [ i ]
else
for i = 0 to j exclusive print b [ i ]
print newline
declare is_vowel taking in char ch and returning bool
make string vowels = " AEIOUY "
return the result of vowels . find ( ch ) ! = string : : npos
make string s
read s
create int vector d
append 0 to d
for i = 0 to s . length ( ) exclusive
if is_vowel ( s [ i ] ) is truthy , append i + 1 to d
append s . length ( ) + 1 to d
create int mx = 0
show mx
create character array s with size 100005 , create character pointer p
create integer x
read s
if p is first occurrence of " AB " in s and first occurrence of " BA " in p + 2
print " YES " print newline
else if p is first occurrence of " BA " in s and first occurrence of " AB " in p + 2
print " YES " print newline
else
print " NO " print newline
declare int variables n , x1 , y1 , x2 and y2
read n , x1 , y1 , x2 and y2
create integer ans = 1e9
if x1 = 0 or x1 = n or x2 = 0 or x2 = n
if x1 is equal to x2 , change ans to min of ans and abs ( y1 - y2 )
assign min of ans and y1 + y2 + abs ( x1 - x2 ) to ans
change ans to min of ans and ( n - y1 ) + ( n - y2 ) + abs ( x1 - x2 )
if y1 = 0 or y1 = n or y2 = 0 or y2 = n
if y1 is equal to y2 , change ans to min of ans and abs ( x1 - x2 )
assign min of ans and x1 + x2 + abs ( y1 - y2 ) to ans
set ans to min of ans and ( n - x1 ) + ( n - x2 ) + abs ( y1 - y2 )
print ans and " \ n "
create long long ints n , m , mex , l , and r
read n and m
set mex to n
while m - - is truthy , read l and r and set mex to min of mex and r - 1 + 1
for i = 0 to n exclusive , print i % mex and " \ n " [ i = = n - 1 ]
MAXN = const int with MAXN = 2e7
prime = int array of size MAXN
vis = int array of size MAXN
a = int array of size MAXN
in function init
for i = 2 to MAXN
if not prime [ i ] increment prime [ 0 ] then set prime [ prime [ 0 ] ] to i
iterate j from 1 while j < = prime [ 0 ] and prime [ j ] < = MAXN / i
set prime [ prime [ j ] * i ] to 1
if i is a multiple of prime [ j ] break
n = int
gcd = int
read n
for i = 1 to n inclusive
read a [ i ]
if i is 1
set gcd to a [ 1 ]
else
set gcd to __gcd of gcd , a [ i ]
Max = int with Max = 0
call init
for i = 1 to n inclusive
set a [ i ] to a [ i ] / gcd
iterate j from 1 while j < = prime [ 0 ] and prime [ j ] * prime [ j ] < = a [ i ]
if a [ i ] is a multiple of prime [ j ]
loop while a [ i ] is a multiple of prime [ j ] set a [ i ] to a [ i ] / prime [ j ]
increment vis [ prime [ j ] ]
set Max ot max of Max , vis [ prime [ j ] ]
if a is not 1
increment vis [ a [ i ] ]
set Max to max of Max , vis [ a [ i ] ]
if Max is 0
print - 1
else
print n - Max
create int n
create vector of integers button
declare int variable i = 0
declare string variable result
read n
loop while i < n , incrementing i
declare int variable tmp
read tmp
push tmp into button
declare integer variable cntNotFastened = 0
if n = 1
set result to " YES " if button [ 0 ] is 1 , else set to " NO "
else
for i from 0 to n exclusive
if button [ i ] is equal to 0 , increment cntNotFastened
if cntNotFastened is greater than 1
set result to " NO "
break the loop
if cntNotFastened = 1
set result to " YES "
else
assign " NO " to result
print result
declare integers x and y
create boolean arrays xasphalt and yasphalt with size 69
days and wrkdsz are integers with days = 1 , workdays is an int array with size 6969
declare integer variable a
read a
for A = 0 to a squared exclusive
read input to x and y
if xasphalt [ x ] and yasphalt [ y ] are false
assign true to xasphalt [ x ]
assign true to yasphalt [ y ]
assign days to workdays [ wrkdsz ]
increment wrkdsz
increment days
for A from 0 to wrkdsz exclusive
if A is equal to wrkdsz - 1
print workdays [ A ] and " \ n "
else
print workdays [ A ] and " "
assign elements of last to 8 , 4 , 2 , 6
create int n
read n
if n = 0
print - 1
else
print last [ ( n - 1 ) mod 4 ]
let pi = acos ( - 1 ) be a const double
let inf be a const int = 1000 * 1000 * 100
let size be an int constant = 10000
let mas be an int array of length size
bon = int array of length size
let tp , lb , rb , val be int arrays all of length size
n , m = int
read n and m
for i = 0 to n exclusive then set mas [ i ] to inf
for i = 0 to m exclusive
read tp [ i ] , lb [ i ] , rb [ i ] , val [ i ]
decrement lb at i
decrement rb at i
for i = 0 to m exclusive
if tp [ i ] = 1
for j = lb at i to rb [ i ] inclusive , increment bon [ j ] by val [ i ]
else
fir i = 0 to n exclusive then set bon [ i ] = 0
let flag be a bool = true
for i = 0 to m exclusive
if tp at i = 1 then
for j = lb [ i ] to rb [ i ] then increment bon [ j ] by val [ i ]
else
let mx = int = - inf
for j = lb [ i ] to rb [ i ] inclusive then set mx to the max between mx and mas [ j ] + bon [ j ]
if mx isn ' t val [ i ] then set flag to false
if flag
for i = 0 to n exclusive then print ams at i and new line [ i = = n - 1 ]
else
MAXN = constant int , MAXN = 200005
N , M , K , L , ans = long long
read N , M , K , L
let ans = ( K + L + M - 1 ) / M
if K + L < = M * ans AND M * ans < = N )
print ans
else
print - 1
declare mult taking in long long ints a , b , and p = 1000000007 and returning long long
return the result of ( ( a % p ) * ( b % p ) ) % p
declare add taking in long long ints a , b , and p = 1000000007 and returning long long
return ( a % p + b % p ) % p
declare fpow taking in long long ints n , k , and p = 1000000007 and returning long long
create long long int r = 1
loop while k is truthy
if k & 1 is truthy , set r to r * n % p
set n to n * n % p
return r
declare inv taking in long long ints a and p = 1000000007 and returning long long
return fpow ( a , p - 2 , p )
declare inv_euclid taking in long long ints a and m = 1000000007 and returning long long integer
make long long m0 = m
create long long ints y = 0 and x = 1
if m is equal to 1 , return 0
while a is greater than 1
make long long int q = a / m
make long long t = m
set m to a % m and a to t
set t to y
set y to x - q * y
set x to t
if x is less than 0 , set x to x + m0
return x
create long long array spff of size 1000003
declare spf
set spff [ 0 ] to 1
set spff [ 1 ] to 1
for i = 2 to 1000003
if i % 2 is 0
set spff [ i ] to 2
otherwise
set spff [ i ] to 1
for i = 3 while i * i is less than or equal to 1000003
if spff [ i ] is equal to i
for j = i * i to 1000003 by increasing by i , set spff [ j ] to i
call spf ( )
make long long n
read n
for i = 1 , loop indefinitely
if spff [ n * i + 1 ] is not equal to n * i + 1
create integers b1 , b2 , b3 , emm1 , emm2 and integer array lk of size 10 within an array of size 10
create integer array a of size 8
create string key - type integer map m
declare js taking in integers x , y , and z and returning integer
set x to b1 / x
set y to b2 / y
set z to b3 / z
set emm1 = the max of abs ( x - y ) , max ( abs ( y - z ) , abs ( x - z ) ) and return emm1
declare haogan taking in integers x , y , and z and returning integer
create integer ss = 0
for i = 1 to x inclusive
for j = 1 to x inclusive
if lk [ a [ i ] [ a [ j ] ] is truthy , increment ss
for i = x + 1 to x + y inclusive
for j = x + 1 to x + y inclusive
if lk [ a [ i ] ] [ a [ j ] ] is truthy , increment ss
for i = x + y + 1 to 7 inclusive
for j = x + y + 1 to 7 inclusive
if lk [ a [ i ] ] [ a [ j ] ] is truthy , increment ss
set emm2 to ss and return emm2
set m [ " Anka " ] to 1
set m [ " Chapay " ] to 2
set m [ " Cleo " ] to 3
set m [ " Troll " ] to 4
set m [ " Dracul " ] to 5
set m [ " Snowy " ] to 6
set m [ " Hexadecimal " ] to 7
create integer n
read n
while n - - is truthy
create strings s1 , s , and s2
read s1 , s , and s2
set lk [ m [ s1 ] ] [ m [ s2 ] ] to 1
create integers ans1 = 1e9 and ans2 = - 1e9
read b1 , b2 , and b3
if b1 is less than b2 , swap the values of b1 and b2
if b2 is less than b3 , swap the values of b2 and b3
if b1 is less than b2 , swap the values of b1 and b2
for i = 1 to 7 inclusive , set a [ i ] to i
do
if the return value of js ( 4 , 2 , 1 ) is equal to ans1 and the return value of haogan ( 4 , 2 , 1 ) is greater than ans2 , set ans2 to emm2
if emm1 is less than ans1
set ans1 to emm1
set ans2 to the return value of haogan ( 4 , 2 , 1 )
if the return value of js ( 3 , 3 , 1 ) is equal to ans1 and the return value of haogan ( 3 , 3 , 1 ) is greater than ans2 , set ans2 to emm2
if emm1 is less than ans1
set ans1 to emm1
set ans2 to the return value of haogan ( 3 , 3 , 1 )
if the return value of js ( 3 , 2 , 2 ) is equal to ans1 and the return value of haogan ( 3 , 2 , 2 ) is greater than ans2 , set ans2 to emm2
if emm1 is less than ans1
set ans1 to emm1
set ans2 to the return value of haogan ( 3 , 2 , 2 )
if the return value of js ( 5 , 1 , 1 ) is equal to ans1 and the return value of haogan ( 5 , 1 , 1 ) is greater than ans2 , set ans2 to emm2
if emm1 is less than ans1
set ans1 to emm1
set ans2 to haogan ( 5 , 1 , 1 )
while the return value of next_permutation ( a + 1 , a + 7 + 1 ) is truthy
print ans1 , ' ' , and ans2
INF = 0x3f3f3f3f
create char s [ 10 ] [ 10 ]
create int i , j , k
create int n , m , cou , set cou to 1
read n
while decrement n
cou = 1
set x , y , x1 , y1 to 0
for i = 0 to 8 exclusive
for j = 0 to 8 exclusive
read s [ i ] [ j ]
if s [ i ] [ j ] = K and cou = 1
increment cou , set x to i and y to j
else if s [ i ] [ j ] = K and cou = 2
increment cou , set x1 to i and y1 to j
if ( x1 - x ) % 4 = 0 and ( y1 - y ) % 4 = 0
else
inf = constant integer = 0x3f3f3f3f
maxn = constant integer = 110
in function max with arguments of integer a and integer b that returns an integer
return a if a > b else return b
in function min with arguments of integer a and integer b that returns an integer
return n if a > b else return a
a = integer array of size maxn
i , n = integer
while n can be read as a valid integer
for i = 0 to n exclusive , then read a [ i ]
l = integer
maxi = integer = 1
for l = 0 to n - 1 exclusive
pos = integer = l
while l < n - 1 and a [ l ] + 1 is a [ l + 1 ]
if l - pos + 1 > maxi , then maxi = l - pos + 1
cnt1 = integer = 1
if a [ 0 ] is 1
for i = 0 to maxi - 1 exclusive
if a [ i ] + 1 is not a [ i + 1 ]
exit for loop
else
increase cnt1 by 1
cnt2 = integer = 1
if a [ n - 1 ] is 1000
for i = 0 to maxi - 1 exclusive
if a [ n - 1 - i ] - 1 is not a [ n - 1 - i - 1 ]
exit for loop
else
increase cnt2 by 1
if cnt1 is maxi or cnt2 is maxi
print maxi - 1
else
print maxi - 2
create const int mod = 1e9 + 7
create integer array dp of size 5001 with array of size 5001
make strings s and t
read s
read t
for i = s . size ( ) - 1 to 0
make integer ret = 0
for i = 0 to s . size ( ) exclusive , set ret to ( ret + dp [ i ] [ 0 ] ) % mod
display ret
x = long long with x = 0
in function dfs taking a pointer to an int vector edges , an int a and an int array v
increment x
set v [ a ] to 1
ans = long long with ans = size of edges [ a ]
for i = 0 to size of edges [ a ]
if v [ edges [ a ] [ i ] ] is 0 then call dfs on edges , edges [ a ] [ i ] and v
n , m = int
ans = long long with ans = 0
read n then m
edges = int vector array of size n
for i = 0 to m
a , b = int
read a then b
append b - 1 to edges [ a - 1 ]
append a - 1 to edges [ b - 1 ]
v = int array of size n with all values set to 0
for i = 0 to n
if v [ i ] is 0
set x to 0
call dfs on edges , i and v
add x * ( x - 1 ) / 2 to ans
if ans is m
print " YES "
else
print " NO "
debug = const bool with debug = 1
in the function solve that takes string s , t and returns integer
n = const int n = ( int ) s . size ( ) , m = ( int ) t . size ( )
s = $ + s
t = ^ + t
equal , sdiag = static integer array of size [ 2048 ] [ 2048 ]
fill reference equal [ 0 ] [ 0 ] , reference equal [ 0 ] [ 0 ] + 2048 * 2048 , 0
fill reference sdiag [ 0 ] [ 0 ] , reference sdiag [ 0 ] [ 0 ] + 2048 * 2048 , 0
for i = 1 to n
for j = 1 to m , equal [ i ] [ j ] = ( s [ i ] is t [ j ] )
for i = 1 to n
answ = integer with answ = m
for i = 1 to n
for j = 1 to m
len = integer with len = min ( n - i + 1 , m - j + 1 )
nOp = integer with nOp = m - ( sdiag [ i + len ] [ j + len ] - sdiag [ i ] [ j ] )
answ = min of answ and nOp
return answ
s , t = string
while ( read s , t ) , print solve ( s , t )
num = integer array of size 200
ord = integer array of size 200
cnt = integer with cnt = 0
n , k = integers
read n , k
for i = 0 to n exclusive
tmp = int
flag = integer with flag = 1
read tmp
for j = 0 to cnt exclusive
if ( num [ j ] is not tmp )
flag = 1
else
flag = 0
break loop
if ( flag is 1 )
num [ cnt ] = tmp
ord [ cnt ] = i
increment cnt
if ( cnt < k )
else
for p = 0 to k - 1 exclusive , print ord [ p ] + 1
print ord [ k - 1 ] + 1
n , a , b , c , ans are long integers
read n , a , b , c , ans
if a < b - c , print n / a and stop
if n > = b , increase ans by ( n - c ) / ( b - c )
decrease n by ans * ( b - c )
increase ans by n / a
print ans and newline
create integers n , k , cnt with cnt = 0
create integers maxx , maxn , ans with ans = 0
create integer arrays a , used , e , with a size 81 , used size 81 , e size 81
set bytes from a to size of a to value 0
set bytes from used to size of used to value 0
read n read k
for i = 1 to n inclusive , read a [ i ]
for i = 1 to n inclusive
if used [ a [ i ] ] , break current loop iteration
if cnt is less than k
increment cnt
set used [ a [ i ] ] to 1
increment ans
else
set bytes from e to size of e to value 0
for j = 1 to i exclusive
if used [ a [ j ] ] is true , set e [ a [ j ] ] to 81
for j = 1 to i exclusive
if used [ a [ j ] ] is true
for k = i + 1 to n inclusive
if a [ k ] is a [ j ]
set e [ a [ j ] ] to k
break loop
set maxx to 0
set maxn to - 1
for j = 1 to i exclusive
if e [ a [ j ] ] is greater than maxx
set maxx to e [ a [ j ] ]
set maxn to a [ j ]
set used [ maxn ] to 0
set used [ a [ i ] ] to 1
increment ans
print ans print newline
create long long a , b , c , d , k
read b , a , d and c
for i = 0 to 100 inclusive
for j = 0 to 100 inclusive if
if a + i * b = c + j * d , print a + i * b and a newline , return 0
print - 1 and a newline
define string variable a
b , t and c are long longs where c = 0
read line from the input and put it into a
assign to b
change t to b
add 2 to b
assign the new value = to b
for i = 0 to t exclusive
increment c by one if a [ i ] is equal to ' | '
if c + 1 is equal to b - 1
print ' | '
in a for loop , change i from 0 to length of a - 1 exclusive and print a [ i ] to the output on each loop
print new line to the standard output
else if c = b
print a to the standard output
else if c = b + 2
declare new long long z
if z is greater than 1
print all elements of a , except the first , to the output in a loop
print ' | ' to the standard output
else
for i from 0 to length of a exclusive
if i is equal to z + 1 , skip the rest of the loop
print a [ i ] to the standard output
print ' | '
else
print " Impossible " to the standard output
create new strings x and y and an array s with size 15
set the value of s [ 1 ] to " monday "
change the value of s [ 2 ] to " tuesday "
assign " wednesday " to s [ 3 ]
change s [ 4 ] to " thursday "
set s [ 5 ] to " friday "
change s [ 6 ] to " saturday "
assign the new value = " sunday " to s [ 7 ]
read x and y from the user input
declare integers num1 and num2 = 0
in a for loop , change i from 1 to 7 inclusive incrementing i
if x = s [ i ] , change the value of num1 to i
in a for loop , change i from 1 to 7 inclusive incrementing i
if y is equal to s [ i ] , set the value of num2 to i
if num2 is less than num1 , change num2 to num2 + 7
define integer variable sum with value num2 - num1
if sum = 0 or sum is equal to 2 or sum = 3
print " YES "
else
print " NO " to the output
declare integer variables n and m
lg is a new 2d array of booleans with size 111 by 111
a is a new array of integers 111 by 111
v is an array of booleans with 111 elements
create new array of booleans zero with size 111
create integer ex = 0
dfs is a void function with int argument i
change the value of v [ i ] to true
start for loop from j = 1 to n inclusive
call dfs ( j ) if a [ i ] [ j ] is true and v [ j ] is false
read n and m from the user input
in a for loop , change i from 1 to n inclusive
declare new integer called t
read standard input to t
if t is equal to 0
assign true to zero [ i ]
increment ex by one
decrement t and loop further , while t is not 0
declare integer variable with name c
read c
change the value of lg [ i ] [ c ] to true
for integer i = 1 to n inclusive
in a for loop , change j from 1 to n inclusive
if i ! = j
increment k from 1 to m inclusive in a loop
if lg [ i ] [ k ] and lg [ j ] [ k ] are true , assign the new value = 1 to a [ i ] [ j ]
declare new integer variable ans = 0
start for loop from i = 1 to n inclusive incrementing i
if both v [ i ] and zero [ i ] are false
call dfs ( i )
increment ans by one
decrement ans
if ans is less than 0 , change the value of ans to 0
print ans + ex to the standard output
a , b , c , d , i , j , k , n , l = long integers with c = 0
read n , a
ar = integer array of size [ n + 2 ]
for i = 0 to n ( exclusive ) , read ar [ i ]
for i = n - 1 to 0 ( inclusive )
let b = ar [ i ]
if b modulo a is 0
let d = b / a
if c is less than d
let c = d
let j = i + l
otherwise
let d = ( b / a ) + l
if c is less than d
let c = d
let j = i + l
print j
create integers n , k
read n read k
create string t
read t
create integer s with s = n
for i = n - 1 to 0 exclusive , decrementing i
if substring of t from i to n - 1 is substring of t from 0 to n - 1 , set s to i
print t
decrement k
while decrement k is true
for i = n - s to n exclusive , print t [ i ]
print newline
create ints n and s
read n and s
create ints lowest = 100 , ans = 0 , flag = 0 , and low and int arrays a of size n and b of size n
let ins i , j , k , and l
for i = 0 to n exclusive
read a [ i ] and b [ i ]
if s * 100 is greater than or equal to a [ i ] * 100 + b [ i ]
set flag to 1
if b [ i ] is not 0
set low to b [ i ]
if low is less than lowest , set lowest to low
if flag is not 0
print the result of 100 - lowest
otherwise
print " - 1 "
n , m , a , b = long long
read n , m , a , b
decrease a by 1 , decrease b by 1
if a / m is b / m
print 1
if a modulo m is 0 and b modulo m is m - 1
print 1
if b + 1 is n
if a modulo m is 0
print 1
print 2
if a modulo m is 0 or b modulo m is m - 1
print 2
if the absolute value of the following ( a / m ) - ( b / m ) < = 1
print 2
if ( a + m - 1 ) modulo m is b modulo m
print 2
print 3
create constant integer MAX with value 100005
f is a new vector of integers with MAX elements filled with - 1
create vector of integers fr with size MAX filled with - 1
valid is a new vector of booleans with MAX elements filled with 1
new boolean variable ans = 1
define integer n
lastValid is a new integer variable with value 1
read input to n
if n = 1
print " 1 \ n "
else
if n & 1 is 1
change the value of f [ n / 2 + 1 ] to n / 2 + 1
change valid [ n / 2 + 1 ] to 0
set f [ 1 ] to 2 and f [ n ] to n - 1
set fr [ 2 ] to 1 and fr [ n - 1 ] to n
set the values of valid [ 2 ] and valid [ n - 1 ] to 0
for i from 2 to n / 2 inclusive incrementing i
define integers x = f [ i ] and y = fr [ i ]
if x ! = - 1 and y = - 1
change fr [ i ] to n + 1 - x
change the value of f [ n + 1 - x ] to i
assign the new value = 0 to valid [ i ]
else if y ! = - 1 and x = - 1
change f [ i ] to n + 1 - y
assign 0 to valid [ n + 1 - y ]
set the value of fr [ n + 1 - y ] to i
if f [ i ] = - 1
create boolean variable update = 1
for integer j = lastValid to n inclusive incrementing j
if valid [ j ] is true
if i = j
change update to 0
skip the rest of the loop
change f [ i ] to j
set the value of fr [ j ] to i
set the value of valid [ j ] to 0
if update is true , assign the new value = j to lastValid
stop the loop
assign the new value = n + 1 - f [ i ] to f [ n + 1 - i ]
change the value of fr [ f [ n + 1 - i ] ] to n + 1 - i
set the value of valid [ n + 1 - f [ i ] ] to 0
for integer i = 1 to n inclusive
if f [ f [ i ] ] ! = n + 1 - i , set ans to 0
if ans is equal to 0
print " - 1 \ n "
else
create long long n , i , k , a , j , mx = - 1
read n
for i = 0 to n exclusive
read k and a
for j = 1 to 15 exclusive
if pow of 4 and j is greater than or equal to a , break
set mx to max of mx and j + k
print mx
create map hit from int to int
create integers n , a [ 100005 ] , temp , flag , set flag to 0
read n
for i = 0 to n exclusive
read temp
increment hit [ temp ]
if temp = 50
if hit [ 25 ] > = 1
decrement hit [ 25 ]
continue
flag = 1
else if temp equal to 100
if hit [ 50 ] > = 1 and hit [ 25 ] > = 1
decrement hit [ 50 ]
decrement hit [ 25 ]
continue
else if hit [ 25 ] > = 3
set hit [ 25 ] to hit [ 25 ] - 3
continue
flag = 1
if flag = 0
else
bigmod is a long long function with long long arguments a , b and m
if b = 0 , return 1 % m
create long long x = bigmod ( a , b / 2 , m )
set x to x squared modulo m
if b is odd , assign ( x * a ) modulo m to x
return x
declare integer variable n
read n
declare string array s with size n + 2
for i from 0 to n exclusive , read s [ i ]
let r and c be vectors of integers arrays with size n + 1
for i = 0 to n exclusive
for j from 0 to n exclusive
if s [ i ] [ j ] = ' . '
push j to r [ i ]
push i to c [ j ]
declare integer p = 1
loop i from 0 to n exclusive
if r [ i ] is empty
change p to 0
break the loop
if p is true
for integer i = 0 to n exclusive , print i + 1 , " " and r [ i ] [ 0 ] + 1
set p to 1
for i = 0 to n exclusive
if c [ i ] is empty
change p to 0
break
if p is true
loop i from 0 to n exclusive , print c [ i ] [ 0 ] + 1 , " " and i + 1
print " - 1 "
n = int
read n
cnt = int with cnt = 0
for i = 1 to n inclusive
x = int
read x
if x is 0 then increment cnt
if n is 1
print " YES " if cnt is 0 else print " NO "
if cnt is 1
print " YES "
else
print " NO "
declare constant long long maxn = 1e9 + 5
declare long longs t , s , x
read t , s , x
if x is less than t or x is t + 1
print " NO " and newline
if ( x - t ) % s is 0 or ( x - t ) % 2 is 1
print " YES " and newline
else
print " NO " and newline
A and B = array of 10000 long , n , i , a , s , j , k , tam , dem = long
read n
for i = 1 to n + 1 exclusive read A [ i ]
if n is 1
if A [ 1 ] is 1
print " YES "
else if A [ 1 ] is 0
print " NO "
else
dem = 0
for i = 1 to n + 1 exclusive
if A [ i ] is 0 increment dem
if A [ i ] < 0 or A [ i ] > 1 add 2 to dem
if dem > = 2 or dem is 0
print " NO "
else
if dem is 1 print " YES "
ip , ip2 and n are ints with ip and ip2 = 0
declare vector of integers called v
s is a new array of characters with 100010 elements
in the function next_token that returns boolean
set the value of ip to ip2
while ip < n and ( s [ ip ] < ' a ' or s [ ip ] > ' z ' )
if ip is equal to n , return false
change ip2 to ip
while ip2 < n and s [ ip2 ] > = ' a ' and s [ ip2 ] < = ' z '
return true
declare character z
function get_type that returns integer
define new integer len with value ip2 - ip
change z to s [ ip2 ]
assign the new value = 0 to s [ ip2 ]
if s + ip + len - 4 matches " lios " , return 0
if result of s + ip + len - 5 = " liala " return 1
if s + ip + len - 3 matches " etr " return 10
if strcmp ( s + ip + len - 4 , " etra " ) returns 0 , return 11
if comparison of s + ip + len - 6 with " initis " returns 0 , return 20
return 21 if s + ip + len - 6 matches " inites "
return - 1
boolean function solve
in a for loop , change i from 0 to length of v exclusive
if v [ i ] is equal to - 1 , return false
return true if length of v = 1
start for loop from i = 0 to length of v exclusive incrementing i
in a for loop , change j from 0 to i exclusive
return false if v [ i ] % 10 ! = v [ j ] % 10
start for loop from i = 0 to length of v - 1 exclusive incrementing i
if v [ i ] is greater than v [ i + 1 ] , return false
create new integer cnt = 0
increment i in a loop from i = 0 to length of v exclusive
if v [ i ] / 10 = 1 , increment cnt
if cnt is equal to 1
return true
else
return false
store input into s
change n to length of s
while next_token ( ) returns true
push new value = the result of get_type ( ) into v
change s [ ip2 ] to z
if call to solve ( ) returned true
print " YES "
else
print " NO " to standard output
declare integer variable numberOfStudents
declare new integer variable studentsRate
create integer variable with name result with value 1
read numberOfStudents from the user input
create an int pointer arr pointed to the new array of integers with numberOfStudents elements
for integer x = 0 to numberOfStudents exclusive incrementing x
read studentsRate from the input
set arr [ x ] to studentsRate
in a for loop , change x from 0 to numberOfStudents exclusive
assign 1 to result
lopp y from 0 to numberOfStudents exclusive incrementing by 1
if arr [ x ] is less than arr [ y ]
if x = numberOfStudents - 1
print result
else
print result and " "
t1 , t2 , x1 , x2 , t0 = long long
read t1 , t2 , x1 , x2 , t0
if t1 is t0 and t2 is t0
print x1 x2
end execution of code
if t1 is t0
print x1 0
end execution of code
if t2 is t0
print 0 x2
end execution of code
Y1 = Y2 = long long = 0
dif = long double = maximum value of an integer
for y1 = 0 to x1 inclusive
l = next whole number of 1 . 0L * y1 * ( t1 - t0 ) / ( t0 - t2 )
got y2 = l to l + 10 inclusive
if y1 is 0 and y2 is 0 , continue
if 1 > y2 and y2 is not 0 , continue
t = long double = 1 . 0L * ( t1 * y1 + t2 * y2 ) / ( y1 + y2 )
if t > - t0 and t - t0 < = dif
if the absolute value of t - t0 - dif < 1e - 6 and y1 + y2 < Y1 + Y2 , then continue
dif = t = t0
Y1 = y1
Y2 = y2
print Y1 Y2
end the execution of code
ans , n = int and b = int array of size 20
a = two dimensional bool array of sizes 10 and 10
in function check returning bool
i , j , r , l , tot = int
for i = 1 to 5 inclusive
set l and r to 0
for j = 1 to 5 inclusive
if a [ i ] [ j ]
increment l
if b [ j ] increment r
if l - 1 > r return false
for i = 1 to 5 inclusive
set l and r to 0
for j = 1 to 5 inclusive
if a [ i ] [ j ]
increment l
if b [ 5 + j ] increment r
if l - 1 > r return false
set tot to 0
for i = 1 to 5 inclusive
for j = 1 to 5 inclusive
if a [ i ] [ j ] and not b [ i + 5 ] and not b [ j ] increment tot
if tot > 1 return false
return true
in function dfs taking int x
i , sum = int
if x is 11
if check
set sum to 0
for i = 1 to 11 inclusive
if b [ i ] is 1 increment sum
set ans to min of sum , ans
return
set b [ x ] to 1
call dfs of x + 1
set b [ x ] to 0
call dfs of x + 1
i , y = int
ch = char
k = int
read n
set all values of a to false
for i = 1 to n inclusive
read ch then k
if ch is ' R '
set y to 1
else if ch is ' G '
set y to 2
else if ch is ' B '
set y to 3
else if ch is ' Y '
set y to 4
else if ch is ' W '
set y to 5
set a [ y ] [ k ] to true
set all values of b to 0
set ans to 9999999
noop
call dfs of 1
print ans
new static double constant EPS = 1e - 5
new chat array colortable with elements ' R ' , ' G ' , ' B ' , ' Y ' and ' W '
int function getX with string argument s
for i from 0 to 5 exclusive incrementing i
if colortable [ i ] is equal to s [ 0 ] , return i
return - 1
getY is a integer function with string argument s
return s [ 1 ] - ' 1 '
bitcount is a int function with int argument b
declare new integer variable ans = 0
while b ! = 0
increment ans
change b to b & ( b - 1 )
return ans
bool function check with int arguments maskX and maskY and string arguments C1 and C2
x1 is a new integer = result of getX ( C1 )
create new integer variable x2 with value from getX ( C2 )
declare integer variable y1 = value , returned by getY ( C1 )
declare integer y2 = result of getY ( C2 )
return true if x1 is equal to x2 and y1 = y2
if x1 ! = x2
if ( maskX & ( 1 < < x1 ) ) ! = 0 | | ( maskX & ( 1 < < x2 ) ) ! = 0 , return true
if y1 ! = y2
if ( maskY & ( 1 < < y1 ) ) ! = 0 | | ( maskY & ( 1 < < y2 ) ) ! = 0 , return true
return false
declare new integer variable n
read n
cards is a new vector of strings with n elements
read n elements from the input into cards in a loop
declare new integer ans = 100000
start for loop from maskX = 0 to 1 < < 5 exclusive
start for loop from maskY = 0 to 1 < < 5 exclusive incrementing maskY
create boolean variable with name ok = true
incremen i in a loop from 0 , while ok is true and i < size of cards
if ok is true , set the value of ans to min of ans and bitcount ( maskX ) + bitcount ( maskY )
print ans to the standard output
create 2d integer array d with size 7 by 7
create integer n
declare as with integers x , y , node as arguments , returning void
if not x
set x [ node ] [ 1 ] to y
set d [ 1 ] [ node ] to y
set d [ node ] [ 2 ] to n - y
set d [ 2 ] [ node ] to n - y
if not y
set d [ node ] [ 1 ] to x
set d [ 1 ] [ node ] to x
set d [ node ] [ 3 ] to n - x
set d [ 3 ] [ node ] to n - x
if x is n
set d [ node ] [ 3 ] to y
set d [ 3 ] [ node ] to y
set d [ node ] [ 4 ] to n - y
set d [ 4 ] [ node ] to n - y
if y is n
set d [ node ] [ 2 ] to x
set d [ 2 ] [ node ] to x
set d [ node ] [ 4 ] to n - x
set d [ 4 ] [ node ] to n - x
create integers x1 , y1 , x2 , y2
read n read x1 read y1 read x2 read y2
for i = 1 to 6 inclusive
for j = 1 to 6 inclusive , set d [ i ] [ j ] to 3000
for i = 1 to 6 inclusive , set d [ i ] [ i ] to 0
set d [ 1 ] [ 2 ] to n
set d [ 2 ] [ 2 ] to n
set d [ 1 ] [ 3 ] to n
set d [ 3 ] [ 1 ] to n
set d [ 4 ] [ 2 ] to n
set d [ 2 ] [ 4 ] to n
set d [ 3 ] [ 4 ] to n
set d [ 4 ] [ 3 ] to n
run as with x1 , y1 , 5 as arguments
run as with x2 , y2 , 6 as arguments
if x1 is x2 and absolute value of ( y1 - y2 ) is less than n
set d [ 5 ] [ 6 ] to absolute value of ( y1 - y2 )
set d [ 6 ] [ 5 ] to absolute value of ( y1 - y2 )
if y1 is y2 and absolute value of ( x1 - x2 ) is less than n
set d [ 5 ] [ 6 ] to absolute value of ( x1 - x2 )
set d [ 6 ] [ 5 ] to absolute value of ( x1 - x2 )
for i = 1 to 6 inclusive
for j = 1 to 6 inclusive
for k = 1 to 6 inclusive
if d [ j ] [ i ] + d [ i ] [ k ] is less than d [ j ] [ k ]
set d [ j ] [ k ] to d [ j ] [ i ] + d [ i ] [ k ]
set d [ k ] [ j ] to d [ j ] [ i ] + d [ i ] [ k ]
print d [ 6 ] [ 5 ] print newline
a is an array of long longs with size 1001000
declare new array of long longs b with size 1001000
create long long variable n
read variable n from the input
for i from 0 to n exclusive
read variable a [ i ] from the input
increase b [ a [ i ] ] by one
sort first n elements of array a
declare new long long variable ans
for i = 0 to 1000100 exclusive
increase b [ i + 1 ] by b [ i ] / 2
change b [ i ] to b [ i ] modulo 2
if b [ i ] is true , increment ans
print ans
declare new integer variable n
read variable n from the input
declare an arrays of integers ar and br with n elements
read n new elements to ar and br in a loop
create new integer c with value 0
start for loop from j = 0 to n exclusive
in a for loop , change i from 0 to n exclusive
if i ! = j and ar [ j ] = br [ i ]
increment c
break the loop
print n - c
str = string
read str
a , b , c , d , x , y = long long int
a = str [ 0 ] - ' 0 '
b = str [ 1 ] - ' 0 '
c = str [ 3 ] - ' 0 '
d = str [ 4 ] - ' 0 '
y = c * 10 + d
x = a * 10 + b
s1 , s2 = vector of long long int
while true
clear s1
clear s2
increment y
if y is 60
y = 0
increment x
if x is 24 x = 0
add y / 10 at end of s2
add y modulo 10 at end of s2
add x / 10 at end of s1
add x modulo 10 at end of s1
if s1 [ 0 ] is s2 [ 1 ] and s1 [ 1 ] is s2 [ 0 ]
print s1 [ 0 ] , s1 [ 1 ] , " : " , s2 [ 0 ] , s2 [ 1 ]
function lcm with long long int arguments x and y that returns long long int
create new long long integer called i with value 1
increment i in a loop , while i < = x
return y * i if ( y * i ) % x = 0
define long long ints n , ans , k , i , res and j
read variable n from the input
if n < = 2
print n
else
if n is odd
print n * ( n - 1 ) * ( n - 2 )
else
change the value of ans to n * ( n - 1 )
set i to 2
set res to the result of lcm ( n - i , ans )
change the value of k to res / ans
for j = n - i - 1 to k exclusive counting down
change the value of res to max of res and lcm ( j , ans )
set the value of k to max of k and res / ans
print max of res and ( n - 1 ) * ( n - 2 ) * ( n - 3 )
create const long long MOD = 1e9 + 7
in function powmod return long long and accepting long long a , long long b , long long m = MOD
make long long r = 1
while b greater than 0
if b bitwise and 1 , set r to r * a % m
set a to a * a % m
bitwise shift b right by itself and 1
return r
in function power returning long long and having long long a and long long b as parameters
create long long r = 1
while b greater than 0
if b bitwise and 1 , set r to r * a
set a to a * a
bitwise shift b right by itself and 1
return r
in function gcd , taking long long a and long long b and returning long long
if not b , return a
return gcd ( b , a % b )
in function inv , returning long long with parameters long long a , long long m = MOD
return powmod ( a , m - 2 , m )
in function lcm with long long a and long long b as parameters and return type of long long
return ( a * b ) / gcd ( a , b )
create map mmap of string to long long
in function init
set mmap [ " monday " ] to 0
set mmap [ " tuesday " ] to 1
set mmap [ " wednesday " ] to 2
set mmap [ " thursday " ] to 3
set mmap [ " friday " ] to 4
set mmap [ " saturday " ] to 5
set mmap [ " sunday " ] to 6
call init
create string s1 and s2
read s1 and s2
create long longs n1 = mmap [ s1 ] and n2 = mmap [ s2 ]
if ( ( n1 + 31 ) % 7 equals n2 ) or ( ( n1 + 30 ) % 7 equals n2 ) or ( ( n1 + 28 ) % 7 equals n2 )
print " YES "
else
print " NO "
integer as n , k , a , ans = 1 , tmp
read n
if n is true do the following
read k , a
if a is 1 then do the following
set tmp to k + 1
else
set tmp to k
if a is greater than 1 then do the following
set a to ( a - 1 ) / 4 + 1
add one to
if ans is less than tmp then do the following ans = tmp
output ans
declare integer variable n
declare int sum = 0
declare integer variable npos = 0
declare int variable nneg = 0
let x be 2d integer array with size 100 by 2
read input to n
for i = 0 to n exclusive
for j from 0 to 2 exclusive , read x [ i ] [ j ]
for i from 0 to n exclusive
if x [ i ] [ 0 ] is greater than 0
increment npos
else
increment nneg
for i from 0 to n - 1 exclusive
for integer j = i + 1 to n exclusive
if x [ i ] [ 0 ] is greater than x [ j ] [ 0 ]
declare integer variables auxp and auxc
change auxp to x [ i ] [ 0 ]
change x [ i ] [ 0 ] to x [ j ] [ 0 ]
change x [ j ] [ 0 ] to auxp
set auxc to x [ i ] [ 1 ]
assign x [ j ] [ 1 ] to x [ i ] [ 1 ]
set x [ j ] [ 1 ] to auxc
if npos is greater than nneg
loop i from 0 to 2 * nneg + 1 exclusive , change sum to sum + x [ i ] [ 1 ]
else if npos is less than nneg
for i from n - ( 2 * npos + 1 ) to n exclusive , change sum to sum + x [ i ] [ 1 ]
else
loop i from 0 to n exclusive , set sum to sum + x [ i ] [ 1 ]
print sum
let n , L , a be integers
read n , L , a
result be an unsigned integer equals 0
integers prevbeg , prevlen equals 0
for currcase = 0 to n exclusive
begin , length be integers
read begin , length
if currcase not equals 0
integer breaktime equals begin - ( prevbeg + prevlen )
increase result by floor ( breaktime / a )
else
increase result by floor ( begin / a )
prevbeg equals begin
prevlen equals length
integer lastbreaktime = L - ( prevbeg + prevlen )
increase result by floor ( lastbreaktime / a )
print result and endline
create long long ints n and d
read n and d
create long long vector v of size n
for i = 0 to n exclusive , read v [ i ]
create unsigned long long ans = 0
let long long int j = 0
for i = 0 to n exclusive
while j is less than n and v [ j ] - v [ i ] is less than or equal to d , increment j
set ans to ans + ( j - i - 1 ) * ( j - i - 2 ) / 2
MAXN = const integer with MAXN = 1e6 + 10
INF = const integer with INF = 1e9 + 7
res , a , ans = strings with a = array of size 110
lt = character
isU , vis = bool array of size 110
n = integer
read n
for i = 0 to n exclusive
read a [ i ]
for j = 0 to a [ i ] . length ( ) exclusive
if ( isupper ( a [ i ] [ j ] ) ) , a [ i ] [ j ] = a [ i ] [ j ] - A - a
read res
ans = res
for i = 0 to res . length ( ) exclusive
if ( isupper ( res [ i ] ) )
res [ i ] = res [ i ] - A - a
isU [ i ] = 1
read lt
for i = 0 to res . length ( ) exclusive
for j = 0 to n exclusive
if ( res [ i ] = is a [ j ] [ 0 ] )
k = integer
for k = 0 to a [ j ] . length ( ) exclusive
if ( res [ i + k ] is not a [ j ] [ k ] ) , break loop
if ( k is a [ j ] . length ( ) )
for k = 0 to a [ j ] . length ( ) exclusive
if ( vis [ i + k ] ) , continue next iteration
if ( res [ i + k ] is not lt )
ans [ i + k ] = if isU [ i + k ] , lt - a + A else lt
else
for L = a to z
if ( res [ i + k ] is not L )
ans [ i + k ] = if isU [ i + k ] , L - a + A else L
break loop
vis [ i + k ] = 1
print ans
let n be a integer
read n
if n equals 1
print - 1 and newline
else
print n space n and newline
n , k , sub = int
t = string
read n then k then t
for i = 0 to n
if substring of t starting at position 0 and a length of i is substring of t starting at position n - i and a length of i then set sub to i
for i = 1 to k print substring of t starting at position 0 and the length of n - sub
print t
create new constant integer N with value 5e2 + 7
xinc is a new int array filled with 0 , 0 , 1 , - 1
yinc is a new int array with elements 1 , - 1 , 0 , 0
create integers n , m , x and y
declare double variables w and ans , and double array a with N elements
solve is a void function
set output decimal flag to fixed and precision to 15
read user input to n and m
for integer i = 1 to n inclusive , read standard input to a [ i ]
start for loop from i = 0 to m exclusive
read user input to x , y and w
set ans to max of ans and ( a [ x ] + a [ y ] ) / w
print ans and ' \ n ' to the standard output
create new integer called t
change t to 1
decrement t and loop further , while t is not 0
a = double double
read a
if a < = 127
else if a < = 32767
else if a < = 2147483647
else if a < = 9223372036854775807
else
N , INF = const integers with N = 3e2 + 10 , INF = 1e9
n , ans = integers
second = string
read n , second
for i = 0 to n exclusive
if second [ i ] is <
increment ans
else
break loop
for i = ( n - 1 ) down to 0
if second [ i ] is >
increment ans
else
break loop
let M be a constant integer with M = 1e5 + 10
let N be a constant integer with N = 1000
let cur be a string
let ispal be a function that accepts integers x , y and returns a integer
if x / 10 is equal to y modulo 10
if x modulo 10 is equal to y / 10 , return 1
while read cur
let h , m , ans be integers with ans = 0
h is equal to ( cur [ 0 ] - 0 ) * 10 + ( cur [ 1 ] - 0 )
m is equal to ( cur [ 3 ] - 0 ) * 10 + ( cur [ 4 ] - 0 )
while not ispal ( h , m )
increment m by 1
increment ans by 1
if m is equal to 60
m is equal to 0
increment h by 1
if h is equal to 24 , h is equal to 0
print ans and new line
declare integer variables x , t , a , b , da and db
read input to x , t , a , b , da and db
in a for loop , change i from 0 to t exclusive
for j from 0 to t exclusive incrementing j
declare integer pa with value a - da * i
declare new integer called pb = b - db * j
if any of pa + pb , pa , pb = x or x = 0
print " YES " and ' \ n ' to the stdout
print " NO " and ' \ n ' to the output
declare integer array N size 2
for i = 0 to 2 exclusive
declare character array str size 100
read str
if string compare between str and " monday " is 0
let N [ i ] be 1
else if string compare between str and " tuesday " is 0
let N [ i ] be 2
else if string compare between str and " wednesday " is 0
let N [ i ] be 3
else if string compare between str and " thursday " is 0
let N [ i ] be 4
else if string compare between str and " friday " is 0
let N [ i ] be 5
else if string compare between str and " saturday " is 0
let N [ i ] be 6
else if string compare between str and " sunday " is 0
let N [ i ] be 7
declare integer array arr size 11 = { 3 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 2 }
declare integer t = N [ 1 ] - N [ 0 ]
if t is less than 0 , increment t by 7
declare integer flag = 0
for i = 0 to 11 exclusive
if t is arr [ i ] , let flag be 1
if flag is true
print " YES " , newline
else
print " NO " , newline
x = integer 2d array of [ 5 ] [ 5 ]
f = bool with f = false
for i = 1 to 4
for j = 1 to 4 , read x [ i ] [ j ]
for i = 1 to 4
if x [ i ] [ 4 ]
for i = 1 to 3
if x [ i ] [ j ] , f = true ;
for j = 1 to 3
p = integer with p = i + j
if p > 4 , p = p - 4
if x [ p ] [ j ] , f = true
if f
else
let a , b , and s ints
read a , b , and s
set a to absolute value of a
set b to absolute value of b
if s < a + b or s - a - b is odd
otherwise
make ints n and t
read n and t
create string s
read s
make integer i = 0
while i is less than n and s [ i ] is not equal to ' . ' , increment i
if i is not equal to n and t is greater than 0
make integer p = i
increment i
while i is less than n and s [ i ] is less than ' 5 ' , add 1 to i
if i is not equal to n
set s to s . substr ( 0 , i )
subtract 1 from i
add 1 to s [ i ]
take away 1 from t
decrease i by 1
while i is greater than p , s [ i + 1 ] is more than ' 4 ' , and t is greater than 0
increment s [ i ]
set s [ i + 1 ] to ' 0 '
decrease t by 1
decrease i by 1
if s [ i + 1 ] is equal to ' / '
set s to s . substr ( 0 , i + 1 )
while i is greater than or equal to 0 and s [ i ] is equal to ' 9 '
set s [ i ] to ' 0 '
decrease i by 1
if i is not equal to - 1
increment s [ i ]
else
output 1
else if i is equal to p , s [ p + 1 ] is greater than ' 4 ' , and t is greater than 0
take away 1 from t
set s to s . substr ( 0 , i )
decrease i by 1
while i is greater than or equal to 0 and s [ i ] is equal to ' 9 '
set s [ i ] to ' 0 '
reduce i by 1
if i not equal to - 1
increment s [ i ] by 1
else do
print 1
otherwise
set s to s . substr ( 0 , i + 2 )
declare ok with string t as argument , returning boolean
declare integer msk = 0
for i = 0 to integer casted size of t exclusive
if t [ i ] is upper case , let msk be msk bitwise or 1
if t [ i ] is lower case , let msk be msk bitwise or 2
if t [ i ] is digit , let msk be msk bitwise or 4
return mks is 7
declare integer t
declare string s
read t
for i = 0 to t exclusive
read s
if result of run ok ( s ) is true
print s and newline
end current loop iteration
declare boolean fnd = false
for i = 0 to integer casted size of s exclusive
deeclare string t = s
let t [ i ] be ' 1 '
if result of run ok ( t ) is true
print t , newline
let fnd be true
end loop
let t [ i ] be ' a '
if result of run ok ( t ) is true
print t , newline
let fnd be true
end loop
let t [ i ] be ' A '
if result of run ok ( t ) is true
print t , newline
let fnd be true
end loop
if fnd is true , end loop iteration
if s [ 2 ] is upper case
let s [ 0 ] be ' a '
let s [ 1 ] be ' 1 '
print s , newline
end loop iteration
if s [ 2 ] is lower case
let s [ 0 ] be ' A '
let s [ 1 ] be ' 1 '
print s , newline
end loop iteration
if s [ 2 ] is digit
let s [ 0 ] be ' a '
let s [ 1 ] be ' A '
print s , newline
end loop iteration
declare long longs N , M , K
while read N , M , and K
ans is a long long with ans initialized to 0
set ans to call max with arguments N / ( K + 1 ) * M , M / ( K + 1 ) * N
if K + 1 is greater than N , set ans to call max with arguments ans , M / ( K - N + 2 )
if K + 1 is greater than M , set ans to call max with arguments ans , N / ( K - M + 2 )
if K + 2 is greater than M + N , set ans to - 1
display ans
declare character array a with size 1204000
loop when read input to a
create int array A with 1204 elements
declare integer ans = 0
declare integer r = 0
declare integer flag = 0
declare integer p = 0
for i from 0 to exclusive incrementing i
if a [ i ] is ' ? '
if flag is false
change A [ r ] to 1
increment r
increment p
if flag is true
assign - 1 to A [ r ]
increment r
decrement p
if a [ i ] is ' - ' , change flag to 1
if a [ i ] is ' + ' , change flag to 0
if a [ i ] > = ' 0 ' and a [ i ] < = ' 9 ' , change n to n * 10 + a [ i ] - ' 0 '
loop i from 0 to r exclusive incrementing i
if A [ i ] is less than 0
if p is greater than n
looping infinitely
if absolute value pf A [ i ] > = n or p = n , stop the loop
decrement A [ i ]
decrement p
else if A [ i ] is greater than 0
if p is less than n
in the infinite loop
if A [ i ] > = n or p = n , stop the loop
increment A [ i ]
increment p by one
if p ! = n
print " Impossible "
else
print " Possible "
if A [ 0 ] is greater than 0
print A [ 0 ]
else
print A [ 0 ]
for i = 1 to r exclusive
print " "
if A [ i ] is greater than 0
print " + "
else
print " - "
print " " and absolute value of A [ i ]
print " = " and n
let lucky a vector of long longs
in function baktrack which takes long long x
if x > 1e10 , return
append x to lucky
apply backtrack to x * 10 + 4
apply backtrack to x * 10 + 7
let ans a long long with value 0
apply backtrack to 0
let a and b ints
read a and b
for i from 1 to ( int ) size of lucky exclusive
let l , r , and m ints
set l to a and r to b
while l at most r
right shift l + r by 1 and store result in m
if m at most lucky [ i ]
add lucky [ i ] * ( m - l + 1 ) to ans
set a to m + 1
decrement i
leave loop
otherwise
set r to m - 1
maxn = constant integer = 105
a = integer array of size maxn
b = integer array of size maxn
vis = integer array of size maxn
n = integer
num = integer = 0
read n
for i = 0 to n exclusive , read a [ i ] , b [ i ]
set all element of vis to 0
for i = 0 to n exclusive
for j = 0 to n exclusive
if i is not j and b [ i ] is a [ j ] , then vis [ j ] = 1
for i = 0 to n exclusive , then num = num + vis [ i ]
print n - num
a = array of long integers of length 100005 , b = array of long integers of length 100005 , c = array of long integers of length 100005
let n , sum , s be long integers
while read n
sum is equal to 0
s is equal to 0
for i = 0 to n exclusive , read a [ i ]
a [ n ] is equal to 0
for i = 0 to n exclusive
if not ( i modulo 2 )
b [ i ] is equal to absolute value of ( a [ i ] - a [ i + 1 ] )
b [ i ] = - absolute value of ( a [ i ] - a [ i + 1 ] )
c [ i ] = - b [ i ]
for i = 0 to n - 1 exclusive
increment sum by b [ i ]
if sum is less than 0 , sum is equal to 0
s is equal to maximum of sum and s
sum is equal to 0
for i = 0 to n - 1 exclusive
increment sum by c [ i ]
if sum is less than 0 , sum is equal to 0
s is equal to maximum of sum and s
print s and newline
maxn = const long long with maxn = 1e5 + 8
t = string
vis = int array of size maxn
read t
len = int with len = size of t
if len is less than 4
print " NO "
else
a , b , c , d = int
set a to find of " AB " on t
set b to find of " BA " and a + 2 of t
set c to find of " BA " on t
set d to find of " AB " and c + 2 of t
if a and b are not - 1 or c and d are not - 1
print " YES "
else
print " NO "
declare long long integers p , q
declare long long integer array primes size 2100000
declare long long integer pi size 2100000
declare long long integer rub size 2100000
declare integer ans
declare inv with integer x as argument , returning integer
declare integer ret = 0
while x is not 0
let ret be ret * 10 + x % 10
let x be x / 10
return ret from function
declare chk with integer x as argument , returning integer
if result of run inv ( x ) is x , return 1
read p and q
declare integers i , j
for i = 2 to 2050000 inclusive , let primes [ i ] be 1
for i = 2 to 2050000 inclusive
if primes [ i ] is 1
for j = 2 to i * j is less than or equal to 2060000 , incrementing j , let primes [ i * j ] be 0
for i = 2 to 2050000 inclusive , let pi [ i ] be pi [ i - 1 ] + primes [ i ]
for i = 1 to 2050000 inclusive , let rub [ i ] be rub [ i - 1 ] + result of run chk with i as argument
for i = 2050000 to 1 inclusive , decrementing i
if q * pi [ i ] is less than or equal to p * rub [ i ]
print i and newline
vetor = int vector
n , i , colunas = int
read n
for i = 0 to n
read colunas
append colunas to vetor
for i = 0 to n - 1 print vetor [ i ] then " "
print last element of vetor
declare constant long long integer MAXN = 1e4 + 5
declare constant long long integer MINN = 1e2
declare constant inf = ( 1e6 + 5 )
declare it = 0 , k , k1 as integers
declare long long array a size MAXN , long long sum
declare create with long longs s , l as arguments , returning void
if l is greater than 0 , let a [ increment it ] be s
if l is less than 10 , run create with s * 10 + 4 , l + 1 as arguments
if l is less than 10 , run create ( s * 10 + 7 , l + 1 )
return from function
run create ( 0 , 0 )
sort from a to a + it
declare l , r as integers
read l and r
for i = 0 to ( it - 2 ) inclusive
if a [ i ] is greater than or equal to l
let k be i
end loop
for i = 0 to it - 2 inclusive
if a [ i ] is greater than or equal to r
let k1 be i
end loop
while k is not k1
increment sum by a [ k ] * ( a [ k ] - l + 1 )
let l be a [ k ] + 1
increment k
increment sum by ( r - l + 1 ) * a [ k1 ]
print sum and newline
let S be a string
let N , M , A , B , sum , x , y , and K be integers
let cek be an array of booleans of size 26
read in N , A , and B
if B is less than N
print NO and a newline
else if B is equal to N + 1
print NO and a newline
else if ( B - N ) % A is equal to 0 or ( B - N ) % A is equal to 1
print YES and a newline
or else
print NO
declare long long array dp with length of 100005
declare integer n
read n
declare long long array a with length of n
declare long long array b with length of n
declare long long array c with length of n
for i = 0 to n - 1 exclusive
set b [ i ] to abs of a [ i + 1 ] - a [ i ]
if i is odd , multiply b [ i ] by itself and - 1
for i = 0 to n - 1 exclusive
set c [ i ] to abs of a [ i + 1 ] - a [ i ]
if i is even , multiply c [ i ] by itself and - 1
define long long ans with value b [ 0 ]
define long long minimum with value b [ 0 ]
for i = 1 to n - 1 exclusive
increase b [ i ] by b [ i - 1 ]
set ans to max of ans and b [ i ] - minimum
set ans to max of ans and b [ i ]
set minimum to min of minimum and b [ i ]
set minimum to c [ 0 ]
for i = 1 to n - 1 exclusive
add c [ i - 1 ] to c [ i ]
set ans to max of ans and c [ i ] - minimum
set ans to max of ans and c [ i ]
set minimum to min of minimum and c [ i ]
print ans
v = two dimensional int array of sizes 110 and 110 and visited = int array of size 110 with all values set to 0 and k = int array of size 110
n , m = int
in function dfs taking int a
set visited [ a ] to 1
for i = 1 to k [ a ] inclusive
for j = 1 to n inclusive
if visited [ j ] is 0
for p = 1 to k [ j ]
if v [ j ] [ p ] is v [ a ] [ i ] call dfs of j
read n then m
sum , ans = int with sum = 0 and ans = 0
i , j = int
for i = 1 to n inclusive
read k [ i ]
for j = 1 to k [ i ] inclusive
read v [ i ] [ j ]
increment sum by v [ i ] [ j ]
if sum is 0
print n
for i = 1 to n inclusive
if visited [ i ] is 0
increment ans
cal dfs of i
print ans - 1
let M be a constant integer with M is equal to 1005
let n be a integer
let x1 , y1 , x2 , y2 be integers
read n , x1 , y1 , x2 , y2
integer disx = x1 - x2 if x1 is greater than x2 else disx = x2 - x1
integer disy = y1 - y2 if y1 is greater than y2 else disy = y2 - y1
let disx + disy is assigned to dis
if disx is equal to n , dis is equal to y1 + y2 + n
if disy is equal to n , dis is equal to x1 + x2 + n
if dis < = 2 * n
print dis and newline
print 4 * n - dis and newline
create integer n
read n
create map d from integer to integer
create integers q , w , a , s , z , x , with a = 0 , s = 0 , z = 0 , x = 0
for i = 0 to n exclusive
read q read w
if q is less than 0
set a to a + 1
set s to s + w
if q is greater than 0
set z to z + 1
set x to x + w
insert new pair of integer , integer initialized with ( q , w ) into d
insert new pair of integer , integer initialized with ( 0 , 0 ) into d
create integer y with y = a
create integer sum with sum = 0
if a is z
print s + x print newline
else if a is less than z
set sum to sum + s
create integer h with h = a + 1
for b = first index of 0 in d to b is not end of d , incrementing b
if h is greater than or equal to 0
create integer g with hg = second element of b
set sum to sum + g
else
break loop
decrement h
print sum print newline
else
set sum to sum + x
create integer h with h = z + 1
for b = first index of 0 in d to b is not end of d , decrementing b
if h is greater than or equal to 0
create integer g with g = second element of b
set sum to sum + g
else
break loop
decrement h
print sum print newline
declare constant integer maxn = 100000 + 5
a is an array of integers with maxn elements
declare new integer variables n , m and k
read n from the user input
read m from the user
read from the input to k
declare new integer i
if n is even
print 0
declare new long long called ans with value 0
nn is a new integer variable with value n / 2 + 1
if nn is greater than m
assign 0 to ans
else
set ans to a [ 0 ]
in a for loop , change i from 0 to n exclusive
if i & 1 is equal to 0 , change the value of ans to ans if ans < a [ i ] and a [ i ] otherwise
declare new long long integer aa
change aa to n / nn * k
set ans to min of ans and aa
print ans
a = array of int filled with 8 , 4 , 2 , 6
n = int
read n
if n is not 0
print a [ ( n - 1 ) modulo 4 ]
else
print 1
maxn is a constant integer set to 101000
mo is a constant integer set to 1e9 + 7
ans is a long long
f , n , m , h are integers
a , c , sum are all integer arrays all of size maxn , k is an integer
b = integer array of size maxn , flag = integer , temp = integer
s is a character array of size maxn
T is an integer
cas is an integer set to 1
while read n , m
assign n * 2 + 1 to n
assign 0 to ans
read n values into array a
display a [ 0 ] , " "
for i = 1 to n - 1 exclusive
if m and a [ i ] are greater than a [ i - 1 ] + 1 and a [ i ] is greater than a [ i + 1 ] + 1
display a [ i ] - 1 , " "
decrement m
else
display a [ i ] , " "
display a [ n - 1 ]
n , m , k , l , tmp , tmp2 = long long
read n , m , k , l
if k + l > n then return print - 1
set tmp to ( l + k ) / m ) + ( ( l + k ) % m isn ' t 0
if m * tmp2 > n
print - 1
else
declare new integer n
declare integer variable a with value 0
read n from the user input
if n is odd
decrease n by 3
change the value of n to n divided by 2
change a to the sum of a and n + 1
print a and " \ n "
print 2 and " " in a loop a - 1 times
print 3 and " \ n "
else
change a to a + n / 2
print a and " \ n "
in a for loop , change i from 1 to a inclusive
if i is equal to a
print 2 and " \ n "
else
print 2 and " "
M = constant integer set to 100 + 5
s = string
read s
for i = 0 to length of s exclusive
if s [ i ] is ' : ' , set s [ i ] to ' '
declare ss with s , as a string stream
h , m = integer
ss to h to m
if s [ 1 ] > = ' 0 ' and s [ i ] < = ' 5 '
pm = integer set to s [ 1 ] - ' 0 ' * 10 + s [ 0 ] - ' 0 '
if m < pm
if h / 10 is 0
print " 0 " , h , and " : "
else
print h and " : "
if pm / 10 is 0
print " 0 " and pm
else
print pm
else
set h to h + 1 modulo 24
while h modulo 10 > 5 , set h to h + 1 modulo 24
pm = integer set to h modulo 10 * 10 + h / 10
if h / 10 is 0
print " 0 " , h , and " : "
else
print h and " : "
if pm / 10 is 0
print " 0 "
else
print pm
else
set h to h + 1 modulo 24
while h modulo 10 > 5 , set h to h + 1 modulo 24
pm = integer set to h modulo 10 * 10 + h / 10
if h / 10 is 0
print " 0 " , h , and " : "
else
print h and " : "
if pm / 10 is 0
print " 0 " and pm
else
print pm
n = integer
while read n
if n bitwise and 1
subtract 3 from n
shift n right 1 bit
output n + 1
for i = 1 to n inclusive , output " 2 "
else
shift n right 1 bit
output n
for i = 1 to n exclusive , output " 2 "
let n and count be long longs with count = 0
read standard input to n
declare constant integer max_i = 2e5
declare new integer counter with value 0
create an array of tuples of int , int , int > called data with max_i + 9 elements
in a for loop , change i from 0 to n exclusive incrementing i
declare long long variables k , a0 , x , y , m , t and a where t and a = 0
read from the input to k , a0 , x , y and m
in a for loop , change j from 0 to k exclusive
if counter < = max_i , change the value of data [ counter ] to the new tuple from make_tuple ( t , a0 , i ) and increment counter
change the value of a to ( a0 * x + y ) % m
if a < a0 and j ! = k - 1 , increment t by one
change a0 to a
change the value of count to max of count and t
print count
if counter < = max_i
sort data from the start to the index = counter
s = string
read s
len = integer = length of s
i = integer = 0
f = integer = 1
for i = 0 to len exclusive
if s [ i ] isn ' t the character a , set f to 0
if f
set s [ len - 1 ] to the character z
print s
while s [ i ] is the character a and i is less than len , print s [ i ] , increment i
flag = integer = 0
iterate as long as i is less than n with increment i + 1
if s [ i ] is the character a , set flag to 1
if flag
print s [ i ]
else
print character value of ( s [ i ] - 1 )
print newline
let str be a string
let i , j be integers
input str
for i = 0 to size of str exclusive
if str [ i ] isn ' t the character a , break
for j = i to size of str exclusive
if str [ j ] is the character a , break
decrement str [ j ]
if i equals size of str , assign the character z to str [ ( size of str ) - 1 ]
display str
n = long long int
ini , med , fin , test = long long int
read n
set ini to 1
set fin to ( - 1 + sqrt of ( 1 + 8 * n ) ) / 2
loop while ini < = fin
set test to ( ( ( ini * ( ini + 1 ) ) / 2 ) + ( ( fin * ( fin + 1 ) ) / 2 ) )
if test is n break
if test < n
increment ini
else
decrement fin
if ini < = fin
print " YES "
else
print " NO "
mod = 1000000007
n , p = long long
in , out , child , dia = array of 1005 long long
read n , p
x , y , z = long long
while decremented value of p not equal 0
read x , y , z
increment in [ y ]
increment out [ x ]
child [ x ] = y
dia [ x ] = z
cnt = 0
for i = 1 to n inclusive
if not in [ i ] and out [ i ] increment cnt
idx , c = long long
for i = 1 to n inclusive
if not in [ i ] and out [ i ]
idx = i
c = 10 ^ 18
while out [ idx ]
c = min ( c , dia [ idx ] )
idx = child [ idx ]
print i , space , idx , space , c , newline
declare constant integer base = 1000 * 1000 * 1000
declare constant integer N = integer casted 2e5 + 2
declare constant integer INF = integer casted 1e9 + 7
declare constant long double pi = acosign of - 1
declare constant long long linf = long long casted 1e18
declare string s
declare integer k
read s and k
if integer casted size of s % k is not 0 , return print " NO \ n " , 0
declare integer kol = 0
for i = 0 to integer casted size of s exclusive , incrementing i by integer casted size of s / k
declare string cur
declare string rs = cur
reverse sort from beginning of rs to end of rs
if cur is rs , increment kol
if kol is k
print " YES \ n "
else
print " NO \ n "
create ints h , m , and count = 0
make char c
read h , c , and m
loop indefinitely
if h / 10 is equal to m % 10 and m / 10 is equal to h % 10 , break loop
add 1 to m
if m is equal to 60 , increment h and set m to 0
if h is greater than 23 , set h to 0
add 1 to count
print count
declare int temp
declare map c with int keys and int values
declare map m with int keys and int values
read temp
increase m [ 1 ] by temp
increase m [ 4 ] by temp
read temp
increase m [ 1 ] by temp
increase m [ 3 ] by temp
read temp
increase m [ 1 ] by temp
increase m [ 2 ] by temp
read temp
increase c [ 1 ] by temp
read temp
increase m [ 1 ] by temp
increase m [ 2 ] by temp
read temp
increase m [ 2 ] by temp
increase m [ 4 ] by temp
read temp
increase m [ 3 ] by temp
increase m [ 2 ] by temp
read temp
increase c [ 2 ] by temp
read temp
increase m [ 3 ] by temp
increase m [ 2 ] by temp
read temp
increase m [ 1 ] by temp
increase m [ 3 ] by temp
read temp
increase m [ 3 ] by temp
increase m [ 4 ] by temp
read temp
increase c [ 3 ] by temp
read temp
increase m [ 3 ] by temp
increase m [ 4 ] by temp
read temp
increase m [ 4 ] by temp
increase m [ 2 ] by temp
read temp
increase m [ 1 ] by temp
increase m [ 4 ] by temp
read temp
increase c [ 4 ] by temp
define int flag = 0
if c [ 1 ] is greater than 0
if m [ 1 ] is greater than 0 : set flag to 1
if c [ 2 ] is greater than 0
if m [ 2 ] is greater than 0 : set flag to 1
if c [ 3 ] is greater than 0
if m [ 3 ] is greater than 0 : set flag to 1
if c [ 4 ] is greater than 0
if m [ 4 ] is greater than 0 : set flag to 1
if flag equals 0
print " NO "
else
print " YES "
fs = string vector
valid = long long integer array of size 200
n , in = long long integers
read n
h , w , k = strings
ch = char
for i = 0 to n exclusive
read h
add h to end of fs
read w and ch
if ch - ' a ' > = 0 or ' z ' - ch > = 0
set in = ch - ' a '
set in = ch = ' A '
set k = w
for i = 0 to n exclusive
create long long integer z = length of fs [ i ]
for j = 0 to length of w exclusive
create a empty string temp
for k = j to j + z exclusive set temp = temp + w [ k ]
if temp is equal to fs [ i ]
for k = j to j + z exclusive set valid [ k ] = 1
create empty string res
for i = 0 to length of w exclusive
if valid [ i ] is not 0
if k [ i ] > = ' a ' and k [ i ] < = ' z '
if k [ i ] - ' a ' is not equal to in
set res = res + ' a ' + in
if ch > ' a ' and ch < = ' z '
set res = res + ' a '
else if ch = ' a '
set res = res + ' b '
else ch > ' A ' and ch < = ' Z '
set res = res + ' a '
else if ch = ' A ' then do the following
set res = res + ' b '
if k [ i ] - ' A ' is not equal to in
set res = res + ' A ' + in
if ch > ' A ' and ch < = ' Z '
set res = res + ' A '
else if ch = ' A
set res = res + ' B '
else if ch > ' a ' and ch < = ' z '
set res = res + ' A '
else if ch = ' a ' then do the following
set res = res + ' B '
set res = res + k [ i ]
print res
declare character variable maohao
declare integers h and m
read h , maohao and m
in a for loop , change i from 0 to 16 exclusive
if ( hor [ i ] = h & & mie [ i ] > m ) or hor [ i ] > h
if hor [ i ] is less than 10 , print " 0 "
print hor [ i ] and " : " to the standard output
if mie [ i ] is less than 10 , print " 0 "
print mie [ i ]
print " 00 : 00 "
t = int
read t
x = int array of size 1000020
for i = 0 to 1000020 set x [ i ] to 0
for i = 0 to t
temp = int
read temp
increment x [ temp ]
sum = int with sum = 0
for i = 0 to 1000020
increment x [ i + 1 ] by x [ i ] bitshift right by 1
set x [ i ] to x [ i ] bitwise - and 1
for i = 0 to 1000020 increment sum by x [ i ]
print sum
i , j , k , m , n , k0 , k1 = integers with k0 = k1 = 0
s = array of characters of size 1000
read n
read s
for i = 0 to n exclusive
if s [ i ] is 0 then increment k0
if s [ i ] is 1 then increment k1
if k1 > 0
then print 1
for i = 0 to k0 print 0
print new line
print 0
declare gcd1 taking in long long ints a and b and returning long long
if a is 0 , return b
return the return value of gcd1 ( b % a , a )
declare modx taking in long long ints base and ex and returning long long
make long long ints ans = 1LL and val = base
while ex is greater than 0LL
if ex & 1LL is truthy , set ans to ( ans * val ) % 1000000009LL
set val to ( val * val ) % 1000000009LL
set ex to ex > > 1LL
return ans
create constant integer maxn = 1e5 + 10
set bool arrays visit of size maxn and visit1 of size maxn
create ints n , m , x , and y and int array a of size maxn
create bool arrays D of size maxn and P of size maxn
make int vectors adj of size maxn and v of size maxn
declare dfs taking in int start
set visit [ start ] to true
for i = 0 to adj [ start ] . size ( ) exclusive
make integer pt = adj [ start ] [ i ]
if visit [ pt ] is falsy , call dfs ( pt )
declare dfs2 taking in int start
set visit1 [ start ] to true
for i = 0 to v [ start ] . size ( ) exclusive
make integer pt = v [ start ] [ i ]
if visit1 [ pt ] is falsy , call dfs2 ( pt )
read n and m
for i = 1 to n , read a [ i ]
for i = 1 to m
read x and y
append y to adj [ x ]
if a [ x ] is not equal to 1 and a [ y ] is not equal to 1 , append x to v [ y ]
for i = 1 to n
if visit [ i ] is falsy and a [ i ] is 1 , call dfs ( i )
for i = 1 to n
if visit1 [ i ] is falsy and a [ i ] is 2 , call dfs2 ( i )
for i = 1 to n
if a [ i ] is not equal to 1 , continue to next loop iteration
for j = 0 to adj [ i ] . size ( ) exclusive
create int pt = adj [ i ] [ j ]
if visit1 [ pt ] is truthy and a [ pt ] is not equal to 1 , set visit1 [ i ] to true
for i = 1 to n
if visit1 [ i ] and visit [ i ] are truthy
show 1
else
display 0
let t1 , t2 , x1 , x2 , t0 , res_x , res_y be long integers
read t1 , t2 , x1 , x2 , t0
let t , ct be double values with ct = 1e99
while x1 > = 0 and x2 > = 0
t is equal to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if t is less than t0
decrement x1 by 1
proceed to next
if t is less than ct
ct is equal to t
res_x is equal to x1
res_y is equal to x2
decrement x2 by 1
print res_x and ' ' and res_y and newline
MAXN = const integer with MAXN = 1e6 + 2007
cnt = integer array of size MAXN
n = integer
read n
for i = 0 to n exclusive
p = integer
read p
increment cnt [ p ]
ans = integer with ans = 0
for i = 0 to MAXN - 1 exclusive
ans = ans + cnt [ i ] & 1
cnt [ i + 1 ] = cnt [ i + 1 ] + right shift cnt [ i ] 1 place
m , n = int
while m , n can be read
a , b , c , d = int arrays storing 11 values
for int i = 0 to m
read a [ i ]
let c [ i ] = 10
for int i = 0 to n , read n [ i ]
for int i = 0 to m
for int j = 0 to n
if b [ j ] = = a [ i ] , let c [ i ] equal a [ i ]
k = int , k = 0
for int i = 0 to m
if c [ i ] is not 10
let d [ k ] equal c [ i ]
add one to k
if k equals 0
end line
else
for int i = 0 to k - 1 , print d [ i ] , space
print d [ k - 1 ]
n , k = integers
read n , k
num = integer array of size 100005
for i = 1 to n - k , num [ i ] = i
flag = integer with flag = ( n - k ) modulo 2
for i = n - k + 1 to n
if i modulo 2 is flag
num [ i ] = num [ i - 1 ] - k
else
num [ i ] = num [ i - 1 ] + k
decrement k
for i = 1 to n
if i is 1
print num [ i ]
else
print ' ' , num [ i ]
print new line
s = string
a = integer = 0 , b = integer = 0 , v = integer = 0
read s
for i = 1 to length of s exclusive
if s [ i = 1 ] > s [ i ]
print NO
for i = 0 to length of s exclusive
if s [ i ] is a
increase a by 1
else if s [ i ] is b
increase b by 1
else
increase c by 1
if a > 0 and b > 0 and ( c is a or c is b )
print YES
else
print NO
n , m , a , b = integer
in function solve that returns nothing
x = integer = a / m + ( a modulo m is not 0 ) , y = integer = b / m + ( b modulo m is not 0 )
if m is 1
print 1
else if b is n
if a modulo m is 1 or x is y
print 1
else
print 2
else if a modulo is 1 and b modulo m is 0 or x is y
print 1
else if a modulo is 1 or b modulo m is 0 or y is x + 1 or ( b + 1 ) modulo m is a modulo m
print 2
else
print 3
print endline
while n , m , a , b can be read as valid integers , call solve
define const int MAXN = 5000 + 7 , DELTA = 1000 * 1000 * 1000 + 7
declare long long array of array numberOfPartialAns , size MAXN x MAXN
declare string s , t
read s , t
for i = 1 to size of s cast to int inclusive
for j = 1 to size of t cast to int inclusive
set numberOfPartialAns [ i ] [ j ] to numberOfPartialAns [ i ] [ j - 1 ]
if s [ i - 1 ] equals t [ j - 1 ]
increase numberOfPartialAns [ i ] [ j ] by numberOfPartialAns [ i - 1 ] [ j - 1 ]
set numberOfPartialAns [ i ] [ j ] to numberOfPartialAns [ i ] [ j ] mod DELTA
increment numberOfPartialAns [ i ] [ j ]
set numberOfPartialAns [ i ] [ j ] to numberOfPartialAns [ i ] [ j ] mod DELTA
define long long ans = 0
for i = 1 to size of s cast to int inclusive
increase ans numberOfPartialAns [ i ] [ ( int ) t . size ( ) ]
set ans to ans mod DELTA
print ans
declare integer array t and l , both of size 100005
declare integer n , L , a
read n , L , a
read n values into t and l
define integer ans = 0
for i = 1 to n exclusive do add ( t [ i ] - t [ i - 1 ] - l [ i - 1 ] ) / a to ans
if n
increase ans by t [ 0 ] / a
increase ans by ( L - t [ n - 1 ] - l [ n - 1 ] ) / a
else
set ans to L / a
print ans
create char f [ 1005 ] , ff [ 1005 ]
create int n and k
read f
read k
set n to length of f
if n mod k different from 0
a = n / k
assign - 1 to p
set flag to 1
while p different from n - 1
for i = 0 to a exclusive
increment p
ff [ i ] = f [ p ]
flagg = 1
set b to 0 and e = a - 1
while b < = e
if ff [ b ] different from ff [ e ]
flagg = 0
break
increment b
decrement e
if flagg = 0
set flag to 0
break
if flag different from 0
else
create char a [ 1010 ]
create int n
f = true
read a + 1 , n
len = length of a + 1
if len mod n different from 0
if len = n
set ave = len / n
i = 1 to len inclusive , with increment of i + ave
x = i
set y to i + ave - 1
if a [ x ] different from a [ y ]
f = false
break
while a [ x ] = a [ y ]
increment x
decrement y
if x > = y , break
if a [ x ] different from a [ y ]
f = false
break
if f = 0 , break
if f different from 0
else if f = 0
declare string s
declare integer n
read s
let n be integer casted size of s
declare integer idx = 0
while idx is less than n and s [ idx ] is ' a ' , increment idx
if idx is n , let s [ idx - 1 ] be ' z '
while idx is less than n and s [ idx ] is not ' a ' , decrement s [ idx ] , increment idx
print s and newline
create int n , zer and jed , set zer and jed to 0
create string s and t
read n
read s
for i = 0 to n exclusive
if s [ i ] = 0
increment zer
else
add 1 to jed
if jed = 0
t = s
else
t = 1
while zer > 0
assign 0 to last element of t
decrement zer
print t
n , s = long long
read n
m , maxi = long long vector of size n each
for i = 0 to n
read m [ i ]
set maxi [ i ] to - 1
for j = 0 to m [ i ]
read s
set maxi [ i ] to max of maxi [ i ] , s
maximum , ans = long long with maximum = value of max_element of begin of maxi , end of maxi and ans = 0
for i = 0 to n increment ans by m [ i ] * ( maximum - maxi [ i ] )
let a = array if integers with size = 100050 and values = 0
let p , res , ui = integers with values = 0
let T = integer
read T
while ( decrement T ) is true read a [ increment p ]
call sort on a and a + p
for integer i = 0 to p - 1 inclusive do the following
for integer k = ui to p - 1 inclusive
if a [ ui ] is less than or equal to a [ i ]
increment ui
else
exit the loop
if ui is less than p increment res and increment ui
print res
let n , m , max , idx = integers with max = - 1
let x = float
read n , m
for integer i = 0 to n exclusive do the following
read x
set x = round up of x / m
if x is greater than or equal to max do the following
set max = x
set idx = i
print idx + 1
declare ints n , v , sum and cnt
create int array ans with size 60 and 2d array s with 60 by 60
read user input to n and v
change the value of sum to 0
change cnt to 0
start for loop from i1 = 0 to n exclusive
create integer k
read user input to k
in a for loop , change i2 from 0 to k exclusive
read s [ i1 ] [ i2 ] from the user input
increment sum if v is greater than s [ i1 ] [ i2 ]
if sum is greater than 0
assign i1 + 1 to ans [ cnt ]
increment cnt
set sum to 0
print cnt to the standard output
for i2 = 0 to cnt exclusive
if i2 ! = cnt - 1
print ans [ i2 ] and " " to the standard output
else
print ans [ i2 ]
let n be a integer
create a vector of strings by name v
create a vector of strings by name q which is of size n
for i = 0 to n exclusive , read q [ i ]
return the value of q
rot = vector of strings , q = vector of strings
assign the vector of strings a to q
for i = 0 to n exclusive
for j = 0 to n exclusive , a [ i ] [ j ] is equal to q [ n - 1 - j ] [ i ]
return the value of a
read n
vector < string > a is equal to g ( )
vector < string > b is equal to g ( )
reverse the values of string b from beginning to end
if ok1 or ok2
print Yes and newline
print No and new line
make int n
read n
if n mod 2
print ( n + 1 ) / 2 - 1
else
print ( n ^ ( 1 < < ( 31 - __builtin_clz ( n ) ) ) ) / 2
N = constant integer = 50000
ans = long long , a = long long array of size N , s = long long array of size N , h = long long array of size N
x , n = integers
ss = string
read x , ss
n = size of ss
for i = 0 to n inclusive
a [ i + 1 ] = ss [ i ] - 0
s [ i + 1 ] = s [ i ] + a [ i + 1 ]
for i = 1 to n inclusive
for j = 0 to i exclusive , then increase h [ s [ i ] - s [ j ] ] by 1
if x is nonzero
for i = 0 to s [ n ] inclusive , then ans = ans h [ 0 ] * h [ i ]
for i = 1 to s [ n ] inclusive
if x modulo i is 0 and x / i < = s [ n ] then ans = ans + h [ i ] * h [ x / i ]
create integers x and y
create integer ans
read x and y
if x equals 0 and y equals 0
print " 0 "
else
create integer n
if the absolute value of x is greater than or equal to the absolute value of y
set n to the absolute value of x
else
set n to the absolute value of y
set ans to the result of ( n - 1 ) * 4
if x is greater than or equal to n - 1 and x is less than or equal to n and y is equal to 1 - n
ans
else if x is equal to n and y is greater than of equal to 1 - n and y is less than or equal to n
increment ans
else if x is greater than of equal to - n and x is less than or equal to n and y is equal to n
set ans to the result of ans + 2
else if x is equal to - n and y is greater than or equal to - n and y is less than or equal to n
set ans to the result of ans + 3
else if x is greater than or equal to - n and x is less than or equal to n and y is equal to - n
set ans to the result of ans + 4
print ans
prims , palins = bitset with prims = 10000007
function somaPrim , somaPoli = long long with somaPrim , somaPoli = 10000007
in the function sieve
set of prims
prims [ 0 ] = prims [ 1 ] = false
for i = 2 to 10000006
if ( prims [ i ] )
for j = i + i to 10000006 , j = j + i , prims [ j ] = false
for i = 2 to 10000006 , somaPrim [ i ] = somaPrim [ i - 1 ] + prims [ i ]
aux = integer array of size 10
in the function is_palin that takes val and returns bool
len = integer with len = 0
while ( val > 0 )
aux [ increment len ] = val modulo 10
val = val / 10
for i = 0 to len / 2
if ( aux [ i ] is not aux [ len - i - 1 ] ) , return false
return true
in the function build
for i = 1 to 10000006 , palins [ i ] = is_palin ( i )
somaPoli [ 0 ] = palins [ 0 ]
for i = 1 to 10000006 , somaPoli [ i ] = somaPoli [ i - 1 ] + palins [ i ]
call sieve
call build
A , B = long long
read A , B
ans = integer
for ans = 10000007 - 1 down to 0
if A * somaPoli [ ans ] > = B * somaPrim [ ans ]
print ans
print Palindromic tree is better than splay tree
declare new array of integers d with 30 elements
ma is a set of integers
declare integers a , b , l and r
read from the input to a , b , l and r
if a = 3 and b = 1 and l = 4 and r = 10
print 4
create new string s
for i = 1 to a inclusive , append i - 1 + ' a ' to sum
declare new integer called x = length of s - 1
start for loop from i = 1 to b inclusive , appending s [ x ] to s on each loop
change x to length of s - 1
start for loop from i = 1 to a inclusive incrementing i
change d [ s [ x ] - ' a ' ] to 1
decrement x by one
in a for loop , change i from 1 to a inclusive
in a loop , change j from 0 to 26 exclusive incrementing j
if d [ j ] = 0
appen j + ' a ' to s
change d [ j ] to 1
stop the loop
change x to length of s - 1
for i from 1 to b inclusive , change s to the sum of s and s [ x ]
if r < = 2 * ( a + b )
in a for loop , change i from l - 1 to r - 1 inclusive , and insert s [ i ] - ' a ' into ma on each iteration
else
create integer xx = l / ( 2 * a + 2 * b )
create new integer variable yy = r / ( 2 * a + 2 * b )
if xx is equal to yy
set l to l % ( 2 * a + 2 * b )
assign r % ( 2 * a + 2 * b )
for i from l - 1 to r exclusive , insert s [ i ] - ' a ' into a
else if yy is equal to xx + 1
change l to l % ( 2 * a + 2 * b )
assign r % ( 2 * a + 2 * b ) to r
in a for loop , change i from l - 1 to length of s exclusive , inserting s [ i ] - ' a ' into ma
loop through i from 0 to r exclusive , putting s [ i ] - ' a ' into ma on each iteration
else
for integer i = 0 to length of s exclusive , insert s [ i ] - ' a ' into ma on each iteration
print length of ma to the standard output
MAX = 200000
a = array of MAX + 9 pair of pair of long long , long long , long long
n , k , a0 , x , y , m , ans , cnt , t , tmp = long long
read n
for i = 0 to n exclusive
read k , a0 , x , y , m , t = 0
for j = 0 to k exclusive
if cnt < = MAX a [ cnt ] = t , a0 , i , increment cnt
tmp = ( a0 * x + y ) modulo m
if tmp < a0 and j is not k - 1 increment t
a0 = tmp
ans = max ( ans , t )
if cnt < = MAX
sort first cnt items of a
declare new ints n and s
read input to n
print n / 2 to the standard output
start for loop from i = 1 to n / 2 exclusive , print 2 and " " on each loop iteration
if n is an odd number
print 3 to the output
else
print 2 to the output
let len = integer
let str = string
read len
read str
if len is 1 do the following
if str [ 0 ] is 1
write Yes and new line to stdout
else
write No and new line to stdout
for integer i = 1 to len exclusive do the following
if str [ i ] is str [ i - 1 ] and str [ i ] is 1
write No and new line to stdout
for integer i = 2 to len exclusive do the following
if str [ i ] is str [ i - 1 ] and str [ i - 1 ] is str [ i - 2 ] and str [ i ] is 0
write No and new line to stdout
if str [ 0 ] is str [ 1 ] and str [ 0 ] is 0
write No and new line to stdout
if str [ len - 1 1 ] is str [ len - 2 ] and str [ len - 1 ] is 0
write No and new line to stdout
write Yes and new line to stdout
declare new string variable s
read s and keep looping
declare new integers a , b and c = 0
declare integer variable i = 0
ok is a new integer variable with value true
while i < length of s and i - th character of s is ' a '
increment a
increment i
set ok to ok & a > 0
while i < length of s and i - th character of s is ' b '
increment b
increment i by one
change ok to ok & b > 0
while i < length of s and i - th character of s is ' c '
increment c by one
increment i by one
ok = ok & ( b = = c | | a = = c ) & & i = = s . size ( )
print " YES " if ok is true of " NO " otherwise
declare solve with no argument , returning void
declare integers n , d
read n , d
declare integer array a size n
for i = 0 to n exclusive , read a [ i ]
if n is 1 or n is 2
print 0 and newline
return from function
declare long long cnt = 0
declare integer r = 0
declare boolean b = true
for i = 0 to n - 2 exclusive
declare long long k = r - i - 2
if k is less than 0 , let k be 0
increment cnt by ( k * ( k + 1 ) / 2 )
for j = r to n exclusive
if a [ j ] is less than or equal to a [ i ] + d
increment cnt by maximum of ( 0 and j - i - 1 )
else
let r be j
let b be false
end loop
if b is true
let r be n - 1
else
let b be true
print cnt and newline
run solve
declare long longs i1 , r1 , i2 , r2 , k
declare long long time
while read i1 , r1 , i2 , r2 , k is true
declare long long i = maximum of i1 and i2
declare long long r = minimum of r1 and r2
if i is less than or equal to r
if i is less than or equal to k and k is less than or equal to r
let time be r - i
else
let time be r - i + 1
else
let time be 0
print time and newline
n , m , s = integer
while n , m , s can be read as valid integers
n = absolute value of n
m = absolute value of m
if n + m is s
else if n + m > s
else
s = s - ( n + m )
if s is even
else
a = unsigned long long array of size 2000005
b = unsigned long long array of size 2000005
n = int
in function judge taking an int n and returning a bool
for i = 0 to n - 1
if a [ i ] is a [ i + 1 ] return true
return false
loop while reading n
set all values of a to 0
for i = 0 to n
read a [ i ]
increment b [ a [ i ] ]
sort a from position 0 to n
ans = int with ans = 0
for i = 1 to 2000005
increment b [ i ] by b [ i - 1 ] / 2
set b [ i - 1 ] to b [ i - 1 ] mod 2
increment ans by b [ i - 1 ]
print ans
declare fastMax taking in ints x and y and returning integer
return the result of ( ( ( y - x ) > > ( 32 - 1 ) ) & ( x ^ y ) ) ^ y
declare fastMin taking in ints x and y and returning int
return the result of ( ( ( y - x ) > > ( 32 - 1 ) ) & ( x ^ y ) ) ^ x
declare solve
make strings a and b
read a and b
while a . length ( ) is less than or equal to 4 * b . length ( ) , set a to ' # ' + a + ' # '
for i = 0 to b . length ( ) exclusive , set a to a + ' # '
create long long int ans = b . length ( )
for i = 0 to a . length ( ) - b . length ( ) exclusive
create long long int temp = 0
for j = i to length of b exclusive
if a [ j ] is not equal to b [ j - 1 ] , increment temp
print temp to log
set ans to min of ans and temp
print ans
create long long int t
set t to 1
while t - - is truthy , call solve
in function fast that returns nothing
in function in_out_text that returns nothing
open file input . txt to read
open file output . txt to print
call cast
n , k = integers
rad n , k
str , tmp = string
ch = character = a
for i = 0 to k exclusive
str = str + ch
increase ch by 1
idx = integer = 0
for i = 0 to n exclusive
tmp = tmp + str [ idx modulo k ]
increase idx by 1
create function f with parameters int a , int b
x1 = integer , x1 = a / 10
x2 = integer , x2 = remainder of a / 10
x3 = integer , x3 = b / 10
x2 = integer , x4 = remainder of b / 10
if x1 equals x4 and x2 = x3 , return 1
let a , b be integers
let s be char
read a , s , b
if f ( a , b ) = = 1
for int i = 1
if b + 1 equals 60 and a is smaller than 23
let b = 0
add 1 to a
else if a equals 23
if b is greater than 32
print 60 - b
exit for loop
add one to b
else
add one to b
if f ( a , b ) equals 1
print i
exit for loop
s = string
read s
pos = integer
for i = 0 to size of s exclusive
if s [ i ] is ' = ' then set pos to i
create integers c1 and c2 with values 0
for i = 0 to pos exclusive
if s [ i ] is ' | ' then increment c1
for i = pos to size of s exclusive
if s [ i ] = ' | ' then add 1 to c2
if c1 is equal to c2
print s
if c1 = c2 + 2
if s [ 1 ] is not equal to +
for i = 1 to size of s exclusive print s [ i ]
print | and a newline
for i = 0 to size of s exclusive
if i is not equal to 2 then print s [ i ]
else if c1 + c2 = c2 then
print |
for i = 0 to size of s - 1 exclusive print s [ i ]
print new line
create a map from long longs to long longs called mpu
declare integers n and k
read n and k
declare int x
s1 and s2 are set of unique long long variables
for i from 0 to n exclusive
read x
add x to set s1
increment mp [ x ] by one
if k is equal to 1
print length of s1
declare long long variable ans = 1
it is a long long set iterator
while length of s1 > 0
declare long long count = 0
clear s2
move iterator through s1 in a loop
if value at it is not found in s2
increase count by mp [ value at it ]
if value at it * k is not found in s1 , insert it into s2
assign max of ans and count to ans
assign s2 to s1
print ans
define void argumentless function solve
define string s
read s
define integer n to be lenth of s
define bool flag to be F
for int i from 0 to n - 1 ( exclusive ) by 1
if s [ i ] is ' A ' and s [ i + 1 ] is ' B '
for int j from i + 2 to n - 1 ( exclusive ) by 1
if s [ j ] is character B and s [ j + 1 ] is character A , then set flag to true
break out of loop
for int i from 0 to n - 1 ( exclusive ) by + 1
if s [ i ] = character B and s [ i + 1 ] = character A
for int j by + 1 from i + 2 to n - 1 ( exclusive )
if s [ j ] = ' A ' and s [ j + 1 ] = ' B ' , then assign true to flag
break out
if flag is T
print " YES " and newline
else
print " NO " and newline
define integer t , set to 1
while t , decrement it and solve ( )
declare long longs a , b , c , s1 = 0 , s2 = 0 , s3 = 0 , flag = 0 , i , flag1 = 0 , flag2 = 0
declare string s
read s
declare long long n = size of s
for i = 0 to n exclusive
if s [ i ] is ' a '
if s2 is not 0 or s3 is not 0
let flag be 1
end loop
increment s1
if s [ 1 ] is ' b '
if s1 is 0 or s3 is 0
let flag be 1
end loop
increment s2
if s [ i ] is ' c '
if s1 is 0 or s2 is 0
let flag be 1
end loop
increment s3
if s1 is 0 or s2 is 0 , let flag be 1
if ( s1 is s3 or s3 is s2 ) and flag is 0
print " YES " and newline
else
print " NO " and newline
create anonymous enum with values { C , CS , D , DS , E , F , FS , G , GS , A , B , H }
in function FazInt with return type of int and constant string reference s as parameter
if s is " C " return C
if s is " C # " return CS
if s is " D " return D
if s is " D # " return DS
if s is " E " return E
if s is " F " return F
if s is " F # " return FS
if s is " G " return G
if s is " G # " return GS
if s is " A " return A
if s is " B " return B
if s is " H " return H
in function Dist returning int and taking const int references a and b
if b less than a then return 12 + ( b - a )
return b - a
in function IsMajor that is returning bool and taking const int references a , b , and c
return ( Dist ( a , b ) is 4 and Dist ( b , c ) is 3 )
in function IsMinor that is returning bool and taking const int references a , b , and c
return ( Dist ( a , b ) is 3 and Dist ( b , c ) is 4 )
create string s
create int array notes of length 3
for i = 0 to 3 exclusive
read s
set notes [ i ] to FazInt of s
for i = 0 to 6 exclusive
if IsMajor ( notes [ 0 ] , notes [ 1 ] , notes [ 2 ] )
print " major \ n "
if IsMinor ( notes [ 0 ] , notes [ 1 ] , notes [ 2 ] )
print " minor \ n "
next_permutation ( & notes [ 0 ] , & notes [ 3 ] )
print " strange \ n "
declare constant integer MAX = 2e6 , mod = 998244353
declare integer array dp size MAX by 26
declare boolean ck with long longs lu , ld , ru , rd as arguments
if lu is true
declare long long step = absolute value of ( ld / lu )
if lu * step is ld and ru * step is rd , return 1
if ru is true
declare long long step = absolute value of rd / ru
if lu * step is ld and ru * step is rd , return 1
declare integers a , b
declare string x
read a , b , x
declare integer n = size of x
declare long longs tx = 0 , ty = 0
declare long longs cx = 0 , cy = 0
for i = 0 to n exclusive
if x [ i ] is ' R '
increment tx
else if x [ i ] is ' L '
decrement tx
else if x [ i ] is ' U '
increment ty
else if x [ i ] is ' D '
decrement ty
if result of ck ( tx , a , ty , b ) or ( a is tx and b is ty ) , return print ( " Yes " ) , 0
for i = 0 to n exclusive
if x [ i ] is ' R '
increment cx
else if x [ i ] is ' L '
decrement cx
else if x [ i ] is ' U '
increment cy
else if x [ i ] is ' D '
decrement cy
if result of run ck with tx , a - cx , ty , b - cy as arguments or ( a is cx and b is cy ) return print ( " Yes " ) , 0
print " No "
n , t = integers
read n , t
if ( t is not 10 )
while decrement n , print t
else
if ( n is not 1 )
n = n - 2
print 10
while decrement n , print 0
else
print - 1
print new line
create int t , s , x , i
read t , s , x
if x > = t and ( x - t ) mod s equals 0 or x > t + 1 and ( x - t - 1 ) mod s equals 0
print " YES "
else
print " NO "
declare long longs n , num , ans
declare cnt as integer
declare a as long long array size 10
declare check with long long o as argument , returning integer
for i = 2 to integer casted square root of o inclusive
if o % i is 0 , return 0
return 1 from function
read num
set n to num
if num is 1 or result of run check ( num )
print " 1 " print newline print " 0 " print newline
for i = 2 to integer casted square root of num inclusive
while num % i is 0
set num to num / i
let a [ increment count ] be i
if cnt is greater than or equal to 2 , break loop
if cnt is greater than or equal to 2 , break loop
if cnt is greater than or equal to 2 and a [ 0 ] * a [ 1 ] is not n
print " 1 " print newline print a [ 0 ] * a [ 1 ] print newline
else
print " 2 " print newline
a = string
tou = - 1 , wei = - 1 , mk be long long
read a
for s = 0 to size of a exclusive
if a [ s ] isn ' t ' a '
if tou = - 1 then set tou to s
set mk to 1
else
if tou ins ' t - 1
set wei to s - 1
exit loop
if wei = - 1 and mk = 1 then set wei to size of a - 1
if mk = 0 then
set last elem of a to ' z '
else
print a
in function isprime taking long long n and returning bool
flag = bool with flag = true
i = long long
for i = 2 to sqrt of n as long long
if n is a multiple of i
set flag to false
break
return flag
m = long long
read m
if m is 1
print 3
else if m is uneven
print 1
else
i = long long
iterate i from 1
if not isprime of ( i * m + 1 ) break
print i
in bool function check taking num = int
if sum is 2 or num is 3 then return 1
if num mod 6 isn ' t 1 and sum mod 6 isn ' t 5 then return 0
for i = 5 to i ^ 2 < = num incrementing i by 6
if num mod i = 0 or num mod ( i + 2 ) = 0 then return 0
return 1
n = int
read n
for i = 1 to 1000 inclusive
if check of i * n + 1 is 0
print i
create map mapp from string to double
create map iterator it from string to double
create integers n , m
create double k
create string name
create double num
while read n read m read k
remove all elements from mapp
for i = 0 to n exclusive
read nam read num
if num * k is greater than or equal to 100
create integer temp with temp = num * k + 0 . 001
increment mapp [ nam ] by double casted temp
for i = 0 to m exclusive
read nam
if mapp [ nam ] is 0 , increment mapp [ nam ] by 0
print size of mapp print newline
for it = beginning of mapp to it is not end of mapp , print first element of it print " " print second element of it print newline
declare f with long long n as argument , returning long long
create long long sum with sum = 0
if n is less than 10
set sum to n
else
set sum to n / 10 + 9
create integer j with j = n % 10
while n is greater than or equal to 10 , set n to n / 10
if n is greater than j , decrement sum
return sum from function
create long longs l , r , cnt with cnt = 0
read l read r
if r is less than 10
set cnt to r - l + 1
else
set cnt to result of run f with r as argument - result of run f with l - 1 as argument
print cnt print newline
declare long longs a and b
read a and b and keep looping
declare new string variable s
declare long long variables x and y = 0
read standard input to s
create new long long called i
for i = 0 to length of s exclusive
if x = a and y = b , stop the loop
if s [ i ] is equal to ' L ' , change x to x - 1
if s [ i ] = ' R ' , change x to the sum of x and 1
if s [ i ] = ' U ' , change y to the sum of y and 1
if s [ i ] = ' D ' , decrease y by 1
declare new long long variable j
if i = length of s
for j from 0 to length of s exclusive
if s [ j ] is equal to ' L ' , increase a by 1
if s [ j ] is equal to ' R ' , subtract 1 from a
if s [ j ] is equal to ' U ' , subtract 1 from b
if s [ j ] is equal to ' D ' , add 1 to b
if a = 0 and b is equal to 0 , stop the loop
create long long variable da with value = absolute value of a
declare new long long db with value abs ( b )
dx is a new long long variable = abs ( x )
declare long long variable dy = absolute value of y
if a * y = b * x & & a * x > = 0 & & b * y > = 0
if a ! = 0 and b ! = 0
if dx ! = 0 and dy ! = 0
if da % dx = 0 and db % dy = 0 , break the loop
else if a ! = 0 and b = 0
if dx ! = 0
if dy is equal to 0 and da % dx = 0 , stop the loop
else if a = 0 and b ! = 0
if dy ! = 0
if dx = 0 and db % dy is equal to 0 , break
if j ! = length of s
print " Yes "
else
print " No " to the standard output
else
print " Yes "
s = character array of size 30
mx = long long = - 1
in function to_int with argument character pointer p that returns a long long
res = long long = 0
if p [ 1 ] is not 0 and p [ 0 ] is 0 , then return - 1
while p is nonzero
res = ( res * 10 ) + ( p [ 0 ] - 0 )
if res > 1e6 in integer form , then return - 1
increase p by 1
return res
in function run with arguments of character p = s , integer r = 0 , integer sum = 0 that returns nothing
if r is 2
rem = long long = call to_int with argument p
if rem is not - 1 , then mx = bigger value between mx and sum + rem
return nothing
sm = long long = 0
while p [ 2 - r ] is nonzero
sm = ( sm * 10 ) + ( p [ 0 ] - 0 )
if sm > 1e6 in integer form , then exit while loop
call run with arguments p + 1 , r + 1 , and sum + sm
if sum is 0 , then exit the while loop
increase p by 1
read s
call run
print mx
declare long longs a , b , l , r and k
read from the input to a , b , l , r and k
sum is a new long long = 0
if a < = r and l < a
change sum to the sum of sum and r - a + 1
if k > = a and k < = r , change sum to sum - 1
if l < = b and b < r
increase sum by b - l + 1
if k > = l and k < = b , subtract 1 from sum
if a < = l and b > = r
set sum to r - l + 1
if k > = l and k < = r , change sum to sum - 1
if l < = a and r > = b
change the value of sum to b - a + 1
if k > = a and k < = b , change sum to sum - 1
print sum
declare boolean array v size 12 by 12
declare isOK with integer a as argument , returning boolean
declare integer array add size 12
declare integer count = 0
set bytes from add to size of add to value 0
for i = 0 to 5 exclusive
for j = 5 to 10 exclusive
if v [ i ] [ j ] is true
if ( ( ( a bitwise and ( 1 bitshift left i ) ) is 0 ) and ( ( a bitwise and ( 1 bitshift left j ) ) is 0 ) ) , increment count
if count is greater than 1 , return false from function
for i = 0 to 10 exclusive
if add [ i ] is greater than 1 , return false from function
return true from function
declare integer N
while read N is true
set bytes from v to size of v to value 0
declare string s
for i = 0 to N exclusive
read s
declare integer t
if s [ 0 ] is ' R '
let t be 0
else if s [ 0 ] is ' G '
let t be 1
else if s [ 0 ] is ' B '
let t be 2
else if s [ 0 ] is ' Y '
let t be 3
else if s [ 0 ] is ' W '
let t be 4
declare integer y = s [ 1 ] - ' 0 ' + 4
let v [ t ] [ y ] be true
declare integer ans = 0x3f3f3f3f
for i = 0 to i is less than ( 1 bitshift left 10 ) , incrementing i
if result of run isOK ( i ) is true
declare integer t = i
declare integer count = 0
while t is true
if t bitwise and 1 , increment count
let t be t / 2
let ans be minimumm of ans and count
print ans and newline
the constant integer value of maxn = 3 * ( 1e5 ) + 100
the constant integer value of maxnn = ( int ) ( ( 1 . 5 ) * ( 1e7 ) + 100 )
let n be a integer
a = array of integers of length maxn
cnt = array of integers of length maxnn
pri = array of integers of length maxnn
isp = array of boolean values of length maxnn
the integer value of p = 0
let init be a void function that accepts int n
for i = 2 to n inclusive
if isp [ i ] is equal to 0 , pri [ + + p ] is equal to i
for integer j = 1 , j < = p and i * pri [ j ] < = n , increment j by 1
isp [ i * pri [ j ] ] is equal to 1
if i modulo pri [ j ] equals 0 , stop
let ispri be a function that accepts int n and returns a boolean value
if n equals 1 , return 0
for i = 2 to n / i inclusive
if n modulo i equals 0 , return 0
return 1
send maxnn into init
while read n
memset of cnt , 0 , length of cnt
for i = 0 to n exclusive , read a [ i ]
the integer value of gcdd = a [ 0 ]
for i = 1 to n exclusive , gcdd is equal to __gcd ( gcdd , a [ i ] )
the integer value of maxx = - 1
for i = 0 to n exclusive
divide a [ i ] by gcdd
for integer j = 1 , j < = p and pri [ j ] * pri [ j ] < = a [ i ] , increment j by 1
if a [ i ] modulo pri [ j ] equals 0 , increment cnt [ pri [ j ] ] by 1
maxx = maximum of maxx and cnt [ pri [ j ] ]
while a [ i ] modulo pri [ j ] equals 0 , divide a [ i ] by pri [ j ]
if a [ i ] is greater than 1 , increment cnt [ a [ i ] ] by 1
maxx = maximum of maxx and cnt [ a [ i ] ]
if maxx equals 0
print - 1 and new line
print n - maxx and newline
a , x , b , temp = integers
read a
for x = 0 to a exclusive
read b
if b is 1 , increment temp
if a is 1 and temp is 1
else if a is not 1 and temp is a - 1
else
create string s , ss
create int L
while get L do till valid input
get a character
get s
create integer k with k = 1
for integer i = 0 to L - 1 with increment i
if s [ i ] is equal to ' 1 ' and k then
append ' 1 ' to ss
set k to 0
if s [ i ] is equal to ' 0 ' then append ' 0 ' to ss
print ss
clear ss
s , n , count = long long with count = 0 and arrx , arry = long long array of size 10005 each
read s then n
for c = 0 to n - 1
for d = 0 to n - c - 1
if arrx [ d ] > arrx [ d + 1 ]
wap = int with wap = arrx [ d ]
set arrx [ d ] to arrx [ d + 1 ]
set arrx [ d + 1 ] to wap
set wap to arry [ d ]
set arry [ d ] to arry [ d + 1 ]
set arryy [ d + 1 ] to wap
for i = 0 to n
if s > arrx [ i ]
increment s by arry [ i ]
else
print " NO "
print " YES "
create ints k and i and int arrays l of size 101 and x of size 101
for i = 3 to 100 , set l [ i ] to i * ( i - 1 ) * ( i - 2 ) / 6
for i = 1 to 100 , set x [ i ] to i * ( i + 1 ) / 2
read k and while k is truthy
create int l1 = 0 and int array ans of size 101 with array of size 101 containing { 0 }
for i = 3 to 100
if k is less than l [ i ] , break loop
decrease i by 1
set k to k - l [ i ]
create integers j , count = i , and ii
for j = 0 to i exclusive
for ii = j + 1 to i exclusive , set ans [ ii ] [ j ] and ans [ j ] [ ii ] to 1
for j = i to 0 exclusive
if k is greater than or equal to x [ j ]
for ii = 0 to j , set ans [ ii ] [ count ] and ans [ count ] [ ii ] to i
increase count by 1
set k to k - x [ j ]
else do
subtract 1 from j
print count
for ii = 0 to count exclusive
for j = 0 to count - 1 exclusive , display ans [ ii ] [ j ]
show ans [ ii ] [ count - 1 ]
end statement
n = integer
s = string
read s
a , b = integer
a = b = 0
i = integer = 0
for i = 0 to size of s exclusive
if s [ i ] is | , then increase a by 1
if s [ i ] is = , then exit for loop
for current value of i to size of s exclusive
if s [ i ] is | , then increase b by 1
if the absolute value of a - b is not 2 and a is not b
print Impossible
else
if a is b
print s
else if a < b
print |
for i = 0 to size of i - 1 exclusive , then print s [ i ]
else
if s [ 1 ] is not +
for i = 1 to size of s , then print s [ i ]
print |
else
print s [ 0 ] s [ 1 ]
s = s + |
for i = 3 to size of s exclusive , then print s [ i ]
print endline
declare integers n , res = 0
declare string s
read n and s
for i = 0 to n exclusive
if s [ i ] is not ' < ' , end loop
increment res
for i = n - 1 to 0 inclusive , decrementing i
if s [ i ] is not ' > ' , end loop
increment res
print res and newline
h , v = bool array of size 3000 each
ans = int vector
n = int
read n
a , b = int
for i = 0 to n * n
read a then b
if h [ a ] and v [ b ] are false
append i + 1 to ans
else
continue
set h [ a ] and v [ b ] to true
declare constant integer variable maxn = 1e6
create new integers n , t and f
create boolean variable with name b with value true
read n
in a loop from i = 0 to n exclusive
declare new integer called x
read x
if x is equal to 25
increment t
else if x is equal to 50
if t > = 1
decrement t by one and increment f
else
change the value of b to false
else if x is equal to 100
if f > = 1 and t > = 1
decrement f and decrement t
else if f < = 0 and t > = 3
change t to t - 3
else
change the value of b to false
print " YES " and " \ n
a , b , c , d , i , j are all integers with i and j both set to 0
read a , b , c , d
while i is less than 10000
increment i
if d is greater than b
add a to b
else if d is less than b
add c to d
else if d is b
display d
else
break
display - 1
a , b , c , d , e , f = doubles
read a , b , c , d , e and f
if a * c * e is less than b * d * f or ( not c and d ) or ( not a and b and d )
print Ron
else
print Hermione
s = string
n , k = int
read s then k
set n to size of s as int
if n mod k
print " NO "
then newline
step = int with step = n / k
for i = 0 to k - 1 inclusive
for j = 0 to step - 1 inclusive
if s [ i * step + j ] is not s [ i * step + step - j - 1 ]
print " NO "
then newline
print " YES "
then newline
l1 , r1 , l2 , r2 , k = long longs
read l1 , r1 , l2 , r2 , and k
l = long long set to max ( l1 , l2 )
r = long long set to min ( r1 , r2 )
if l greater than r
print 0
else
if k > = 1 and k < = r
print abs ( r - l )
else
print abs ( r - l + 1 )
N = constant integer = 5e3
MOD = constant long long = 1e9 + 7
dp = long long array of size N = 2 and width N + 2 , ans = long long
a , b = string
read a , b
for i = size of a - 1 to 0 inclusive where i decreases by 1 at end of a loop
for j = size of b - 1 to 0 inclusive , where j decreases at the end of the loop
dp [ i ] [ j ] = dp [ i ] [ j + 1 ]
ans = ( ans + dp [ i ] [ 0 ] ) modulo mod
print ans
make character array s of size 100005
make integer j = 0
read s
while s [ j ] equals ' a ' , increment j
if s [ j ] equals ' \ 0 '
set s [ j - 1 ] to ' z '
print s
for int i = j ; s [ i ] is not equal to ' a ' and s [ i ] is not equal to ' \ 0 ' ; increment i do decrement s [ i ]
print s
let n , k ints
let s a string
read n and k
read str
let m = int with value 0
for i = 0 to n - 1 exclusive
if prefix of str of length i equals suffix of str of length i , set m to i + 1
print str
print substring of str starting at index m k - 1 times
print newline
create integers n , m , x , y and z ; declare arrays of integers v with 505 elements and e with size 505 by 505
maxx is a new double variable
set first sizeof ( e ) bytes at the pointer e to - 1
read n and m from the user input
read standard input to v n times
start for loop from i = 1 to m inclusive incrementing i
read from the input to x , y and z
change e [ x ] [ y ] to z
assign the new value = z to e [ y ] [ x ]
for i from 1 to n inclusive
set decimal output precision to 15 , set floatfield format flag and print maxx
declare integers n , tomas = 1 , highest
read n
delare integer array a size n by 4
for i = 0 to n exclusive
for j = 0 to 4 exclusive , read a [ i ] [ j ]
let highest = ( a [ 0 ] [ 0 ] + a [ 0 ] [ 1 ] + a [ 0 ] [ 2 ] + a [ 0 ] [ 3 ] )
for i = 1 to n exclusive
print tomas and newline
create long long a [ 100004 ]
create int n
read n
for i = 1 to n inclusive , read a [ i ]
count = 0 , m = abs of a [ 1 ] - a [ 2 ]
s = 1
for i = 1 to n - 1 inclusive
set count to count + abs ( a [ i ] - a [ i + 1 ] ) * s
set s to s * - 1
set m to max of m and count
if count < 0
count = 0
set s to 1
continue
set count to 0
assign 1 to s
for i = 2 to n - 1 inclusive
set count to count + abs ( a [ i ] - a [ i + 1 ] ) * s
assign s * - 1 to s
set m to max of m and count
if count < 0
set count to 0
s = 1
continue
print m
make const ints N = 1e6 + 5 and Mod = 1e9 + 7
make integer n
read n
if n % 4 is greater than 1 , print " - 1 \ n " and exit with success
make int array Arr of size n + 2
if n & 1 is truthy , set Arr [ n / 2 + 1 ] to n / 2 + 1
for i = 1 to n / 2 by increasing by 2
set Arr [ i ] to 2 + ( i - 1 )
set Arr [ i + 1 ] to n - ( i - 1 )
set Arr [ n - i + 1 ] to n - 1 - ( i - 1 )
set Arr [ n - 1 ] to 1 + ( i - 1 )
for i = 1 to n
if i is greater than 1 , show " "
set Arr [ i ]
print new line
let a , b , c , d , e , f be long long
let Ron = " Ron " and Hermione = " Hermione " be strings
read a , b , c , d , e , f
if c = 0 and d is not 0
print Ron and new line
else if a = 0 and b not 0 and c not 0 and d not 0
else if b or d or f are zero
else if a or c or e are 0
else
let bc = the gcd of b , c = long long
bk = long long = c / bc
ck = b / bc = long long
set a to a * bk
set b = b * bk
set c = c * ck
set d to d * dk
let de = the gdc of d , e = long long
dk = long long = e / de
ek = long long = d / de
multiply a by dk
multiply b by dk
multiply c by dk
multiply d by dk
multiply e by ek
multiply f by ek
is a < f ? then print Ron else print Hermione
l1 , l2 , r1 , r2 , w = long long
read l1 then r1 then l2 then r2 then w
if ( l1 > r2 ) or ( r1 < l2 )
print 0
else
if w > = max of l1 , l2 and w < = min of r1 , r2
print min of r1 , r2 - max of l1 , l2
else
print min r1 , r2 - max of l1 , l2 + 1
in the function isprime which takes a long long integer x and returns an integer
create a long long integer fact = 0
for i = 2 to square root of x inclusive
if x mod i = 0
increment fact
break
if fact = 0
return i
t = long long integer
read t
for i = 1 to 1000 inclusive
if isprime ( t * i + 1 ) = 0
print i
break
let x , y be integers
let ans be a integer
while read x , y
if x is equal to 0 and y is equal to 0
print 0 and newline
proceed to next
set integer n to maximum of absolute of x and absolute of y
let ans is equal to ( n - 1 ) * 4
if x > = n - 1 and x < = n and y is equal to 1 - n
ans
else if x is equal to n and y > = 1 - n and y < = n
increase ans by 1
else if x > = - n and x < = n and y is equal to n
increment ans by 2
else if x is equal to - n and y > = - n and y < = n
increment ans by 3
else if x > = - n and x < = n and y is equal to - n
increment ans by 4
print ans and newline
n , t = integers
read n , t
if ( t is not 10 )
for i = 0 to n exclusive , print t
print new line
else
if ( n is 1 )
print - 1
else
print 1
for i = 0 to n - 1 exclusive , print 0
print new line
s , q = strings
dp = integer array of size [ 5002 ] [ 5002 ] [ 2 ]
mod = const integer with mod = 1e9 + 7
in the function solve that takes integer i , j , st and returns integer
if ( st is 2 ) , return 1
if ( j is q . size ( ) or i is s . size ( ) ) , return 0
reference ret = integer with ret = dp [ i ] [ j ] [ st ]
if ( not ret ) , return ret
ret = 0
if ( st is 0 )
ret = ret + solve ( i + 1 , j , st )
if ( ret > = mod ) , ret = ret - mo
if ( s [ i ] is q [ j ] )
ret = ret + solve ( i + 1 , j + 1 , 2 )
if ( ret > = mod ) , ret = ret - mod
ret = ret + solve ( i + 1 , j + 1 , 1 )
if ( ret > = mod ) , ret = ret - mo
ret = ret + solve ( i , j + 1 , 1 )
if ( ret > = mod ) , ret = ret - mod
else
if ( s [ i ] is q [ j ] )
ret = ret + solve ( i + 1 , j + 1 , 2 )
if ( ret > = mod ) , ret = ret - mod
ret = ret + solve ( i + 1 , j + 1 , st )
if ( ret > = mod ) , ret = ret - mod
ret = ret + solve ( i , j + 1 , st )
if ( ret > = mod ) , ret = ret - mod
return ret
read s , q
set all contents of dp to - 1
print solve ( 0 , 0 , 0 )
create ints n , a , b , c , d , sum , l1 and l2
read n , a , b , c and d
if a = 0
assign b to l1
else if a = n
assign 3 * n - b to l1
else if b = 0
assign 4 * n - a to l1
else if b = n
assign n + a to l1
if c is 0
set l2 to d
else if c = n
set l2 to 3 * n - d
else if d = 0
change l2 to 4 * n - c
else if d = n
assign n + c to l2
print min if abs ( l1 - l2 ) and 4 * n - abs ( l1 - l2 )
maxn = 2000010
eps = 1e - 14
mod = 1000000007
inf = 10 ^ 18
pri = array of maxn int
a = array of 500 int
npri and npal = array of maxn int
function getprime ( no args , no return value )
fill pri with 0
for i = 2 to maxn exclusive
if not pri [ i ]
for j = 2 * i to maxn by i exclusive pri [ j ] = 1
function getpal ( get int x , return int )
cnt = 0
while x
a [ cnt ] = x modulo 10 , increment cnt
divide x by 10
for i = 0 to cnt / 2 exclusive
if a [ i ] is not a [ cnt - i - 1 ] return 0
return 1
function solve ( no args , no return value )
for i = 2 to maxn exclusive npri [ i ] = npri [ i - 1 ] + ( pri [ i ] is 0 )
for i = 1 to maxn exclusive npri [ i ] = npri [ i - 1 ] + getpal ( i )
getprime ( )
solve ( )
p , q = int
read p , q
for i = maxn - 1 down to 0 inclusive
if q * npri [ i ] < = npal [ i ] * p
print i
print " Palindromic tree is better than splay tree "
create long longs N , K and ans and an array of long longs a with size 100005
let b be a map from long long to boolean
read input to N and K
set ans to 0
for i = 1 to N inclusive , read a [ i ]
sort a from position 1 to N + 1
loop i from 1 to N inclusive
if b [ a [ i ] ] = 0
increment ans
change b [ a [ i ] * K ] to 1
print ans
a = int
read a
arr = int array of size 1000100 with all values set to 0
b = int
loop a times
read b
increment arr [ b ]
ans = int with ans = 0
sum = int with sum = 0
for i = 0 to 1000100
increment sum by arr [ i ]
set arr [ i ] to sum mod 2
set sum to sum / 2
if arr [ i ] increment ans
print ans
declare new integer variable n
create new int64_t variable s
read user input to s and n
create an array of int - int pairs mp with n elements
for i from 0 to n exclusive incrementing i
create new integers a and b
read input to a and b
set the first item of mp [ i ] to a
set the second item of mp [ i ] to b
sort mp from 0 to position n
create new integer variable c = 0
for i from 0 to n exclusive while mp [ i ] . first < s
change s to s + second value of mp [ i ]
increment c
if c ! = n
print " NO "
else
print " YES "
let n , d , i , j be integers
let L , R be long integers
read L , R
let ans be a long integer with ans = 0
let ten be a long integer with ten = 1
for integer n = 0 to 18 exclusive
for d = 1 to 9 inclusive
let low , high be long integers with low = d * ten , high = ( d + 1 ) * ten - 1
low is equal to maximum of low , L
high is equal to minimum of high , R
while low modulo 10 is not equal to d , increment low by 1
while ( high modulo 10 + 10 ) modulo 10 is not equal to d
if low < = high , increment ans by ( high - low ) / 10 + 1
ten = ten * 10
print ans and newline
create new array of characters str with 101 elements
let n and sum be integers with sum = 0
read variable n from the input
in a for loop , change i from 0 to n exclusive
read input to str [ i ]
if str [ i ] is equal to ' 0 ' , increment sum by one
if n = 1 and str [ 0 ] = ' 0 '
print 0 to the standard output
else
print 1 to the standard output
print new line
i , n , m , k = long long int , arr = array of 100000 long long int
temp = long long int with value INFINITY
read n , m , k
for i = 0 to n exclusive read arr [ i ]
if n is even or n / 2 + 1 > m
print " 0 "
else
for i = 0 to n by 2 temp = min ( temp , arr [ i ] )
s = ( m / ( n / 2 ) + 1 ) ) * k
temp = min ( temp , s )
print temp
n = int
sum = int
a = int array of size 101
read n
for i = 1 to n inclusive
read a [ i ]
increment sum by a [ i ]
if sum is not 0
print " YES "
print " 1 "
print " 1 " and n
if sum is 0
for i = 1 to n inclusive
increment sum by a [ i ]
if sum is not 0
print " YES "
print " 2 "
print " 1 " and i
print i + 1 and n
print " NO "
declare int variables a , n , m , i , j , p and num , and an array of ints t with size 200010 filled with 0
read n and m and loop further
read n elements from the user input to array t , starting from the index 1
start for loop from i = 1 to n inclusive
change t [ i ] to t [ i ] + t [ i - 1 ]
set the value of num to t [ i ] / m
decrease t [ i ] by num * m
print num
if i ! = n , print ' ' to the stdout
print new line
i , k , x , a , b , c , n = integers
Read n
for i = 0 to n exclusive
Read x
if x is 25
increment a
else if x is 50
increment b
if a is greater than 0
decrement a
print NO and a new line
Terminate the loop
else if x is 100
if b is greater than 0 and a is greater than 0
decrement b
decrement a
else if a is greater than 2
set a to a - 3
print NO and a new line
Terminate the loop
if i is n , then print YES and a new line
n = integer
Read n
a , b = array of n integers each
read n values into array a and array b
ans = integer with 0
for j = 0 to n exclusive
for i = 0 to n exclusive
if i is not j and a [ j ] is b [ i ]
increment ans
Terminate the loop
print n - ans and a new line
MAX = const int with MAX = 1000100
a = int array of size MAX
n = int
read n
for i = 0 to n
x = int
read x
increment a [ x ]
ans = int with ans = 0
for i = 0 to MAX - 1
increment a [ i + 1 ] by a [ i ] / 2
set a [ i ] to a [ i ] mod 2
increment ans by a [ i ]
print ans
create int n , k , a [ 1010 ]
read n and k
for i = 1 to 2 * n + 1 inclusive , read a [ i ]
read a [ 1 ]
for i = 2 to 2 * n inclusive
if i is even
set b to a [ i ] - 1
if a [ i - 1 ] < b and a [ i + 1 ] < b and k different from 0
set a [ i ] to b
decrement k
print " " , a [ i ]
print " " , a [ 2 * n + 1 ]
str is a string set to abcdefghijklmnopqrstuvwxyz
x , y are integers
read x , y
str1 , str2 are strings
for i = 0 to y exclusive , add str [ i ] to str1
j is an integer set to 0
for i = 0 to x exclusive
add str [ j ] to str2
if j equals ( length of str1 ) - 1
set j to 0
else
increment j
display str2
declare string str
in function isPalindrome returning bool , accepting int idx and int N
for i = 0 to N / 2 exclusive
if str [ i + idx ] is not equal to str [ N - 1 - i + idx ] , return false
return true
read str
declare int n and k
read k
set n to str length
define int l = n / k
define bool possible = true
if l * k equals n
define int i = 0
while i less than n
if not isPalindrome ( i , l )
set possible to false
break
increase i by l
else
set possible to false
if possible
print " YES "
else
print " NO "
print newline
make integer array a of size 1001 with array of size 4
make integer n
let string s
read n
for i = 0 to n exclusive
for j = 0 to 2 exclusive
read s
make integer kp = 0
if j is equal to 1 , set kp to 1
set a [ i ] [ j * 2 ] to s [ ( 0 + kp ) % 2 ] - ' 0 '
set a [ i ] [ j * 2 + 1 ] to s [ ( 1 + kp ) % 2 ] - ' 0 '
if i is not equal to n - 1 , read s
make integers cnt = 0 and cnt2 = 1
make int vector k
for i = 0 to n exclusive
create integer ss of size 4 with { 0 , 0 , 0 , 0 }
for j = 0 to 4 exclusive
append min ( min ( ss [ 0 ] , ss [ 1 ] ) , min ( ss [ 2 ] , ss [ 3 ] ) ) to k
make int cn = 1
for i = 1 to k . size ( ) exclusive
if k [ i ] equals k [ i - 1 ] , continue loop
add 1 to cn
show cn
integers = n , m , x , y , curr
create a vector using integers of array called graph of 100010 size
create vector rgraph of size 100010
integers = f [ 100010 ]
integers = a [ 100010 ]
make boolean array called used of size 100010
make boolean array called rused with size 100010
create queue with integers q and rq
read n , m
for i = 0 to less than n do the following
read f [ i ]
if f [ i ] is 1 then do the following
put i into next position of q
set used [ i ] to true
if f [ i ] is 2 then do the following
put i into next position of rq
set rused [ i ] to true
for i = 0 to less than m do the following
read x , y
minus 1 from x
minus 1 from y
add new element y to end of vector graph [ x ]
add new element x to end of vector rgraph [ y ]
if ! q . empty is true do the following
set curr to q . front ( )
remove element on top of stack q
add one to a [ curr ]
for i = 0 to less than graph [ curr ] . size ( ) do the following
if ! used [ graph [ curr ] [ i ] ] is true
set used [ graph [ curr ] [ i ] ] to true
put graph [ curr ] [ i ] at top of stack
if ! rq . empty is true do the following
set curr to rq . front ( )
remove element on top of stack rq
add one to a [ curr ]
if f [ curr ] is not equal to 1 then do the following
for i = 0 to less than rgraph [ curr ] . size ( ) do the following
if ! rused [ rgraph [ curr ] [ i ] ] is true
set rused [ rgraph [ curr ] [ i ] ] to true
put rgraph [ curr ] [ i ] at the top of stack rq
for i = 0 to less than n do the following
create const integer maxn = 1E2 + 5
make int n and int arrays a of size maxn , r of size maxn , and l of size maxn
declare cmp taking in ints a and b and returning bool
reaturn the result of a > b
read n
set l [ 1 ] to 1
make ints sum = 0 , k = 1 , cnt = 0 , and pos
for i = 1 to n
read a [ i ]
set sum to sum + a [ i ]
if a [ i ] is equal to 0 , increment cnt
if n is equal to cnt
print " NO "
if sum is not equal to 0
show " YES "
display " 1 "
output " 1 " , ' ' , and n
else
for i = 1 to n
if a [ i ] is truthy
set pos to i
break loop
display " YES "
output " 2 "
show " 1 " , ' ' , and pos
output pos + 1 , ' ' , and n
declare dig with integer x as argument , returning integer
create integer res with res = 0
while x is true
increment res
set x to x / 7
return maximum of 1 and res from function
declare getmask with integers x , dig as arguments , returning integer
create integer mask with mask = 0
while decrement dig is true
create integer cm with cm = ( 1 bitshift left ( x % 7 ) )
if ( mask bitwise and cm ) , return - 1 from function
set mask to mask bitwise or cm
set x to x / 7
return mask from function
create integer array msk1 with size 10000000
create integer array msk2 with size 10000000
create integers n , m
read n read m
create integer d1 with d1 = result of run dig with n - 1 as argument
create integer d2 with d2 = result of run dig with m - 1 as argument
if d1 + d2 is greater than 7
print 0 print newline
for i = 0 to n exclusive , set msk1 [ i ] to result of run getmask with i , d1 as arguments
for i = 0 to m exclusive , set msk2 [ i ] to result of run getmask with i , d2 as arguments
create integer ans with ans = 0
for i = 0 to n exclusive
for j = 0 to m exclusive
if msk1 [ i ] is less than 0 or msk2 [ j ] is less than 0 , break current loop iteration
if ( msk1 [ i ] bitwise and msk2 [ j ] ) is 0 , increment ans
print ans print newline
PI = constant double = acos ( - 1 . 0 )
eps = constant double = 1e - 6
inf = constant integer = 0x3f3f3f3f
str1 , str2 = strings
st1 = character array of size 5 , st2 = character array of size 5
counter = integer
read str1 , str2
counter = 0
if the size of str1 is not the size of str2
else
for i = 0 to the size of str1 exclusive
if str1 [ i ] is not str2 [ i ]
if counter > 2
st1 [ counter ] = str1 [ i ]
st2 [ counter ] = str2 [ i ]
increase counter by 1
if counter > 2 , then print NO
if counter is 1 , then print NO
if counter is 2
if st1 [ 0 ] is st2 [ 1 ] and st1 [ 1 ] is st2 [ 0 ]
else
if counter is 0 , then print YES
declare string variable s
declare ints a , b and c
declare integer variable len
read s
create int n = length of s
create an array of ints w with size n + 10
for integer i = 0 to length of s exclusive
if s [ i ] is equal to ' ( '
increment a
else if s [ i ] = ' # '
increment len and change w [ len ] to 1
increment b by one
else if s [ i ] = ' ) '
increment b by one
if b is greater than a
print - 1
loop i from length of s - 1 to 0 inclusive counting down
if s [ i ] = ' ) '
increment c
else if s [ i ] = ' ( '
decrement c by one
else if s [ i ] = ' # '
break
if c is less than 0
print - 1
increase w [ len ] by a - b
for i = 1 to len inclusive , print w [ i ]
n , a , b , i , j = integers
Read n
for i = 1 to 1000 exclusive
set a to n * i + 1
for j = 2 to a exclusive
if a modulo j is 0
print i and a new line
let n , m , i , len , flag be ints with flag = 0
s , x , s1 , s2 = string
read na dn m
read s and x
for i = 0 to n exclusive
if s [ i ] = ' * '
set flag to 1
exit loop
if n - 1 > m
if flag isn ' t 0
set s1 to substring form 0 to i of s
set s2 = substring from i + 1 to n - i - 1 of s
set len to the length of s2
if substring of x form 0 to i = s1 and substring of x form m = len to m - i = s2
else
else
if s = x
else
define function fun
declare integer variables n and capacity
read n and capacity
declare int variable count = 0
create an array of integers num with size n
create integer j = 0 and an array of integers lib with size = capacity
loop i from 0 to n exclusive , read num [ i ]
loop i from 0 to n exclusive
declare integer variable found = 0
if i is equal to 0
change lib [ j ] to num [ i ]
increment count
increment j
else
for k from 0 to j exclusive
if lib [ k ] = num [ i ]
set found to 1
break
if found = 0
if j ! = capacity
assign num [ i ] to lib [ j ]
increment j by one
increment count by one
else
new integers min = j - 1 , flag , min2 = n - 1 , min3 = j - 1 , prevmin = - 1 , min4 = j - 1
create int counter = 0
for x from 0 to j exclusive
set flag to 0
for y = i to n exclusive
if num [ y ] = lib [ x ]
assign y to min2
change min3 to x
set flag to 1
increment counter by one
stop the loop
if flag is equal to 0
change min to x
else
if prevmin is less than min2
assign min2 to prevmin
change min4 to x
if counter is equal to j
assign num [ i ] to lib [ min4 ]
else
change lib [ min ] to num [ i ]
increment count
print count
call method fun ( )
declare constant long long MAX_N = 1e7
declare solve with no arguments , returning void
declare long long a , b , c , d
read a , b , c , d
declare answer = - 1 as long long
for x = 0 to MAX_N inclusive
declare temp = b + a * x - d as long long
if temp is greater than or equal to 0 and temp % c is 0
let answer be temp + d
end loop
print answer , newline
declare integer t = 1
while decrement t is true , run solve
let i , n , m , k be long integers , arr = array of long integers of length 100000
let ans be a long integer with ans = INFINITY
read n , m , k
for i = 0 to n exclusive , read arr [ i ]
if n modulo 2 is equal to 0 or ( n / 2 ) + 1 is greater than m
print 0 and newline
for i = 0 to n exclusive , i is incremented by 2 , ans is equal to minimum of ans , arr [ i ]
let s be a long integer with s = m / ( ( n / 2 ) + 1 )
ans is equal to minimum of ans , s * k
print ans and new line
mod = const int with mod = 1e9 + 7
eps = const double with eps = 1e - 6
q = long long vcector
in function dfs taking long long x
if x > = 10000000005 return
append x to q
call dfs of x * 10 + 4
call dfs of x * 10 + 7
l , r = long long
call dfs of 0
loop while reading l then r
ans_l , ans_r = long long with ans_l = 0 and ans_r = 0
len = int with len = size of q
for i = 1 to len inclusive
if q [ i ] < = l - 1
increment ans_l by ( q [ i ] - q [ i - 1 ] ) * q [ i ]
else
increment ans_l by ( l - 1 - q [ i - 1 ] ) * q [ i ]
break
for i = 1 to len inclusive
if q [ i ] < = r
increment ans_r by ( q [ i ] - q [ i - 1 ] ) * q [ i ]
else
increment ans_r by ( r - q [ i - 1 ] ) * q [ i ]
break
print ans_r - ans_l
create new constant integer MAX_N = 50
new integer constant MAX_M with value 50
define new 2d array of integers v with size MAX_N by MAX_M
define new 2d array of integers u MAX_N by MAX_M elements
define new integers n and m
void function dfs with int arguments x , y and first
if first is false , assign the new value = 1 to u [ y ] [ x ]
if x > 0 and v [ y ] [ x - 1 ] is true and u [ y ] [ x - 1 ] is false , call dfs ( x - 1 , y )
call dfs ( x + 1 , y ) if x < m - 1 and v [ y ] [ x + 1 ] is true and u [ y ] [ x + 1 ] is false
if y > 0 and v [ y - 1 ] [ x ] is true and u [ y - 1 ] [ x ] is false , run function dfs ( x , y - 1 )
read n and m from the user input
create new integer called k = 0
for i from 0 to n exclusive
new string variable s
read variable s from the input
start for loop from j = 0 to m exclusive
assign the new value = ( true if s [ j ] = ' # ' or false otherwise ) , to v [ i ] [ j ]
add v [ i ] [ j ] to k
if k < = 2
print - 1
define boolean f = false
start for loop from i = 0 to n exclusive
increment j in a loop from 0 to m exclusive
if v [ i ] [ j ] is false , skip the rest of the loop
set first MAX_N * MAX_M * sizeof ( int ) bytes at the pointer u to 0
assign 0 to v [ i ] [ j ]
create boolean variable with name f = false
for integer ii = 0 to n exclusive incrementing ii , while f is false
in a for loop , change jj from 0 to m exclusive , while f is false
if v [ ii ] [ jj ] ! = 0
call dfs ( jj , ii )
assign true to f
start for loop from ii = 0 to n exclusive
loop through jj from 0 to m exclusive incrementing by 1
if i = ii and j = jj , go to the start of the loop
if v [ ii ] [ jj ] ! = u [ ii ] [ jj ]
print 1 and a new line
change the value of v [ i ] [ j ] to 1
print 2
create new integer variable n
define new string called s
read n and s from the user input
declare integer variable with name ans with value 0
for i from 0 to n exclusive incrementing i
if s [ i ] = ' < '
increment ans by one
else
break
in a for loop , change i from n - 1 to 0 inclusive decrementing by 1
if s [ i ] = ' > '
increment ans
else
break
print ans and " \ n "
a , b , c , d , k = double
read a , b , c , d
if ( ( a - b ) is ( b - c ) and ( b - c ) is ( c - d ) )
print d + ( b - a )
else
if ( ( b / a ) is ( c / b ) and ( c / b ) is ( d / c ) )
k = d * ( b / a )
if ( k is ( cast to int ) k )
print k
else
print 42
else
print 42
declare new constant long long mod = 998244353
define constant integer maxn with value 2e5
declare new integer t
create long longs n , a , b and c
read standard input to n
read user input to a , b and c
create long long variables one a and two = b - c
new long long variables sum1 = n / one , yu1 = n % one , and ci
while yu1 / b > 0
set the value of ci to ( yu1 - b ) / two
if ci = 0 and yu1 > = b
if yu1 / a > 0 and yu1 / a * a < yu1 / b * two
set the value of yu1 to yu1 - yu1 / a * a
change the value of sum1 to sum1 + yu1 / a
else
subtract two from yu1
increment sum1
else
change the value of yu1 to yu1 - ci * two
change sum1 to sum1 + ci
create new long longs yu2 = n , sum2 = 0 and ans = 0
while yu2 / b > 0
assign ( yu2 - b ) / two to ci
if ci = 0 and yu2 > = b
if yu2 / a > 0 and yu2 / a * a < yu2 / b * two
assign yu2 - yu2 / a * a to yu2
change sum2 to sum2 + yu2 / a
else
decrease yu2 by two
increment sum2
else
assign the new value = yu2 - ci * two to yu2
change sum2 to sum2 + ci
change sum2 to sum2 + yu2 / one
set yu2 to yu2 modulo one
set ans to max of ans and sum2
change the value of ans to max of sum1 and ans
print ans
let int array days of size 12 with { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }
make strings s1 and s2
read s1 and s2
make map have from strings to ints
set have [ " monday " ] to 1
set have [ " tuesday " ] to 2
set have [ " wednesday " ] to 3
set have [ " thursday " ] to 4
set have [ " friday " ] to 5
set have [ " saturday " ] to 6
set have [ " sunday " ] to 7
create integer d1 to have [ s1 ]
make int d1 to have [ s2 ]
decrease d1 by 1
decrease d2 by 1
for i = 0 to 12 exclusive
make int now to d1
set now to now + days [ i ]
modulo now by 7
if now is d2
show " YES "
display " NO "
create new integer n
read input to n
if n % 4 = 1
print 8
else if n modulo 4 is equal to 2
print 4 to the standard output
else if n modulo 4 is 3
print 2 to the output
else if n is equal to 0
print 1
else
print 6
let companies be a long integer
read companies
emps = vector of long integers
employeenum = vector of long integers
let long integer value of maxmaxsalary = 0
for long integer i = 0 to companies exclusive
let employees be a long integer
read employees
push_back employees into vector employeenum
let long integer value of maxsalary = 0
for long integer j = 0 to employees exclusive
let salary be a long integer
read salary
if maxsalary is less than salary , maxsalary is equal to salary
if maxmaxsalary is less than maxsalary , maxmaxsalary is equal to maxsalary
push_back maxsalary into vector emps
let long integer value of sum = 0
for long integer i = 0 to length of emps exclusive , increment sum by ( maxmaxsalary - emps [ i ] ) * employeenum [ i ]
print sum and newline
size = 5004
dp = array of size by size int
s1 and s2 = array of size char
read s1
read s2
ans = 0
n = length of s1 , m = length of s2
for i = 1 to n + 1 exclusive
for j = 1 to m + 1 exclusive
add dp [ i ] [ j - 1 ] to dp [ i ] [ j ]
dp [ i ] [ j ] = dp [ i ] [ j ] modulo 1000000007
if s1 [ i - 1 ] is s2 [ j - 1 ] add dp [ i - 1 ] [ j - 1 ] + 1 to dp [ i ] [ j ]
dp [ i ] [ j ] = dp [ i ] [ j ] modulo 1000000007
if j is m
add dp [ i ] [ j ] to ans
ans = ans modulo 1000000007
print ans
declare an array of bools a with size 55
create an array of booleans b with size 55
declare vector of ints called ivec
create integers n , aa and bb
read input to n
declare int variable days = n squared
for integer i = 1 to days inclusive
read aa and bb
if a [ aa ] is false and b [ bb ] is false
change a [ aa ] and b [ bb ] to true
push i into ivec
for integer i = 0 to length of ivec exclusive
if i = length of ivec - 1
print ivec [ i ]
else
print ivec [ i ] and ' '
x , LCM , memo = integer array of size 101
T = long long with T = 1
in the function Call that takes integer i , Target and returns integer
if i is Target , return 1
if memo [ i ] , return - 1000
memo [ i ] = 1
return 1 + Call ( x [ i ] , Target )
in the function Fac that takes integer n
i , M = integer with i = 2 , M = integer array of size 101 = { 0 }
while n > 1
if n modulo i is 0
n = n / i , M [ i ]
else
increment i
for i = 2 to 99 , LCM [ i ] = max ( LCM [ i ] , M [ i ] )
n = integer
read n
for i = 1 to n , read x [ i ]
for i = 1 , a to n
if memo [ i ] , continue
a = Call on x [ i ] and i
if a < 1
print - 1
if a modulo 2 is 0 , a = a / 2
Fac on a
for i = 2 to 99
for j = 0 to LCM [ i ] , T = T * i
print T
n = integer
s = string
read n , s
last = character with last = ?
flag = integer with flag = 1
ite = s . begin ( ) to ite is not s . end ( )
if last is pointer ite
if pointer ite is not ?
flag = 0
break loop
else
flag = 2
if ite is not s . begin ( ) and ite is not s . end ( ) - 1
if pointer ite is ? and last is pointer ( ite + 1 ) , flag = 2
else
if pointer ite is ? , flag = 2
last = pointer ite
if flag < = 1
else
declare maxin taking in long long ints a and b and returning long long
if a is greater than b , return a
return b
create long long int n
read n
make long long array arr of size n
for i = 0 to n exclusive , read arr [ i ]
make long long array dif of size n - 1
for i = 0 to n - 1 exclusive , set dif [ i ] to abs ( arr [ i ] - arr [ i + 1 ] )
make long long int soma = 0
create long long maxi = 0
for i = 0 to n - 1 exclusive
if i % 2 is equal to 0 , add dif [ i ] to soma
if i % 2 is not equal to 0 , set soma to soma + dif [ i ] * - 1
set soma to maxin ( soma , 0 )
set maxi to return value of maxin ( soma , maxi )
set soma to 0
for i = 0 to n - 1 exclusive
if i modulo 2 is not equal to 0 , set soma to soma + dif [ i ]
if i % 2 is 0 , add dif [ i ] * - 1 to soma
set soma to maxin ( soma , 0 )
set maxi to maxin ( soma , maxi )
display maxi
s = string
read s
N = size of s
count = array of 101 by 3 int
fill count with 0
for i = 0 to N exclusive
if i is 0
if s [ i ] ! = ' . '
count [ i + i ] [ s [ i ] - ' A ' ] = 1
count [ i ] [ s [ i ] - ' A ' ] = 1
else if i is N - 1
if s [ i ] ! = ' . '
count [ i - i ] [ s [ i ] - ' A ' ] = 1
count [ i ] [ s [ i ] - ' A ' ] = 1
else
if s [ i ] ! = ' . '
count [ i - i ] [ s [ i ] - ' A ' ] = 1
count [ i + i ] [ s [ i ] - ' A ' ] = 1
count [ i ] [ s [ i ] - ' A ' ] = 1
for i = 0 to N exclusive
if count [ i ] [ 0 ] is 1 and count [ i ] [ 1 ] is 1 and count [ i ] [ 2 ] is 1
print " Yes "
print " No "
create an array of int / int pairs trees with 105 elements
declare int variable n
read input to n
declare integers sum , sum_pos and sum_neg = 0
loop i from 0 to n exclusive
read trees [ i ] . first and trees [ i ] . second
increase sum by trees [ i ] . second
if trees [ i ] . first is less than 0 , increase sum_neg by trees [ i ] . second
if trees [ i ] . first is greater than 0 , increase sum_pos by trees [ i ] . second
declare integers pos and neg = 0 and center = - 1
loop i from 0 to n exclusive
if trees [ i ] . first is greater than 0 , increment pos
if trees [ i ] . first > 0 and center = - 1 , change center to i
if pos is equal to 0 , change center to n
assign n - pos to neg
if absolute value of pos - neg < = 1
print sum
else
if neg is greater than pos
assign sum_pos to sum
for integer i = center - 1 , j = 0 while i > = 0 and j < pos + 1 , decrementing i and incrementing j , increase sum by trees [ i ] . second
else
change sum to sum_neg
for i = center , j = 0 while i < n and j < neg + 1 , increase sum by trees [ i ] . second
print sum
long long function bigmod with long long arguments a , b and m
if b = 0 , return 1 % m
declare long long variable x = bigmod ( a , b / 2 , m )
change x to ( x * x ) modulo % m
if b is odd , assign ( x * a ) % m to x
return x
f is a long long function with long long argument n
if n = 0 , return 0
if n % 10 = 0 , decrement n by one
if n is less than 100 , return n / 11 + ( n if n < 10 or 9 otherwise )
declare long long variable r = n % 10
declare long long l = n and d = 1
while l > 9
divide l by 10
increment d by one
declare long long variable m
declare long long variable c = 1
for i = 0 to d - 1 exclusive , multiply c by 10
change m to ( n % c ) / 10 + 1
declare long long an = 18
set c to 1
for i from 3 to d inclusive
multiply c by 10
for j from 1 to 9 inclusive
if i is equal to d and j is equal to l
if l < = r
return an + m
else
return an + m - 1
increase an by c
return an
declare long long variables a and b
read a and b and loop further , printing f ( b ) - f ( a - 1 ) on each iteration
declare integers n , i
declare integer array arr size 100005
read n
for i = 0 to n exclusive , read arr [ i ]
declare integers counter = 0 , flag = 0 , found = 0
for i = 0 to n exclusive
if arr [ i ] is 25 , increment counter
if arr [ i ] is 50
if counter is less than 1
increment flag
end loop
else
increment found
decrement counter
if arr [ i ] is 100
if counter is less than 0 or ( found is less than 1 and counter is less than 1 )
increment flag
end loop
else
if found is greater than 0 and counter is greater than 0
decrement found
decrement counter
else
if counter is less than 3
increment flag
end loop
decrement counter by 3
if flag is 0
print " YES " and newline
else
print " NO " and newline
pos , flag = int with flag = 0
str , s , t = string
read str then s then t
set pos to index of s in str and if pos is not string : : npos
if str contains t after pos + length of s then increment flag
set pos to index of s in str and if pos is not string : : npos
if str contains t after pos + length of s then increment flag by 2
if flag is 0
print " fantasy "
else if flag is 1
print " forward "
else if flag is 2
print " backward "
else
print " both "
declare new boolean variable cek = true
declare integer variable n
create new string s
read n and s
start for loop from i = 1 to n exclusive incrementing i
if s [ i - 1 ] and s [ i ] are both equal to ' 1 ' , assign the new value = false to cek
in a for loop , change i from 2 to n exclusive incrementing i
if values of s [ i - 2 ] , s [ i - 1 ] and s [ i ] are equal to ' 0 ' , assign false to cek
if n > = 2
change cek to false if s [ 0 ] and s [ 1 ] are equal to ' 0 '
set the value of cek to false if s [ n - 1 ] and s [ n - 2 ] = ' 0 ' ,
else if s [ 0 ] is equal to ' 0 '
set cek to false
print " Yes " if cek is true of " No " otherwise
define unsigned long long integer n
read standard input to n
if n < = 127
print " byte \ n "
else if n < = 32767
print " short \ n "
else if n < = 2147483647
print " int \ n " to the standard output
else if n < = 9223372036854775807
print " long \ n "
else
print " BigInteger \ n "
let str a string
read str
let temp a string
set temp to str
if temp same as str
otherwise
let ans an int with value 0
let k1 an int with value ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' )
let k2 an int with value ( str [ 3 ] - ' 0 ' ) * 10 + ( str [ 4 ] - ' 0 ' )
repeat forever
increment k2
increment ans
if k2 at least 60
set k2 to 0
increment k1
if k1 at least 23 , set k1 to k1 mod 24
let blah an empty string
append ( k1 / 10 + ' 0 ' ) to blah
append ( k1 mod 10 + ' 0 ' ) to blah
append ( k2 / 10 + ' 0 ' ) to blah
append ( k2 mod 10 + ' 0 ' ) to blah
let val a string , and set it equal to blah
if val same as blah , leave loop
print ans
let N be a constant interger , set N to 1e5 + 1
let arr be of array of length N of long long integers
let n be an integer
read in n
set arr [ 0 ] to 0
iterate for N - 1 times , set arr [ i ] to arr [ i - 1 ] + i
iterate for N - 1 times
if n - arr [ i ] is in the array
create const int MAXN = 1e5 + 10
create int arrays mp and dp with MAXN elements
declare integers x and y
read x and y
if x is false or y is false
if x is false and y is false
print 0
else
if y is false
if x is less than 0
print 4 * ( - x ) - 1
else
if x is equal to 1
print 0
else
print ( x - 1 ) * 4 + 1
else
if y is greater than 0
print ( y - 1 ) * 4 + 2
else
print ( - y ) * 4
else
if x > 0 and x > = y and y > - x + 1
print ( x - 1 ) * 4 + 1
else if y > 0 and - y < = x and y > x
print ( y - 1 ) * 4 + 2
else if x < 0 and y > = x and - x > y
print 4 * - x - 1
else
print - y * 4
a = array of unsigned long integers of length 2000000
b = array of unsigned long integers of length 2000000
let n be a integer
let judge be boolean which accepts int n
for i = 0 to n - 1 exclusive
if a [ i ] is equal to a [ i + 1 ] , return the value true
return the value false
while read n
memset of a , 0 , length of a
for i = 0 to n exclusive
read a [ i ]
increment b [ a [ i ] ] by 1
sort the values a , a + n
let ans be a integer with ans = 0
for i = 1 to 2000000 exclusive
increment b [ i ] by b [ i - 1 ] / 2
b [ i - 1 ] is equal to b [ i - 1 ] modulo 2
increment ans by b [ i - 1 ]
print ans and new line
in function maxx taking long long int a , long long int b and returning long long int
if a > b return a else return b
in function minn taking long long int a , long long int b and returning long long int
if a > b return b else return a
dx = int array with the values 1 , 1 , 1 , 0 , 0 , - 1 , - 1 , - 1 , 0
dy = int array with the values - 1 , 0 , 1 , 1 , - 1 , 0 , 1 , - 1 , 0
define empty function boostISO
in function gcd taking long long int a , long long int b and returning long long int
if b is 0 return a else return gcd of b , a mod b
in function lcm taking long long int a , long long int b and returning long long int
return ( a * b ) / gcd of a , b
in function poww taking long long int base , long long int exp and returning long long int
set base to base mod 1000000007
result = long long int with result = 1
loop while exp > 0
if exp bitwise - and 1 set result to ( result * base ) mod 1000000007
set base to ( base * base ) mod 1000000007
set exp to exp bitshift right by 1
return result
a = int vector array of size 200
pos = two dimensional bool array of sizes 120 and 120 and vis = bool array of size 120
n , m = int
in function dfs taking int root
set vis [ root ] to 1
for i = 0 to size of a [ root ]
if not vis [ a [ root ] [ i ] ] call dfs of a [ root ] [ i ]
return
in function comp returning int
ret = int with ret = 0
for i = 1 to n icnlusive
if not vis [ i ]
increment ret
call dfs of i
return ret
read n then m
tot = int with tot = 0
for i = 1 to n inclusive
x = int
read x
increment tot by x
for j = 0 to x
l = int
read l
set pos [ i ] [ l ] to 1
if tot is 0
print n
for i = 1 to n inclusive
for j = i + 1 to n inclusive
for k = 1 to m inclusive
if pos [ i ] [ k ] and pos [ j ] [ k ]
append j to a [ i ] then append i to a [ j ]
break
print comp - 1
create int n
read n
create int b [ n + 5 ]
create int c [ n + 5 ]
for l and k = 1
for i = 1 to n inclusive
create int m
read m
set b [ l ] to m
increment l
create int a [ m + 5 ]
for i = 1 to m inclusive , read a [ i ]
sort on ( a + 1 , a + 1 + m )
set c [ k ] = a [ 1 ]
increment k
for i = 1 to m inclusive , set a [ i ] = 0
set su = b [ 1 ]
assign 0 to sum1
mx = c [ 1 ]
for i = 2 to n inclusive
if mx > c [ i ]
s = mx - c [ i ]
set sum = s * b [ i ]
assign sum1 + sum to sum1
set su to su + b [ i ]
else
s = c [ i ] - mx
set sum = s * su
set sum1 to sum1 + sum
assign su + b [ i ] to su
mx = c [ i ]
print sum1
x = int
read x
a = x
b = a
if a * b < = x or a / b > = x
print - 1
else
print a , space , b
a = array of 150 integers
b = array of 150 integers
n , m , i , j , k , flag , t , g , sum = integers with flag = 1 and sum = 0
Read n
Read n values into array a
s = integer with 0
set g to 0
set t to 0
for i = 1 to n exclusive
increment t
if a [ i ] is less than 0 , then increment g
if g is 3 OR i is n
if i is n and g is not 3
increment s
set b [ s ] to t
Terminate the loop
increment s
set b [ s ] to t - 1
set t to 0
set g to 0
decrement i
print s and a new line
for i = 1 to n exclusive
if i is 1
print b [ i ]
print b [ i ]
print a new line
c1 = bool array of size 51
c2 = bool array of size 51
n = int
a = int
b = int
v = int vector
read n
set n to n * n
for i = 1 to n inclusive
read a then b
if c1 [ a ] and c2 [ b ] are both false
set c1 [ a ] to true
set c2 [ b ] to true
append i to v
for i = 0 to size of v
if i is size of v - 1
print v [ i ] then newline
else
print v [ i ] then " "
n , m = integers
read n , m
min = integer with min = 1000000011
for i = 0 to m exclusive
l , r = integers
read l , r
min = if ( min > ( r - l + 1 ) ) , ( r - l + 1 ) else min
print min
for i = 0 to n - 1 exclusive , print i modulo min
print ( n - 1 ) modulo min
create constant integer N = 2e5 + 10
make string z = " GRBYW "
make int arrays t1 of size N and t2 of size N
make long ints ans = 1e9 , temp , and same
declare resolve taking in char c and returning integer
for i = 0 to z . size ( ) exclusive
if z [ i ] is equal to c , return i
declare cbits taking in long long x and returning long long
make integer r = 0
for i = 0 to 10 exclusive
if x & ( 1 < < i ) is truthy , increment r
return r
make long long integer n
read n
for i = 0 to n exclusive
create string s
read s
set t1 [ i ] to resolve ( s [ 0 ] )
set t2 [ i ] to s [ 1 ] - ' 1 ' + 5
for mask = 0 to 1024 exclusive
set temp to cbits ( mask )
if temp is more than ans , continue loop
make integer err = 0
for i = 0 to n exclusive
for j = i + 1 to n exclusive
if t1 [ i ] is equal to t1 [ j ] and t2 [ i ] is equal to t2 [ j ] , continue loop
set same to 1
if t1 [ i ] is not equal to t1 [ j ]
if mask & ( 1 < < t1 [ i ] ) is truthy , set same to 0
if mask & ( 1 < < t1 [ j ] ) is truthy , set same to 0
if t2 [ i ] is not equal to t2 [ j ]
if mask & ( 1 < < t2 [ j ] ) , set same to 0
if mask & ( 1 < < t2 [ j ] ) , set same to 0
if same is truthy , set err to 1
if err is falsy , set ans to min of ans and temp
let M be a map from long long to boolean
declare integer n
declare long long variable k and long long array a with 100009 elements
read n and k
loop i from 1 to n inclusive , read a [ i ]
create int c = 0
sort a from the index 1 to n + 1
for i from 1 to n inclusive
if M [ a [ i ] ] is false
increment c by one
M [ a [ i ] * k ] = 1
print c
v is an array of integers with 1000500 elements
create integer variable with name n
read n and loop further
set first sizeof ( v ) bytes at the pointer v to 0
for i from 0 to n exclusive incrementing i
x is a new integer
read x
increment v [ x ] by one
start for loop from i = 0 to 1000400 exclusive incrementing i
change v [ i + 1 ] to the sum of v [ i + 1 ] and v [ i ] / 2
change the value of v [ i ] to v [ i ] modulo 2
t is a new integer variable with value 0
for integer i = 0 to 1000400 exclusive , change t to t + v [ i ]
print t
declare a , b , c , d , e , f as integers
read a and b and c and d and e and f
declare boolean test = a and c and e and b * d * f is greater than a * c * e
declare booleans sgs = e is 0 and f is not 0 , sgl = a is 0 and b is not 0 , sgg = c is 0 and d is not 0
declare booleans cgs = f is not 0 , cgl = b is not 0 , cgg = d is not 0
declare boolean ron = sgg or ( sgl and cgg ) or ( sgs and cgl and cgg ) or tests
if ron is true
print " Ron " , newline
else
print " Hermione " , newline
MAXN is a new constant integer = 2e7
prime is an array of integers with size MAXN
declare new array of integers vis with MAXN elements
a is an array of integers with size MAXN
function init
start for loop from i = 2 to MAXN exclusive incrementing i
if ! prime [ i ] , increment prime [ 0 ] and change prime [ prime [ 0 ] ] to i
increment j in a for loop from j = 1 , while j < = prime [ 0 ] and prime [ j ] < = MAXN / i
change value of prime [ prime [ j ] * i ] to 1
if i % prime [ j ] = 0 , stop the loop
create integer variable n
define integer variable gcd
read from the input to n
for i from 1 to n inclusive
read user input to a [ i ]
if i is equal to 1
change the value of gcd to a [ 1 ]
else
set gcd to the resulf of __gcd ( gcd , a [ i ] )
define new integer Max with value 0
call init ( )
for integer i = 1 to n inclusive
change the value of a [ i ] to a [ i ] divided by gcd
change j in a loop from 1 , while < = prime [ 0 ] & & prime [ j ] * prime [ j ] < = a [ i ]
if a [ i ] modulo prime [ j ] is equal to 0
while a [ i ] % prime [ j ] is 0 , divide a [ i ] by prime [ j ]
increment vis [ prime [ j ] ]
assign the new value = max of Max and vis [ prime [ j ] ] to Max
if a [ i ] ! = 1
increase vis [ a [ i ] ] by one
set the value of Max to max of Max and vis [ a [ i ] ]
if Max is equal to 0
print - 1
else
print n - Max to the standard output
let n be a integer
read n
print n / 2 and endline
for integer i = 1 to n / 2 - 1 inclusive , print 2 and space
print 2 + n % 2 and endline
create new boolean called answerFound
new long longs t0 , t1 , t2 , x1 , x2 , ansy1 and ansy2
check is a void function with long long arguments y1 and y2
set y1 to min of y1 and x1
assign min of y2 and x2 to y2
set y1 to max of y1 and 0LL
set y2 to max of y2 and 0LL
return if t0 * ( y1 + y2 ) is greater than t1 * y1 + t2 * y2
if answerFound is false
assign the new value = y1 to ansy1
change ansy2 to y2
assign true to answerFound
else
create long long variable l = ( t1 * y1 + t2 * y2 ) * ( ansy1 + ansy2 )
declare long long r = ( t1 * ansy1 + t2 * ansy2 ) * ( y1 + y2 )
if l is less than r
assign the new value = y1 to ansy1
change the value of ansy2 to y2
assign the new value = true to answerFound
else if l = r and y1 + y2 > ansy1 + ansy2
change ansy1 to y1
change ansy2 to y2
change answerFound to true
divUp is a long long function with long long arguments a and b
return ( a + b - 1 ) / b
read input to t1 , t2 , x1 , x2 and t0
call check ( 0 , 0 )
run function check ( 0 , 1 )
run check with arguments 1 and 0
start for loop from y1 = 0 to x1 inclusive incrementing y1
check ( y1 , x2 )
if t2 ! = t0
y2 is a new long long = the result of divUp ( t0 * y1 - t1 * y1 , t2 - t0 )
run check ( y1 , y2 )
for y2 = 0 to x2 inclusive
call check for x1 and y2
if t1 ! = t0
declare new long long called y1 = ( t2 * y2 - t0 * y2 ) / ( t0 - t1 )
check ( y1 , y2 )
print ansy1 , " " and ansy2 to the standard output
y is a string array of 3 elements
z is an integer array of size 3
let i , k be integers
for i = 0 to 3 exclusive
read y [ i ]
for k = 0 to 12 exclusive
if y [ i ] equals x [ k ]
z [ i ] equals k
stop
sort the values z , z + 3
a , b are integers
do loop
a equals ( ( z [ 1 ] - z [ 0 ] ) + 12 ) modulo 12
b equals ( ( z [ 2 ] - z [ 1 ] ) + 12 ) modulo 12
if a equals 4 and b equals 3
print major and endline
if a equals 3 and b equals 4
print minor and endline
while condition is next_permutation ( z , z + 3 )
print strange and endline
t = int
read t
while decremented value of t is not 0
c = char
x , y , a , b , i , j , l = 0
for i = 1 to 8 inclusive
for j = 1 to 8 inclusive
read c
if c is ' K ' and l is 0
x = i
y = j
l = 1
else if c is ' K ' and l is 1
a = i
b = j
if a - x and b - y are multiple of 4
else
let f be a map from strings to integers
in the function init
set the value of f [ " C " ] to 0
set the value of f [ " C # " ] to 1
assign 2 to f [ " D " ]
assign the new value = 3 to f [ " D # " ]
assign the new value = 4 to f [ " E " ]
assign the new value = 5 to f [ " F " ]
change f [ " F # " ] to 6
change the value of f [ " G " ] to 7
change f [ " G # " ] to 8
assign the new value = 9 to f [ " A " ]
assign 10 to f [ " B " ]
change f [ " H " ] to 11
call function init ( )
create new array of strings s with size 3
read s [ 0 ] , s [ 1 ] and s [ 2 ] from the input
declare new string tag with value " strange "
start while loop
declare integer variable with name a = f [ s [ 1 ] ] - f [ s [ 0 ] ]
declare integer b with value f [ s [ 2 ] ] - f [ s [ 1 ] ]
if a is less than 0 , increase a by 12
if b is less than 0 , add 12 to b
if a = 4 and b is equal to 3
assign " major " to tag
stop the loop
else if a is equal to 3 and b = 4
set tag to " minor "
break
call next_permutation ( s , s + 3 ) and go to the start of the loop
print tag
integer as n
read n
integer as p [ n ]
create integer vector of v [ n ]
set p [ 0 ] to - 1
for i = 1 to less than n do the following
read p [ i ]
add new element i to end of vector v [ p [ i ] - 1 ]
add new element p [ i ] - 1 to end of vector v [ i ]
create integer vector of ans
add new element n to end of vector ans
integer as cur = n
if cur is not equal to 1 then do the following
set cur to p [ cur - 1 ]
add new element cur to end of vector ans
for i = ans . size ( ) - 1 to greater than or equal to 0 do the following
output ans [ i ]
if i is not equal to 0 then print space
output end line
convert_str is a int function with string argument str
create new integer x
create new stringstream ss with the size = size of str
read str to ss
print ss to x
return x
convert_int is a string function with int argument x
create new stringstream ss
put x into ss
return ss converted to string
declare string variable called str
read str from the user input
left and right are new strings = " "
increase left by str [ 0 ]
change left to left + str [ 1 ]
increase right by str [ 3 ]
increase right by str [ 4 ]
declare new string psg = left
if convert_str ( right ) is less than convert_str ( psg )
declare new integer variable temp with value = the result of convert_str ( left )
if temp < = 8 and temp > = 5
print " 10 : 01 "
else if temp < = 19 and temp > = 15
print " 20 : 02 "
else
print left , ' : ' and psg
else
if left is " 23 "
print " 00 : 00 " to the standard output
else
create new integer temp
assign the result of convert_str ( left ) to temp
if temp < = 8 and temp > = 5
change temp to 10
else if temp < = 19 and temp > = 15
set temp to 20
else
increment temp by one
change left to the result of the call to convert_int ( temp )
if length of left is equal to 1
create string cat = " 0 "
append left to cat
change left to cat
set right to left
print left , ' : ' and right to the standard output
d , l , a , b = double
read d , l , a , b
print ( with 6 decimal digits ) ( l - d ) / ( a + b )
let N be const integer with N = 1e5 + 5
let n , d be integers and x an array of integers of size N
let ans be long long
read n and d
for i = 0 to n exclusive and p = 0
read x [ i ]
while x [ i ] - x [ p ] is greater than d , increment p by 1
update ans to ans + ( i - p - 1LL ) * ( i - p ) / 2
print out ans with newline
make string Sentence
read Sentence
make ints beforeP = 0 , afterP = 0 , and after = 0
let bool equal = true
make bool Plus = true
for i = 0 while Sentence [ i ] is not equal to ' \ 0 '
if equal is true
if Sentence [ i ] is equal to ' | ' and Plus is true
increment beforeP
else if Sentence [ i ] equals ' | '
add 1 to afterP
if Sentence [ i + 1 ] is equal to ' + ' , set Plus to false
else do
if Sentence [ i ] is equal to ' | ' , increment after
add 1 to i
if Sentence [ i ] is equal to ' = ' , set equal to false
if abs ( after - ( beforeP + afterP ) is equal to 2
if after is greater than ( beforeP + afterP )
print " | "
for i = 0 while Sentence [ i + 1 ] is not ' \ 0 ' , show Sentence [ i ]
otherwise
if beforeP is equal to 1
for i = 0 while Sentence [ i ] is not equal to ' \ 0 '
show Sentence [ i ]
if Sentence [ i ] is equal to ' + ' , add 1 to i
otherwise do
for i = 1 while Sentence [ i ] is not ' \ 0 ' , show Sentence [ i ]
display " | "
else if after is equal to ( beforeP + after )
show Sentence
else
print " Impossible "
print new line
create long long t , s , x
read t , s , x
if x < t
print NO and a new line
else if x - 1 = t
print NO and a new line
else if ( x - t ) % s = 0 or ( x - t ) % s = 1
print YES and a newline
else
print NO and a newline
in the function to_num which takes a string s and returns an integer
if size of s is greater than or equal to 4
if s . substr ( s . size ( ) - 4 ) = " lios " then return 0
if size of s > = 5
if s . substr ( s . size ( ) - 5 ) = " liala " then return 1
if size of s > = 3
if s . substr ( s . size ( ) - 3 ) = " etr " then return 2
if size of s > = 4
if s . substr ( s . size ( ) - 4 ) = " etra " then return 3
if size of s > = 6
if s . substr ( s . size ( ) - 6 ) = " initis " then return 4
if size of s > = 6
if s . substr ( s . size ( ) - 6 ) = " inites " then return 5
return - 1
in the function islegal which takes a integer vector ans and returns a boolean
if ans [ 0 ] % 2 is equal to 0
for i = 1 to size of ans exclusive
if ans [ i ] % 2 is not equal to 0 then return false
for i = 1 to size of ans exclusive
if ans [ i ] is equal to - 1 then return false
if ans [ i ] % 2 = 0 then return false
return true
in the function isok which takes an integer vector ans and returns a boolean
create a boolean f = false
for i = 0 to size of ans exclusive
if ans [ i ] / 2 is equal to 0 and f is false
set f to true
continue
if f is false
if ans [ i ] / 2 is not equal to 0 then return false
if ans [ i ] / 2 is not equal to 2 then return false
if f is false then return false
return true
c = array of chars of size 100010
s = string
res = vector of string
ans = vector of integer
create an integer pos = 0
read c
set s = c
for i = 0 to size of s exclusive
if s [ i ] is empty
add s . substr ( pos , i - pos ) to the end of res
set pos to i + 1
add s . substr ( pos ) to end of res
for i = 0 to size of res exclusive add to_num ( res [ i ] to end of ans
if size of ans is equal to 1 and asn [ 0 ] > = 0
print YES
if islegal ( ans ) is true
if isok ( ans ) is true
print YES
print NO
print NO
let rotate be a function that accepts string curr and returns a string value
let ans be a string
increment ans by curr [ 2 ]
increment ans by curr [ 0 ]
increment ans by curr [ 3 ]
increment ans by curr [ 1 ]
return the value of ans
create a set of strings by name dict
let ans , n be integers with ans = 0
read n
let temp be a string
while n is decremented by 1
let curr be a string
read curr , temp
increment curr by temp
read temp
if dict . find ( curr ) equals dict . end ( )
insert curr into dict
for i = 0 to 4 exclusive
curr is equal to rotate ( curr )
insert curr into dict
increment ans by 1
print ans and newline
declare integer array dp size 26 by 26
declare maxi with integer address a , integer a as arguments , returning void
let a be maximum of a and b
declare integer n
read n
for i = 0 to n exclusive
declare string s
read s
declare integers first = s [ 0 ] - ' a ' , last = s [ size of s - 1 ] - ' a '
for j = 0 to 26 exclusive
if dp [ j ] [ first ] is true , run maxi with dp [ j ] [ last ] , size of s + dp [ j ] [ first ] as arguments
run maxi with dp [ first ] [ last ] , size of s as arguments
declare integer ans = 0
for i = 0 to 26 exclusive , run maxi with ans , dp [ i ] [ i ] as arguments
print ans and " \ n "
create strings s1 , s2
read s1 read s2
create integers count , len1 , len2 , len , b1 , b2 with count = 0 , len1 = size of s1 , len2 = size of s2
set len to len1 if len1 is less than len2 , else len2
create characters a1 , a2
for i = 0 to len exclusive
if character at position i in s1 is not character at position i in s2
increment count
if count is 1 , set a1 to character at position i in s1 , set b1 to i
if count is 2 , set a2 to character at position i in s1 , set b2 to i
if count is 2
set character at position b1 in s1 to a2
set character at position b2 in s1 to a1
if count is not 2 or s1 is not s2
print " NO " print newline
else
print " YES " print newline
declare vector of long longs called v
fun is a void function with long long argument x
push x to the v
if x is greater than 1e9 , return
call fun ( of * 10 + 4
call function fun with an argument = x * 10 + 7
call fun ( 4 )
call fun ( 7 )
declare new int variables l , r and cur where cur = 0
declare long long variable res = 0
read from the input to l and r
for integer i = 0 to length of v exclusive
if v [ i ] > = l
change cur to i
stop the loop
start for loop from l = to r inclusive
if v [ cur ] is less than l , increment cur
add v [ cur ] to res
print res
declare map from string to long long cnt
let cnt [ " C " ] be 1
let cnt [ " C # " ] be 2
let cnt [ " D " ] be 3
let cnt [ " D # " ] be 4
let cnt [ " E " ] be 5
let cnt [ " F " ] be 6
let cnt [ " F # " ] be 7
let cnt [ " G " ] be 8
let cnt [ " G # " ] be 9
let cnt [ " A " ] be 10
let cnt [ " B " ] be 11
let cnt [ " H " ] be 12
declare strings input1 , input2 , input3
read input1 , input2 , input3
declare long long vector v
add cnt [ input1 ] to end of v
add cnt [ input2 ] to end of v
add cnt [ input3 ] to end of v
sort from beginning of v to end of v
if v [ 1 ] - v [ 0 ] is 4 and v [ 2 ] - v [ 1 ] is 3
print " major \ n "
else if v [ 2 ] - v [ 1 ] is 4 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ]
print " major \ n "
else if v [ 1 ] - v [ 0 ] is 3 and ( v [ 2 ] + 4 ) % 12 is v [ 0 ]
print " major \ n "
else if ( v [ 1 ] - v [ 0 ] ) * 2 is 4 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ]
print " major \ n "
else if ( v [ 2 ] + 4 ) % 12 is v [ 0 ] and ( v [ 2 ] - v [ 1 ] ) * 2 is 3
print " major \ n "
else if ( v [ 2 ] - v [ 1 ] ) * 2 is 4 and ( v [ 1 ] - v [ 0 ] ) * 2 is 3
print " major \ n "
else if v [ 1 ] - v [ 0 ] is 3 and v [ 2 ] - v [ 1 ] is 4
print " minor \ n "
else if v [ 2 ] - v [ 1 ] is 3 and ( v [ 2 ] + 4 ) % 12 is v [ 0 ]
print " minor \ n "
else if v [ 1 ] - v [ 0 ] is 4 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ]
print " minor \ n "
else if ( v [ 1 ] - v [ 0 ] ) * 2 is 3 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ]
print " minor \ n "
else if ( v [ 2 ] + 3 ) % 12 is v [ 0 ] and ( v [ 2 ] - v [ 1 ] ) * 2 is 4
print " minor \ n "
else if ( v [ 2 ] - v [ 1 ] ) * 2 is 3 and ( v [ 1 ] - v [ 0 ] ) * 2 is 4
print " minor \ n "
else
print " strange \ n "
create long long int mod = 1000000007
create long long ints l and r
create long long int array p with 18 elements
create long long int array ct with 19 elements
in the function init
assign 1 to p [ 0 ]
loop i from 1 to 17 inclusive , set p [ i ] to 10ll * p [ i - 1 ]
set ct [ 1 ] to 9
set ct [ 2 ] to 9
for integer i = 3 to 18 inclusive , set ct [ i ] to 9 * p [ i - 2 ]
long long int function calc with long long int argument num
declare vector of ints digits
declare long long int n = num
while num ! = 0
push num % 10 to the end of digits
divide num by 10
if size of digits = 1 , return n - 1
declare integer l = length of digits
create long long int ans = 0
for i from l - 1 to 0 inclusive decrementing i
if i = l - 1
if digits [ i ] is greater than 1 , add ( digits [ i ] - 1 ) * ( p [ l - 2 ] ) to ans
else if i = 0
if digits [ l - 1 ] is less than digits [ 0 ] , add 1 to ans
else if digits [ i ] > 0
increase ans by ( digits [ i ] ) * ( p [ i - 1 ] )
for integer i = 0 to l exclusive , add ct [ i ] to ans
return ans
call init ( )
read l and r
print calc ( r + 1 ) - calc ( l )
N is a constant integer set to 105
let is be a boolean array of sizes N and N
in function f with parameter integer x and return integer
return ( x * ( x - 1 ) * ( x - 2 ) ) / 6
let k be an integer
input k
let n be an integer set to 1
while call f with n + 1 is at most k
subtract call f with n from k
for i = 1 to n inclusive
for j = 1 to n inclusive
if i isn ' t j , set is [ i ] [ j ] to true
let s be an integer with s = n
while k is positive
increment s
for i = 1 to n inclusive
if k is at least i - 1
subtract i - 1 from k
assign true to is [ s ] [ i ]
assign true to is [ i ] [ s ]
for i = 1 to s inclusive
for j = 1 to s inclusive , display is [ i ] [ j ]
display newline
s = array of characters of size 1000
read s
create integer n = length of s
if n < 3 or ( n = 3 and strcmp ( s , " 127 " ) < = 0 )
print byte and newline
else if n < 5 or ( n = 5 and strcmp ( s , " 32767 " ) < = 0 )
else if n < 10 or ( n = 10 and strcmp ( s , " 2147483647 " ) < = 0 )
else if n < 19 or ( n = 19 and strcmp ( s , " 9223372036854775807 " ) < = 0 )
print long and a new line
declare char array s with 200006 as length
declare int count , n , flag
while reading n
assign 0 to count
fill s with 0
for i = 0 to n exclusive , read s [ i ]
define int i = 0 , j = n - 1
while s [ i + + ] equals ' < ' , increment count
while s [ i - - ] equals ' > ' , increment count
print count
n is an integer
a is a string
b is a string
read a , b
map mp from string to integer
mp [ " monday " ] equals 1
mp [ " tuesday " ] equals 2
mp [ " wednesday " ] equals 3
mp [ " thursday " ] equals 4
mp [ " friday " ] equals 5
mp [ " saturday " ] equals 6
mp [ " sunday " ] equals 0
let p1 equals mp [ a ]
let p2 equals mp [ b ]
if ( p1 + 30 ) % 7 equals p2
put YES
if ( p1 + 28 ) % 7 equals p2
put YES
if ( p1 + 31 ) % 7 equals p2
put YES
print NO and endline
let s be a string
read s
let ac be integer 0
for integer i = 0 to size of s exclusive , increase ac by s [ i ]
if ac equals s . size ( )
s [ s . size ( ) - 1 ] equals ' z '
else
astarted be integer 0
for integer i = 0 to size of s exclusive
if astarted and s [ i ] equals ' a '
if s [ i ] not equals ' a '
astarted equals to 1
decrease s [ i ] by 1
print s and endline
pause
pause be integer
read pause
create constant integer maxn with maxn = 110
create integer array crush with size maxn
create integer n
create boolean array vis with size maxn
create boolean can with can = true
create long long d with d = 0
create long long ans with ans = 1
declare dfs with integers now , start as arguments , returning void
if now is start and vis [ start ] is true , return from function
if vis [ now ] is true
set can to false
return from function
set vis [ now ] to true
run dfs with crush [ now ] , start as arguments
increment d
read n
for i = 1 to n inclusive , read crush [ i ]
set bytes from vis to size of vis to value 0
for i = 1 to i is less than or equal to n and can is true , incrementing i
if not vis [ i ]
set d to 0
run dfs with i , i as arguments
if d % 2 is 0 , set d to d / 2
set ans to ans * d / result of run __gcd with ans , d as arguments
if can is true
print ans print newline
else
print " - 1 " print newline
create long long ints l and r
make long long int vector s
let long long integer vector Next
declare fun taking in long long int num
if num is greater than r
append num to Next
return
if num is greater than or equal to 1 , append num to s
call fun ( num * 10 + 4 )
call fun with argument num * 10 + 7
read l and r
call fun ( 0 )
create long long int len = s . size ( )
make long long int Left = 1 - 1
let long long integer sum = 0
for i = 0 to len exclusive
let long long integer num = ( s [ i ] - Left )
add num * s [ i ] to sum
set Left = s [ i ]
if len is equal to 0
set sum to sum + ( r - Left ) * Next [ 0 ]
else if s [ len - 1 ] is not equal to r
set sum to sum + ( r - Left ) * Next [ 0 ]
n , d = integers
read n and d
v = array of integers with length of 1000005
for i = 0 to n exclusive
point = integer
read point
set v [ i ] to point
result = long long integer set to 0
for right = 2 , left = 0 , right to n exclusive
while v [ right ] - v [ left ] > d , increment left by 1
increment result by right - left * right - left - 1 / 2
print result
n , L , a are integers
read n , L , a
result is an unsigned integer set to 0
prevbeg , prevlen are integers both set to 0
for currcase = 0 to n exclusive
declare integers begin , length
read begin , length
if currcase isn ' t 0
breaktime = integer = begin - ( prevbeg + prevlen )
add floor ( breaktime / a ) to result
else
add floor ( begin / a ) to result
assign begin to prevbeg
assign length to prevlen
lastbreaktime = integer = L - ( prevbeg + prevlen )
add floor ( lastbreaktime / a ) to result
output result
let n , m be integers
lg = 2d array of boolean values with 111 rows and 111 columns respectively
a = 2d array of integers with 111 rows and 111 columns respectively
111th element in the boolean array v is equal to 0
111th element in the boolean array zero is equal to 0
let integer ex is equal to 0
let dfs be a void function which accepts integer i
v [ i ] is equal to true
for j = 1 to n inclusive
if a [ i ] [ j ] and not v [ j ] , depth first search of j
read n , m
for i = 1 to n inclusive
let t be a integer
read t
if t is equal to 0
zero [ i ] is equal to true
increment ex by 1
while t is decremented by 1
let c be a integer
read c
lg [ i ] [ c ] is equal to true
for i = 1 to n inclusive
for j = 1 to n inclusive
if i is not equal to j
for k = 1 to m inclusive
if lg [ i ] [ k ] and lg [ j ] [ k ] , a [ i ] [ j ] is equal to 1
let ans be a integer with ans = 0
for i = 1 to n inclusive
if not v [ i ] and not zero [ i ]
depth first search of i
increment ans by 1
decrement ans by 1
if ans is less than 0 , ans is equal to 0
print ans + ex and newline
create int array data of size 100005 , initialized to 0
create int n
read n
print n / 2
for i = 1 to n / 2 exclusive , print 2 , " "
if n is odd
print 3
else
print 2
n = integer
myv = vector of integer
read n
for i = 0 to n exclusive
res = integer with res = 0
for j = 0 to 3
tmp = int
read tmp
res = res + tmp
append res in myv
tomas = integer with tomas = myv [ 0 ]
sort myv . begin ( ) and myv . end ( )
reverse myv . begin ( ) and myv . end ( )
for i = 0 to n exclusive
if ( tomas is myv [ i ] )
print i + 1
s = string
n = int
sum = int
while reading n
read s
set sum to 0
for i = 0 to n exclusive
if s at i = ' < '
increment sum
else
exit loop
for j = n - 1 to 0 inclusive
if s [ j ] = ' > '
increment sum
else
exit loop
print sum
declare double EPS = 1e - 8
declare fast with no arguments , returning void
declare sortby with constant pairs from integer to integer addresses a , b , returning boolean
if first element of a is greater than or equal to first element of b and second element of a is greater than or equal to second element of b , return true from function
return false from function
declare area with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , returning double
return absolute value of ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 . 0 ) from function
declare gcd with integers a , b as arguments , returning integer
return a if b is 0 , else result of run gcd ( b , a % b )
run fast
declare integers n , m , x , ans = 0 , z = 0
read n and m
for i = 1 to n inclusive
read x
declare integer y
let y be x / m if x % m is 0 , else let y be x / m + 1
if y is greater than or equal to z
let z be y
let ans be i
print ans and newline
create const integer arrays dx with elements 1 , 0 , - 1 , 0 and dy with elements 0 , 1 , 0 , - 1
bad = set of integers
let a be integer array with size 100010
create ints n and k
read n and k
for i from 0 to n exclusive , read a [ i ]
declare int variable ans = 0
for i = n - 1 to 0 inclusive counting down
if there is no a [ i ] in bad
increment ans by one
if a [ i ] % k = 0 , insert a [ i ] / k into bad
print ans
create int a
make string str
let int array sum of size 4005
make long long array used of size 36005
create long long int result = 0
make ints ii and jj
created ints len and usedLen
read a and str
set len to str . size ( )
for ii = 0 to len exclusive , set sum [ ii ] to sum [ ii ] + ( str [ ii ] - ' 0 ' )
for ii = 0 to len exclusive
for jj = ( ii + 1 ) to len , increment used [ sum [ jj ] - sum [ ii ] ]
if a is not equal to 0
set usedLen to min of a and 36000
for ii = 1 to usedLen
if a modulo ii is 0 and a / ii is less than or equal to usedLen , add used [ ii ] * used [ a / ii ] to result
otherwise do
set result to ( len * len + ( len - used [ 0 ] ) ) * used [ 0 ]
create constant integer with name maxn = 2e6 + 7
prime is a new array of booleans with maxn elements
in the function palindrome with string argument s that returns boolean
declare ints lo = 0 and hi = length of s - 1
while lo < = hi
if s [ lo ] ! = s [ hi ] , return false ; increment lo and decrement hi in any case
return true
assign the new value = true to prime [ 1 ]
in a for loop , change i from 2 to maxn exclusive incrementing i
if prime [ i ] is false
start for loop from j = i + i to maxn exclusive adding i to j , and changing prime [ j ] to true on each iteration
declare new integer variables p and q
read variables p and q from the input
declare new int variables pi and rub = 0
ans is a new integer variable = 0
for integer i = 1 to maxn exclusive
declare string variable num with value " "
create integer x with value i
while x is not 0
append x % 10 + ' 0 ' to num
change the value of x to x divided by 10
if palindrome ( num ) is true , increment rub
if prime [ i ] is false , increment pi by one
if pi * q < = rub * p , change the value of ans to i
if ans is equal to 0
print " Palindromic tree is better than splay tree " and ' \ n ' to the standard output
else
print ans and ' \ n ' to the standard output
declare long longs N , M , K , L
read N and M and K and L
declare long long left = ( K + L ) / M
if ( left * M ) is less than ( K + L ) , increment left
declare long long right = N / M
declare long long ans = - 1
if leeft is less than or equal to right , let ans be left
print ans and newline
let mp be a map from string to integer
it is an iterator for map from string to integer
declare string variable a
declare ints n and m
create integer val
create double k
read n , m and k
loop i from 0 to n exclusive
read a and val
if val * 1 . 0 * k + 0 . 001 > = 100 . 0
add val * 1 . 0 * k + 0 . 001 to mp [ a ]
else
erase a
loop i from 0 to m exclusive
read a
if mp [ a ] = 0 , assign 0 to mp [ a ]
print length of mp
move it through mp , printing it - > first , ' ' and it - > second on each iteration
N = 2002
mp = map from string to long long
likes = map from pair of long long , long long to long long
n = 7 , sz = 0 , m , a , b , c = long long
read m
while decremented value of m not equal 0
l , r = string
read l , r , r
if mp [ l ] is 0 increment sz , mp [ l ] = sz
if mp [ r ] is 0 increment sz , mp [ r ] = sz
likes [ make_pair ( mp [ l ] , mp [ r ] ) ] = l
read a , b , c
pt = 2187 , minimal = a + b + c , ml = long long
for i = 0 to pt excluisve
t = array of 3 vector of long long
k = i , m1 , m2 , m3 = long long , lks = 0
for i = 1 to n inclusive
add i at end of t [ k modulo 3 ]
divide k by 3
it size of t [ 0 ] and size of t [ 1 ] and size of t [ 2 ]
m1 = a / size of t [ 0 ]
m2 = b / size of t [ 1 ]
m3 = c / size of t [ 2 ]
m1 = max ( m1 , max ( m2 , m3 ) ) - min ( m1 , min ( m2 , m3 ) )
for i = 0 to 3 exclusive
for j = 0 to size of t [ i ] exclusive
if minimal > m1
minimal = m1
ml = lks
else if minimal is m1
ml = max ( ml , lks )
print minimal , space , ml
a = character array of size 120
in the function check that takes integer n and returns integer
flag1 = integer
for i = 1 to n
flag1 = 0
for j = 1 to n
if a [ i ] [ j ] is .
flag1 = 1
break loop
if not flag1 , break loop
flag2 = integer
for i = 1 to n
flag2 = 0
for j = 1 to n
if a [ j ] [ i ] is .
flag2 = 1
break loop
if not flag2 , break loop
if flag1 is 0 and flag2 is 0
else
if flag1
return 1
else
return 2
n = integer
while read n
for i = 1 to n
for j = 1 to n , read a [ i ] [ j ]
judge = integer with judge = check on n
if judge
if judge is 1
for i = 1 to n
for j = 1 to n
if a [ i ] [ j ] is .
print i , " " , j
break loop
else
for i = 1 to n
for j = 1 to n
if a [ j ] [ i ] is .
print j , " " , i
break loop
else
print - 1
N = int
read N
S = int array of size N
print first N - 1 values of S
print last value of S
let n = integer
read n
set n = n * 2
let ans = boolean with value false
let sqr = integer with value = square root of n rounded up
for integer i = 1 to sqr inclusive do the following
let l , r , j = integers with l = 1 and r = sqr
wile l is less than or equal to r do the following
set j = l + ( r - 1 ) / 2
let integer t = i * ( i + 1 ) + j * ( j + 1 )
if t is n do the following
set ans = true
exit the loop
else if t is less than n
set l = j + 1
else
set r = j - 1
if ans is true exit the loop
if ans is true print YES else print NO
make strings cad and salida
make integer flag = 1
read cad
for i = 0 to length of cad exclusive
if cad [ i ] is ' 0 ' and flag is 1
set flag to 0
otherwise do
set salida to salida + cad [ i ]
if length of salida is equal to length of cad , set salida to salida . substr ( 0 , salida . length ( ) - 1 )
print salida
integer as n , i , temp , cnt = - 1 , res = 0
create integer vector of a
read n
add new element 0 to end of vector a
add new element 0 to end of vector a
for = 0 to less than n do the following
read temp
add new element temp to end of vector a
add new element 1001 to end of vector a
for = 2 to less than or equal to n + 2 do the following
if a [ i ] is a [ i - 1 ] + 1 then do the following
add one to cnt
else
if cnt is greater than res then do the following res = cnt
set cnt to - 1
if cnt is greater than res then res = cnt
output res
sz , tot , pt are constant long longs with sz = 5e6 + 5 , tot = 1e7 + 5 , pt = 666e3
ara = boolean array of size sz
in function makePrimes
i , j , r , k are long longs with k = 1
for i = 0 to sz exclusive , set ara [ i ] to 1
set r to square root tot
for i = 1 to r / 2 inclusive
if ara [ i ] equals 1
call makePrimes
n , m , i are long longs
read n
for i = 1 with increment i + 1
x = long long = n * i + 1
if x is even and x isn ' t 2
break
else
if ara [ ( x - 1 ) / 2 ] equals 0 , break
display i
n = integer , a and b are both integer arrays both of size 102
k , cnt , res are all integers all set to 0
let vis be an integer array of size 102 with vis = 0
input n
for i = 1 to n inclusive
input a [ i ]
increment k
if a [ i ] is negative , increment cnt
if cnt is greater than 2
increment res
assign k - 1 to b [ res ]
assign 1 to k
assign 1 to cnt
assign 1 to vis [ i - 1 ]
assign 0 to both cnt and k
for i = n to 1 inclusive with decrement i
if vis [ i ] , break
increment k
if a [ i ] is negative , increment cnt
if cnt is true , increment res
if res is equal to 0 , increment res
assign k to b [ res ]
display res
for i = 1 to res inclusive , display b [ i ] and ' '
display b [ res ]
m = map from int to int
s = array of integers of length 300000 , a = array of integers of length 505
let cmp be a function that accepts integers a , b and returns a boolean value
return a is greater than b
let gcd be a function that accepts integers a , b and returns a integer value
return gcd of b , a modulo b if b else return a
let n , t , k be integers
while read n
for i = 0 to n * n exclusive
read s [ i ]
increment m [ s [ i ] ] by 1
sort the values s , s + n * n , cmp
t is equal to 0 , k is equal to 0
for i = 0 to n * n exclusive
if m [ s [ i ] ] is equal to 0 , proceed to next
decrement m [ s [ i ] ] by 1
for j = 0 to t exclusive
k is equal to gcd of s [ i ] and a [ j ]
decrement m [ k ] by 2
a [ t + + ] is equal to s [ i ]
print a [ 0 ]
for i = 1 to t exclusive , print space and a [ i ]
print newline
let n , k = - 1 , s = 0 , a [ 100 ] be ints
read n
for i = 0 to n exlcusive
read a [ i ]
increment s by a [ i ]
if a [ i ] isn ' t 0 and k is - 1 then set k to i + 1
if k = - 1
else
if s isn ' t 0
print 1 and new line and " 1 " and n
else
print " 1 " and k
print k + 1 and space and n
n = long long
s = string
read n
ignore input
getline ( cin , s )
C0 = long long set to 0
C1 = long long set to 0
for 0 to s . length ( ) - 1 inclusive
if s [ i ] equal to ' 0 '
increment C0 to 1
else
increment C1 to 1
if C1 greater than 1 set C1 to 1
for 1 to C1 inclusive print 1
for 1 to C0 inclusive print 0
print new line
declare boolean array isprime size 1500000
declare sieve with no arguments , returning void
assign value boolean casted 1 from isprime to isprime + 1500000
for i = 2 to 1500000 exclusive
if isprime [ i ] is true
for j = 2 * i to 1500000 exclusive , incrementing j by i , let isprime [ j ] be 0
let isprime [ 1 ] be 0
return from function
declare ispalin with integer num as argument , returning boolean
declare integer divisor = 1
while num / divisor is greater than or equal to 10 , let divisor be divisor * 10
while num is not 0
declare leading = num / divisor
declare trailing = num % 10
if leading is not trailing , return false from function
let num be ( num % divisor ) / 10
let divisor be divisor / 100
return true from function
run sieve
declare lprime = 0 , lpalin = 0 as integer
declare integers p , q
read p and q
declare integer ans
for i = 1 to 1500000 exclusive
if isprime [ i ] , increment lprime
if result of run ispalin ( i ) is true , increment lpalin
if long long casted q * lprime is less than or equal to long long casted p * lpalin , let ans be i
print ans and newline
n , m , t , sum , esum , id = integers
while read n , m
esum = 0
for i = 1 to n
read t
sum = ( t - 1 ) / m + 1
if ( sum > = esum )
esum = sum
id = i
print id
s , t , z = string array of size 40 each
f , i , j , n , m , p , x = int with p = 0 and dz = int array of size 40
k = long double and d = long double array of size 40
read n then m then k
read n values into s then d
for i = 0 to n
set x to floor of k * d [ i ] + 0 . 00001
if x is greater or equal to 100
set z [ p ] to s [ i ]
set dz [ p ] to x
increment p
for j = 0 to m
set f to 0
for i = 0 to p
if t [ j ] is z [ i ]
set f to 1
break inner loop
if f is 0
set z [ p ] to t [ j ]
set dz [ p ] to 0
increment p
for i = 0 to p - 1
for j = i + 1 to p
if z [ i ] is greater than z [ j ]
call swap on z [ i ] and z [ j ]
call swap on dz [ i ] and dz [ j ]
print p
for i = 0 to p print z [ i ] and dz [ i ]
create a map from long longs to long longs called mpu
let vec be a vector of long longs
declare string array s with size 101
let path be long long array with size 1000006
declare long long variable n
read n
for i from 0 to n exclusive , read s [ i ]
let row and col be boolean arrays with size 100
for i from 0 to n exclusive
for j from 0 to n exclusive
if s [ i ] [ j ] is equal to ' . '
set row [ i ] to 1
set col [ j ] to 1
create int p = 0
loop i from 0 to n exclusive
if row [ i ] is false , set p to 1
if p is equal to 1
for integer i = 0 to n exclusive
if col [ i ] is false , change p to 2
if p = 2
print " - 1 \ n "
loop i from 0 to n exclusive
for j from 0 to n exclusive
if col [ j ] = 1 and s [ i ] [ j ] is equal to ' . '
set col [ j ] to 0
print i + 1 , " " and j + 1
else
for integer i = 0 to n exclusive
loop j from 0 to n exclusive
if s [ i ] [ j ] = ' . '
print i + 1 , " " and j + 1
break the loop
create new integers i , j , u , v and w
numbers is a new vector of integers
create new integer called nums
read input to nums
for i from 0 to nums exclusive
read w from the user input
push w to numbers
start for loop from i = 0 to nums exclusive
if i ! = 0 , print ' '
print numbers [ i ] to the standard output
print new line
new vector of long longs v
declare integer p = 0
declare long long variables i , n , x , num and numm
read input to n
start for loop from i = 1 to 100000 exclusive incrementing i
change x to ( i * ( i + 1 ) ) / 2
push x to the end of v
for i from 1 to 100000 exclusive
set num to ( i * ( i + 1 ) ) / 2
assign n - num to numm
if numm is found in v using binary_search
assign the new value = p + 1 to p
break
if p = 1
print " YES "
else
print " NO "
create string str
declare check taking in integer p and returning bool
create character set se
clear the contents of se
insert str [ p ] into se
insert str [ p + 1 ] into se
insert str [ p - 1 ] into se
insert ' . ' into se
if the size of se is equal to 4 , return true
return false
read str
for i = 1 to the size of str exclusive
if calling check with i returns true
print " Yes "
print " No "
declare long long n
read n
if n is 0
print 1 , newline
else if n % 4 is 2
print 4 , newline
else if n % 4 is 3
print 2 , newline
else if n % 4 is 0
print 6 , newline
else
print 8 , newline
let a , b , c , d , e , f ints
read a , b , c , d , e , and f
if c is 0 and d is positive or a is 0 and b + d is positive
if a * c * e < b * d * f
otherwise
declare constant integer N = 1e5 + 5
declare constant long long limit = 1e10
declare long long l , r , res , cnt , long long array a size N
declare lucky_numbers with long long numb as argument , returning void
if numb is greater than limit , return from function
increment cnt , let a [ cnt ] be numb
run lucky_numbers ( numb * 10 + 4 )
run lucky_numbers with numb * 10 + 7 as arguments
declare Solve with no arguments , returning void
declare long long L = 0 , R = 0
for i = 1 to cnt inclusive
if a [ i ] is greater than or equalt o l
let L be i
end loop
for i = 1 to cnt inclusive
if a [ i ] is greater than or equal to r
let R be i
end loop
declare long long root = l
for i = L to R inclusive
declare long long length = minimum of ( a [ i ] and r ) - root + 1
let res be res + ( a [ i ] * length )
let root be a [ i ] + 1
print res and ' \ n '
read l and r
run lucky_numbers with 0 as argument
sort from a + 1 to a + cnt + 1
run Solve
create new constant integer MAX with value 1e7 - 8 . 8e6
declare integer arrays a , sushu and huiwen with size MAX
function init
change the value of a [ 1 ] to 1
assign the new value = 1 to a [ 0 ]
for integer i = 2 to 10000 inclusive incrementing i
if a [ i ] is false
in a for loop , change j starting from i while i * j < MAX , setting the value of a [ i * j ] to 1 on each iteration
function panduan with int argument x that returns integer
create new integer variable w with value x
declare new integer y = 0
while w is not 0
assign the new value = y * 10 + w % 10 to y
divide w by 10
if y = x
return 1
else
call init ( )
in a for loop , change i from 1 to MAX exclusive
if a [ i ] is true
set sushu [ i ] to sushu [ i - 1 ]
else
assign sushu [ i - 1 ] + 1 to sushu [ i ]
if panduan ( i ) is true
set huiwen [ i ] to huiwen [ i - 1 ] + 1
else
assign huiwen [ i - 1 ] to huiwen [ i ]
create new integers p and q
read input to p and q
in a for loop , change i from MAX - 1 to 0 inclusive decrementing i
if sushu [ i ] * q < = huiwen [ i ] * p
if i is equal to 0
print " Palindromic tree is better than splay tree "
else
print i to the standard output
let n be an integer
read in n
let s be a string
read in s
let i , count and k be integers , set count to 0
if s [ 0 ] is equal to ' > '
for i = 0 to s . size ( )
is s [ i ] is equal to ' > '
increment count
or else
set count to 0
print count
else if s [ 0 ] is equal to ' < '
set i to 0
let g be an integer and set it to 0
while s [ i ] is equal to ' > '
increment count
increment i
for k = i to s . size ( )
if s [ k ] is equal to ' > '
increment g
else if s [ k ] is equal to ' > '
set g to 0
print g + count
let abso be a function that accepts integer a and returns a integer value
if a is less than 0 , return - a
return a
c = map from string to int
c [ C ] is equal to 0
c [ C # ] is equal to 1
c [ D ] is equal to 2
c [ D # ] is equal to 3
c [ E ] is equal to 4
c [ F ] is equal to 5
c [ F # ] is equal to 6
c [ G ] is equal to 7
c [ G # ] is equal to 8
c [ A ] is equal to 9
c [ B ] is equal to 10
c [ H ] is equal to 11
let a , b , cs be strings
read a , b , cs
val = array of integers of length 3
val [ 0 ] is equal to c [ a ]
val [ 1 ] is equal to c [ b ]
val [ 2 ] is equal to c [ cs ]
sort the values val , val + 3
for i = 0 to 3 exclusive
the integer value of dist = ( - val [ i + 0 ] + val [ ( i + 1 ) modulo 3 ] )
if dist is less than 0 , increment dist by 12
the integer value of dist1 = ( - val [ ( i + 1 ) modulo 3 ] + val [ ( i + 2 ) modulo 3 ] )
if dist1 is less than 0 , increment dist1 by 12
if dist equals 3 and dist1 equals 4
print minor and newline
if dist1 equals 3 and dist equals 4
print major and newline
print strange and newline
a , v = integer vectors both of length 150005
used = boolean array of length 150005
n , m , k , x , y = integers
in function dfs that returns nothing and takes argument u = integer
set used [ u ] = 1
append u to the end of v [ k ]
for i = 0 to the size of a [ u ] exclusive
if used [ a [ u ] [ i ] ] is 0 then call dfs with argument a [ u ] [ i ]
p = integer
read n and m
for i = 0 to m exclusive
read x and y
append y to the end of a [ x ]
append x to the end of a [ y ]
for i = 0 to n exclusive
if used [ i ] is 0
add 1 to k
call dfs with argument i
set p to the size of v [ k ]
for j = 0 to p exclusive
if the size of a [ v [ k ] [ j ] ] does not equal p - 1
declare integer n = 100000
create integer aux
create integer aux2
let x be integer array with size n
let a be integer array with size n
declare int negativos = 0
declare int positivos = 0
declare int manz = 0
declare int ne
declare int po
read n
for i = 0 to n exclusive
read x [ i ]
read a [ i ]
loop v from 1 to n exclusive
for integer b = 0 to n - 1 exclusive
if x [ b ] is greater than x [ b + 1 ]
set aux to x [ b ]
set x [ b ] to x [ b + 1 ]
set x [ b + 1 ] to aux
set aux2 to a [ b ]
set a [ b ] to a [ b + 1 ]
set a [ b + 1 ] to aux2
for i from 0 to n exclusive
if x [ i ] is less than 0
increment negativos
else
increment positivos
if negativos is equal to positivos
for t from 0 to n exclusive , change manz to manz + a [ t ]
else if negativos is less than positivos
if negativos is equal to 0
assign a [ 0 ] to manz
else
change ne to negativos
change po to negativos + 1
for y from negativos - ne to negativos - 1 + po inclusive , assign manz + a [ y ] to manz
else
if positivos = 0
change manz to a [ negativos - 1 ]
else
set ne to positivos + 1
set po to positivos
for integer y = negativos - ne to negativos - 1 + po inclusive , assign manz + a [ y ] to manz
print manz
TT , T , n , m = integers
i , j , k = integers
a = character array of size 110
b = integer array of size 110
c = integer array of size [ 110 ] [ 110 ] , d = integer
e , f , g = integer
mx , mn = integers with mx = - 0x3f3f3f3f , mn = 0x3f3f3f3f
T = 1
for TT = 1 to T
read n
cnt = integer with cnt = 0
for i = 0 to n exclusive
read a [ 1 ]
if a [ 1 ] is 0 , increment cnt
if n is 1 and cnt
else
print 1
while decrement cnt , print 0
print new line
define integer arrays a , b and c with 100100 elements
create new integer n
read user input to n
for i = 0 to n exclusive
read user input to a [ i ]
if i is not 0
create new integer variable t = absolute value of a [ i ] - a [ i - 1 ]
if i is odd
set the value of b [ i ] to t
assign - t to c [ i ]
else
change b [ i ] to - t
assign the new value = t to c [ i ]
new long long MAX with value 0
declare long long sum = 0
in a for loop , change i from 1 to n exclusive
if sum + b [ i ] is greater than 0
change sum to sum + b [ i ]
else
set the value of sum to 0
change the value of MAX to max of MAX and sum
set sum to 0
for i = 1 to n exclusive
if sum + c [ i ] is greater than 0
increase sum by c [ i ]
else
change the value of sum to 0
change the value of MAX to max of MAX and sum
print MAX
declare int variables n and i
read n from the input
create new string s
read input to s
declare new ints q and sp = 0
if value of s [ 0 ] is ' ? ' , increment q
if s [ n - 1 ] is ' ? ' , increment q by one
in a for loop , change i from 1 to n - 1 exclusive incrementing i
if s [ i ] = ' ? '
if s [ i - 1 ] ! = s [ i + 1 ]
if s [ i - 1 ] = ' ? ' | s [ i + 1 ] = ' ? '
increment q by one
else
increment sp
else
increment q
else
if s [ i ] = s [ i - 1 ] | s [ i + 1 ] = s [ i ]
print " No " to the standard output
return ( 0 )
if q is greater than 0
print " Yes "
else
print " No "
return ( 0 )
create int n , b and l , set l to 0
read n
for i = 0 to n exclusive
read b
if b = 0 , increment l
if l = 1 and n different from 1 or n = 1 and l = 0
else
print NO and a newline
create integer variable t
read variable t from the input
if t = 1
print " - 1 " to the standard output
else
print t , " " and t
N = const int with N = 1e5 + 100
arr = long long array of size N
x , y = int
read x then y
a , b = int with a = absolute of x and b = absolute of y
mx = int with mx = max of absolute of x and absolute of y
if mx is 0
print 0
c = int with c = ( mx - 1 ) * 4
if mx is a
if x is greater than 0
if y is less or equal to 0 and b is mx - 1
print c
else if y is less or equal to 0 and b is mx
print c + 4
else
print c + 1
else
if y is greater than 0 and b is mx
print c + 2
else
print c + 3
else
if y is greater than 0
if x is greater than 0 and a is mx
print c + 1
else
print c + 2
else
if x is less than 0 and a is mx
print c + 3
else
print c + 4
f is a integer function with int arguments a and b
declare integer x1 = a divided by 10
define integer variable x2 with value a modulo 10
declare integer variable x3 with value = b divided by 10
define integer x4 = b modulo 10
return 1 if x1 is equal to x4 and x2 is equal to x3
define new ints a and b
create character variable with name s
read a , s and b and loop further
if f of a and b is 1
print " 0 " to the standard output
else
increase i by 1 , starting from 1 , in a loop
if b + 1 = 60 and a < 23
assign the new value = 0 to b
change a to a + 1
else if a is equal to 23
if b is greater than 32
print 60 - b and a new line
stop the loop
else
increment b by one
else
increment b
if f of a and b returned 1
print i to the standard output
stop the loop
declare long long ans
declare maxsum with long long array p , long long n as argument , returning long long
declare long long tmp = 0
for i = 0 to n exclusive
let tmp be maximum of ( 0LL and tmp + p [ i ] )
let ans be maximum of ( ans and tmp )
declare long long n
read n
declare long long array a size n
for i = 0 to n exclusive , read a [ i ]
declare long long array b size n
declare long long array c size n
for i = 0 to n - 1 exclusive
let b [ i ] be absolute value of ( a [ i ] - a [ i + 1 ] ) * ( 1 if i % 2 is 0 , else - 1 )
run maxsum with b , n - 1 as arguments
run maxsum ( c , n - 1 )
print ans and ' \ n '
maxn = constant int , maxn = 1e6
function gcd type long long that takes in parameters long long a and long long b
if b is 0
return a
else
return gcd ( b , remainder of a / b )
function lcm type long long that takes in parameters long long a and long long b
return a * b / gcd ( a , b )
n = int
while n can be read
ans = long long
if n > 3
let ans = lcm ( lcm ( n - 2 , n - 1 ) , n )
ans2 = long long , ans 2 = lcm ( lcm ( n - 3 , n - 1 ) , n )
ans3 = long long , ans 3 = lcm ( lcm ( n - 3 , n - 2 ) , n - 1 )
ans = max ( max ( ans , ans2 ) , ans3 )
else
if n equals 1
let ans = 1
else if n = 2
let ans = 2
else if n = 3
let ans = 6
print ans
create constant long long inf with inf = 0xFFFFFFFFFFFFFFFL
create clock_t time_p with time_p = result of run clock
declare time with no arguments , returning void
set time_p to result of run clock - time_p
print to stderr " Time Taken : " print float casted ( time_p ) / CLOCKS_PER_SEC print " \ n "
create long longs n , m , k
read n read m read k
if k is greater than n + m - 2
print - 1 print " \ n "
if k is less than or equal to n - 1 and k is less than or equal to m - 1
create long long mn1 with mn1 = ( m / ( k + 1 ) ) * n
create long long mn2 with mn2 = ( n / ( k + 1 ) ) * m
print maximum of mn1 and mn2 print " \ n "
if k is less than or equal to n - 1 and k is greater than m - 1
create long long mn1 with mn1 = ( n / ( k - ( m - 1 ) + 1 ) )
create long long mn2 with mn2 = m * ( n / ( k + 1 ) )
print maximum of mn1 and mn2 print " \ n "
if k is less than or equal to m - 1 and k is greater than n - 1
create long long mn1 with mn1 = ( m / ( k - ( n - 1 ) + 1 ) )
create long long mn2 with mn2 = n * ( m / ( k + 1 ) )
print maximum of mn1 and mn2 print " \ n "
if k is greater than n - 1 and k is greater than m - 1
create long long mn1 with mn1 = m / ( k - ( n - 1 ) + 1 )
create long long mn2 with mn2 = n / ( k - ( m - 1 ) + 1 )
print maximum of mn1 and mn2 print " \ n "
run time
integers = a in 4 by 4 array
for i = 0 to i is less than 4 do the following
for j = 0 to 3 read a [ i ] [ j ]
for i = 0 to less than 4 do the following
if a [ i ] [ 3 ] is 1 then do {
if a [ i ] [ 0 ] is 1 or a [ i ] [ 1 ] is 1 or a [ i ] [ 2 ] is 1 then do next command
output " YES "
output " YES "
if a [ i ] [ 3 ] is 1 then do
if a [ remainder of i + 1 / 4 ] [ 0 ] is 1 then do next commands
output " YES "
if a [ i ] [ 3 ] is 1 then do
if a [ remainder of i + 3 / 4 ] [ 2 ] is 1 then do {
output " YES "
output " NO "
in function gcd1 taking long long a , long long b and returning long long
if a is 0 return b
return gcd1 of b mod a , a
in function modx taking long long base , long long ex and returning long long
ans , val = long long with ans = 1LL and val = base
loop while ex > 0LL
if ex bitwise - and 1LL set ans to ( ans * val ) mod 1000000009LL
set val to ( val * val ) mod 1000000009LL
set ex to ex bitshift right by 1LL
return ans
maxn = const int with maxn = 1e5 + 10
visit , visit1 = bool array of size maxn each
n , m , x , y = int and a = int array of size maxn
D , P = bool array of size maxn each
adj , v = int vector array of size maxn each
in function dfs taking int start
set visit [ start ] to true
for i = 0 to size of adj [ start ]
pt = int with pt = adj [ start ] [ i ]
if not visit [ pt ] call dfs of pt
in function dfs2 taking int start
set visit1 [ start ] to true
for i = 0 to size of v [ start ]
pt = int with pt = v [ start ] [ i ]
if not visit1 [ pt ] call dfs2 of pt
read n then m
for i = 1 to n inclusive read a [ i ]
for i = 1 to m inclusive
read x then y
append y to adj [ x ]
if a [ x ] ! = 1 and a [ y ] ! = 1 append x to v [ y ]
for i = 1 to n inclusive
if not visit [ i ] and a [ i ] is 1 call dfs of i
for i = 1 to n inclusive
if not visit1 [ i ] and a [ i ] is 2 call dfs2 of i
for i = 1 to n inclusive
if a [ i ] is not 1 continue
for j = 0 to size of adj [ i ]
pt = int with pt = adj [ i ] [ j ]
if visit1 [ pt ] and a [ pt ] is not 1 set visit1 [ i ] to true
for i = 1 to n inclusive
if visit1 [ i ] and visit [ i ]
print 1
else
print 0
dx = integer array of size 4 with dx = { 0 , 0 , - 1 , 1 }
dy = integer array of size 4 with dy = { 1 , - 1 , 0 , 0 }
n = integer
read n
s = vector of string
c = character
tmp = string
for i = 0 to n exclusive
read tmp
append tmp in s
transform ( s [ i ] . begin ( ) , s [ i ] . end ( ) , s [ i ] . begin ( ) , tolower )
shit , fuck = string
read shit , c
save = string with save = shit
fuck = shit
transform ( save . begin ( ) , save . end ( ) , save . begin ( ) , tolower )
rep = integer array of size [ save . size ( ) ] = { }
for i = 0 to n exclusive
for j = 0 to shit . size ( ) exclusive
if ( j + s [ i ] . size ( ) - 1 > = save . size ( ) ) , continue next iteration
if ( save . substr ( j , s [ i ] . size ( ) ) is s [ i ] )
for k = 0 to s [ i ] . size ( ) , rep [ k + j ] = 1
for i = 0 to shit . size ( ) exclusive
if ( rep [ i ] )
if ( save [ i ] is not c )
shit [ i ] = c
else
if ( c is a )
shit [ i ] = b
else
shit [ i ] = a
if ( fuck [ i ] < = Z and fuck [ i ] > = A ) , shit [ i ] = ( cast to character ) toupper ( shit [ i ] )
function iamax ( get pointer to int arr , int N , return int )
ma = arr [ 0 ]
for i = 1 to N exclusive ma = max ( arr [ i ] , ma )
return ma
function readarr ( get pointer to int arr and N , return nothing )
read into N
for i = 0 to number pointed by N exclusive read arr [ i ]
arr = array of 1005 char
k , n = int
function pal ( get int a and b , return bool )
while a < b
if arr [ a ] is not arr [ b - 1 ] return false
increment a
decrement b
return true
function run ( no args , return bool )
mul = n / k
for i = 0 to n exclusive by mul
if not pal ( i , i + mul ) return false
return true
read arr , k
n = length of arr
if n modulo k
print " NO "
else
if run ( )
print " YES "
else
print " NO "
integer as x , t , a , b , da , db
create boolean called solve
for i = 0 to less than t do the following
for j = 0 to less than t do the following
if a - i * da + b - j * db is x or a - i * da = x or b - j * db = x then return a 1
read inputs into x , t , a , b , da , db
if ! x is true
else
output YES if solve is true else put a NO
function get_ans with long long argument n that returns long long
if n < = 0 , return 1
return 10 raised to power n
function calc with long long argument n that returns long long
if n is less than 10 , return n
declare an arrays of integers a and arr with size 20
create integer no_of_digits = 0
create long long tmp = n
create integer first_digit
create integer last_digit = n modulo 10
while tmp ! = 0
increment no_of_digits by one
change a [ no_of_digits ] to tmp modulo 10
if tmp is less than 10 , assign tmp to first_digit
divide tmp by 10
create long long res = 0
for i from 1 to no_of_digits exclusive , add 9 * get_ans ( i - 2 ) to res
for integer i = no_of_digits to 1 inclusive counting down , set arr [ no_of_digits - i + 1 ] to a [ i ]
increase res by ( first_digit - 1 ) * get_ans ( no_of_digits - 2 )
declare long long variable tmp2 = 1
loop i from 2 to no_of_digits - 1 inclusive , increasing tmp2 by ( arr [ i ] ) * get_ans ( no_of_digits - i - 1 )
add tmp2 to res
if first_digit is greater than last_digit , decrement res by one
return res
declare long longs l and r
read l and r
print calc ( r ) - calc ( l - 1 ) and " \ n "
create long long integers m , x1 , x2 , y1 , y2 , h1 , h2 , a1 , and a2
read m
read h1 and a1
read x1 and y1
read h2 and a2
read x2 and y2
create integer vector ans1
create integer vector ans2
create long long integer total = 0
while total is less than 2 * m
if h1 is equal to a1 , append total to ans1
if h2 is equal to a2 , append total to ans2
increment total
set h1 to the result of ( h1 * x1 + y1 ) % m
set h2 to the result of ( h2 * x2 + y2 ) % m ;
if ans1 . empty ( ) is truthy or ans2 . empty ( ) is truthy
print " - 1 "
create long long integers t1 = ans1 [ 0 ] and t2 = ans2 [ 0 ]
create long long integer s1 = ans1 [ 1 ] - ans1 [ 0 ]
create long long integer s2 = ans2 [ 1 ] - ans2 [ 0 ]
for i = 0 to 5e6
if t1 is equal to t2
print t1
if t1 is less than t2
set t1 to t1 + s1
else
set t2 to t2 + s2
print " - 1 "
declare doubles a1 , a , b , c , d , e , f
read a , b , c , d , e , f
set a1 to 1 / a * b / c * d / e * f
if c equals 0 and d is greater than 0
print " Ron "
else if a = = 0 and b is greater than 0 and d is greater than 0
print " Ron "
else if a1 is greater than 1
print " Ron "
else
print " Hermione "
a is a new array of integers with 100001 element
n is a new integer variable
read from the input to n
read n elements into a starting from the index 1
res is a new long long with value 0
create integer t
start for loop from i = 1 to n exclusive incrementing i
in a loop , multiply t by 2 , starting from t = 1 , while i + t < = n
change t to t > > 1
increase res by a [ i ]
add a [ i ] to a [ i + t ]
print res
primeFactures = vector of long long
function f ( get long long q , return nothing )
while q is even
add 2 at end of primeFactures
divide q by 2
for i = 3 to sqrt ( q ) inclusive by 2
while w modulo i is 0
add i at end of primeFactures
divide q by i
if q > 2 add q at end of primeFactures
function isprime ( get long long x , return bool )
for i = 2 to sqrt ( x ) inclusive
if x modulo i is 0 return false
return true
q = long long
read q
if isprime ( q )
print " 1 " , newline , " 0 " , newline
f ( q )
if size of primeFactures > 2
print " 1 " , newline , primeFactures [ 0 ] * primeFactures [ 1 ]
else
print " 2 " , newline
create new constant integer called mod = 1e9 + 7
create new constant double eps = 1e - 6
q is a new vector of long longs
function dfs with long long argument x
if x > = 10000000005 , return
push x to the end of vector q
call dfs of x * 10 + 4
call dfs of x * 10 + 7
declare new long longs l and r
call dfs ( 0 )
sort whole vector q
read l and r and keep looping
declare long longs ans_l and ans_r = 0
len is a new integer variable with value length of q
in a for loop , change i from 1 to len inclusive incrementing i
if q [ i ] < = l - 1
change ans_l to ans_l + ( q [ i ] - q [ i - 1 ] ) * q [ i ]
else
change ans_l to the sum of ans_l and ( l - 1 - q [ i - 1 ] ) * q [ i ]
break
for i = 1 to len inclusive incrementing i
if q [ i ] < = r
change ans_r to ans_r + ( q [ i ] - q [ i - 1 ] ) * q [ i ]
else
set the value of ans_r to the sum of ans_r and ( r - q [ i - 1 ] ) * q [ i ]
break the loop
print ans_r - ans_l
create constant int maxn = 1e5 + 10
create bool array mark of size maxn and rmark of size maxn
make integer a of size maxn
create int vector v of size maxn and rv of size maxn
declare inline dfs taking in ints x and par
if mark [ x ] is true , return
if par is not equal to - 1 and a [ x ] is equal to 1 , return
set mark [ x ] to 1
for i = 0 to v [ x ] . size ( ) exclusive
if mark [ v [ x ] [ i ] ] is falsy , call dfs ( v [ x ] [ i ] , x )
declare inline rdfs taking in integer x
if rmark [ x ] is true , return
set rmark [ x ] to 1
if a [ x ] is 1 , end function
for i = 0 to rv [ x ] . size ( ) exclusive
if rmark [ rv [ x ] [ i ] ] is falsy , call rdfs ( rv [ x ] [ i ] )
create ints n , m , x , and y
read n and m
for i = 0 to n exclusive , read a [ i ]
for i = 0 to m exclusive
read x and y
subtract 1 from x
decrease y by 1
append y to v [ x ]
append x to rv [ y ]
for i = 0 to n exclusive
if a [ i ] is equal to 1 , call dfs ( i , - 1 )
for i = 0 to n exclusive
if a [ i ] is equal to 2 , call rdfs ( i )
for i = 0 to n exclusive
if mark [ i ] and rmark [ i ] are truthy
else
declare vector of unsigned long longs called prime
declare new array of booleans chkPrime1to10000000 with 10000001 element
function primeFunction
create new unsigned long longs i and j
for i from 4 to 10000001 exclusive increasing i by 2 , change the value of chkPrime1to10000000 [ i ] to 1
add new element = 0 after the last element of prime
assign the value of 1 to chkPrime1to10000000 [ 1 ]
add 2 to the end of prime
in a for loop , change i from 3 to 10000001 exclusive by steps of 2
if chkPrime1to10000000 [ i ] is equal to 0
push new value = i to the end of prime
if i squared < = 10000000
in a for loop , change j from i squared to 10000000 inclusive adding ( 2 * i ) to j , setting chkPrime1to10000000 [ j ] to 1 on each loop iteration
define ulong long variables n , i and j
call primeFunction ( )
read n from the input
for i from 1 to exclusive
set the value of j to n * i + 1
if chkPrime1to10000000 [ j ] is true
print i
INF is a new constant integer variable = 0x3f3f3f3f
create new integer variable n
read variable n from the input
create new string called str
read str from the input
declare new integer variable numofzero = 0
for integer i = 0 to n exclusive
if value of str [ i ] is equal to ' 0 ' , increment numofzero by one
if numofzero = n
print " 0 " to the standard output
else
print " 1 "
for integer i = 1 to numofzero inclusive , print " 0 "
print new line to the standard output
let s be a string
let k be a integer
read s , k
let sl be a integer with sl = int ( length of s )
if sl modulo k is not equal to 0
print NO and newline
for integer i is equal to 0 , i is less than sl , i = i + sl / k
for j = 0 to sl / k / 2 exclusive
if s [ i + j ] is not equal to s [ i + sl / k - j - 1 ]
print NO and newline
print YES and newline
maxn = const integer with maxn = 110
adj = vector integer array of size maxn
A = 2d bool array of size [ maxn ] [ maxn ]
in the function c that takes integer x and returns integer
return ( x * ( x - 1 ) * ( x - 2 ) ) / 6
in the function c2 that takes integer x and returns integer
return ( x * ( x - 1 ) ) / 2
k = integer
read k
q = integer with q = 0
for i = maxn down to 3
if ( c ( i ) < = k )
k = k - c ( i )
for j = 0 to i exclusive
for k = 0 to j exclusive
append k in adj [ j ]
append j in adj [ k ]
q = i
break loop
for i = maxn down to 2
while ( c2 ( i ) < = k and i < = q )
k = k - c2 ( i )
for j = 0 to i exclusive
append j in adj [ q ]
append q in adj [ j ]
increment q
for i = 0 to q exclusive
for j = 0 to adj [ i ] . size ( ) , A [ i ] [ adj [ i ] [ j ] ] = true
print q
for i = 0 to q exclusive
for j = 0 to q exclusive , print A [ i ] [ j ]
print new line
declare constant long long INF = 1e18
declare string s
read s
declare integers i = 0 , n = integer casted size of s
while i is less than n and s [ i ] is ' a ' , increment i
if i is n
let s [ n - 1 ] be ' z '
print s and newline
while i is less than n and s [ i ] is not ' a ' , decrement s [ increment i ]
print s and newline
declare constant integer MAXN = 2e5 + 10
str is a new string
read variable str from the input
create new integers cnta , cntb and cntc = 0
flag is an integer with value 0
in a for loop , change i from 0 to length of str exclusive
if str [ i - 1 ] is greater than str [ i ] , change the value of flag to 1
if str [ i ] = ' a ' , increment cnta
if str [ i ] = ' b ' , increment cntb by one
if str [ i ] = ' c ' , add 1 to cntc
if flag is not 0
print " NO "
else
if ( cnta = cntc or cntc = cntb ) and none of cnta , cntb and cntc is equal to 0
print " YES "
else
print " NO " to the standard output
declare integer array dx = { - 1 , 0 , 0 }
declare integer array dy = { 0 , 1 , - 1 }
declare integer array prime size 10000002
declare ispal with integer n as argument , returning boolean
declare integers rem initialized with 0 , orginal initialized with 0
let orginal be n
while n is greater than 0
let rem be rem * 10 + n % 10
let n be n / 10
return ( original is rem ) from function
declare seive with no arguments , returning void
let prime [ 1 ] be 1
for i = 1 to 1e7 inclusive
if not prime [ i ]
for j = i * 2 to 1e7 inclusive , incrementing j by i , let prime [ j ] be 1
run seive
declare boolean done = 0
declare long longs n , pal initialized with 0 , pr initialized with 0 , p , q , ans initialized with 0
read p and q
for i = 1 to 1e7 inclusive
if not prime [ i ] , increment pr
if run ispal with i as argument is true , increment pal
if pr * q is less than or equal to pal * p
let ans be i
let done be 1
if done is true
print ans and " \ n "
else
print " Palindromic tree is better than splay tree \ n "
s1 = array of characters of length 10 , s2 = array of characters of length 10
read s1
read s2
let x , y be integers
if string compare of s1 and monday equals 0
x is equal to 1
else if string compare of s1 and tuesday equals 0
x is equal to 2
else if string compare of s1 and wednesday equals 0
x is equal to 3
else if string compare of s1 and thursday equals 0
x is equal to 4
else if string compare of s1 and friday equals 0
x is equal to 5
else if string compare of s1 and saturday equals 0
x is equal to 6
else if string compare of s1 and sunday equals 0
x is equal to 7
if string compare of s2 and monday equals 0
y is equal to 1
else if string compare of s2 and tuesday equals 0
y is equal to 2
else if string compare of s2 and wednesday equals 0
y is equal to 3
else if string compare of s2 and thursday equals 0
y is equal to 4
else if string compare of s2 and friday equals 0
y is equal to 5
else if string compare of s2 and saturday equals 0
y is equal to 6
else if string compare of s2 and sunday equals 0
y is equal to 7
the integer value of x1 = x + 31 modulo 7
if x1 is greater than 7 , x1 = x1modulo 7
the integer value of x2 = x + 30 modulo 7
if x2 is greater than 7 , x2 = x2 modulo 7
the integer value of x3 = x + 28 modulo 7
if x3 is greater than 7 , x3 = x3 modulo 7
if x1 equals y or x2 equals y or x3 equals y
print YES and newline
print NO and newline
n , i , j , s = integers
while read n , s
x , y = integer array of size n + 5
m = map from integer to integer
it = iterator map from integer to integer
mx , c = integer with mx = - 1 , c = 0
for i = 0 to n exclusive
read x [ i ] , y [ i ]
if ( x [ i ] is s and y [ i ] is 0 )
mx = max of mx and 0
else if ( x [ i ] < s )
mx = max of mx and ( 100 - y [ i ] ) modulo 100
print mx
declare integers vector array mp with size 150005
create int64_t variables n , m , a , b , ans and size and an array of int64_t called mark with 150005 elements
void function dfs with int arguments x and prev
change mark [ x ] to 1
if prev ! = length of mp [ x ] or size > length of mp [ x ] , set ans to 1
increase size by one
for i = 0 to length of mp [ x ] exclusive
if mark [ mp [ x ] [ i ] ] = 0 , call dfs of mp [ x ] [ i ] and length of mp [ x ]
read n and m
loop i from 1 to m inclusive incrementing i
read a and b
push b into mp [ a ]
push a into mp [ b ]
for i from 1 to n inclusive
if mark [ i ] = 0 and mp [ i ] is not empty
assign 0 to size
call function dfs with arguments i and length of mp [ i ]
if ans is true
print " NO \ n "
else
print " YES \ n "
create int n and t
while read n and t
if t < 10
while decrement n , print t
else
if n = 1
print - 1
else
print 1
decrement n
while decrement n , print 0
print a newline
let a , b , need be integers with need = 0
read a and b
let n be an integer equal to a / b
while n decrements by 1
for i = 0 to b exclusive
let c be a character equal to 97 + i
print c
add 1 to need
set need to a - need
for i = 0 to need exclusive
let c be a character equal to 97 + i
print c
print a newline
make integer n
make long long array a of size 100001
make long long array b of size 100001
make long long array dp of size 100001
read n
for i = 1 to n inclusive , read a [ i ]
for i = 1 to n - 1 inclusive , set b [ i ] to abs of a [ i ] - a [ i + 1 ]
set dp [ 1 ] to 0
for i = 2 to n inclusive
if i is even
set dp [ i ] to dp [ i - 1 ] + b [ i - 1 ]
else
set dp [ i ] to dp [ i - 1 ] - b [ i - 1 ]
sort elements in dp 1 through 1 + n
print dp [ n ] - dp [ 1 ]
declare constant integer N with N = 110
declare n as integer , a size N as integer array
read n
for i = 0 to n exclusive , read a [ i ]
sort from a to a + n
for i = 0 to n exclusive , print a [ i ] , ' \ n ' if i + 1 is n , else ' '
declare string variable s
read input to s
declare integer is = 0
for i from 0 to length of s - 2 exclusive
declare vector of chars v
loop j from 0 to 3 exclusive , pushing s [ i + j ] to v
if v [ 0 ] = ' A ' and v [ 1 ] = ' B ' and v [ 2 ] = ' C ' , change is to 1
if is ! = 0
print " Yes "
else
print " No "
declare int variables x and y
read x and y
if x and y are both false or ( x = 1 and y is false )
print 0
print " \ n "
declare int up = max of absolute value of x and max of absolute value of y * 4
if x > y or ( x > 0 and x = y )
if x > y and abs ( x ) < = abs ( y )
print up
else if x > 0 and y < and abs ( x ) - abs ( y ) = 1
print up - 4
else
print up - 3
else
if x < y and abs ( x ) < = abs ( y )
print up - 2
else
print up - 1
print " \ n "
define long longs n , m and i
create new array of characters s with 200001 elements
read n and s from the input and keep the loop going
define integer cnt = 0
for i from 0 to n exclusive
if s [ i ] is equal to ' < '
increment cnt
else
break
start for loop from i = n - 1 to 0 inclusive counting down by 1
if s [ i ] is equal to ' > '
increment cnt by one
else
break
print cnt
let n and p be integers
input n and p
let a be a string
let b be an integer with b set to 97
for i = 0 to n exclusive , add 97 + i modulo p to a
print a
a is an array of characters with 100 elements
ans is a new integer with value 0
read user input to a
while a [ 0 ] ! = a [ 4 ] or a [ 1 ] ! = a [ 3 ]
if a [ 0 ] = ' 2 ' and a [ 1 ] = ' 3 ' and a [ 3 ] = ' 5 ' and a [ 4 ] = ' 9 '
change ans to the sum of ans and 1
stop the loop
increase a [ 4 ] by 1
increment ans
if a [ 4 ] is equal to 58
assign ' 0 ' to a [ 4 ]
change a [ 3 ] to the sum of a [ 3 ] and 1
if a [ 3 ] = 54
assign the new value = ' 0 ' to a [ 3 ]
add 1 to a [ 1 ]
if a [ 1 ] is equal to 58
set a [ 1 ] to ' 0 '
increase a [ 0 ] by 1
print ans to the standard output
declare integers a , b , c , d
read a , b , c , d
if a % 2 is 0 and c % 2 is 0 and absolute value of ( b - 2 ) % 2 is 1
print " - 1 " , newline
exit program with code 0
for i = 0 to 10000000 inclusive
declare integer p = a * i + b
if ( p - d ) % c is 0 and p is greater than or equal to d
print p , newline
exit program with code 0
print " - 1 " and newline
create constant integer maxn = 1e5 + 100
let w and v be vector integer array of size maxn
a = long long integer array of size maxn
d = array of boolean of size maxn
c = 2D long long integer array of size maxn by 5
n , m = long long integers
mark = array of booleans of size maxn by 2
into the function dfs1 which takes a long long integer i
set c [ i ] [ 0 ] to 1
set mark [ i ] [ 0 ] to 1
for y = 0 to size of v [ i ] exclusive
if mark [ v [ i ] [ y ] ] [ 0 ] is not true then call dfs1 ( v [ i ] [ y ] )
into the function dfs2 which takes a long long integer i
set mark [ i ] [ 1 ] = 1 ;
set c [ i ] [ 1 ] = 1
if a [ i ] = 1 then return
for y = 0 to size of w [ i ] exclusive
if mark [ w [ i ] [ y ] ] [ 1 ] is false then call dfs2 ( w [ i ] [ y ]
read n and m
for y = 1 to n inclusive
read a [ y ]
if a [ y ] is 1 then add y to end of v [ 100000 + 1 ]
if a [ y ] is 2 then add y to end of w [ 100000 + 1 ]
while m is true , decrement m and do the following
create long long integers i , j
read i and j
add i to end of v [ i ]
add i to end of w [ j ]
call dfs1 with argument 100000 + 1
call dfs2 ( 100000 + 1 )
for y = 0 to n inclsuive print c [ y ] [ 0 ] & & c [ y ] [ 1 ]
let MOD , maxN = integer constants with MOD = 1000000007 and maxN = 5005
let i , j , sum = integers with sum = 0 and dp = maxN arrays of integers of size maxN
let s , t = string
read s , t
for i = 1 to size of s inclusive do the following
for j = 1 to size of t inclusive do the following
set dp [ i ] [ j ] = dp [ i ] [ j - 1 ]
set dp [ i ] [ j ] = dp [ i ] [ j ] modulo MOD
for i = 1 to size of s inclusive set sum = dp [ i ] [ size of t ] modulo MOS
print sum
make constant integer MAX_N = 1000 + 10
create int array in of size MAX_N and out of size MAX_N
make int array C of size MAX_N with array of size MAX_N
let int n
create int e
read n and e
for i = 0 to e exclusive
make ints a , b , and c
read a , b , and c
set C [ a ] [ b ] to c
set in [ b ] to a
set out [ a ] to b
make int cnt = 0
for i = 1 to n
if in [ i ] is 0
if out [ i ] is not equal to 0 , increment cnt
display cnt
for i = 1 to n
if in [ i ] is equal to 0
if out [ i ] is not equal to 0
make int mind = INT_MAX
create int u = i
loop indefinitely
create int v = out [ i ]
if v is falsy , break loop
set mind to min of mind and C [ u ] [ v ]
set u to v
show i , " " , u , " " , and mind
arr1 = array of integer of size 110
arr2 = array of integer of size 110
create integr i , j , ind , count , n with value ind = 0 and count = 0
read n
read n values of array arr1 and arr2
for i = 1 to n inclusive
set ind = 0
for j = 1 to n inclusive
if i is not equal to j
if arr2 [ j ] = arr1 [ i ] then set ind = 1
if ind is false then increment count
print count
let n , a , b , c , d be long integers
read a , b
read c , d
read n
cross is a long integer equal to 0
let x , y , z be long integers
for long integer i = 0 to n exclusive
read x , y , z
if ( a * x + b * y + z ) is greater than 0 and value of ( c * x + d * y + z ) is less than 0 , increment cross by 1
if ( a * x + b * y + z ) is greater than 0 and value of ( c * x + d * y + z ) is less than 0 , increment cross by 1
print cross value and new line
declare new constant integer maxn = 1e5 + 5
new constant long long variable mod with value 1e9 + 7
define new long long n
create long longs a and b
read variable n from the input
read a and b from the user input
if a + b is greater than n + 1
print " Black "
else
print " White "
create long long vector v of size 0
for len = 1 to len 10
for mask = 0 to 1 < < len exclusive
make long long int val = 0
for i = 0 to len exclusive
if mask & ( 1 < < i )
set val to val * 10 + 4
else do
multiply val by 10 + 7
append val to v
create long long ints l and r
read l and r
make long long ans = 0
for loop while l is less than or equal to r
create long long val = * lower_bound ( v . begin ( ) , v . end ( ) , l )
make long long int count = val - 1 + 1
if val is greater than 4 , set count to r - 1 + 1
set ans to ans + val * count
set l to val + 1
print ans
k = long long int
ara = array of 19 long long int
v = vector of long long int
y = iterator on vector of long long int
function permu ( get long long int pos , return nothing )
if pos is k + 1
i = long long int , p = 1 , l = 0
for i = k down to 1 inclusive
add ara [ i ] * p to l
multiply p by 10
add l at end of v
return
ara [ pos ] = 4
permu ( pos + 1 )
ara [ pos ] = 7
permu ( pos + 1 )
n , m , f , r = long long int , p and flag = 0
read n , m
for k = 1 to 11 inclusive permu ( 1 )
f = item pointed by v
if n > = f and m < = f and flag is 0
add ( m - n + 1 ) * f to p
flag = 2
if n < = f and flag is 0
flag = 1
add ( f - n + 1 ) * f to p
r = f
if m < = f and flag is 1
flag = 2
add ( m - r ) * f to p
else if flag is 1
add ( f - r ) * f to p
r = f
print p
a , b , s , k = integers
read a , b , s
if ( a is 0 and b is 0 and s is 2 )
else
k = abs ( a ) + abs ( b )
if ( s > = k and ( s - k ) modulo 2 is 0 )
else
let p be a string
read p
the string value of ans is equal to space
for i = 0 to length of p exclusive
if p [ i ] equals /
while i is less than length of p and p [ i ] equals / , increment i by 1
ans = ans + /
if i is less than length of p , increment ans by p [ i ]
print ans and newline
create integer n
create constant integer MAXN with MAXN = 105
create integer arrays c , occ , with c size MAXN , occ size MAXN
create boolean array vis with size MAXN
declare dfs with integer idx as argument , returning integer
if vis [ idx ] is true , return 0 from function
set vis [ idx ] to true
return 1 + result of run dfs with c [ idx ] as argument , from function
declare gcd with integers a , b as arguments , returning integer
if a is 0
return b from function
else if b is 0
return a from function
if a is greater than or equal b , return result of gcd with a % b , b as arguments , from function
return result of run gcd with a , b % a as arguments from function
read n
for i = 1 to n inclusive
read c [ i ]
increment occ [ c [ i ] ]
for i = 1 to n inclusive
if occ [ i ] is not 1
print - 1 print " \ n "
create integer ans with ans = 1
for i = 1 to n inclusive
if not vis [ i ]
create integer x with x = result of run dfs with i as argument
if x % 2 is 0 , set x to x / 2
set ans to ans * x / result of run gcd with ans , x as arguments
print ans print " \ n "
integer t integer maxn = 1e5 + 5
integers = a [ maxn ] , b [ maxn ]
integer n
integers = c = 0
integers = cur
read n
set cur to n - 2
sort the values of a to a + n
for i = n - 1 to greater than or equal to 0 and cur is greater than 0 do the following
if a [ cur ] > = a [ i ] and cur is greater than - 1 then subtract one from cur
if cur is greater than or equal to 0 then add one to c
minus 1 from cur
output c
vowel = array of 6 char filled with vowels
s = string
read s
yes = bool
for i = 0 to size of s exclusive
yes = true
for j = 0 to 6 exclusive
if s [ i ] transformed in lowercase is vowel [ j ]
yes = false
break
if yes print ' . ' , char [ s [ i ] in lowercase ]
print newline
x1 , y1 = long long integers
read x1 , y1
x = 1 , y = 0 = long long integers
count set to 0 = long long integer
step equals 1 = long long integers
if x1 is 0 and y1 then do the following
output 0
if x1 is 1 and y1 then do the following
output 0
if 1 is true do the following
if x is x1 and y then do the following
y equals y plus step
add one to count
if x = x1 and y1 is less than or equal to y and y1 > = y - step then break
subtract step + 1 from x
add one to count
if y = y1 and x1 > = x and x1 is less than or equal to x + step + 1 then break
subtract step + 1 from y
add one to count
if x = x1 and y1 > = y and y1 is less than or equal to y + step + 1 then break
x equals x plus step + 2
add one to count
if y = y1 and x1 is less than or equal to x and x1 > = x - step - 2 then break
step equals step plus 2
write count
declare integers n , i = 0 , integer array size 1000
declare string vectors names , unique_names , final_names
declare string a
read n
while decrement n is true
read a , score [ i ]
add a to end of names
increment i
add names [ 0 ] to end of unique_names
for k = 1 to size of names exclusive
for j = 0 to size of unique_names exclusive
if names [ k ] is unique_names [ j ] , end loop
if j is size of unique_names - 1 , add names [ k ] to end of unique_names
declare integer len_unique = size of unique_names
declare integer vector total initialized with ( 1000 , 0 )
declare integer vector time initialized with ( 1000 , 0 )
declare integer counter = 0
for k = 0 to size of names exclusive
for j = 0 to size unique_names exclusive
if names [ k ] is unique_names [ j ]
let total [ j ] be total [ j ] + score [ k ]
if score [ k ] as greater than 0 , increment counter
let time [ j ] be counter
for l = 0 to size of time exclusive
declare integer max_score = value of largest element from beginning of total to end of total
declare string winner
declare integer time1 = 100000000
for k = 0 to size of unique_names exclusive
if total [ k ] is max_score
declare integer sum = 0
for l = 0 to size of names exclusive
if names [ i ] is unique_names [ k ]
let sum be sum + score [ l ]
if sum is greater than or equal to max_score and time1 is greater than l
let time1 be l
let winner be unique_names [ k ]
print winner and newline
create integers x , y , xx , yy , k , c , with x = 0 , y = 0 , xx = 0 , yy = 0 , k = 2 , c = 1
create map mp from pair of ( integer , integer ) to integer
while 1 is true
increment c
set x to ( x * - 1 ) + 1
if x is xx
for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2
else
for i = minimum of x and xx to maximum of x and xx inclusive , set mp [ make pair from ( i , y ) ] to c - 2
if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ]
set xx to x
set y to ( y * - 1 ) + 1
increment c
if x is xx
for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2
else
for i = minimum of x and xx to maximum of x and xx , set mp [ make pair from ( i , y ) ] to c - 2
if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ]
set yy to y
set value of x to - 1
increment c
if x is xx
for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2
else
for i = minimum of x and xx to maximum of x and xx , set mp [ make pair from ( i , y ) ] to c - 2
if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ]
set xx to x
set value of y to - 1
increment c
if x is xx
for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2
else
for i = minimum of x and xx to maximum of x and xx , set mp [ make pair from ( i , y ) ] to c - 2
if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ]
set yy to y
if x is - 300 and y is - 300 break loop
set mp [ make pair from ( 0 , 0 ) ] to 0
create integers a , b
read a read b
if ( a is 0 and b is 0 ) or ( a is 1 and b is 0 ) , return print 0 print ' \ n ' , 0 from function
print mp [ make pair from ( a , b ) ] print ' \ n '
create ints p , q , A , B , R , and i = 1 and int array C of size 2000000 containing { 1 , 1 }
read p and q
for loop i to 2e6 exclusive
if C [ i ] is falsy
set A to A + q
for j = i to 2e6 exclusive by incrementing by i , set C [ j ] to 1
make ints r = 0 and t = i
for loop while t is truthy and increment by r = 10 * r + t % 10 and t / = 10
end statement
set B to B + p * ( r = = i )
set R to A < = B ? i : R
display R
a , b , c = long long integers
read a , b , and c
if a is less than zero , let a = - a
if b is less than zero , let b = - b
if a + b is greater than c
otherwise if c - a - b bitwise and with 1 is true
otherwise
create long long t1 , t2 , x1 , x2 , t0 , res_x , res_y
read t1 , t2 , x1 , x2 , t0
create double t and ct , set ct = 1e99
while x1 > = 0 and x2 > = 0
set to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if t < t0
decrement t1
continue
if t less than ct
ct = t
res_x = x1
res_y = x2
decrement x2
print res_x , ' ' , res_y
declare integer variables h and m
read h and m
declare integer variables p and q = 0 , f1 = h - 1 and f2 = m - 1
while f1 > 0
divide f1 by 7
increment p by one
while f2 > 0
divide f2 by 7
increment q
if h is 1 , change p to 1
if m is 1 , change q to 1
if p + q is greater than 7
print 0
declare integer ans = 0
loop i from 0 to h exclusive incrementing i
for j from 0 to m exclusive incrementing j
create vector of int used with 7 elements filled with 0
for a = i and k = 0 while k < p , dividing a by 7 and incrementing k , add 1 to used [ a % 7 ]
for b = j and k = 0 while k < q , dividing b by 7 and incrementing k , add 1 to used [ b % 7 ]
if * max_element of used . begin ( ) and used . end ( ) is < = 0 , increment ans
print ans
M = long long const with M = 2e5 + 10
head , tail = long long with head = 0 and tails = 0 and col , q , ans , ans2 = long long array of size M each
adj , adj2 = long long vector array of size M each
n , m , a , b = long long
read n then m
for i = 1 to n inclusive
read col [ i ]
set col [ i ] to ( 3 - col [ i ] ) mod 3
of col [ i ] is 2 set q [ head ] to i then set ans [ i ] to 1 then increment head
loop while head > tail
v = long long with v = q [ tail ] then increment tail
for i = 0 to size of adj [ v ]
u = long long with u = adj [ v ] [ i ]
if not ans [ u ] and col [ u ] is not 2 set q [ head ] to u then set ans [ u ] to 1 then increment head
set head to 0 then set tail to 0
for i = 1 to n inclusive
if col [ i ] is 1 set q [ head ] to i then set ans2 to 1 then increment head
loop while head > tail
v = long long with v = q [ tail ] then increment tail
for i = 0 to size of adj2 [ v ]
u = long long with u = adj2 [ v ] [ i ]
if not ans2 [ u ] and col [ u ] is not 2
set ans2 [ u ] to 1 then set q [ head ] to u then increment head
else if col [ u ] is 2
set ans2 [ u ] to 1
for i = 1 to n inclusive
if ans [ i ] is 1 and ans2 [ i ] is 1
print 1
else
print 0
create integers ne = 0 , po = 0 , sumne = 0 , sumpo = 0 and integer arrays nega with size of 100003 and posi with length of 100003
create bool z = false
create integers n , x , a
read n
set all contents of nega to 0
set all contents of posi to 0
for i = 0 to n exclusive
read x and a
if x is less than 0
set nega [ - x ] to a
increment ne
set sumne to sumne + a
else
set posi [ x ] to a
set sumpo to sumpo + a
set po to n - ne
if po is equal to ne
print sumne + sumpo and new line
if po is less than ne
set sumne to 0
create integer cont = 0
for cont = 0 to po inclusive
if nega [ i ] is not equal to 0
set sumne to sumne + nega [ i ]
increment cont
if po is less than ne
set sumpo to 0
create integer cont = 0
for cont = 0 to ne inclusive
if posi [ i ] is not equal to 0
set sumpo to sumpo + posi [ i ]
increment cont
print sumne + sumpo
a = array of integers of length 105 , s = array of integers of length 1005 , 105th element of num = 0
let n , i , j , k , maxn be integers
read n , maxn
for i = 1 to n inclusive
read a [ i ]
increment num [ a [ i ] ] by 1
let sum be a integer with sum = 0
let p , top be integers with p = 0 , top = 0
for i = 1 to n inclusive
for j = p to top exclusive
if s [ j ] is equal to a [ i ] , stop
if j is less than top
proceed to next
if top - p is less than maxn
the value of s [ top + + ] is equal to a [ i ]
increment sum by 1
decrement num [ a [ i ] ] by 1
the value of k is equal to 0
for j = 0 to top exclusive
let qq , ww be integers
for qq = i + 1 to n inclusive
if a [ qq ] is equal to s [ k ] , stop
for ww = i + 1 to n inclusive
if a [ ww ] is equal to s [ j ] , stop
if qq is less than ww , k is equal to j
s [ k ] is equal to a [ i ]
increment sum by 1
decrement num [ a [ i ] ] by 1
print sum and newline
n , m , i , j , num , cnt = integers with num = array of size 105 , cnt = 0
read n , m
for i = 0 to t exclusive
read num [ i ]
if ( num [ i ] < = m )
num [ i ] = 0
j = i
else
num [ i ] = num [ i ] - m
cnt = 1
while ( cnt )
cnt = 0
for i = 0 to n exclusive
if ( num [ i ] < = m and num [ i ] is not 0 )
num [ i ] = 0
j = i
else if ( num [ i ] > m )
num [ i ] = num [ i ] - m
cnt = 1
print j + 1
declare constant integer INF = 0x3f3f3f3f
declare string s
declare integers i , j , k
declare n , m , t as integers
read n
read s
declare integers cou = 0 , co = 0
for i = 0 to length of s exclusive
if s [ i ] is ' 0 '
increment cou
else
increment co
if co is 0
print 0 , newline
else
print 1
for i = 0 to cou exclusive , print 0
print newline
create int n
read n
make string s
read s
let string ans
let bool ok = 0
for i = 0 to n exclusive
if s [ i ] is equal to ' 1 ' and ! ok is true
set ans to ans + s [ i ]
set ok to 1
else if ok is true and s [ i ] is ' 0 '
set ans to ans + s [ i ]
if ans . size ( ) is truthy
print ans
otherwise
print 0
a = long long array of size 100010
N , M , K = long long
mm = long long with mm = 1e9
read N then M then K
for i = 1 to N inclusive
read a [ i ]
if i is uneven set mm to min of mm , a [ i ]
if N is even
print " 0 "
temp = int with temp = ( N + 1 ) / 2
print min of mm , M / temp * K
declare long long ans
in function maxsum , return type long long , parameters long long p array , long long n
define long long tmp = 0
for long long i = 0 to n exclusive
set ans to max of ans and tmp
increase tmp by p [ i ]
if tmp less than 0 , set tmp to 0
set ans to max of ans and tmp
declare long long n
read n
declare long long array a with a length of n
for long long i = 0 to n exclusive , read a [ i ]
declare long long b array with n as length
declare long long c array with n as length
for long long i = 0 to n - 1 exclusive
set b [ i ] to abs of a [ i ] - a [ i + 1 ] * ( if i is even , 1 ; else , - 1 )
set c [ i ] to abs of a [ i ] - a [ i + 1 ] * ( if i + 1 is even , 1 ; else , - 1 )
maxsum ( b , n - 1 )
maxsum ( c , n - 1 )
day = map from strings to integers
set the value of day [ " monday " ] to 1
change day [ " tuesday " ] to 2
assign the new value = 3 to day [ " wednesday " ]
assign the new value = 4 to day [ " thursday " ]
assign 5 to day [ " friday " ]
set the value of day [ " saturday " ] to 6
set the value of day [ " sunday " ] to 7
create new strings fd and sd
read variables fd and sd from the input
new integers f = day [ fd ] and s = day [ sd ]
create integer k with value ( s - f + 7 ) % 7
if k = 0 , 2 or 3
print " YES "
else
print " NO "
s = string
n = int
read n , s
s = ' 0 ' + s + ' 0 '
if ' 000 ' and ' 11 ' are not present in s
print " Yes "
else
print " No "
declare constant integer variable maxn = 1e5 + 10
create bool arrays mark and rmark with maxn elements
a is an array of integers with maxn elements
declare an arrays of int vectors v and rv with size maxn
inlined void function dfs with int arguments x and par
return if mark [ x ] is true
if par ! = - 1 and a [ x ] = 1 , return
assign 1 to mark [ x ]
start for loop from i = 0 to length of v [ x ] exclusive incrementing i
if mark [ v [ x ] [ i ] ] is false , call function dfs for v [ x ] [ i ] and x
inlined void function rdfs with int argument x
if rmark [ x ] is true , return
assign 1 to rmark [ x ]
if a [ x ] is equal to 1 , return
start for loop from i = 0 to length of rv [ x ] exclusive
if rmark [ rv [ x ] [ i ] ] is false , call rdfs ( rv [ x ] [ i ] )
declare integers n , m , x and y
read from the input to n and m
in a loop , read n elements into array a
for i from 0 to m exclusive incrementing i
read from the input to x and y
decrement x by one
decrement y
push new value = y into v [ x ]
push x to the end of rv [ y ]
start for loop from i = 0 to n exclusive incrementing i
call dfs ( i , - 1 ) if a [ i ] is equal to 1
for i from 0 to n exclusive incrementing i
if a [ i ] = 2 , run rdfs with i as an argument
start for loop from i = 0 to n exclusive
if both mark [ i ] and rmark [ i ] are true
print 1 and " \ n "
else
print 0 and " \ n " to the standard output
s = string
read s
i , j , k , l = integers with l = s . length ( )
a1 , b1 , c1 , m = integers with a1 = 0 , b1 = 0 , c1 = 0 , m = - 1
for i = 0 to l - 2 exclusive
if ( a1 * 10 + ( s [ i ] - 48 ) > 1000000 ) , break loop
if ( i and s [ 0 ] is 0 ) , break loop
a1 = a1 * 10 + ( s [ i ] - 48 )
for j = i + 1 to l - 1 exclusive
if ( b1 * 10 + int ( s [ j ] - 48 ) > 1000000 ) , break loop
if ( i + 1 < j and s [ i + 1 ] is 0 ) , break loop
b1 = b1 * 10 + cast to int ( s [ j ] - 48 )
c1 = 0
for k = j + 1 to 1 exclusive
if ( c1 * 10 + cast to int ( s [ k ] - 48 ) > 1000000 ) , goto w
if ( j + 1 < k and s [ j + 1 ] is 0 ) , goto w
c1 = c1 * 10 + cast to int ( s [ k ] - 48 )
if ( m < a1 + b1 + c1 ) , m = a1 + b1 + c1
label w
b1 = 0
print m
N = constant integer = 200010
n , t , ans , maxn are long longs
m , ms are long long arrays of size N
read n
for i = 1 to n inclusive
read m [ i ]
for j = 1 to m [ i ] inclusive , read t , set ms [ i ] to call max with ms [ i ] , t
set maxn to call max with maxn , ms [ i ]
for i = 1 to n inclusive , add m [ i ] * ( maxn - ms [ i ] ) to ans
print ans
a , b , s = integers
read a , b and s
d = integer set to absolute value of a + absolute value of b
if d < = s and d ^ s & 1 is 0 , print " Yes \ n " if true and " No \ n " if false
let printSt be a void function that accepts integer x
for integer i is equal to int ( 0 ) to int ( x ) exclusive , print |
let get be a void function that accepts int & a , int & b , int & c , string cad
let p be a integer
for p is equal to 0 , cad [ p ] is not equal to + , increment p by 1 , increment a by 1
for increment p by 1 , cad [ p ] is not equal to = , increment p by 1 , increment b by 1
for increment p by 1 , p is less than int ( length of cad ) , increment p by 1 , increment c by 1
let cad be a string
read cad
let a , b , c be integers
initialize the values of a , b , c to 0
send the values a , b , c , cad into get
if a + b + 1 is equal to c - 1 , increment a by 1 , decrement c by 1
if a + b - 1 is equal to c + 1
if a is greater than b
decrement a by 1
decrement b by 1
increment c by 1
if a + b is not equal to c
print Impossible and newline
exit ( 0 )
send a into printSt
print +
send b into printSt
print =
send c into printSt
print newline
x1 , y1 , x2 , y2 = long long
n = integer
cont = integer = 0
read x1 , y1 , x2 , y2
read n
for i = 0 to n exclusive
a , b , c = long long
read a , b , c
if ( x1 * a + y1 * b + c ) > 0 ) and ( x2 * a + y2 * b + c ) < 0 ) , then increase cont by 1
if ( x1 * a + y1 * b + c ) < 0 ) and ( x2 * a + y2 * b + c ) > 0 ) , then increase cont by 1
print cont
let t1 , t2 , x1 , x2 , t0 , res_x , res_y be long lon
read t1 , t2 , x1 , x2 , t0
let t , ct be double with ct = 1e99
while x1 is greater than or equal to 0 and x2 is greater than or equal to 0
set t to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if t is less than t0
decrement x1
continue
if t is less than ct
set ct to t
set res_x to x1
set res_y to x2
decrement x2
print out res_x , ' ' , res_y with newline
n = long long , t = long long = 0 , z = long long = 1 , l = long long = 1
read n
x , m = character
for i = 0 to n exclusive
read m
if t is 0
if m is ? , then z = 2
increase t by 1
x = m
else if m is x and m is not ?
l = 0
z = 2
exit for loop
else if m is ? and m is x and z is not 2
z = 2
else if m is ? and z is not 2 and i + 1 is n
z = 2
if m is ? and z is not 2 and i + 1 is not n
read m
increase i by 1
if x is m or m is ? , then z = 2
x = m
if l is not 0 and z is 2 , then print Yes
if z is 1 , then print No
let n , s , x , y , and = integers with ans = - 1
read n , s
for integer i = 0 to n exclusive do the following
read x , y
if ( s * 100 is greater than or equal to x * 100 + y set ans = max of ans and ( 100 - y ) modulo 100
print ans
declare cek taking in int x and returning bool
create integer ada = 0
for i = 1 to sqrt ( x )
if x % i is equal to 0 , add 1 to ada
if ada is equal to 1
otherwise
return 1
make integer n
read n
for i = 1 to 1000
make int x = ( i * n )
set x to x + 1
if cek ( x ) is truthy
print i
create long longs x , y
declare exgcd with long longs a , b as arguments returning long long
if b is 0
set x to 1
set y to 0
return a from function
crate long long d with d = result of run exgcd with b , a % b as arguments
create long long t with t = x
set x to y
set y to t - a / b * y
return d from function
create long longs m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2
create long longs p1 , p2 , q1 , q2
while read m read h1 read a1 read x1 read y1 read h2 read a2 read x2 read y2 is true
set p1 to p2 to q1 to q2 to 0
for i = 1 to 2 * m inclusive
set h1 to ( h1 * x1 + y1 ) % m
if h1 is a1
if p1 is 0
set p1 to i
else if q1 is 0
set q1 to i - p1
break loop
for i = 1 to 2 * m inclusive
set h2 to ( h2 * x2 + y2 ) % m
if h2 is a2
if p2 is 0
set p2 to i
else if q2 is 0
set q2 to i - p2
break loop
create long long d with d = result of run exgcd with q1 , - q2 as arguments
create long long c with c = p2 - p1
if d is 0
print " - 1 "
break current loop iteration
if c % d
print " - 1 "
break current loop iteration
if p1 is 0 or p2 is 0
print " - 1 "
break current loop iteration
if q2 is 0 and q1 is 0 and p1 is not p2
print " - 1 "
break current loop iteration
if ( q2 is 0 and p2 - p1 is less than 0 ) or ( q2 is 0 and p1 - p2 is less than 0 )
print " - 1 "
break current loop iteration
create long long k with k = c / d
set x to x * k
set y to y * k
if d is less than 0 , set d to - d
if x is less than 0 or y is less than 0
while 1 is true
increment x by q2 / d
increment y by q1 / d
if x is greater than or equal to 0 and y is greater than or equal to 0 , break loop
if x is greater than 0 and y is greater than 0
while 1 is true
decrement x by q2 / d
decrement y by q1 / d
if x is less than 0 or y is less than 0 , break loop
increment x by q2 / d
increment y by q1 / d
create long long ans with ans = x * q1 + p1
print ans print newline
MOD = constant long long = 1e9 + 9LL
s = string
n , a , b , k = long long
in function MODULUS with arguments of long long b and long long p that returns a long long
ret = long long = 1LL
while p is nonzero
if bitwise and of p and 1LL , then ret = ( ret * b ) modulo MOD
b = ( b * b ) modulo MOD
p shifted by 1LL bits to the right
return ret
in function MODINVERSE with an argument long long x that returns a long long
return the result of calling MODULUS with arguments of x , MOD - 2LL
in function Add with arguments of long long x and long long that returns a long long
x = x + y
if x > MOD that returns x - MOD
return x
in function Sub with arguments of long long x and long long y that returns a long long
x = x - y
if x < 0 , then return x + MOD
return x
in function Mul with arguments of long long x and long long y that returns a long long
x = x * y
return x modulo MOD
in function Div with arguments of long long x and long long y that returns a long long
return ( x * MODINVERSE ( y ) ) modulo MOD
read n , a , b , k , s
ans = long long = 0LL
x = long long = call Div with arguments of b and a
c = long long = call MODULUS with arguments of a and n
for i = 0 to k exclusive
if s [ i ] is +
ans = ans + c
else
ans = ans - c
c = call Mul with arguments c and x
if ans < 0 then ans = ans + MOD
x = call MODULUS with arguments of x and k
if x is 1
ans = call Mul with arguments ans and ( n + 1 ) / k
else
ans = ( call Mul with arguments x and ( n + 1 ) / k ) - 1
ans = call Div with arguments of ans and x - 1
print ans modulo MOD
mem = integer array of size [ 6000 ] [ 6000 ]
s , t = strings
in the function f that takes integer i , j and returns integer
if ( i is s . length ( ) or j is t . length ( ) ) , return 0
if ( mem [ i ] [ j ] is not - 1 ) , return mem [ i ] [ j ]
if ( s [ i ] is t [ j ] )
mem [ i ] [ j ] = ( f ( i + 1 , j + 1 ) + f ( i , j + 1 ) + 1 ) modulo 1000000007
else
mem [ i ] [ j ] = f ( i , j + 1 )
return mem [ i ] [ j ]
read s , t
set all contents of mem to - 1
ans = integer with ans = 0
for i = 0 to s . length ( ) exclusive , ans = ( ans + f ( i , 0 ) ) modulo 1000000007
print ans
N , INF , MOD are constant integers all set to 0
n , L , a , t , l , last are integers with last = 0
ans = long long
read n , L , a
for i = 0 to n exclusive
read t , l
add call max with 0 , ( t - last ) / a to ans
set last to t + 1
add call max with 0 , ( L - last ) / a to ans
output ans
create long long int a
read a
if a = 0
print - 1
else if a mod 4 = 0
else if a mod 4 = 1
else if a modulo 4 = 2
else
print 2 and a newline
declare int variables flag , gender , ok , t and cnt
declare new string called s
define new array of strings filled with elements " lios " , " liala " , " etr " , " etra " , " initis " and " inites "
integer function cmp with string arguments a and b
define integers len1 = length of a , and lent2 = length of b
start for loop from i = 0 to len2 exclusive
return 0 if a [ len1 - len2 + i ] ! = b [ i ]
return 1
assign the new value = 3 to gender
read s and keep looping
set ok to 0
for integer i = 0 to 6 exclusive incrementing i
if cmp ( s , x [ i ] ) is not 0
assign 1 to ok
increment cnt by one
if gender = 3
set the value of gender to i modulo 2
else if i % 2 ! = gender
print " NO "
assign the new value = i / 2 + 1 to t
if t is equal to 1 and flag = 0
change flag to 1
else if t and flag are both 1
change flag to 1
else if t is equal to 2 and flag is equal to 1
set the value of flag to 2
else if t is equal to 2 and flag = 0
assign the new value = 2 to flag
else if t is equal to 3 and flag = 0
assign the new value = - 1 to flag
else if t is equal to 3 and flag = 2
set the value of flag to 3
else if t and flag are both equal to 3
change flag to 3
else
print " NO "
if ok is equal to 0
print " NO "
if character from the input is equal to ' \ n ' , break the loop
if flag = 1 and cnt > 1
print " NO "
else
print " YES "
p , n , k , s = integer with p = 1 , s = array of size 105
c = character
s [ increment k ] = 1
while ( read c and c is not =
if c is + , increment p , s [ increment k ] = 1
if c is - , decrement p , s [ increment k ] = - 1
read n
for i = 0 to k exclusive
if s [ i ] > 0
while p < n and s [ i ] < n , increment s [ i ] , increment p
else
while p > n and s [ i ] > - n , decrement s [ i ] , decrement p
if p is not n
print = and n
let n , a , b , c , d , sum , l1 , l2 be integers
read n , a , b , c , d , sum , l1 , l2
if a is equal to 0
assign b to l1
else if a is equal to n
assign 3 * n - b to l1
else if b is equal to 0
assign 4 * n - a to l1
else if b is equal to n
assign n + a to l1
if c is equal to 0
assign d to l2
else if c is equal to n
assign 3 * n - d to l2
else if d is equal to 0
assign 4 * n - c to l2
else if d is equal to n
assign n + c to l2
display call min with arguments absolute value of ( l1 - l2 ) , 4 * n - absolute value of ( l1 - l2 )
create const long long integer mod = 1e9 + 9
declare mod_pow taking in long long ints x and n and returning long long integer
make long long res = 1
while n is greater than 0
if n & 1 is truthy , set res to res * x % mod
set x to x * x % mod
move bits of n 1 place to right
return res
declare extgcd taking in long long ints a , b , & x , and & y and returning long long integer
make long long int d = a
if b is not 0
set d to extgcd ( b , a % b , y , x )
set y to y - ( a / b ) * x
else do
set x to 1
set y to 0
return d
declare mod_inverse taking in long long a and returning long long int
create long long ints x , y , and m
set m to mod
call extgcd ( a , m , x , y )
return the result of ( m + x % m ) % m
make long long ints n , a , b , k , ans , temp , rec , and q
make string s
read n , a , b , and k
read s
set ans to 0
for i = 0 to k exclusive
set temp to ( mod_pow ( a , n - i ) * mod_pow ( b , i ) ) % mod
if s [ i ] is equal to ' + '
set ans to ( ans + temp ) % mod
else do
set ans to ( ans - temp ) % mod
if ans is less than 0 , set ans to ans + mod
if n + 1 is k
print ans
set rec to ( n + 1 ) / k
set q to mod_pow ( ( mod_inverse ( a ) * b ) % mod , k ) % mod
if q is equal to 1
set ans to ( ans * rec ) % mod
otherwise
set ans to ( ( ans * ( mod_pow ( q , rec ) - 1 ) % mod ) * mod_inverse ( q - 1 ) ) % mod
display ans
define gcd which takes long long a , b as arguments and return long long
return a if b = = 0 else gcd of b , a mod b
define lcm which takes long long a , b as arguments and return long long
return a * ( b / gcd of a , b )
let q be const integer with q = 1e9 + 7
let ans be long long with ans = 0
let v be vector of integers
let n , f , iv , l be long lon
read n , f , iv , l
increment l by iv
update ans to l / f
if l % f , increment ans
if ans * f > n
print - 1 with newline
else
print out ans with newline
let MAXN be a constant integer with MAXN = 1001
let INF be a constant integers with INF = 1e6 + 1
in = array of integers of length MAXN
out = array of integers of length MAXN
d = array of integers of length MAXN
let n , m be integers
read n , m
for i = 0 to n exclusive , out [ i ] is equal to - 1
for i = 0 to m exclusive
let a , b , c be integers
read a , b , c
decrement a by 1
decrement b by 1
increment in [ b ] by 1
out [ a ] is equal to b
d [ a ] is equal to c
let r1 , r2 , r3 be vectors of integer elements
for i = 0 to n exclusive
if in [ i ] is equal to 0 and out [ i ] is not equal to - 1
let j be a integer with j = i
let res be a integer with res = INF
while out [ j ] is not equal to - 1
res is equal to minimum of res , d [ j ]
j is equal to out [ j ]
push_back i + 1 into r1
push_back j + 1 into r2
push_back res into r3
print length of r1 and newline
dp = long long array of size 5000
m = long long and long long map
n = long long
read n
s = string
read s
cnt = long long with cnt = 0
for i = 0 to size of s
if i is not 0
set dp [ i + 1 ] to dp [ i ] + ( s [ i ] - ' 0 ' )
else
set dp [ i + 1 ] to s [ i ] - ' 0 '
for i = 1 to size of s inclusive
for j = 1 to i inclusive
increment m [ dp [ i ] - dp [ j - 1 ] ]
increment cnt
if n is 0
ans2 = long long with ans2 = m [ 0 ] * 2 * cnt - m [ 0 ] * m [ 0 ]
print ans2
ans = long long with ans = 0
for i = 1 to sqrt of n inclusive
if n is a multiple of i and i is not sqrt of n
increment ans by 2 * ( m [ i ] * m [ n / i ] )
else if i is sqrt of n
increment ans by ( m [ i ] * m [ n / i ] )
print ans
let MX be a constant integer with MX = 100005
let n be a integer
let a be a pair of two integer values
read n
for integer i = 0 to n exclusive , read a [ i ] . first and a [ i ] . second
sort the values a and a + n
let i , j , acu be integers with all values equal to 0
while i is less than n
j equals a [ i ] . first
acu equals maximum value of max ( acu , a [ i ] . second )
while acu is greater than 1 and i + 1 equals to n or j is less than a [ i + 1 ] . first ) ,
acu equals ( acu + 3 ) / 4
increase j value by 1
increase i value by 1
print maximum of , a [ n - 1 ] . first + 1 and new line
n = integer
while read n
a = integer array of size 110
cnt = integer with cnt = 0
s = integer array of size 110
set all contents of s to 0
m = integer with m = 0
for i = 0 to n exclusive , read a [ i ]
for i = 0 to n exclusive
if a [ i ] < 0 , increment cnt
increment s [ m ]
if cnt is 2 and i + 1 < n and a [ i + 1 ] < 0
increment m
cnt = 0
print m + 1
for i = 0 to m
if i , print " "
print s [ i ]
print new line
declare character array a size 104
declare integers n , j , t , e , sum
read string into a
declare l = string length of a as integer
for i = 0 to l exclusive
if a [ i ] is ' n ' , increment n
if a [ i ] is ' i ' , increment j
if a [ i ] is ' e ' , increment e
if a [ i ] is ' t ' , increment t
let sum be minimum of ( minimum of ( minimum of ( t and j ) and e / 3 ) and ( n - 1 ) / 2 )
print sum and newline
s , ss = set of int
n , p , a , b , d = int
in = array of 100005 pair of int , int
read n , p
for i = 0 to p exclusive
read a , b , d
in [ a ] = b and d , insert b into s and a into ss
a = 0
for i = 1 to n inclusive
if i is not present in s and is present in ss increment a
print a
for i = 1 to n inclusive
if i is not present in s and is present in ss
a = i , b = second item of in [ i ]
while first item of in [ a ] b = min ( b , second item of in [ a ] ) , a = first item of in [ a ]
print i , space , a , space , b
let n be an integer , let a be an integer array of size 500008
let slove be a function that takes int x and int y as parameters
let integer k = y = x + 1
let i be an integer
if k is even
for i = x to x + k / 2 , let a [ i ] equal a [ x ]
for i = x + k / 2 to y inclusive , let a [ i ] equal a [ y ]
for i - x + 1 to y inclusive , let a [ i ] be equal to a [ x ]
return ( k - 1 ) / 2 to main method
let ans , l , r be integers
let i be an integer
read n
for i = 1 to n inclusive , read a [ i ]
let ans equal 0
for i = 2 to n
if a [ i ] is not equal to a [ i - 1 ] AND a [ i ] is not equal to a [ i + 1 ]
let l = i - 1
add one to i
for i is smaller than n
if a [ i ] is not equal to a [ i - 1 ] AND a [ i ] is not equal to a [ i + 1 ]
continue on
break out of loop
let r equal i
let ans equal to the larger value of either ans or slove ( l , r )
let l equal 0
let r equal 0
print ans and endline
for i = 1 to n , print a [ i ] and a space after it
print a [ i ] and endline
x , y , xx , yy = 0 , k = 2 , c = 1
mp = map from pair of int to int
while true
increment c
x = ( x * - 1 ) + 1
if x is xx
for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2
else
for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2
if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ]
xx = x
y = ( y * - 1 ) + 1
increment c
if x is xx
for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2
else
for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2
if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ]
yy = y
multiply x by - 1
increment c
if x is xx
for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2
else
for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2
if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ]
xx = x
multiply y by - 1
increment c
if x is xx
for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2
else
for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2
if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ]
yy = y
if x is - 100 or y is - 100 break
mp [ make_pair ( 0 , 0 ) ] = 0
a , b = int
read a and b
if ( a is 0 and b is 0 ) or ( a is 1 and b is 0 ) print 0 , newline , 0
if mp [ make_pair ( a , b ) ] is 0
print mp [ make_pair ( b , a ) ] + 1
else
print mp [ make_pair ( a , b ) ]
declare long longs i , j = 0 , n , l = 0 , declare long long array a size 1000 , b size 1001
read n
for i = 0 to n exclusive , read a [ i ] and b [ i ]
for i = 0 to n exclusive
for j = 0 to n exclusive
if j is not i and a [ i ] is b [ j ]
increment l
end loop
print n - l and newline
n , i are integers
read n
if n & 1
n equals n shifted bitwise by 1 to right
else
for i = 1 to n inclusive
end statement
n equals n - ( i > > 1 ) shifted bitwise by 1 to right
print n and endline
n , m = integer , u = integer = 0 , e = integer = 0 , x = integer = 1 , p = integer = 0
read n , m
s , t = string
read s , t
if n - 1 > m
for i = 0 to n exclusive
if s [ i ] is not t [ i ] and s [ i ] is not *
if s [ i ] is *
e = i
increase p by 1
exit the for loop
for i = n - 1 to e exclusive , decrease i by 1
if s [ i ] is not t [ m - x ] , then increase u by 1
increase x by 1
if u > = 1 or n - p > m
else if n < m and p is 0
else
connected is a new array of integers with size 1005
diameter is a new array of integers with size 1005
create a new array of integers called in with 1005 elements
out is an array of integers with 1005 elements
declare integers n and p
read input to n and p
decrement p and loop further , while p is not 0
declare integers a , b and d
read standard input to a , b and d
assign the new value = b to connected [ a ]
change the value of diameter [ a ] to d
increment in [ b ]
increment out [ a ] by one
declare integer variable with name sol = 0
in a for loop , change i from 1 to n inclusive incrementing i
if in [ i ] = 0 and out [ i ] ! = 0 , increment sol
print sol and ' \ n '
for integer i = 1 to n inclusive incrementing i
if in [ i ] is 0 and out [ i ] is not 0
create integer variable with name id with value i
declare new integer ans with value INT_MAX
while out [ id ] is not 0
assign min of ans and diameter [ id ] to ans
change the value of id to connected [ id ]
print i , ' ' , id , ' ' , ans and ' \ n '
arr1 = array of integers of length 110
arr2 = array of integers of length 110
let i , j , ind , count , n be integers with ind = 0 , count = 0
read n
for i = 1 to n inclusive , read arr1 [ i ] , arr2 [ i ]
for i = 1 to n inclusive
ind is equal to 0
for j = 1 to n inclusive
if i is not equal to j
if arr2 [ j ] is equal to arr1 [ i ] , ind is equal to 1
if not ind , increment count by 1
print count and newline
create long long ints n , d , and m = 0 and int array x of size 100005
read n and d
for i = 1 to n , read x [ i ]
for i = 1 to n - 2
make long long ints l = i and r = n + 1
while r - 1 is greater than 1
make long long mid = ( l + r ) / 2
if x [ mid ] - x [ i ] is greater than d
set r to mid
else do
set l to mid
add max ( 0 * 1ll , ( l - i - 1 ) ) * ( l - i ) / 2 to m
display m
n , m , a , b , ans1 , ans2 = integer
read n , m , a , b
row1 = integer = ( a - 1 ) / m
row2 = integer = ( a - 1 ) / m
col1 = integer = m if a modulo m is 0 else col1 = a modulo m
col2 = integer = m if b modulo m is 0 else col2 = b modulo m
if row1 is row2
ans1 = 1
else if row2 - row1 is 1
ans1 = 2
if col1 is 1 and b is n
ans1 = 1
else if col1 is 1 and col2 is m
ans1 = 1
else
ans1 = 3
if b is n or col2 is m , decrease ans1 by 1
if col1 is 1 , decrease ans1 by 1
ans2 = 3
if col1 - 1 is col2 , then increase ans2 by 1
print the lower value between ans1 and ans2
create constant integer INF_INT = 2147483647
create new constant long long INF_LL with value 9223372036854775807LL
declare new unsigned long long constant INF_ULL = 18446744073709551615Ull
define new constant long long P with value 92540646808111039LL
declare long long constants maxn = 1e5 + 10 and MOD = 1e9 + 7
create new 2d array of integers Move , with size 4 by 2 and filled by values - 1 , 0 , 1 , 0 , 0 , 1 , 0 , - 1
define inlined function read that returns integer
create new integers x = 0 and f = 1
create character variable with name ch and value read from the input
while ch is not a digit
if ch is equal to ' - ' , set f to - 1
change ch to character from the input
while ch is a digit character
change the value of x to x * 10 + ch - ' 0 '
change ch to char from the input
return x multiplied by f
void function init
call function init ( )
declare long long variables n , a , b and c
read n , a , b and c from the user input
if n is less than b
print n / a
if a < = b - c
if n % a > = b
print ( n / a ) + 1 + ( ( n % a ) - b ) / ( b - c )
else
print n / a
else
create long long variable t with value 1 + ( n - b ) / ( b - c )
decrease n by t * ( b - c )
print t + n / a
declare function rh taking float array and returning bool
declare function zero2 taking float array and returning bool
i = int with i = 0
A = float array of size 6
if A [ 2 ] is 0 and a [ 3 ] is not 0
print " Ron "
else if rh of A
print " Hermione "
else if A [ 0 ] is 0 and a [ 1 ] is not 0
print " Ron "
else
set A [ 3 ] to A [ 3 ] / ( A [ 2 ] / A [ 1 ] )
set A [ 5 ] to A [ 5 ] / ( A [ 4 ] / A [ 3 ] )
if A [ 5 ] > A [ 0 ]
print " Ron "
else
print " Hermione "
in function rh taking float array A and returning bool
if A [ 2 ] is not 0 and A [ 3 ] is 0
return true
else if zero2 of A
return true
return false
in function zero2 taking float array A and returning bool
for i = 0 to 4
if A [ i ] is 0 and A [ i + 1 ] is 0 return true
return false
getPoint is a int function with int arguments x , y and n
if y is equal to 0
return x
else if x = n
return x + y
else if y = n
return 3 * n - x
else
return 4 * n - y
declare int variables n , a , b , c and d
read n , a , b , c and d
declare int variables p1 = getPoint ( a , b , n ) and p2 = getPoint ( c , d , n )
print min of ( p1 - p2 + 4 * n ) % ( 4 * n ) and ( p2 - p1 + 4 * n ) % ( 4 * n )
x , y , ans = int with ans = 0
read x then y
p = int
set p to max of absolute x and absolute y
if x is p and x is greater than 0 and x + y is greater than 1
decrement p then set ans to p
set ans to ans * 4
increment ans
else if y is p and y is greater than 0 and y - x is greater than 0
set ans to p
set ans to ans * 4
subtract 2 from ans
else if x is - 1 * p and x is less than 0 and x + y is less than 0
set ans to p
set ans to ans * 4
decrement ans
else
if x + y is 1
decrement x
set ans to x
set ans to ans * 4
else
set ans to p
set ans to ans * 4
if x and y are both 0 then set ans to 0
set ans to max of ans and 0
print ans
set integer num [ 110 ] to 0
integers = n
read n
for i = 1 to less than or equal to n do the following
create integer vector p
set integer a to 0 , b
for i = 1 to less than or equal to n do the following
if i is n then do the following
if num [ i ] is greater than or equal to 0 then do the following
add one to a
add one to b
push_back part of p = b
else
if c is 2 then do the following
a equals a plus 2
push_back part of p = b
push_back part of p = 1
else
add one to a
push_back part of p = b + 1
else
if num [ i ] is greater than or equal to 0 then do the following b + +
if num [ i ] is less than 0 then do the following
if c is 2 then do the following
add one to a
push_back part of p = b
set b to 1
set c to 1
else
add one to c
add one to b
output a
for i = 0 to less than p . size ( ) do the following
if i is false
output p [ i ]
else
output , p [ i ]
output endl
make string array S with a length of 4
make integers I , J , K
in function jarak , returning int and accepting int x and int y
if y greater than x
return y - x
else
return ( y + 12 ) - x
make map A of string to int
set A [ " C " ] to 1
set A [ " C # " ] to 2
set A [ " D " ] to 3
set A [ " D # " ] to 4
set A [ " E " ] to 5
set A [ " F " ] to 6
set A [ " F # " ] to 7
set A [ " G " ] to 8
set A [ " G # " ] to 9
set A [ " A " ] to 10
set A [ " B " ] to 11
set A [ " H " ] to 12
read S [ 1 ] , S [ 2 ] , S [ 3 ]
for i = 1 to 3 inclusive
for j = 1 to 3 inclusive
for k = 1 to 3 inclusive
if i is not equal to j and i is not equal to k and j is not equal to k
assign A [ S [ i ] ] to I
assign A [ S [ j ] ] to J
assign A [ S [ k ] ] to K
if jarak ( I , K ) equals 7
if jarak ( I , J ) equals 4 and jarak ( J , K ) equals 3
print " major "
else if jarak ( I , J ) equals 3 and jarak ( J , K ) equals 4
print " minor "
print " strange "
create int n
read n
make int array a of size n
create int vector array banyakyangmilihini of size 2001
create int array inilahhasilnya of size n
for i = 0 to n exclusive
read a [ i ]
append i to banyakyangmilihini [ a [ i ] ]
make int i = 1
for k = 2000 to 0 exclusive
if banyakyangmilihini [ k ] . size ( ) is more than 0
for m = 0 to banyakyangmilihini [ k ] . size ( ) exclusive , set inilahhasilnya [ banyakyangmilihini [ k ] [ m ] ] to i
set i to i + banyakyangmilihini [ k ] . size ( )
for k = 0 to n exclusive
if k is equal to 0
print inilahhasilnya [ k ]
else do
print " " , and inilahhasilnya [ k ]
print new line
MAX_N = const int with MAX_N = 2000
in function solve
s , u = string
read s then u
n = int with n = size of s
m = int with m = size of u
mierda = string with mierda = " "
append ' # ' to mierda MAX_N times
set s to mierda + s + mierda
answer = int with answer = m
for i = 0 to MAX_N inclusive
temp = int with temp = 0
for j = 0 to m
if s [ i + j ] is not u [ j ] increment temp
set answer to min of answer , temp
print answer
t = int
set t to 1
loop t times call solve
declare constant integer N = 2e6 + 123
declare constant integer INF = 1e9 + 123
declare constant integer MOD = 1e9 + 7
declare constant double EPS = 1e - 9
declare integers a , b , s
read a and b and s
if absolute value of a + absolute value of b is less than or equal to s or ( a is 0 and b is 0 )
if ( absolute value of a + absolute value of b ) % 2 is s % 2
print " Yes \ n "
else
print " No \ n "
else
print " No \ n "
declare integers t , s , x
read t and s and x
if x is t
print " YES " and newline
if x is less than t
print " NO " and newline
print " YES " and newline
else
print " NO " and newline
declare integer variables a , b , c , d , e and f
read from the input to a , b , c , d , e and f
if b * d * f is equal to 0 and a * c * e is equal to 0
if c = 0 and d ! = 0
print " Ron "
else if a = 0 and b ! = 0 and d ! = 0
print " Ron " to the output stream
else
print " Hermione "
else if b * d * f < = a * c * e
print " Hermione " to the stdout
else
print " Ron " to the standard output
N = static const int with N = 1005
n , m = int
in , out , nxt , p = int array of size N each
from = int queue
to = int queue
len = int queue
read n then m
for i = 1 to m inclusive
a , b , c = int
read a then b then c
increment out [ a ] then increment in [ b ]
set nxt [ a ] to b
set p [ a ] to c
cnt = int with cnt = 0
for i = 1 to n inclusive
if not in [ i ] and out [ i ]
now , _min = int with now = i and _min = p [ now ]
push now to from
loop while out [ now ]
set _min to min of _min , p [ now ]
set now to nxt [ now ]
increment cnt
push now to to
push _min to len
print cnt
loop while from is not empty
print front of from and front of to and front of len
pop from then pop to then pop len
n , i , j , m = integers , a = 2D array of integers , size 2010x3
read n
for i = 0 to n exclusive
read m
set a [ i ] [ 0 ] to m
set a [ i ] [ 1 ] to i
for i = 0 to n exclusive
for j = i + 1 to n exclusive
if a [ i ] [ 0 ] < a [ j ] [ 0 ]
tmp = integer set to a [ i ] [ 0 ]
set a [ i ] [ 0 ] to a [ j ] [ 0 ]
set a [ j ] [ 0 ] to temp
set temp to a [ i ] [ 1 ]
set a [ i ] [ 1 ] to a [ j ] [ 1 ]
set a [ j ] [ 1 ] to temp
if a [ i ] [ 0 ] is a [ j ] [ 0 ]
if a [ i ] [ 1 ] > a [ j ] [ 1 ]
temp = integer set to a [ i ] [ 0 ]
set a [ i ] [ 0 ] to a [ j ] [ 0 ]
set a [ j ] [ 0 ] to temp
set temp to a [ i ] [ 1 ]
set a [ i ] [ 1 ] to a [ j ] [ 1 ]
set a [ j ] [ 1 ] to temp
set a [ 0 ] [ 2 ] to 1
for i = 1 to n exclusive
if a [ i ] [ 0 ] is a [ i - 1 ] [ 0 ]
set a [ i ] [ 2 ] to a [ i - 1 ] [ 2 ]
else
set a [ i ] [ 2 ] to i + 1
for i = 0 to n exclusive
for j = i + 1 to n exclusive
if a [ i ] [ 1 ] > a [ j ] [ 1 ]
temp = integer set to a [ i ] [ 1 ]
set a [ i ] [ 1 ] to a [ j ] [ 1 ]
set a [ j ] [ 1 ] to temp
set temp to a [ i ] [ 0 ]
set a [ i ] [ 0 ] to a [ j ] [ 0 ]
set a [ j ] [ 0 ] to temp
set temp to a [ i ] [ 2 ]
set a [ i ] [ 2 ] to a [ j ] [ 2 ]
set a [ j ] [ 2 ] to temp
print a [ 0 ] [ 2 ]
for i = 1 to n exlusive , print " " , a [ i ] [ 2 ]
set f [ 11 ] [ 11 ] to all 0
create int n
read n
while n > 0
decrement n
p [ 10 ] to all 0
for i = 0 to 8 exclusive , read p [ i ]
create int x1 , y1 , x2 , y2 , set s to 0
for i = 0 to 8 exclusive
for j = 0 to 8 exclusive
set p [ i ] [ j ] = K
increment s
if s = 1
set x1 to j and y1 to i
else
x2 = j
y2 = i
Y = abs of y1 - y2
int X = abs ( x1 - x2 )
if Y % 4 = 0 and X % 4 = 0
print YES
else if Y and X mod 2 = 0
if X and Y = 0
print YES
else
print NO
else
print NO
print a newline
let dx be an array with elements as 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1
let dy be an array with elements as 1 , 0 , - 1 , 0 , 1 , - 1 , 1 , - 1
let fast be a void function
call fast function
let n , m be integers
read n , m
while n is true
for character c = a to ( a + m - 1 ) and n inclusive , print c , n is decremented by 1
print newline
create long long ints n and i
read from the input to n
if n < = 3
print " NO \ n " to the output
else
print " YES \ n "
if n is even
print " 1 * 2 = 2 \ n2 * 3 = 6 \ n6 * 4 = 24 \ n "
else
print " 2 - 1 = 1 \ n1 + 3 = 4 \ n4 * 5 = 20 \ n20 + 4 = 24 \ n "
let t , s , x be long integers
read t , s , x
if t is equal to x
print YES
print newline
if t is equal to x - 1
print NO
print newline
let l , r , m be long integers with l = 0 , r = x
while l < = r
m is equal to ( l + r ) / 2
let long integer value of a = t + s * m
if a is equal to x or a + 1 is equal to x
print YES
print newline
if a is greater than x
r is equal to m - 1
l is equal to m + 1
print NO
print newline
a , b = long long
loop while reading a then b
s = string
x , y = long long with x = 0 and y = 0
read s
i = long long
for i = 0 to size of s
if x is a and y is b break
if s [ i ] is ' L ' decrement x
if s [ i ] is ' R ' increment x
if s [ i ] is ' U ' increment y
if s [ i ] is ' D ' decrement y
j = long long
if i is size of s
for j = 0 to size of s
if s [ j ] is ' L ' increment a
if s [ j ] is ' R ' decrement a
if s [ j ] is ' U ' decrement b
if s [ j ] is ' D ' increment b
if a and b are both 0 break
da = long long with da = absolute of a
db = long long with db = absolute of b
dx = long long with dx = absolute of x
dy = long long with dy = absolute of y
if a as long long * y is b as long long * x and a as long long * x > = 0 and b as long long * y > = 0
if a and b are both not 0
if dx and dy are both not 0
if da is a multiple of dx and db is a multiple of dy break
else if a is not 0 and b is 0
if dx is not 0
if dy is 0 and da is a multiple of dx break
else if a is 0 and b is not 0
if dy is not 0
if dx is 0 and db is a multiple of dy break
if j is not size of s
print " Yes "
else
print " No "
else
print " Yes "
str2num is a integer function with string reference argument & s
create new stringstream ss from s
ret is a new integer variable
read ss into ret
return ret
boolean function valid with string reference argument & s
create new integer variable n
if s [ 0 ] is equal to ' 0 ' , return true if n = 1 or false otherwise
if length of s is greater than 7 , return false
create new integer x = str2num ( s )
return true if x < = 1000000 or else otherwise
declare new string variable s
read user input to s
create integer variable with name n
in a for loop , change a from 1 to n inclusive
start for loop from b = 1 to n inclusive
create integer c = n - a - b
if c is greater than 0
print ret
define 100 , 005 - element int array b
define int array c of 100 , 005 elements
define 100 , 000 - element int arrays u and v
define 100005 - element int array d
define int n
read into n
define integer k , set to 0
zero out entire c
zero out entirety of d
for int i from 0 to n ^ 2 ( exclusive ) by 1 , read u [ i ] and v [ i ]
for int i from 0 to n * n ( exclusive ) by 1
if b [ u [ i ] ] is 0 and c [ v [ i ] ] is 0
set d [ k ] to i + 1 and then increment k
set b [ u [ i ] ] to 1
assign 1 to c [ v [ i ] ]
for int i from 0 to k - 1 ( exclusive ) by 1 , print d [ i ] and " "
print d [ k - 1 ] and newline
mpu = map from char to char
vec = array of 26 vector to long long
a and b = array of 1000006 int
visit = array of 1000006 bool
n = long long
s , p = string
read s , p
in = array of 26 long long
for i = 0 to 26 exclusive in [ i ] = - 1
n = size of s
for i = 0 to n exclusive
r = s [ i ] - ' a '
put i at end of vec [ r ]
val = - 1
sum = 1
for i = 0 to size of p exclusive
r = p [ i ] - ' a '
if size of vec [ r ] < = 0
print - 1
increment in [ r ]
if in [ r ] < size of vec [ r ]
u = false
while vec [ r ] [ in [ r ] ] < = val and in [ r ] < size of vec [ r ]
increment in [ r ]
if in [ r ] > = size of vec [ r ]
increment sum
u = 1
for kk = 0 to 26 exclusive
in [ kk ] = - 1
val = - 1
break
if u is 0
val = vec [ r ] [ in [ r ] ]
increment i
else
increment sum
for kk = 0 to 26 exclusive in [ kk ] = - 1
val = - 1
print sum
MX = const int with MX = 1e3 + 5
d = int , int pair array of size MX
n , s , a , b , f = long long with f = 0
r = string array of size 2 with values " YES " , " NO "
read s then n
for i = 0 to n
read a then b
set d [ i ] to make_pair of a , b
sort d from index 0 to n
for i = 0 to n
if s > d [ i ] . first
increment s by d [ i ] . first
else
set f to 1
break
print r [ f ]
in void function read taking x = int address
set x to 0
ch = get char = char
f = 1 = int
for , c isn ' t digit , get char c
if c = ' - ' then set f to - f
for , ultil c is digit , get char c , set x = x * 10 + c - ' 0 '
multiply x by f
in void function read2 taking x , y = int address
call read on x , call read on y
in void function read3 taking x , y , z = int addresses
call read on x , call read on y , call read on z
let l1 , r1 , l2 , r2 , k be long long
get form input l1 , r1 , l2 , r2 , k
ans = 0 = long long
if l2 > r1 or r2 > l1
return 0
set l1 to the max between l1 and l2
set r1 to the min between r1 and r2
set ans to r1 - l1 + 1
if k is between l1 and r1 both inclusive then decrement ans
print ans
q , ok , c = long long with c = 1
read q
u = long long with u = q
for j = 2 to sqrt of q  1 inclusive
if q is a multiple of j
loop while q is a multiple of j
set q to q / j
increment ok
if ok < = 2 set c to c * j
if ok is 2 break
if q > 1 increment ok
if ok < = 1 print " 1 " and " 0 "
if ok is 2 print " 2 "
if ok > = 3 print " 1 " and c
s = char array of size 5500
read s
l = int with l = strlen of s
flag , a , b , c , flag1 = int with flag = 0 and a = 0 and b = 0 and c = 0 and flag1 = 0
for i = 0 to l
if s [ i ] is ' a '
increment a
if flag or flag1 is 1
print " NO "
if s [ i ] is ' b '
increment b
set flag to 1
if flag1 is 1
print " NO "
if s [ i ] is ' c '
increment c
set flag1 to 1
if a or b is 0
print " NO "
if c is a or b
print " YES "
else
print " NO "
create string s and t
create int l1 and l2
create int p [ 10001 ] [ 26 ]
while read s and t
set l1 to size of s
assign size of t to l2
set p to all 0
for i = 0 to 26 exclusive , p [ l1 ] [ i ] = - 1
for j = l1 to 1 inclusive
for i = 0 to 26 exclusive
if s [ j ] = i + a
assign j to p [ j - 1 ] [ i ]
else
set p [ j - 1 ] [ i ] = p [ j ] [ i ]
set ans to 1 and l to - 2
for i = 0 to l2 exclusive
if l = - 2
if s [ 0 ] = t [ i ]
assign 0 to l
else
set l to p [ 0 ] [ t [ i ] - a ]
if l equal to - 1
set ans to - 1
break
else
set l = p [ l ] [ t [ i ] - a ]
if l equal to - 1
increment ans
set l to - 2
decrement i
print ans
declare character array a1 size 100000000
read string into a1
declare integers n = 0 , i = 0 , e = 0 , t = 0
for j = 0 to string length of a1 exclusive
if a1 [ j ] is ' n '
increment n
else if a1 [ j ] is ' i '
increment i
else if a1 [ j ] is ' e '
increment e
else if a1 [ j ] is ' t '
increment t
print minimum of ( ( n - 1 ) / 2 and minimum of ( i and minimum of ( e / 3 and t ) ) ) and newline
boolean function if_prime with int argument a
return false if a is less than 2
create integer variable with name flag and value = 1
for i = 2 to a exclusive
if a modulo i = 0
assign 0 to flag
break the loop
if flag is equal to 0
return false
else
return true
n is a new integer variable
read standard input to n
new integer m with value 1
create new integer ans with value n * m + 1
while if_prime ( ans ) is true
increment m
change ans to n * m + 1
print m
int function f with int arguments a and b
define new integer called x1 = a / 10
declare new integer called x2 with value a % 10
create new integer x3 = b / 10
declare new integer variable x4 = b % 10
if x1 = x4 and x2 = x3 , return 1
declare new int variables a and b
define character s
read a , s and b from the input
if f ( a , b ) returned 1
print " 0 "
else
increment i in a loop starting from 1
if b + 1 = 60 and a < 23
assign the new value = 0 to b
increase a by 1
else if a = 23
if b is greater than 32
print 60 - b
break the loop
else
increment b
else
increment b
if the value , returned from f ( a , b ) , is 1
print i
break the loop
f , ans = strings with f = array of size 111
n = integer
read n
for i = 0 to n exclusive
read f [ i ]
s , t = strings with t = " "
read s
for i = 0 to s . size ( ) exclusive , t = t + tolower ( s [ i ] )
ans = t
c = character
read c
for i = 0 to t . size ( )
for j = 0 to n exclusive
if ( i > = f [ j ] . size ( ) )
sub = string with sub = t . substr ( i - f [ j ] . size ( ) , f [ j ] . size ( ) )
if ( sub is f [ j ] )
for l = i - f [ j ] . size ( ) to i exclusive
if ( t [ l ] is c and c is not a )
ans [ l ] = a
else if ( t [ l ] is c and c is a )
ans [ l ] = b
else
ans [ l ] = c
for i = 0 to s . size ( ) exclusive
if ( isupper ( s [ i ] ) ) , ans [ i ] = toupper ( ans [ i ] )
print ans
defin long long variables t , s and x
read user input to t , s and x
if x is less than t , return cout < < " NO " < < ' \ n ' , 0
if x - 1 = t , return cout < < " NO " < < ' \ n ' , 0
print " NO " and ' \ n '
let j1 = array of integers with size = 300
let s1 = string
let yy = array of characters with values A , E , O , U , I , Y
let i , j , n , k , ans = integers with k = 0 and ans = - 1
read s1
set n = size of s1
set s1 [ n ] = P
for i = 0 to n inclusive do the following
increment j1 [ k ]
if j1 [ k ] is greater than ans set ans = j1 [ k ]
for j = 0 to 6 exclusive do the following
if s1 [ i ] is yy [ j ] do the following
increment k
exit the loop
print ans
empty void function init_ios
declare new long long constant N = 1e5 + 10
declare new long long variables n , d and res , and an array of long longs a with N elements
call init_ios ( )
read n and d from the input
read input into a from the index i to n inclusive
create long long variable j = 3
for i = 1 while i + 2 < = n
change the value of j to max of j and i + 2
while j < = n and a [ j ] - a [ i ] < = d
decrement j
add ( ( j - i - 1 ) * ( j - i ) ) / 2 to res
print res and " \ n " to the standard output
a = int array size 150
t , s , x , f = int , f = 0
read t , s , x
let x = x - t
if remainder of x / s = 0 or 1 , let f = 1
if x = 1 or x < 0 , let f = 0
if f = 1
else
num = array of boolean values of length 6667
s = array of characters of length 3
memset of num , 0 , length of num
let n be a integer
read n
the integer value of count = 0
for i = 0 to n exclusive
let a , b be integers
read a
read b
b is equal to b modulo 10 * 10 + b / 10
if num [ a * 100 + b ] equals 0
increment count by 1
the integer value of tmp = a * 100 + b
num [ tmp ] is equal to 1
for j = 0 to 3 exclusive
tmp is equal to tmp modulo 10 * 1000 + tmp / 10
num [ tmp ] is equal to 1
if i is not equal to n - 1 , read s
print count and new line
s = string
read s
h = integer = ( s [ 0 ] - 0 ) * 10 + ( s [ 1 ] - 0 )
m = integer = ( s [ 3 ] - 0 ) * 10 + ( s [ 4 ] - 0 )
indefinite while loop
if m is 59
m = 0
if h is 23
h = 0
else
increase h by 1
else
increase m by 1
if h / 10 is m modulo 10 and h modulo is m / 10
print the result of h / 10 , the result of h modulo 10 , : , the result of m / 10 , the result of m modulo 10
declare constant integer INF = 10000000
declare integers n , m , a , b , ans1 = INF , ans2 = INF
read n , m , a , b
declare integer row1 = ( a - 1 ) / m
declare integer row2 = ( b - 1 ) / m
declare integer col1 = m if a % m is 0 , else a % m
declare integer col2 = m if b % m is 0 , else b % m
if row1 is row2
let ans1 be 1
else if row2 - row1 is 1
let ans1 be 2
if col1 is 1 and b is n
let ans1 be 1
else if col1 is 1 and col2 is m
let ans1 be 1
else
let ans1 be 3
if b is n or col2 is m , decrement ans1
if col1 is 1 , decrement ans1
let ans2 be 3
if col1 - 1 is col2 , decrement ans2
print minimum of ans1 and ans2 , newline
end statement
let n , cnt be integers
let x1 , y1 , x2 , y2 , a , b , c , l1 , l2 be long integers
while read x1 , y1 , x2 , y2 , n
cnt is equal to 0
while n is decremented by 1
read a , b , c
l1 = a * x1 + b * y1 + c
l2 = a * x2 + b * y2 + c
if l1 is greater than 0 and l2 is less than 0 or l1 is less than 0 and l2 is greater than 0 , increment cnt by 1
print cnt and newline
create long long n , amigos , coins , min
read n , amigos , coins , min
i amigos > n or coins > n - min or min > n
print - 1
else
x = ( min + coins ) / amigos
if ( min + coins ) % amigos = 0
if amigos * x < = n
print x
else
print - 1
else
if amigos * ( x + 1 ) < = n
print x + 1
else
print - 1
s , n = long integer
read n , s
dollar = long integer array of size n
cent = long integer array of size n
for i = 0 to n exclusive ,
cent [ i ] = - 4
dollar [ i ] = - 4
d , c = integers
k = integer with k = 0
y = integer with y = 0
for i = 0 to n exclusive
read d , c
if ( d < s )
dollar [ k ] = d
cent [ k ] = c
increment k
else if ( d is s and c is 0 )
dollar [ k ] = d
cent [ k ] = c
increment k
pairt = array of pair of long int to long int of size k
for i = 0 to k exclusive
pairt [ i ] of first = cent [ i ]
pairt [ i ] of second = dollar [ i ]
sort pairt and pairt + k
for i = 0 to k exclusive
cent [ i ] = pairt [ i ] of first
dollar [ i ] = pairt [ i ] of second
flag = integer with flag = 0
i = long integer with i = 0
for i = 0 to k exclusive
if ( cent [ i ] > 0 )
print ( 100 - cent [ i ] )
flag = 1
break loop
if ( cent [ 0 ] is 0 and flag is 0 )
flag = 1
if ( flag is 0 ) print - 1
declare ints h and m
c is a new character
read h , c and m from the user input
create new integer variable rh = ( h % 10 ) * 10 + h / 10
create integer variable res = 0
in a for loop , change rh to ( h % 10 ) * 10 + h / 10 while rh ! = m
add 1 to m
increase res by 1
if m is equal to 60
assign the new value = 0 to m
increment h
if h = 24 , assign 0 to h
print res
create const long double pi = 3 . 1415926535
make long long integer t
make string s
read s
create long long integer a = ( s [ 0 ] - ' 0 ' ) * 10 + ( s [ 1 ] - ' 0 ' )
make long long b = ( s [ 3 ] - ' 0 ' ) * 10 + ( s [ 4 ] - ' 0 ' )
make bool flag = 0
create long long integer cnt = 0
while flag is not equal to 1
if ( a / 10 is equal to b % 10 ) and ( a % 10 is equal to b / 10 )
print cnt
increment cnt
increment b
if b is equal to 60
set b to 0
increase a by 1
if a is 24 , set a to 0
s = string
freq = int arary sze 26
n = int
read s
read n
distinct = int , distinct = 0
for int i = 0 to s [ i ]
if freq [ s [ i ] - a ] = 0 , add one to distinct
add one to freq [ s [ i ] - a ]
if distinct > n
print - 1
else
sheets = int , sheets = 1
while true
chrs = int , chrs = 0
for int i = 0 to 26 , add ( freq [ i ] + sheets - 1 ) / sheets to chrs
if chrs < = n , exit while loop
add one to sheets
t = int , t = 0
for int i = 0 to 26
x = int , x = ( freq [ i ] + sheets - 1 ) / sheets
add x to t
while x > 0 , print i + a in char format
while t < 0 , print a
new line
n , total , input , Smith , cou = integers with Smith = 0 , cou = 1
read n
for i = 1 to n
total = 0
for j = 1 to 4
read input
total = total + input
if ( i is 1 )
Smith = total
else
if ( total > Smith ) , increment cou
print cou
set ans = 0 , i = 0 , j = 0 , cnt = 0 , sum = 0
create long long arr [ 100001 ]
create long long brr [ 100001 ]
t = 1
while decrement t
create long long n , set w and b to 0
read n
create long long x , y
read x and y
if x = y
if x = 1
print White
print a newline
return 0
else if x = n
print Black
print a newline
return 0
set w to x - 1 + x - 1
b = n - x + n - x
else
set w = x - 1 + y - 1
assign n + n - x - y to b
decrement w
if w < = b
print White
print a newline
else
print Black
print a newline
create string str
declare check with integer p as argument , returning boolean
create character set se
remove all elements from se
insert str [ p ] into se
insert str [ p + 1 ] into se
insert str [ p - 1 ] into se
insert ' . ' into se
if size of se is 4 , return true from function
return false from function
read str
for i = 1 to i + 1 is less than size of str
if result of run check with i as argument is true
print " Yes " print newline
print " No " print newline
n is a new integer variable
read user input to n
declare integer variable sq = square root of ( n * 2 )
in a for loop , change i from 1 to sq inclusive incrementing i
for j from 1 to i inclusive incrementing j
if i * i + i + j * j + j = n * 2
print " YES "
print " NO " to the standard output
create ints n , m , i , and k = - 1
let strings s , t , and s2
read n , m , s , and t
for i = 0 to n exclusive
if s [ i ] is equal to ' * '
set k to i
break loop
if k is equal to - 1 and s is not equal to t or if n - 1 is more than m , print " NO " and return 0
set s2 to s . substr ( k + 1 )
set n to s2 . size ( )
print " YES "
v = vector of long long
add 4 at end of v
add 7 at end of v
l = 4444444444 , a , x , y = int , c = 0
i = 0 , j , z = int
while last item of v < l
a = v [ i ] , increment i
add a * 10 + 4 at end of v
add a * 10 + 7 at end of v
read x , y
i = index of x in v - first item of v
j = index of y in v - first item of v
z = x
while i < j
add v [ i ] * ( v [ i ] - z + 1 ) to c
z = v [ i ] + 1 , increment i
add v [ j ] * ( y - z + 1 ) to c
print c
create integer vector array vec with size 3
create map like from string to integer
create integers diff , ans , a , b , c , create 2d integer array mat with size 10 by 10
declare cal
create integers sum , i , j , k , with sum = 0
for i = 0 to 3 exclusive
for j = 0 to integer casted size of vec [ i ]
return sum from function
declare count with integer now as argument , returning void
if now is 7
if size of vec [ 0 ] and size of vec [ 1 ] and size of vec [ 2 ]
sort elements from x to x + 3
if x [ 2 ] - x [ 0 ] is less than diff
set diff to x [ 2 ] - x [ 0 ]
set ans to result of run cal
else if x [ 2 ] - x [ 0 ] is diff
set ans to maximum of ans and result of run cal
return from function
for i = 0 to 3 exclusive
add element now to end of vec [ i ]
run count with now + 1 as argument
remove last element from vec [ i ]
set like [ " Anka " ] to 0
set like [ " Chapay " ] to 1
set like [ " Cleo " ] to 2
set like [ " Troll " ] to 3
set like [ " Dracul " ] to 4
set like [ " Snowy " ] to 5
set like [ " Hexadecimal " ] to 6
create integers n , i
create strings name1 , str , name2
while read n is true
set diff to ( 1 bitshift left 31 ) - 1
for i = 0 to 3 exclusive , remove all elements from vec [ i ]
set bytes from mat to size of mat to value 0
for i = 0 to n exclusive
read name1 read str read name2
increment mat [ like [ name1 ] ] [ like [ name2 ] ]
read a read b read c
run count with 0 as argument
print diff print " " print ans print newline
s , v = string
read s then v
if size of s is not size of v
print " NO "
else
at , at2 = int with at = - 1 and at2 = - 1
for len = size of s , i = 0 to len
if s [ i ] is not v [ i ]
if at is - 1
set at to i
else
if at2 is - 1
set at2 to i
if s [ at ] is not v [ at2 ] or s [ at2 ] is not v [ at ]
print " NO "
else
print " NO "
if at is - 1 print " YES " else if at2 is - 1 print " NO " else print " YES "
return true bitwise - and false
let INF be an int const = 0x7fffffff
let inf be an int const = 0x3f3f3f3f
maxn = 200005 = int const
N = 105 = const int
in inline void read that takes an int address x
let f = 1 be int
set x to 0
let s be a char = getchar
while s < ' 0 ' or s > ' 9 '
if s is ' - ' then set f to - 1
set s to getchar ( )
while s > = ' 0 ' and s < = ' 9 '
set x to x * 10 + s - ' 0 '
read s
multiply x by f
let a , b , c , d , k be long long
read b , a , d , c
for i = 0 to 100 inclusive
for j = 0 to 100 inclusive
if a + i * b = c + j * b
print a + i * b and new line
print - 1
n , x , y = long long
read n and x and y
if x + y < = n + 1
print " White "
else
print " Black "
create int n
read n
create string s
read s
create vector int v
for i = 0 to n exclusive
if s [ i ] = C
assign 1 to last element of v
else if s [ i ] = Y
assign 3 to last element of v
else if s [ i ] equal to M
assign 2 to last element of v
else
count = 0
while s [ i ] = ?
increment i
add 1 to count
decrement i
assign - count to last element of v
assign 1 to b
for i = 1 to n exclusive
if s [ i - 1 ] = s [ i ] and s [ i ] different from ? , set b = 0
assign 0 to count
for i = 1 to size of v - 1 exclusive ,
if v [ i ] < 0 and v [ i - 1 ] = v [ i + 1 ]
increment count
else if v [ i ] < - 1 and v [ i - 1 ] different from v [ i + 1 ]
add 1 to count
if v [ 0 ] less than 0 , count = count + 1
if v [ size of v - 1 ] less than 0 , increment count
if b = 0 or count = 0
else
create char arrays f and ff with 1005 elements
create ints n and k
read f from the input
read user input to k
change n to length of f
if n modulo k is not 0
print " NO "
declare new integer a with value n / k
create new integer variable p = - 1
create new integer flag with value 1
while p is not equal to n - 1
for integer i = 0 to a exclusive
increment p by one
change the value of ff [ i ] to f [ p ]
declare integer variable with name flagg = 1
declare new integer variables b = 0 and e = a - 1
while b < = e
if ff [ b ] ! = ff [ e ]
change flagg to 0
break
increment b by one
decrement e
if flagg is equal to 0
change flag to 0
break
if flag is true
print " YES " to the stdout
else
print " NO " to the output stream
mod = long long with mod = 1000000007
a , b , x , y = long long
read a , b , x , y
ans = long long with ans = 0
n , n1 = long long
read n
n1 = n
while decrement n1
a1 , b1 , c1 = long long
read a1 , b1 , c1
d1 = long long with d1 = ( a1 * a ) + ( b1 * b ) + c1
d2 = long long with d2 = ( a1 * x ) + ( b1 * y ) + c1
if ( ( d1 > = 0 and d2 > = 0 ) or ( d1 < 0 and d2 < 0 ) ) , increment ans
print n - ans
x , y , n = long long
read n
read x then y
w_x , w_y = long long with w_x = 1 and w_y = 1
b_x , b_y = long long with b_x = n and b_y = n
if b_x is x and b_y is y
print " Black "
else if w_x is x and w_y is y
print " White "
else if w_step is b_step
print " White "
else if w_step < b_step
print " White "
else if b_step < w_step
print " Black "
let n , L and a be long long integers
let t be an array of long long integers of size 100001 , let l be an array of long long integers of size 100001
read in n , L and a
read in values for t [ i ] and l [ i ] n times
set t [ 0 ] to 0
set l [ 0 ] to 0
let cnt be a long long integer and set its value to 0
for i = 0 to i < = n
set L to L - ( t [ n ] + l [ n ] )
add L / a to cnt
print cnt
INF = const int with INF = 0x3f3f3f3f
n = int
read n
row = int array of size n + 10
ans = long long array of size n + 10
for i = 1 to n inclusive read row [ i ]
for i = 1 to n inclusive
cont = long long with cont = 1
j = int with j = row [ i ]
loop while cont is less than 103 and j is not i
increment cont
set j to row [ j ]
set ans [ i ] to cont
if ans [ i ] is event then set ans [ i ] to ans [ i ] / 2
mult = long long with mult = ans [ 1 ]
for i = 1 to n inclusive
if ans [ i ] is 103
print - 1
set mult to ( mult * ans [ i ] ) / __gcd of mult and ans [ i ]
print mult
n , b , l = integers with l = 0
Read n
for i = 0 to n exclusive
Read b
if b is 0 , then increment l
if l is 1 and n is not 1 OR n is 1 and l is 0
print YES and a new line
print NO and a new line
a = string
loop while reading a
num_a , num_b , num_c = int with num_a = 0 and num_b = 0 and num_c = 0
la = int
fb = int with fb = - 1
lb = int with lb = - 1
lc = int with lc = - 1
for i = 0 to size of a
if a [ i ] is ' a '
increment num_a
set la to i
else if a [ i ] is ' b '
if fb is - 1 set fb to i
increment num_b
set lb to i
else if a [ i ] is ' c '
if lc is - 1 set lc to i
increment num_c
if not ( fb > la ) or not ( lc > lb )
print " NO "
else
if num_c is not num_b and num_c is not num_a
print " NO "
else
print " YES "
create long long ints a , b , a2 , b2 , k and t
read a , b , a2 , b2 and k from the input
assign min of b and b2 ) - max of a and a2 + 1 to t
decrement t by one if k < = min of b and b2 and k > = max of a and a2
if t is less than 0 , change t to 0
print t
let n and ans be integers where ans = 1
read user input to n
print n / 2
start for loop from i = 1 to n / 2 - 1 inclusive and print 2 and " " on each iteration
if n is even
print 2 to the standard output
else
print 3
n = long long and h , a , x , y = long long array of size 2 each
vis = two dimensional long long array of sizes 1000001 and 2
b = long long vector array of size 2
ans = two dimensional long long array of sizes 2 and 2
val = two dimensional long long array of sizes 1000001 and 2
in function pass taking a long long i and returning a long long
set vis [ h [ i ] ] [ i ] to 1
set val [ h [ i ] ] [ i ] to 1
va = long long with va = 2
append h [ i ] to b [ i ]
loop while vis [ h [ i ] ] [ i ] is 1
set h [ i ] to ( x [ i ] * h [ i ] + y [ i ] ) mod m
append h [ i ] to b [ i ]
if vis [ h [ i ] ] [ i ] is 0
increment vis [ h [ i ] ] [ i ]
set val [ h [ i ] ] [ i ] to va
increment va
else
set ans [ i ] [ 0 ] to val [ h [ i ] ] [ i ] - 1
set ans [ i ] [ 1 ] to va - val [ h [ i ] ] [ i ]
call pass of 0
call pass of 1
if vis [ a [ 0 ] ] [ 0 ] or vis [ a [ 1 ] ] [ 1 ] is 0
print - 1
va1 , va2 = long long with va1 = val [ a [ 0 ] ] [ 0 ] and va2 = val [ a [ 1 ] ] [ 1 ]
cy1 , cy2 = long long with cy1 = ans [ 0 ] [ 1 ] and cy2 = ans [ 1 ] [ 1 ]
if val [ a [ 0 ] ] [ 0 ] is val [ a [ 1 ] ] [ 1 ]
print val [ a [ 0 ] ] [ 0 ] - 1
print - 1
mo = long long with mo = absolute of val [ a [ 1 ] ] [ 1 ] - val [ a [ 0 ] ] [ 0 ]
if mo is a multiple of ans [ 1 ] [ 1 ]
print val [ a [ 0 ] ] [ 0 ] - 1
else
print - 1
if mo is a multiple of ans [ 0 ] [ 1 ]
print val [ a [ 1 ] ] [ 1 ] - 1
else
print - 1
else
print - 1
if absolute of va1 - va2 mod __gcd of cy1 and cy2 is not 0
print - 1
for i = 0 to 1000001
va = long long with va = va1 - va2 + i * cy1
if va is a multiple of cy2 and va is greater or equal to 0
print va1 + i * cy1 - 1
inf = constant integer = 1e15
M = constant integer = 1e9 + 7
arr = integer array of size 5000000
n = integer
read n
for i = 0 to n exclusive , then read a [ i ]
sort a in ascending order
i = country = integer = 0
for j = 0 to n exclusive , increase j at the start of the loop
if arr [ i ] < arr [ j ]
increase county by 1
increase i by 1
print county
declare long longs n , m , k , a
read n and m and k
declare minn = 20000000000 as long long
for i = 0 to n exclusive
read a
if i % 2 is 0 , let minn = minimum of a and minn
if n % 2
if n / 2 + 1 is less than or equal to m
declare long long x = n / 2 + 1
let x be m / x * k
print ( x if x is less than minn , else minn ) and newline
else
print 0 print newline
else
print 0 print newline
declare integer array tab size 55 by 55
declare integer array vis size 55 by 55
declare integers n , m
declare czysc with no arguments , returning void
for i = 1 to n inclusive
for j = 1 to m inclusive , let vis [ i ] [ j ] be 0
return from function
declare dfs with integers i , j as arguments , returning void
let vis [ i ] [ j ] be 1
if tab [ i + 1 ] [ j ] is 1 and vis [ i + 1 ] [ j ] is 0 , run dfs ( i + 1 and j )
if tab [ i - 1 ] [ j ] is 1 and vis [ i - 1 ] [ j ] is 0 , run dfs ( i - 1 , j )
if tab [ i ] [ j + 1 ] is 1 and vis [ i ] [ j + 1 ] is 0 , run dfs with i , j + 1 as arguments
if tab [ i ] [ j - 1 ] is 1 and vis [ i ] [ j - 1 ] is 0 , run dfs ( i , j - 1 )
return from function
declare character c
read n , m
declare integers licz = 0
for i = 1 to n inclusive
for j = 1 to m inclusive
read c
if c is ' # '
let tab [ i ] [ j ] be 1
increment licz
if licz is less than 3
print " - 1 " and newline
declare integers wynik = 5
declare integer akt
declare integer odw
for i = 1 to n inclusive
for j = 1 to m inclusive
if tab [ i ] [ j ] is 1
let akt be 0
if akt is 1
print " 1 " and newline
else
run czysc
let tab [ i ] [ j ] be 0
if tab [ i + 1 ] [ j ] is 1
run dfs with i + 1 , j as arguments
else
if tab [ i - 1 ] [ j ] is 1
run dfs ( i - 1 , j )
else
run dfs ( i , j + 1 )
let tab [ i ] [ j ] be 1
if odw is less than akt
print " 1 " and newline
print " 2 " and newline
create long long x and y
read x , y
set awalz , awaly , and and cnt to 0
add = 1
while awalx different from x and awaly different from y
if cnt mod 4 = 0
for i = 0 to add exclusive
increment awalx
if awalx = x and awaly = y , break
if cnt mod 4 = 1
for i = 0 to add exclusive
add 1 to awaly
if awalx = x and awaly = y , break
increment add
if cnt mod 4 = 2
for i = 0 to add exclusive
decrement awalx
if awalx = x and awaly = y , break the loop
if cnt mod 4 = 3
for i = 0 to add exclusive
decrement awaly
if awalx = x and awaly = y , break the loop
add 1 to add
if awalx = x and awaly = y , break
increment cnt
increment ans
print ans
declare const int M = 100 + 10
cal_digit is a int function with long long int argument x
declare int num = 0
while x > 0
increment num
set x to x / 10
return num
long long int function cal_equaltod with int argument d
create long long int ans = 0
if d = 1 , assign 9 to ans
if d = 2 , assign 9 to ans
if d is greater than 2
create long long int num = 1
loop i from 0 to d - 2 exclusive , change num to 10 * num
change ans to 9 * num
return ans
cal_largerthanorequaltox is a long long int function with int argument d and long long int argument x
declare long long int variable ans = 0
if d = 1 , change ans to 9 - x + 1
if d is equal to 2
declare int id0 = x % 10
declare integer id1 = x / 10
if id1 > = id0
set ans to 9 - id1 + 1
else
set ans to 9 - id1
if d is greater than 2
declare long long int variable d10 = 1
for i from 1 to d - 2 inclusive , set d10 to d10 * 10
declare int id0 = x modulo 10
declare int id1 = x / 10 / d10
change ans to ans + ( 9 - id1 ) * d10
declare long long int mid = x - id1 * 10 * d10
set mid to mid / 10
if id1 > = id0
assign ans + d10 - 1 - mid + 1 to ans
else
change ans to ans + d10 - 1 - mid
return ans
create long long ints l and r
read l and r
declare integer ld = cal_digit of l
declare integer rd = cal_digit of r
declare long long int variable ans = 0
loop d from ld + 1 to rd exclusive , setting ans to ans + cal_equaltod of d
if rd is greater than ld
change ans to ans + cal_largerthanorequaltox of ld and l
declare long long int variable nxt = r + 1
declare integer nxtd = cal_digit of nxt
declare long long int variable tmp = 0
if nxtd = rd , change tmp to cal_largerthanorequaltox of rd and r + 1
set ans to ans + cal_equaltod of rd - tmp
if rd is equal to ld
create long long int nxt = r + 1
declare integer variable nxtd = cal_digit ( nxt )
declare long long int tmp = 0
if nxtd is equal to rd , set tmp to cal_largerthanorequaltox ( rd , r + 1 )
set ans to ans + cal_largerthanorequaltox ( ld , l ) - tmp
print ans
create string variable with name s
read s from the input
create a map from characters to integers called mp
for integer i = 0 to length of s exclusive , increment mp [ s [ i ] ]
create integer variable called mx and set it ' s value to the min of mp [ ' i ' ] and mp [ ' t ' ]
assign the new value = min of mx and mp [ ' e ' ] / 3 to mx
declare integer variable keep with value mp [ ' n ' ]
create integer peek with value = keep / 2
if keep is even , decrement peek by one
set mx to min of mx and peek
change mx to max of 0 and mx
print mx to the standard output
declare long longs ml = 0 and md = 10e10
create vector of ints team with 7 elements filled with 0
create map of string to int called hashi
create map of int / int pairs to bool called likes
create vector of long long called xp with 3 elements
tri is a void function with int argument i
if i is equal to 7
create long longs mie = 10e10 and mae and lik = 0
create bool can = true
for integer j = 0 to 3 exclusive
create long long co = 0
loop k from 0 to 7 exclusive
if team [ k ] is equal to j
increment co
for l = 0 to 7 exclusive
if team [ l ] = j and likes [ pair < int , int > ( k , l ) ] is true , increment lik by one
if co is equal to 0
assign false to can
break
change mie to min of mie and xp [ j ] / co
change mae to max of mae and xp [ j ] / co
if can is true
create long long dif = mae - mie
if dif = md
set ml to max of lik and ml
else if dif < md
assign dif to md
assign lik to ml
else
for integer j = 0 to 3 exclusive
set team [ i ] to j
call tri ( i + 1 )
return
declare int variable n
read input to n
assign 0 to hashi [ " Trolong long " ]
assign 1 to hashi [ " Dracul " ]
assign 2 to hashi [ " Anka " ]
assign 3 to hashi [ " Snowy " ]
assign 4 to hashi [ " Hexadecimal " ]
assign 5 to hashi [ " Chapay " ]
assign 6 to hashi [ " Cleo " ]
loop , decrementing n , while it is not 0
create strings p and q
read input to p , q and q
set likes [ pair < int , int > ( hashi [ p ] , hashi [ q ] ) ] to true
loop i from 0 to 3 exclusive , read xp [ i ]
call tri ( 0 )
print md , " " , ml and " \ n "
function read with int argument & x
declare char ch and read it from the input
create boolean f = 0
change x to 0
while ch is not a digit character
if ch = ' - ' , change f to 1
read ch from the input
while ch is a digit character
assign x * 10 + ch - 48 to x
read ch from the input
if f is true , invert the sigh of x
void function read with long long reference argument & x
declare char ch and read it from the input
create bool f = 0
change x to 0
while ch is not a digit character
if ch = ' - ' , set f to 1
read ch from the input
while ch is a digit character
set x to x * 10 + ch - 48
read ch from the input
if f is true , invert the sigh of x
create int array parent with 150001 element
declare int array ranks with size 150001
let sizeedge be long long array with size 150001
declare long long array size with size 150001
build is a void function with int argument n
for integer i = 0 to n inclusive , set parent [ i ] to i and set size [ i ] to 1LL
int function find with int argument x
return x = x = = parent [ x ] ? x : find ( parent [ x ] )
void function merge with int arguments x and y
set x to find ( x ) and set y to find ( y )
if ranks [ x ] is greater than ranks [ y ] ) swap x and y
if ranks [ x ] = ranks [ y ] , increment ranks [ y ]
if x ! = y
assign y to parent [ x ]
set size [ y ] to size [ x ] + size [ y ]
set sizeedge [ y ] to sizeedge [ x ] + sizeedge [ y ] + 1LL
else
increment sizeedge [ y ] by one
declare integers v and e
call read with argument v
call read with argument e
call build with argument v
for integer i = 0 to e exclusive
declare ints from and to
call read with argument from
call read with argument to
call merge with arguments from and to
for integer i = 1 to v inclusive
if i is equal to find ( i )
if sizeedge [ i ] ! = size [ i ] * ( size [ i ] - 1 ) / 2
print " NO "
print " YES "
declare ints ct = 0 and foo = 1
declare strings str1 and str2
create integer arrays arr1 and arr2 with size 27
read str1 and str2
declare int n1 = length of str1
declare int n2 = length of str2
if n1 ! = n2
print " NO \ n "
else
for integer i = 0 to n1 exclusive
if str1 [ i ] ! = str2 [ i ] , increment ct
loop i from 0 to n1 exclusive
declare int temp1 = str1 [ i ] - ' a '
declare int temp2 = str2 [ i ] - ' a '
increment arr1 [ temp1 ]
increment arr2 [ temp2 ]
for i from 1 to 26 inclusive
if arr1 [ i ] ! = arr2 [ i ] , set foo to 0
if ct < = 2 and foo = 1
print " YES \ n "
else
print " NO \ n "
comp is a new boolean function with long long pair arguments a and b
return true if a . first < b . first or else otherwise
create long long variable with name n
s is a new string variable
read input to n and s
create new boolean variable fl with value 0
declare new long longs cnt and flg = 0
for i from 0 to n exclusive
if s [ i ] = ' ? ' , increment cnt
in a for loop , change i from 0 to n - 1 exclusive incrementing i
if s [ i ] = s [ i + 1 ] and s [ i ] ! = ' ? ' , set fl to 1
if fl is set
print " No " and ' \ n '
else
for i = 1 to n - 1 exclusive incrementing i
if flg = cnt
print " No " and ' \ n ' to the standard output
else
print " Yes " and ' \ n '
let x1 , y1 , x2 , y2 be long integers
while read x1 , y1 , x2 , y2
let a , b , c be long integers
let n , ans be integers with ans = 0
read n
for i = 0 to n exclusive
read a , b , c
if a * x1 + b * y1 + c is less than 0 and a * x2 + b * y2 + c is greater than 0 , increment ans by 1
if a * x1 + b * y1 + c is greater than 0 and a * x2 + b * y2 + c is less than 0 , increment ans by 1
print ans and new line
n , x , y , dB , dW , b1 , b2 , w1 , w2 = long long integers
read n , x , and y
if x is equal to 1 and y is equal to 1 then
else if x is equal to n and y is equal to n
else
set w1 to x - 1
set w2 to y - 1
set dW to max of w1 and w2
set b1 to n - x
set b2 to n - y
set dB to max of b1 and b2
if dW is less than or equal to dB
else if dB is less than dW
A = int array size 1000
n = int
read n
two = int , two = 1
while two < = n , multiply two by 2
divide two by 2
print n % 2 ? ( n - 1 ) / 2 : ( n - two ) / 2
declare unsigned long longs n , cp , x , y , unsigned long long array a size 100010
read n , x , y
if x is greater than y
let cp be y
let y be x
let x be cp
declare unsigned long long sumwhite = y - 1
declare unsigned long long sumblack = n - x
end statement
print " White " if sumwhite is less than or equal to sumblack , else " Black "
create character arrays a , b with a size 100010 b size 100010
create integers i , j , p , q with j = 0 , p = - 1 , q = - 1
read a , read b
for i = 0 to a [ i ] or b [ i ] , incrementing i
if a [ i ] is not b [ i ]
if increment j , p is less than 0
set p to i
else
set q to i
print " YES " if j is 2 and a [ p ] is b [ q ] and a [ q ] is b [ p ] , else " NO "
declare const long long maxn = 1e9 + 7
declare const long double EPS = 1e - 9
create const long long INF = 1e18 + 18
create const long long mod = 1e9 + 7
declare long longs n , k and x with x = INF
create strings s and temp
read n , k and s
loop i from 1 to length of s exclusive
if substring of s from 0 to n - i = substring of s from i to n - i
set x to i
break the loop
if x is equal to INF
loop i from 0 to k exclusive , print s
print ' \ n '
declare string variable op = substring of s from n - x
set temp to s
for long long i = 0 to k - 1 exclusive , append op to temp
print temp and ' \ n '
let n , count , i , j = integers
set count = 0
read n
let line = array of integers size n and values = 0
read n values into array line
let max = integer value = 0
for i = 0 to n exclusive
if line [ i ] is greater than line [ max ] set max = i
for i = max - 1 to 0 inclusive decrementing do the following
let temp = integer value = line [ i ]
set line [ i ] = line [ i + 1 ]
set line [ i + 1 ] = temp
increment count
let min = integer value = 0
for i = 0 to n exclusive do the following
if line [ i ] is greater than or equal to line [ min ] set min = i
print count + n - min - 1
make ints n , a , b , and k
let int array s of size 100000
let string inp
make map dp from ints and ints
declare bpow taking in ints n and e and returning integer
create integer array b of size 30
set b [ 0 ] to n
make integer ans = 1
for i = 0 to 30 exclusive
if e & ( 1 < < i ) are truthy set ans to ( ( long long ) ans * b [ i ] ) % 1000000009
return ans
declare bdiv taking in integers n and d and returning integer
return the result of ( ( long long ) n * bpow ( d , 1000000009 - 2 ) ) % 1000000009
declare alt taking in int e and returning int
if e % k is not 0 , end function
if dp . count ( e ) is falsy
if e is 0
end function
else if e is k
set dp [ e ] to 1
else do
create int l = e / 2 / k * k
make integer r = e - 1
set dp [ e ] to ans
return dp [ e ]
read n , a , b , and k
read inp
for i = 0 to k exclusive
if inp [ i ] is ' + '
set s [ i ] to 1
else do
set s [ i ] to - 1
create int x = 0
for i = 0 to k exclusive
create integer toadd = ( ( long long ) s [ i ] * bpow ( a , k - 1 - i ) ) % 1000000009
set toadd to ( ( long long ) toadd * bpow ( b , i ) ) % 1000000009
set x to ( ( long long ) x + toadd + 1000000009 ) % 1000000009
display x , " " , and alt ( n + 1 ) to error
create integer ans = ( ( long long ) x * alt ( n + 1 ) ) % 1000000009
display ans
declare f with long long p as argument , returning long long
if p is less than 10 , return p from function
create long longs r , f with r = p / 10 + 9 , f = p
while f is greater than or equal to 10 , set f to f / 10
if f is greater than p % 10 , decrement r
return r from function
create long longs m , n
read m reada n
print result of run f with n as argument - result of run f with m - 1 as arguments , print newline
s = character array of size 200005
n = integer
mp = map from char to integer
read n , s
clear mp
for i = 0 to n exclusive , increment mp [ s [ i ] ]
flag = integer with flag = 1
for i = a to z
if mp [ i ] > 1
if n is 1
else
set Pi to acos of - 1
set INF to 0x3f3f3f3f
assign 1e3 + 5 to MAXN
create int n , a , b , c , d , sum , ans , set ans to 1
read n
for i = 0 to n exclusive
read a , b , c and d
if i = 0
set sum to a + b + c + d
else if sum less than a + b + c + d
increment ans
print ans
f = integer 2d array of size [ 110 ] [ 110 ]
i , j , n , k , m = integers
while read k
for i = 1 to 100
for j = 1 to 100 , f [ i ] [ j ] = 0
for i = 1 to 100
if ( i * ( i - 1 ) * ( i - 2 ) / 6 > k ) break loop
n = i - 1
for i = 1 to n
for j = 1 to n
if ( i is not j ) , f [ i ] [ j ] = 1
k = k - n * ( n - 1 ) * ( n - 2 ) / 6
if ( k > 0 )
for i = 1 to 100
if ( i * ( i - 1 ) / 2 > k ) break loop
m = i - 1
for i = 1 to m , f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1
n = n + 1
k = k - ( m - 1 ) * m / 2
if ( k > 0 )
for i = 1 to 100
if ( i * ( i - 1 ) / 2 > k ) break loop
m = i - 1
for i = 1 to m , f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1
n = n + 1
k = k - ( m - 1 ) * m / 2
for i = 1 to k
f [ n + i ] [ 1 ] = f [ 1 ] [ n + i ] = 1
f [ n + i ] [ 2 ] = f [ 2 ] [ n + i ] = 1
n = n + k
print n
for i = 1 to n
for j = 1 to n , print f [ i ] [ j ]
print new line
let fx , fy , dx , dy ints , all with value 0
read fx and fy
let c a string
read c
if fx and fy are 0 , print Yes and return 0
for i = 0 to length of c exclusive
if c [ i ] is u
increment dy
otherwise if c [ i ] is D
decrement dy
otherwise , if c [ i ] is L
decrement dx
otherwise
increment dx
for i = 0 to size of c exclusive
let nx , ny ints with value 0
for j = 0 to i inclusive
if c [ j ] is U
increment ny
otherwise if c [ j ] is D
decrement ny
otherwise if c [ j ] is L
decrement nx
otherwise
increment nx
if nx equals fx and ny equals fy , print Yes and return 0
let k1 and k2 be integers with value 0
if dx is not 0 , set k1 to ( fx - nx ) / dx
if dy is not 0 , set k2 = ( fy - ny ) / dy
if dx is 0 , set k1 equals k2
if dy is 0 , set k2 equals k1
if k1 * dx + nx = fx and k2 * dy + ny = fy and k1 nonnegative , print Yes and return 0
print No and return 0
integers = n , m
read n , m
integers = a , ans , maxa = - 1
for i = 1 to less than or equal to n do the following
read a
if is 0 then do the following
divide a by m
else
divide a by m
add one to a
if a is greater than or equal to maxa then do the following
set maxa to a
set ans to i
declare long long arrays arr size 100010 , dp size 100010 by 2 , d size 100010
declare integer n
declare long long ans = 0
read n
for i = 0 to n exclusive
read arr [ i ]
if i is greater than 0 , let d [ i ] be absolute value of ( arr [ i ] - arr [ i - 1 ] )
for i = 1 to n inclusive
let dp [ i ] [ 0 ] be maximum of ( d [ i ] and d [ i ] + dp [ i - 1 ] [ 1 ] )
let dp [ i ] [ 1 ] be maximum of ( - d [ i ] and dp [ i - 1 ] [ 0 ] - d [ i ] )
let ans be maximum of ( ans and maximum of ( dp [ i ] [ 0 ] and dp [ i ] [ 1 ] ) )
print ans and newline
declare constant integer M = 2e5 + 5
declare integer arrays G size 200 by 200 , T size 200 by 200
declare integers n , m , i , j
read n , m
declare boolean f = 0
for i = 1 to n inclusive
for j = 1 to m inclusive
read G [ i ] [ j ]
let T [ i ] [ j ] be G [ i ] [ j ]
declare integer vectors r , , c
for i = 1 to n inclusive
declare integer mn = 1000
for j = 1 to m inclusive , let mn be minimum of ( mn and G [ i ] [ j ] )
for j = 1 to m inclusive , decrement G [ i ] [ j ] by mn
for j = 1 to mn inclusive , add i to end of r
for i = 1 to m inclusive
declare integer mn = 1000
for j = 1 to n inclusive , let mn be minimum of ( mn and G [ j ] [ i ] )
for j = 1 to n inclusive , decrement G [ j ] [ i ] by mn
for j = 1 to mn inclusive , add i to end of c
for i = 1 to n inclusive
for j = 1 to m inclusive
if G [ i ] [ j ] is true
print " - 1 \ n "
let G [ i ] [ j ] be T [ i ] [ j ]
declare integer vectors r1 , c1
for i = 1 to m inclusive
declare integer mn = 1000
for j = 1 to n inclusive , let mn be minimum of ( mn and G [ j ] [ i ] )
for j = 1 to n inclusive , decrement G [ j ] [ i ] by mn
for j = 1 to mn inclusive , add i to end of c1
for i = 1 to n inclusive
declare integer mn = 1000
for j = 1 to n inclusive , let mn be minimum of ( mn and G [ j ] [ i ] )
for j = 1 to n inclusive , decrement G [ j ] [ i ] by mn
for j = 1 to mn inclusive , add i to end of r1
if size of r + size of c is greater than size of r1 + size of c1
let r be r1
let c be c1
print size of r + size of c , " \ n "
for i = 0 to size of r exclusive
print " row "
print r [ i ] , " \ n "
for i = 0 to size of c exclusive
print " col "
print c [ i ] , " \ n "
a is a new array of integers with 105 elements
declare integer variable n
read variable n from the input
set a [ 0 ] to 0 and a [ n + 1 ] to 1001
create integers maxl = 0 and l = - 1
in a loop , change i from 1 to n inclusive , reading a [ i ] from the user input on each loop
for i from 1 to n + 1 inclusive incrementing i
if a [ i ] is equal to a [ i - 1 ] + 1
increment l
else
change the value of maxl to max of maxl and l
set l to - 1
change maxl to max of maxl and l
print maxl to the standard output
new integer variable n
read variable n from the input
create new vector of strings s with size n
in a for loop , read n elements into s
define new string candidates with value " RGBYW12345 "
create a map from characters to integers called pos
for i = 0 to length of candidates exclusive , change pos [ candidates [ i ] ] to i
declare new integer variable m = 10
create integer variable with name res with value 8
for mask from 0 to 1 < < m exclusive
declare integer variable with name bits = 0
for i from 0 to m exclusive incrementing i
increment bits if mask & ( 1 < < i ) ! = 0
if bits > = res , go to the start of the loop
create vector of booleans used with n elements filled with false
for i from 0 to n exclusive
create new integer u with value pos [ s [ i ] [ 0 ] ]
declare integer variable with name v and value pos [ s [ i ] [ 1 ] ]
if mask & ( 1 < < u ) and mask & ( 1 < < v ) are both ! = 0 , change the value of used [ i ] to true
start infinite loop
new boolean updates with value false
for i from 0 to m exclusive
if mask & ( 1 < < i ) ! = 0
t is a new set of strings
for integer j = 0 to n exclusive incrementing j
if candidates [ i ] = s [ j ] [ i / 5 ] and used [ j ] is false , add s [ j ] into t
if length of t < = 1
move new set iterator it through the set t
for j from 0 to n exclusive incrementing j
if s [ j ] = value at it and used [ j ] is false
assign true to used [ j ]
set updates to true
if updates is false , break the loop
create new set of unique strings called t
start for loop from i = 0 to n exclusive incrementing i
if used [ i ] is false , insert s [ i ] into t
if length of t < = 1 , assign the new value = min of res and bits to res
print res
create int array a of size 10000000
create string s
create ints i , j , m , n = 0 , t = 0 , and k = 0
read s
for i = 0 to the length of s exclusive
if s [ i ] is equal to ' ( '
increment t
else if s [ i ] is equal to ' ) '
reduce t by 1
else
reduce t by 1
increment k
if t is less than 0
print " - 1 "
create int p = 0
for i = 0 to the length of s exclusive
if s [ i ] is equal to ' # '
increment n
if n is equal to k , set p to p - t
set p to p - 1
else if s [ i ] is equal to ' ( '
increment p
else
reduce p by 1
if p is less than 0
print " - 1 "
for i = 1 to k - 1 , print 1
print t + 1
t = string
loop while reading t
h = string with h = substring of t from position 0 to 2
m = string with m = substring of t from position 3 to 5
if h is not " 05 " and h is not " 06 " and h is not " 07 " and h is not " 08 " and h is not " 09 "
if h is not " 15 " and h is not " 16 " and h is not " 17 " and h is not " 18 " and h is not " 19 "
if h is " 23 " and m > = " 32 "
print " 00 : 00 "
else
s = string with s = " 00 "
set s [ 0 ] to h [ 1 ]
set s [ 1 ] to h [ 0 ]
if m > = s
set h [ 1 ] to h [ 1 ] + 1
set s [ 0 ] to h [ 1 ]
print h then " : " then s
else
if h is " 15 " and m < " 51 "
print " 15 : 51 "
else
print " 20 : 02 "
else
if h is " 05 " and m < " 50 "
print " 05 : 50 "
else
print " 10 : 01 "
declare constant integer Maxn = 1e5 + 100
declare integers n , m , integer array a size Maxn
declare boolean array mark size 2 by Maxn
declare integer vector array nei size 2 by Maxn
declare dfs with integers x , v as arguments , returning void
for i = 0 to integer casted size of nei [ x ] [ v ] exclusive
declare integer u = nei [ x ] [ v ] [ i ]
if not mark [ x ] [ u ]
let mark [ x ] [ u ] be true
if x is 0 or a [ u ] is not 1 , run dfs with x , u as arguments
read n and m
for i = 0 to n exclusive , read a [ i ]
for i = 0 , u , v to i is less than m , incrementing i
read u and v
add v - 1 to end of nei [ 0 ] [ u - 1 ]
add u - 1 to end of nei [ 1 ] [ v - 1 ]
for i = 0 to n exclusive
if a [ i ] is 1 and not mark [ 0 ] [ i ]
let mark [ 0 ] [ i ] be true , run dfs with 0 , i as arguments
else if a [ i ] is 2 and not mark [ 1 ] [ i ]
let mark [ 1 ] [ i ] be true , run dfs ( 1 , i )
for i = 0 to n exclusive
if mark [ 0 ] [ i ] and mark [ 1 ] [ i ]
print 1 and newline
else
print 0 and newline
let a1 , a2 , n , k , second , ans , ans1 be long integers with second = 0 , ans = 0
let vector < pair < long long , pair < long long , long long > > > be a vector by name h
let read be a void function
read n
for integer i = 0 , x , y , m , i is less than n , increment i by 1
read k
increment second by k
read a1
the long integer value of t = a1
read x , y , m
push_back the value of ( make_pair ( 0 , make_pair ( a1 , i + 1 ) ) ) into h
ans1 is equal to 0
for integer j = 1 , j is less than k , increment j by 1
a2 is equal to ( a1 * x + y ) modulo m
if a2 is less than a1 , increment ans1 by 1
a1 is equal to a2
t is equal to maximum of t and a1
if length of h < = 200000 , push_back ( make_pair ( ans1 , make_pair ( a1 , i + 1 ) ) ) into h
ans is equal to maximum of ans and ans1
sort the values of h from beginning to end
print ans and newline
if second < = 200000
call the read function
declare integers n and k
read input to n and k
create long long vector a with n elements filled with 0
for i from 0 to n exclusive , read input to a [ i ]
create set of long long called ex
loop i from 0 to n exclusive
if there is no a [ i ] in ex
declare long long b = a [ i ] * k
if b ! = a [ i ] , insert b into ex
create int exCount = 0
for i from 0 to n exclusive
if there is no a [ i ] in ex , increment exCount
print n - exCount
create string s
declare int variable m
read input to s
declare ints l and r = 0
for i from 0 to length of s exclusive
if s [ i ] = ' ( '
increment l and r by one
else
decrement l by one
if r is greater than 0 , decrement r
if l is less than 0
print - 1
if s [ i ] = ' # ' , change r to 0 and increment m
if r ! = 0
print - 1
loop i from 0 to m - 1 exclusive , print 1
print l + 1
let a be an int array of length 1010
let N , K be ints
read N , K
for i = 1 to N * 2 + 1 inclusive the read a [ i ]
let int k = 0
for i = 2 to N * 2 inclusive
if a [ i ] > a [ i - 1 ] + 1 and a [ i ] > a [ i + 1 ] + 1
decrement a at i
increment k
if k is same as K , exit loop
for i = 1 to N * 2 , print a at i and space
print a [ N * 2 + 1 ]
create 2d long long array a with size 4 by 4
for i = 0 to 4 exclusive
for j = 0 to 4 exclusive , print a [ i ] [ j ]
for i = 0 to 4 exclusive
for j = 0 to 3 exclusive
if a [ i ] [ j ] is 1 and a [ i ] [ 3 ] is 1
print " YES "
print " \ n "
for i = 0 to 4 exclusive
if a [ i ] [ 1 ] is 1
if i is greater than or equal to 2 and a [ i - 2 ] [ 3 ] is 1
print " YES "
print " \ n "
if i is less than 2 and a [ i + 2 ] [ 3 ] is 1
print " YES "
print " \ n "
for i = 0 to 4 exclusive
if a [ i ] [ 0 ] is 1
if i is greater than 1 and a [ i - 1 ] [ 3 ] is 1
print " YES "
print " \ n "
if i is 0 and a [ 3 ] [ 3 ] is 1
print " YES "
print " \ n "
for i = 0 to 4 exclusive
if a [ i ] [ 2 ] is 1
if i is less than 3 and a [ i + 1 ] [ 3 ] is 1
print " YES "
print " \ n "
if i is 3 and a [ 0 ] [ 3 ] is 1
print " YES "
print " \ n "
print " NO "
print " \ n "
s = 1000100
b = pointer to int
n = int
b = array of s int
read n
for i = 0 to n exclusive
a = int
read a
increment b [ a ]
ans = 0
for i = 0 to s - 1 exclusive
add b [ i ] / 2 to b [ i + 1 ]
b [ i ] = b [ i ] modulo 2
add b [ i ] to ans
print ans
create constant integer N = 1e5 + 7
create long long arrays a and dp , both of size N
create set < long long > x and y
create integer aux
read aux
for i = 1 to aux inclusive , read a [ i ]
if aux equals 2
print abs of a [ 1 ] - a [ 2 ]
for i = 1 to aux exclusive
create long long x = abs of a [ i ] - a [ i + 1 ]
if i bitwise and 1
set dp [ i ] to dp [ i - 1 ] + x
else
set dp [ i ] to dp [ i - 1 ] - x
insert dp [ 1 ] into x
insert dp [ 2 ] into y
create long long result = max of dp [ 1 ] and dp [ 2 ]
set result to max of result and abs of a [ 2 ] - a [ 3 ]
for i = 3 to aux exclusive
set result to max of result and dp [ i ]
set result to max of result and dp [ i ] - first element of y
set result to max of result and - ( dp [ i ] - last element of x )
if i bitwise and 1
insert dp [ i ] into x
else
insert dp [ i ] into y
print result
in bool function checkprime taking n = long long
if n = 1 then return false
i = 2 = long long
while i ^ 2 < = n
if n mod i = 0 then return false
increment i
return true
n = long long
read n
if n is odd and n isn ' t 1
print 1
else
for long long i = 1 , increment i
if checkprime of n * i + 1 = false
print i
exit loop
create long long n , m and k
read n , m and k
if n - 1 + m - 1 less than k
print - 1
if n less than m , swal n and m
set maxx to 0
assign max of maxx and n / ( k + 1 ) * m to maxx
maxx = max ( maxx , m / ( k + 1 ) * n )
if maxx is different from 0
print maxx
k = k - ( n - 1 )
print m / k + 1 and a newline
i , n , j , s1 , s2 , r = long long with s1 = 0 and s2 = 0 and r = 0
a = long long and long long pair array of size 107
read n
for i = 1 to n inclusive
read a [ i ] . first then a [ i ] . second
if a [ i ] . first is greater than 0
increment s1
else
increment s2
if s1 is s2
for i = 1 to n inclusive increment r by a [ i ] . second
print r
if s1 is greater than s2
sort a from position 1 to position n + 1
for i = 1 to s2 inclusive increment r by a [ i ] . second
for i = s2 + 1 to ( 2 * s2 ) + 1 inclusive increment r by a [ i ] . second
print r
if s1 is less than s2
sort a from position 1 to position n + 1
for i = s2 to s2 - s1 inclusive decrementing i increment r by a [ i ] . second
for i = s2 + 1 to s2 + s1 increment r by a [ i ] . second
print r
n , m , k = long long and a = long long array of size 10004
read n then m then k
if n is even
print " 0 "
x = long long with x = min of a [ 0 ] , a [ n - 1 ]
if n is 1
print min of x , m * k
for i = 0 to n incrementing i by 2 set x to min of x , a [ i ]
onerun = long long with onerun = ( n + 1 ) / 2
set onerun to m / onerun
ans = long long with ans = min of x , onerun * k
print ans
primeFactures = long long vector
in void function f that takes long long q
while q is even
push back 2 in primeFactures
if the size of primeFactures > 2 then end function
divide q by 2
for long long i = 3 , until i squared < = q , increment i by 2
while q mod i is 0
tail insert i into primeFactures
if the size of primeFacture > 2 then return
divide q by i
if q > 1 then push back q into primeFactures
let q = long long
read q
call f of q
if the size of primeFactures < 1 inclusive
print 1 and new line and 0 and new line
else if the size of primeFactures > 2
print 1 and new line and primeFactures [ 0 ] * primeFactures [ 1 ] and new line
else
print 2 and new line
c = character
n , i , t , e = integers set to 0
while reading c
if c is ' n '
increment n by 1
else if c is ' i '
increment i by 1
else if c is ' t '
increment t by 1
else if c is ' e '
increment e by 1
cont = integer set to 0
for k = i to k to 0 , decrementing k by 1
if n > = 2 * k + 1 and t > = k and e > = 3 * k , increment cont by 1
print cont
declare map from integer to integer m
decalre integers n , x , ans = 0
read n
for i = 0 to n exclusive
read x
increment m [ x ]
declare map iterator from integer to integer it
for it = beginning of m to it is not end of m , incrementing it , let ans be maximum of ans and second element of it
print n - ans and newline
a is an array of int int pairs with 105 elements
declare integer variables n and count with count = 0
read n
loop i from 0 to n exclusive
read from the input to a [ i ] . first and a [ i ] . second
if a [ i ] . first is less than 0 , increment count
declare int sum = 0
if 2 * count is less than n
loop i from 0 to min of count * 2 + 1 and n exclusive , increasing sum by a [ i ] . second
else
for i from max of count * 2 - n - 1 and 0 to n exclusive , add a [ i ] . second to sum
print sum
s = string
read s
l , a1 , b1 , c1 = 0 , i = long long , n = size of s
s1 = array of n char
for i = 0 to n exclusive
s1 [ i ] = s [ i ]
if s [ i ] is ' a '
increment a1
else if s1 [ i ] is ' b '
increment b1
else
increment c1
for i = 0 to n exclusive
if s1 [ i ] = = s [ i ] increment l
if l is n
if c1 is a1 or b1 and a1 , b1 and c1 are not 0
else
else
a , b , c , s1 , s2 , s3 , flag , i , flag1 and flag2 are long longs with s1 , s2 , s3 , flag , flag1 and flag2 = 0
declare string s
read s from the input
declare new long long called n = length of s
in a for loop , change i from 0 to n exclusive
if s [ i ] is equal to ' a '
if s2 and s3 are not 0
assign 1 to flag
stop the loop
increment s1
if s [ i ] is equal to ' b '
if s1 = 0 or s3 ! = 0
assign 1 to flag
break the loop
increment s2 by one
if s [ i ] is equal to ' c '
if s1 = 0 or s2 is equal to 0
assign 1 to flag
break the loop
increment s3
if s1 or s2 = 0 , set flag to 1
if ( s1 = s3 or s3 = s2 ) and flag = 0
print " YES "
else
print " NO " to the standard output
let n , s be integers
read n , s
let str be a empty string
for i = 0 to n exclusive , str = str + char ( ( int ) a + i modulo s )
print str and newline
declare long long variables a , b , c , x and y
read user input to a , b and c
set x to the absolute value of a
change y to absolute value of b
if c - a - b is even and x + y < = c
print " Yes "
else
print " No "
let n be a long integer
let ans be a long integer
while read n
if n < = 2
ans is equal to n
else if n & 1
ans is equal to n * ( n - 1 ) * ( n - 2 )
if n modulo 3 is not equal to 0
ans is equal to n * ( n - 1 ) * ( n - 3 )
ans is equal to ( n - 1 ) * ( n - 2 ) * ( n - 3 )
print ans and newline
MAXINT = const integer with MAXINT = 2147483640
MAXLL = const long long with MAXLL = 9223372036854775800LL
MAXN = const long long with MAXN = 1e6
eps = const double with eps = 1e - 9
mod = const long long with mod = 998244353
dp = 3d const long long array of size [ 100006 ] [ 202 ] [ 2 ] , pref = 2d const long long array of size [ 300 ] [ 2 ]
n , a = long long with a = long long array of size MAXN
srand of time ( 0 )
read n
for i = 1 to n , read a [ i ]
if a [ 1 ] is - 1
for i = 1 to 200 , dp [ 1 ] [ j ] [ 0 ] = 1
else
dp [ 1 ] [ a [ 1 ] ] [ 0 ] = 1
for i = 2 to n
for j = 1 to 200
if a [ i ] is - 1
for cur = 1 to 200
sum = long long with sum = 0
( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod
sum = pref [ cur - 1 ] [ 1 ] + pref [ cur - 1 ] [ 0 ]
else
sum = long long with sum = 0
cur = long long with cur = a [ i ]
( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod
sum = 0
ans = long long with ans = 0
( ans = ans + dp [ n ] [ i ] [ 1 ] ) = ( ans = ans + dp [ n ] [ i ] [ 1 ] ) modulo mod
m1 is a map of long long int to long long it
itr is a map iterator
declare an array of bools visited with 105 elements filled with false
create an array of long long ints crush with size 105 filled with 0
declare long long int variable cnt = 0
gcd is a long long int function with long long int arguments a and b
if b = 0 , return a
return gcd ( b , a % b )
declare long long int variable n
read n
for i from 1 to n inclusive , read crush [ i ]
declare long long int variable ans = 1
for i from 1 to n inclusive
if visited [ i ] is false
change cnt to 1
change visited [ i ] to true
declare long long int variable z = crush [ i ]
while z ! = i
if visited [ z ] = true and cnt > 1
print " - 1 "
change visited [ z ] to true
change z to crush [ z ]
increment cnt by one
if cnt is even , divide cnt by 2
declare long long int y = gcd ( ans , cnt )
set ans to ans * cnt / y
change cnt to 1
print ans
create 3d array of long longs dp with size 20 by 10 by 10
create an array of ints d with size 20
create long longs l and r
long long function work with int arguments pos , pre , head and flag
if pos < 0 , return head & & ( head = pre )
if flag ! = 0 or dp [ pos ] [ pre ] [ head ] = - 1
declare int maxx = d [ pos ] if flag ! = 0 or 9 otherwise
create long long ret = 0
if flag ! = 0 , return ret
set dp [ pos ] [ pre ] [ head ] to ret
return dp [ pos ] [ pre ] [ head ]
solve is a long long function with long long argument x
create integer len = 0
while x is not 0
assign x % 10 to d [ len ] and increment len
divide x by 10
set first sizeofdp bytes at the pointer dp to - 1
return work ( len - 1 , 0 , 0 , 1 )
read l and r
print solve ( r ) - solve ( l - 1 )
n = long long int , u = 0
read n
for i = 2 to sqrt ( n ) inclusive
if n modulo i is 0 and not u divide n by i , u = i
if n modulo i is 0 and n > i
print " 1 " , newline , u * i
if not u
print " 1 " , newline , " 0 " , newline
else
print " 2 " , newline
in inline long long function gcd that takes a = long long and b = long long
if a = 0 return b
return the gcd of b mod a and a
in inline long long function power that takes a , n , m = long long
if n = 0 return 1
let p be a long long = the power of a , n / 2 , m
set p to p ^ 2 / m
if n is even
return p * a mod m
else
return p
let MOD = long long constant = 998244353
INF = 0x3f3f3f3f = const int
LL_INF = long lon g constant = 0x3f3f3f3f3f3f3f3f
let adj = 101x101 int matrix
k = int
read k
let l = 3 , u = 100 be ints
vn = 1 = int
ans , n , ans1 , x = int
while u > = 1
set n to ( u + 1 ) / 2
set x to ( n * ( n - 1 ) ) * ( n - 2 )
if x > 6 * k
set u to n - 1
else
set ans to n
set l = n + 1
set x = ans * ( ans - 1 )
multiply x by ans - 2
decrement k by x / 6
for i = 1 to ans inclusive
for j = 1 to ans inclusive
if i isn ' t j
set adj [ i ] [ j ] to 1
set adj [ i ] [ j ] = 1
increment vn by ans
while k is strictly positive
set l = 2
set u = ans
while u > = 1
set n = a half of ( u + 1 )
set x = n * n ( n - 1 )
if x < = 2 * k
set ans1 = n
set l = n + 1
else
set u = n - 1
dcrement k by ans1 * ( ans1 - 1 ) / 2
for i = 1 to ans1 inclusive
set adj [ i ] [ vn ] = 1
set adj [ vn ] [ i ] to 1
increment vn
print vn - 1
for i = 1 to vn - 1 inclusive
for j = 1 to j < = vn - 1 then print adj [ i ] [ j ]
print new line
create int x , t , a , b , da , db
read x , t , a , b , da , db
for i = 0 to t exclusive
for j = 0 to t exclusive
create int p and q
assign a - i * da to p
assign b - j * db to q
if ( p greater than - 1 and q greater than - 1 ) and ( p + q equals x or p equals x or q equals x or x equals 0 )
print " YES "
print " NO "
declare constant integer N = 1e5 + 5
s is a new array of characters with size N
declare integer variables i , len and flag with flag = 0
read input an store it into s
assign the new value = length of s to len
for i = 0 to len exclusive
if s [ i ] ! = ' a '
assign 1 to flag
decrement s [ i ]
else if flag is not 0
break the loop
if flag is 0 , set the value of s [ i - 1 ] to ' z '
print s to stdout
N = integer
read N
p = string
read p
ok = boolean = false
cnt = integer = 0
if p [ 0 ] is ? or p [ N - 1 ] is ? , then ok = true
for i = 1 to N exclusive
if p [ i ] is ? and p [ i - 1 ] is p [ i + 1 ] or p [ i - 1 ] is ?
ok = true
else if p [ i ] is p [ i - 1 ]
ok = false
exit for loop
if ok is true
else
data = array of 51 by 51 char
visited = array of 51 by 51 bool
dr = array of 4 int filled with 0 , 0 , 1 , - 1
dc = array of 4 int filled with 1 , - 1 , 0 , 0
function Counter ( get int i and j , return int )
if visited [ i ] [ j ] return 0
visited [ i ] [ j ] = true
ans = 0
if data [ i ] [ j ] is ' # '
increment ans
for x = 0 to 4 exclusive add Counter ( i + dr [ x ] , j + dc [ x ] ) to ans
return ans
n , m = int
read n , m
Total = 0
start = pair of int , int
for i = 0 to n exclusive
for j = o to m exclusive
read data [ i ] [ j ]
if data [ i ] [ j ] is ' # ' increment Total , start = i , j
fill visited with false
t = Counter ( first item of start , second item of start )
if t < Total
print 0
else if Total < 3
print - 1
else
ans = 0
for i = 0 to n exclusive
for j = 0 to m exclusive
if data [ i ] [ j ] is ' # '
if i is 6 and j is 5 r = 1
fill visited with false
visited [ i ] [ j ] = true
x , y = int
for k = 0 to 4 exclusive
if data [ i + dr [ k ] ] [ j + dc [ k ] ] is ' # '
x = i + dr [ k ]
y = j + dc [ k ]
break
t = Counter ( x , y )
if t < Total - 1
print 2
in function R taking string vector A and returning string vector
B = auto with B = A
for i = 0 to size of A
for j = 0 to size of B set B [ j ] [ i ] to a [ i ] [ j ]
iterate over B with reference to auto s reverse s
return B
n = int
read n
A , B = string vector of size n each
read n values into A
read n values into B
OK = bool with OK = A is B
for j = 0 to 4
set A to R of A
if A is B set OK to 1
iterate over A with reference to auto s reverse s
for j = 0 to 4
set A to R of A
if A is B set OK to 1
for i = 0 to n / 2 call swap of A [ i ] , A [ n - 1 - i ]
for j = 0 to 4
set A to R of A
if A is B set OK to 1
if OK print " Yes " else print " No "
create integers n , x1 , y1 , x2 , y2
read n read x1 read y1 read x2 read y2
if ( x1 is n and x2 is 0 ) or ( x1 is 0 and x2 is n )
if ( y1 + y2 + n ) is less than or equal to ( n - y1 + n - y2 + n )
print y1 + y2 + n print newline
else
print ( n - y1 + n - y2 + n ) print newline
else if ( x1 is n and y2 is 0 ) or ( x2 is n and y1 is 0 )
if x1 is n and y2 is 0
print y1 + ( n - x2 ) print newline
else
print ( n - x1 ) + y2 print newline
else if ( x1 is n and y2 is n ) or ( y1 is n and x2 is n )
print absolute value of ( x1 - y1 ) + absolute value of ( x2 - y2 ) print newline
else if ( y1 is n and x2 is 0 ) or ( y2 is n and x1 is 0 )
if ( y1 is n and x2 is 0 )
print x1 + ( n - y2 ) print newline
else
print x2 + ( n - y1 ) print newline
else if ( y1 is n and y2 is 0 ) or ( y1 is 0 and y2 is n )
if ( x1 + x2 + n ) is less than or equal to ( n - x1 + n - x2 + n )
print x1 + x2 + n print newline
else
print n - x1 + n - x2 + n print newline
else if ( y1 is 0 and x2 is 0 ) or ( x1 is 0 and y2 is 0 )
print x1 + x2 + y1 + y2 print newline
else
print absolute value of x1 - x2 + absolute value of y1 - y2 print newline
vis1 = array of long integers of length 1000005
vis2 = array of long integers of length 1000005
let m be a long integer
let h1 , a1 be long integers
let x1 , y1 be long integers
let h2 , a2 be long integers
let x2 , y2 be long integers
read m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2
memset of vis1 , 0 , size of vis1
memset of vis2 , 0 , size of vis2
let t1 , t2 be long integers with t1 = - 1 , t2 = - 1
let c1 , c2 be long integers with c1 = - 1 , c2 = - 1
let q1 , q2 be long integers with q1 = - 1 , q2 = - 1
let f1 , f2 be long integers with f1 = - 1 , f2 = - 1
set boolean value flag to true
set boolean value fuck to false
for long integer i = 1 to 2 * m inclusive
the value of h1 = h1 * x1
the value of h1 = h1 modulo m
the value of h1 = h1 + y1
the value of h1 = h1 modulo m
the value of h2 = h2 * x2
the value of h2 = h2 modulo m
the value of h2 = h2 + y2
the value of h2 = h2 modulo m
if h1 is equal to a1 and a2 is equal to h2
set fuck to true
print i and newline
stop
if vis1 [ a1 ] is equal to 0 and h1 is equal to a1 , f1 is equal to i
if vis2 [ a2 ] is equal to 0 and h2 is equal to a2 , f2 is equal to i
if h1 is equal to a1 and t1 is equal to - 1 , c1 is equal to i
if h2 is equal to a2 and t2 is equal to - 1 , c2 is equal to i
if vis1 [ h1 ] is not equal to 0 and q1 is equal to - 1
the value of q1 is equal to vis1 [ h1 ]
the value of t1 is equal to i - q1
if c1 is less than q1
set flag to false
stop
decrement c1 by q1
if vis2 [ h2 ] is not equal to 0 and q2 is equal to - 1
the value of q2 is equal to vis2 [ h2 ]
the value of t2 is equal to i - q2
if c2 is less than q2
set flag to false
stop
decrement c2 by q2
if t1 is not equal to - 1 and t2 is not equal to - 1 , stop
if vis1 [ h1 ] is equal to 0 , vis1 [ h1 ] is equal to i
if vis2 [ h2 ] is equal to 0 , vis2 [ h2 ] is equal to i
if fuck is true
else if not flag
if f1 is not equal to f2 or f1 is equal to - 1 or f2 is equal to - 1
print - 1 and newline
print f1 + 1 and newline
if f1 is equal to f2 and f1 is not equal to - 1 and f2 is not equal to - 2
print f1 and newline
else if t1 is equal to t2 and ( c1 is equal to c2 and f1 is not equal to f2 ) or c1 is not equal to c2
print - 1 and newline
let x be a long integer with x = 0
while x * t1 + c1 + q1 - c2 - q2 modulo t2 is not equal to 0
increment x by 1
if x is greater than 1000000 , stop
if x is greater than 1000000
print - 1 and newline
print x * t1 + c1 + q1 and newline
maxn is a constant integer with maxn = 1100
a is an integer array with two dimensions both of size maxn , b is an integer array of size maxn
s is a string array of size 110
declare variable n
while input n
for i = 0 to n exclusive , input s [ i ]
top and flag are both integers and are both set to 0
for i = 0 to n exclusive
for j = 0 to n exclusive
if s [ i ] [ j ] is equal to the character .
increment top
break
if top is equal to n
assign 1 to flag
for i = 0 to n exclusive
for j = 0 to n exclusive
if s [ i ] [ j ] is equal to the character .
display i + 1 , " " , and j + 1
break
assign 0 to top
for j = 0 to n exclusive
for i = 0 to n exclusive
if s [ i ] [ j ] is equal to the character .
increment top
break
if top is equal to n and flag is false
assign 1 to flag
for j = 0 to n exclusive
for i = 0 to n exclusive
if s [ i ] [ j ] is equal to the character .
display i + 1 , " " , and j + 1
break
if not flag , puts - 1
n , i and k are integers where k = 0 and a is an integer array with 110 elements
read n
loop i from 1 to n inclusive
read a [ i ]
if a [ i ] is less than 0 , increment k by one
if k < = 2
print 1 , new line and n
else
if k is even
print k / 2
else
print k / 2 + 1
declare integers t , sum = 0 and x = 1
for i from 1 to n inclusive
if t = 2 and a [ i ] < 0
print i - x and " "
add i - x to sum
change x to i
set t to 0
if a [ i ] is less than 0 , increment t by one
if sum is less than n , print n - sum
print new line
create int constant N = 80 + 5
create integers n and mx
create int now = 0
create an array of bools active with size N
create int array v with size N
create int res = 0
create an array of integers urm with N elements
read input to n and mx
for i = 1 to n inclusive , read v [ i ]
loop i from 1 to n inclusive
create integer x = v [ i ]
if active [ x ] is true , go to the start of the loop
if now = mx
increment res by one
loop j from 1 to n inclusive , assign 1 < < 30 to urm [ j ]
for integer j = n to i exclusive counting down , set urm [ v [ j ] ] to j
create integers maurm and who with maurm = 0
for j from 1 to n inclusive
if active [ j ] is true
change maurm to max of maurm and urm [ j ]
if urm [ j ] = maurm , assign j to who
set active [ who ] to 0
change active [ x ] to 1
else
increment now
increment res
change active [ x ] to 1
print res and " \ n "
create sets of int called h and v
declare int variable n
read n
loop i from 1 to n inclusive
insert i into h
insert i into v
declare int ans = 0
for i from 1 to n squared inclusive
declare int variables x and y
read x and y
if there is x in h and y in v
if ans is true , increment ans in any case and print ' '
print i
remove x from h
remove y from v
print new line
hc = integer with hc = - 1
s , a = strings
read s
for i = s . size ( ) down to i
if ( s [ i ] is 0 ) , hc = i
for i = 0 to s . size ( ) exclusive
if ( ( hc is - 1 and i is 0 ) or i is hc ) , continue next iteration
a = a + s [ i ]
print a
MAXN , DELTA = const integer with MAXN = 5000 + 7 , DELTA = 1000 * 1000 * 1000 + 7
numberOfPartialAns = long long array of size [ MAXN ] [ MAXN ]
s , t = strings
read s , t
for i = 1 to ( cast to integer ) s . size ( )
for j = 1 to ( cast to integer ) t . size ( )
numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j - 1 ]
if ( s [ i - 1 ] is t [ j - 1 ] )
numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j ] + numberOfPartialAns [ i - 1 ] [ j - 1 ]
numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j ] modulo DELTA
increment numberOfPartialAns [ i ] [ j ]
numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j ] modulo DELTA
ans = long long with ans = 0
for i = 1 to ( cast to integer ) s . size ( )
ans = ans + numberOfPartialAns [ i ] [ ( cast to integer ) t . size ( ) ]
ans = ans modulo DELTA
print ans
a , b , d , s = integers
read a , b , d
s = abs ( a ) + abs ( b )
if ( s > d )
else if ( s is d )
else
if ( ( d - s ) modulo 2 is 0 )
else
n , m , k , l = long long
read n , m , k , l
sum = long long , sum = k + l
out = long long , out = sum / m
while true
if out * m < = n
if out * m > = sum
print out
exit while loop
else
add one to out
else
print - 1
exit while loo [
a = integer 2d array of size 5 , 5
p = integer array of size 5
flag = int with flag = 0
set all the contents of p to 0
for i = 0 to 3
for j = 0 to 3
print a [ i ] [ j ]
if j is 3 and a [ i ] [ j ] , p [ i ] = 1
for i = 0 to 3
if p [ i ]
for j = 0 to 2
if a [ ( i + j + 1 ) modulo 4 ] [ j ] or a [ i ] [ j ] )
flag = 1
break loop
call puts , if flag , print YES else print NO
function nc ( no args , return char )
return getchar ( )
function read ( get address of int x , return nothing )
c = nc ( )
b = 1
while not ( c > = ' 0 ' and < = ' 9 ' ) c = nc ( )
if c is ' - ' b = - 1
x = 0 , while c > = ' 0 ' and c < = ' 9 ' x = x * 10 + c - ' 0 ' , c = nc ( )
do nothing
multiply x by b
function read ( get address of long long x , return nothing )
c = nc ( )
b = 1
while not ( c > = ' 0 ' and < = ' 9 ' ) c = nc ( )
if c is ' - ' b = - 1
x = 0 , while c > = ' 0 ' and c < = ' 9 ' x = x * 10 + c - ' 0 ' , c = nc ( )
do nothing
multiply x by b
function read ( get pointer to char s , return nothing )
c = nc ( )
len = 1
while not ( c > = ' a ' and c < = ' z ' ) c = nc ( )
if c is EOF return 0
while c > = ' a ' and c < = ' z ' s [ len ] = c , increment len , c = nc ( )
do nothing
s [ len ] = null byte , increment len
return len - 2
function read ( get address of char x , return nothing )
x = nc ( ) , while not ( x > = ' a ' and x < = ' z ' ) x = nc ( )
do nothing
wt = int , ss = array of 19 int
function print ( get int x , return nothing )
if x < 0 x = - x , print ' - '
if not x
print char with value 48
else
wt = 0 , while x ss [ wt ] = x modulo 10 , increment wt , divide x by 10
do nothing
while wt puchar ( ss [ wt ] + 48 ) , decrement wt
do nothing
function print ( get long long x , return nothing )
if x < 0 x = - x , print ' - '
if not x
print char with value 48
else
wt = 0 , while x ss [ wt ] = x modulo 10 , increment wt , divide x by 10
do nothing
while wt puchar ( ss [ wt ] + 48 ) , decrement wt
do nothing
n , m = int , a = array of 100010 int
function Find ( get int x , return int )
l = 1 , r = n , res = 0 , mid = int
while l < = r
mid = l + r > > 1
if a [ mid ] < = x
res = mid , l = mid + 1
else
r = mid - 1
return res
read ( n )
read ( m )
for i = 1 to n inclusive read a [ i ]
ans = 0
for i = 1 to n inclusive
x = Find ( a [ i ] + m )
if x - i + 1 > = 3
y = x - i - 1
add y * ( y + 1 ) / 2 to ans
create integers n , i , j , x , y , k1 , k2 , ans
create pair array p1 with size 100001 with pair of integer and integer
create pair array p2 with size 100001 with pair of integer and integer
read n
for i = 1 to n inclusive
read x read y
if x is less than 0
set first element of p1 [ incrementk1 ] to x
set second element of p1 [ k1 ] to y
if x is greater than 0
set first element of p2 [ incrementk2 ] to x
set second element of p2 [ k2 ] to y
sort elements from p1 + 1 to p1 + k1 + 1
reverse sort elements from p1 + 1 to p1 + k1 + 1
sort elements from p2 + 1 to p2 + k2 + 1
if k1 is greater than k2
for i = 1 to k2 inclusive , increment ans by second element of p1 [ i ] + second element of p2 [ i ]
increment ans by second element of p1 [ i ]
if k1 is k2
for i = 1 to k2 inclusive , increment ans by second element of p1 [ i ] + second element of p2 [ i ]
if k1 is less than k2
for i = 1 to k1 inclusive , increment ans by second element of p1 [ i ] + second element of p2 [ i ]
increment ans by second element of p2 [ i ]
print ans print newline
let s be a string
let i , x , y , z , k , a , b be integers
read s
for i = 0 to length of s exclusive
if s [ i ] is equal to n , increment x by 1
if s [ i ] is equal to e , increment y by 1
if s [ i ] is equal to i , increment z by 1
if s [ i ] is equal to t , increment k by 1
if x is greater than 2
a is equal to minimum of 1 + ( x - 3 ) / 2 , y / 3
b is equal to minimum of z , k
print 0 and newline
print minimum of a , b and newline
a = long long array of size 1024
in function f taking int n and returning long long
ans = long long with ans = 0
for i = 1 to 1024 inclusive
if a [ i ] < n
increment ans by a [ i ] * ( a [ i ] - a [ i - 1 ] )
else
increment ans by a [ i ] * ( n - a [ i - 1 ] )
break
return ans
set a [ 1 ] to 4
set a [ 2 ] to 7
t = int with t = 3
for i = 1 to 512
set a [ t ] to a [ i ] * 10 + 4 then increment t
set a [ t ] to a [ i ] * 10 + 7 then increment t
l , r = int
read l then r
print f of r - f of ( l - 1 )
declare long long integer function maxSubArraySum taking in long long integer array a and long long integer size
let max_so_far , max_ending_here = long long integers with max_so_far = integer minimum value and max_ending_here = 0
for long long integer i = 0 to size exclusive do the following
set max_ending_here = max_ending_here + a [ i ]
if max_so_far is less than max_ending_here set max_so_far = max_ending_here
if max_so_far is less than 0 set max_ending_here = 0
return max_so_far
let n = long long integer
read n
let ar , f , s = arrays of long long integers with size of a = n , f = n - 1 and s = n - 1
read n values into array ar
for long long integer i = 0 to n - 1 exclusive do the following
let long long integer x = abs ( ar [ i ] - ar [ i + 1 ] )
set f [ i ] = x
let long long integer on = pow ( - 1 , i )
set f [ i ] = f [ i ] * on
for long long integer i = 0 to n - 1 exclusive do the following
let long long integer x = abs ( ar [ i ] - ar [ i + 1 ] )
set s [ i ] = x
let long long integer on = pow ( - 1 , i )
set s [ i ] = s [ i ] * on
let long long integer m1 = result of call maxSubArraySum on f , n - 1
let long long integer m1 = result of call maxSubArraySum on s , n - 1
print max of m1 , m2
create constant long long linf with linf = 1LL bitshift left 62
create constant integer iinf with iinf = 1000000009
create constant double dinf with dinf = 1e15
create constant integer Mod with Mod = 1e9 + 9
create constant integer maxn with maxn = 500005
declare dcmp with double x as argument , returning integer
if absolute value of x is less than or equal to 1e - 9 , return 0 from function
return - 1 if x is less than 0 , else 1
create integer arrays l , r , s , p , with l size 10 , r size 10 , s size 10 , p size 10
declare solve with no arguments , returning void
for i = 1 to 4 inclusive , read l [ i ] read s [ i ] read r [ i ] read p [ i ]
print " YES " print ' \ n '
print " YES " print ' \ n '
print " YES " print ' \ n '
print " YES " print ' \ n '
else
print " NO " print ' \ n '
create integer tt with tt = 1
while decrementing tt , run solve
declare inline key with integers i , j as arguments , returning size_t
return size_t casted i bitshift left 32 bitwise or unsigned integer casted j
declare max with long longs a , b as arguments , returning long long
return a if a is greater than b , else b from function
declare min with long longs a , b as arguments , returning long long
return a if a is less than b , else b from function
create string s
read s
create integer a1 with a1 = - 1
create integer a2 with a2 = INT_MAX
create integer b1 with b1 = - 1
create integer b2 with b2 = INT_MAX
create integers a , b , with a = 0 , b = 0
for i = 0 to length of s - 1 exclusive
if s [ i ] is ' A ' and s [ i + 1 ] is ' B '
set a1 to maximum of a1 and i
set a2 to maximum of a2 and i
set a to 1
else if s [ i ] is ' B ' and s [ i + 1 ] is ' A '
set b1 to maximum of b1 and i
set b2 to minimum of b2 and i
set b to 1
if a and b and ( a1 is greater than b2 + 1 or b1 is greater than a2 + 1 )
print " YES \ n "
else
print " NO \ n "
str is a character array of size 1010
k , i , j are integers
let flag be an integer
input str , k
assign 0 to flag
assign call strlen with str to len
if len is divisible by k
else
cnt is an integer set to len / k
for i = 0 to len exclusive with increment i + cnt
for j = 0 to cnt / 2 exclusive
if str [ i + j ] is unequal to str [ cnt + i - j - 1 ]
assign 1 to flag
break
if flag , break
if flag
else
n , m = int
k = float
skill_name , new_skill = string
skill_level = int
read n then m then k
skills = map of string and int
for i = 0 to n
read skill_name then skill_level
set skill_level to int ( int ( ( k + 0 . 001 ) * 100 ) * skill_level ) / 100
if skill_level is greater or equal to 100 then insert result of make_pair of skill_name and skill_level into skills
for i = 0 to m
read new_skill
if skills does not contain new_skill then insert result of make_pair of new_skill and 0 into skills
print size of skills
it = iterator of map of string and int
for it = beginning of skills to end of skills print it - > first and it - > second
m = map from integer to integer
it , bit = iterator map from integer to integer
a , b , c = integers
read a , b
for i = 1 to a
read c
insert make_pair ( i , c ) in m
i = integer with i = 1
it = m . begin ( )
while ( m . size ( ) is not 1 )
bit = it
increment it
if ( bit of second < = b )
erase bit from m
else
bit of second = bit of second - b
if ( it is m . end ( ) ) , it = m . begin ( )
it = m . begin ( )
print it of first
n = long long int
read n
if ( n is 1 or n is 2 )
print n
else
if ( n bitwise and 1 )
print n * ( n - 1 ) * ( n - 2 )
else if ( n modulo 3 is 0 )
print ( n - 1 ) * ( n - 2 ) * ( n - 3 )
else
print n * ( n - 1 ) * ( n - 3 )
declare character s size 100010
read string into s
declare integer i = 0
declare integer k = 0
for i = 0 to s [ i ] is not ' \ 0 ' , incrementing i
if s [ i ] is not ' a ' , end loop
for s [ i ] is not ' \ 0 ' , incrementing i
if s [ i ] is ' a ' , end loop
decrement s [ i ]
increment k
if k is 0 , let s [ string length of s - 1 ] be ' z '
print s
declare ints a , b , c , d , e and f
read a , b , c , d , e and f from the user input
if b * d * f is greater than a * c * e or c = 0 and d > 0 or a = 0 and b > 0 and d > 0
print " Ron " to the standard output
else
print " Hermione "
a = integer
read a
arr = array of integer of size n
read n values into array arr
ans = integer with value 0
for i = 0 to a exclusive
create integer sum = 0
if arr [ i ] is 1 then add 1 to sum
create integer e = arr [ i ]
while i < a and arr [ i ] = e
add 1 to i
set e = e + 1
increment sum
if e = 1001 then increment sum
set ans to maximum of ans and sum - 2
decrement i
print ans and new line
make const int MAX = 105
create char ss of size MAX
make ints n and k
read n and k
create char s = ' a '
make ints p and j = 0
for i = 0 to n exclusive
set ss [ i ] to s + ( j % k )
increment j
print ss
declare int variables n and m , and an array of ints num with size 550
create integers u , v , w , i and j
read n and m and keep looping
set first sizeofnum bytes at the pointer num to 0
create new double variable maxx with value 0
in a for loop , change i from 1 to n inclusive , read num [ i ] from the user input on each loop
start for loop from i = 0 to m exclusive incrementing i
read u , v and w from the user input
set maxx to max of maxx and ( num [ u ] + num [ v ] ) / w
set output precision to 15 , floatfield format flag and print maxx
let MOD a constant long long with value 1e9 + 9LL
let s a string
let n , a , b , and k long longs
in function MODULUS which takes long longs b and p and returns a long long
let ret a long long with value 1LL
while p
if p & 1LL , set ret to ( ret * b ) mod MOD
set b to ( b * b ) mod MOD1
right shift p by 1LL
return ret
in function MODINVERSE which takes long long x and returns a long long
return MODULUS applied to x and MOD - 2LL
in function Add which takes long longs x and y and returns a long long
add y to x
if x > MOD , return x - MOD
return x
in function Sub which takes long longs x and y and returns a long long
subtract y from x
if x < 0 , return x + MOD
return x
in function MUL which takes long longs x and y and returns a long long
multiply x by y
return x mod MOD
in function Div which takes long longs x and y and returns a long long
return ( x * MODINVERSE ( y ) ) mod MOD
read n , a , b , k , and s
let ans a long long with value 0LL
let x a long long with value Div ( b , a )
let c a long long with value MODULUS ( a , n )
for i from 0 to k exclusive
if s [ i ] is +
set ans to Add ( ans , c )
otherwise
set ans to Sub ( ans , c )
set c to Mul ( c , x )
if ans is negative , add MOD to ans
set x to MODULUS ( x , k )
if x is 1
set ans to Mul ( ans , ( n + 1 ) / k )
otherwise
set ans to Mul applied to ans and Sub ( MODULUS ( x , ( n + 1 ) / k ) , 1 )
set ans to Div ( ans , Sub ( x , 1 ) )
print ans mod MOD
n = unsigned long long integer
read n
if n < = 127
print byte
else if n < = 32767
print short
else if n < = 2147483647
print int
else if n < = 9223372036854775807
print long
else
print BigInteger
integers = x , y , s , z
read x , y , s
make z equal to abs ( x ) + abs ( y )
if z is greater than s then do the following cout < < No < < endl
if z is s then do the following cout < < Yes < < endl
if z is less than s then do the following
if is 0 then do the following
else
N = const integer with N = 2e6
prime = bool array of size N
in the function Prime
set all contents of prime to 0
prime [ 1 ] = 1
for i = 2 to N exclusive
if ( not prime [ i ] )
for j = i * 2 to N with j = j + i , prime [ j ] = 1
in the function is_palindromic that takes integer n and returns bool
t = integer with t = n
fn = integer with fn = 0
while ( t )
fn = fn * 10
fn = fn + t modulo 10
t = t / 10
return n is fn
p , q = double
A = double
call Prime
while read p , q
ans = integer with ans = - 1
A = p / q
pi = integer with pi = 0
pa = integer with pa = 0
for i = 1 to N exclusive
if ( not prime [ i ] ) , increment pi
pa = pa + is_palindromic ( i )
if ( pi < = pa * A ) , ans = i
if ( ans is - 1 )
print Palindromic tree is better than splay tree
else
print ans
make const int MX = 100005
create int n
make pair array of int and int a of size MX
read n
for i = 0 to n exclusive , read a [ i ] . first and a [ i ] . second
sort a using a + n
create ints i = 0 , j = 0 , and acu = 0
while i is less than n
set j to a [ i ] . first
set acu to max of acu and a [ i ] . second
while acu is greater than 1 and ( i + 1 is equal to n or j is less than a [ i + 1 ] . first )
set acu to ( acu + 3 ) / 4
increment j
add 1 to i
print max of j and a [ n - 1 ] . first + 1
a = long long array of size 500000 + 5000
in function isvowel taking char a and returning bool
return a is ' a ' or ' E ' or ' I ' or ' O ' or ' U ' or ' Y '
n = string
read n
ans , lastpos = long long with ans = - 1 and lastpos = - 1
for i = 0 to size of n
if isvowel of n [ i ] set ans to max of ans , i - lastpos then set lastpos to i
set ans to max of ans , size of n as long long - lastpos
print ans
declare constant long longs mod = 1e9 + 7 , maxn = 1e4 + 100
declare long long array a size maxn
declare long longs n , m , k
read n , m , k
for i = 1 to n inclusive , read a [ i ]
for n % 2 is 0 , return print 0 and newline , 0
declare long long op = m / ( ( n + 1 ) / 2 )
let op = op * k
declare long long minn = 1000 * 1000 * 1000
for i = 1 to n inclusive , incrementing i by 2 , let minn be minimum of minn and a [ i ]
print minimum of minn and op , newline
create integers n , i , j , sum , nom and integer arrays a with size 1001 , b with size 1001 , c with size 1001 and 1001
read n
for integer i = 1 to n with increment i
for integer j = 1 to 4 with increment j do read c [ i ] [ j ]
for integer i = 1 to n with increment i
set sum to 0
for integer j = 1 to 4 with increment j do add c [ i ] [ j ] to sum
set a [ i ] to sum
set b [ i ] to i
for integer j = 1 to n with increment j
for integer i = j to n - 1 with increment i
if a [ j ] is less than a [ i + 1 ] then
swap a [ j ] and a [ i + 1 ]
swap b [ j ] and b [ i + 1 ]
else if a [ j ] is equal to a [ i + 1 ] then
if b [ j ] is greater than b [ i + 1 ] then swap b [ j ] and b [ i + 1 ]
for integer i = 1 to n with increment i
if b [ i ] is equal to 1 then
set nom to i
break the loop
declare integers a , b , c , d , e , f
read a and b and c and d and e and f
if c is 0 and d is greater than 0 or a is 0 and b * d is greater than 0 or a * c * e is less than b * d * f
print " Ron " , newline
else
print " Hermione " , newline
let a1 , a2 , n , k , second , ans , and ans1 be long long ints with second = 0 and ans = 0
let h be a vector of pairs of long longs and pairs of long longs and long longs
in function read
read n
for i = 0 to n exclusive with x , y , m ints
read k
set second to second + k
read a1
let t be a long long int with value a1
read x and y and m
append the pair 0 and the pair a1 and i + 1 to h
set ans1 to 0
for j = 1 to k exclusive with j preincremented
set a2 to ( a1 * x + y ) mod m
if a2 is less than a1 increment ans1
set a1 to a2
set t to max of t and a1
if size of h is less than or equal to 200000 append the pair ans1 and pair a1 and i + 1 to h
set ans to max of ans and ans1
print ans and newline
if second is less than or equal to 200000
call read
declare integers n , m , a , k = 0 , id = 0 , t
read n and m
for i = 1 to n inclusive
read a
let t be ( a - 1 ) / m + 1
if t is greater than or equal to k
let k be t
let id be i
print id and newline
create a map called m using string and integer
set m [ C ] to 0
set m [ C # ] to 1
set m [ D ] to 2
set m [ D # ] to 3
set m [ E ] to 4
set m [ F ] to 5
set m [ F # ] to 6
set m [ G ] to 7
set m [ G # ] to 8
set m [ A ] to 9
set m [ B ] to 10
set m [ H ] to 11
s = string array
integer as array a with size 3
for i = 0 to less than 3 do the following
read s
set a [ i ] to m [ s ]
sort the values of a to a + 3
integer as x = ( a [ 1 ] - a [ 0 ] + 12 ) modulo 12
integer as y = ( a [ 2 ] - a [ 1 ] + 12 ) modulo 12
integer as z = ( a [ 0 ] - a [ 2 ] + 12 ) modulo 12
if is 3 and y then do the following
else if x is 4 and yis 3 or y is 4 and z is 3 or zis 4 and x is 3 then do the following
else
in the function search which takes an integer array A and integers l , u , target and returns an integer
for i = 1 to u exclusive
if A [ i ] = target then return i
return - 1
n , C = integers
read n and C
R = array of integers of size n
read n values into array R
B = array of integer of size C
Create integer curr_size = 0
Create integer ans = 0
for i = 0 to n exclusive
create integer idx = search ( B , 0 , curr_size , R [ i ] )
if idx is not - 1 then continue
add 1 to ans
if curr_size is less than C
set B [ curr_size ] = R [ i ]
increment curr_size
set idx to 0
create integer d = search ( R , i + 1 , n , B [ idx ] )
if d is not - 1
for j = 1 to C exclusive
create integer curr_d = search ( R , i + 1 , n , B [ j ] )
if curr_d is equal to - 1
set d to curr_d
set idx to j
break
if curr_d is greater than d
assign curr_d to d
set idx = j
set B [ idx ] = R [ i ]
print ans
let n be a long integer
read n
let s be a string
read s
let f be a long integer with f = 0
for long integer i = 0 to n exclusive
if s [ i ] is equal to 1 , f is equal to 1
let second be a string
if f is equal to 1 , push back element 1 in second
for long integer i = 0 to n exclusive
if s [ i ] is equal to 0 , push back element 0 in second
print second and newline
dx = integer array with element in the following order : 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1
dy = integer array with element in the following order : 1 , 0 , - 1 , 0 , 1 , - 1 , 1 , - 1
in function fast the returns nothing
arr = 4 pairs of strings
call fast
s = string
out = string array with the following elements = byte , short , int , long , BigInteger
read s
arr [ 0 ] = - 128 , 127
arr [ 1 ] = - 32768 , 32767
arr [ 2 ] = - 2147483648 , 2147483647
arr [ 3 ] = - 9223372036854775808 , 9223372036854775807
if s [ 0 ] is -
for i = 0 to 4 exclusive
if size of s < size of first letter of arr [ i ] , then return print out i
;
if size of s = size of first letter of arr [ i ]
for j = 1 to size of s exclusive
if s [ j ] > first j of arr [ i ] , then return print out [ i + 1 ] 0
;
if s [ j ] > second j of arr [ i ] , then return print out [ i ] 0
return print out [ i ] 0
;
return print out [ 4 ] 0
;
else
for i = 0 to 4 exclusive
if size of s < second letter of arr [ i ] , then return print out [ i ] 0
;
if size of s is second letter of arr [ i ] , then return print out [ i ] 0
for j = 0 to size of s exclusive
if s [ j ] > second j of arr [ i ] , then return print out [ i + 1 ] 0
;
if s [ j ] < second j of arr [ i ] , then return print out [ i ] 0
;
return print out [ i ] 0
;
print out [ 4 ] 0
;
l = long long array of size 100009
for i = 1 to 100004 , l [ i ] = i * ( i + 1 ) / 2
n = integer
read n
k , r = long long with k = 1 , r = 100000
while k < = r
if l [ k ] + l [ r ] is n
else if l [ k ] + l [ r ] < n
increment k
else
decrement r
declare constant integer Maxn = 1e5 + 100
declare integers n , m , integer array a size Maxn
declare boolean array mark size 2 by Maxn
declare integer vector nei size 2 by Maxn
delare dfs initialized with integers x and v
for i = 0 to integer casted size of nei [ x ] [ v ] exclusive
declare integer u = nei [ x ] [ v ] [ i ]
if not mark [ x ] [ u ]
let mark [ x ] [ u ] be true
if x is 0 or a [ u ] is not 1 , run dfs with x , u as arguments
read n and m
for i = 0 to n exclusive , read a [ i ]
for i = 0 , u , v to m exclusive
read u and v
add ( v - 1 ) to end of nei [ 0 ] [ u - 1 ]
add ( u - 1 ) to end of nei [ 1 ] [ v - 1 ]
for i = 0 to n exclusive
if a [ i ] is 1 and not mark [ 0 ] [ i ]
let mark [ 0 ] [ i ] be true , run dfs with 0 , i as arguments
else if a [ i ] is 2 and not mark [ 1 ] [ i ]
let mark [ 1 ] [ i ] be true , run dfs ( 1 , i )
for i = 0 to n exclusive
if mark [ 0 ] [ i ] and mark [ 1 ] [ i ]
print 1 and newline
else
print 0 and newline
create ints n and k
declare string s
read n and k
read s
declare string variables a and b
declare int flag = 0
for integer i = 0 to n - 1 exclusive
if substring of a from the start to i + 1 = substring of n from position n - i - 1 to the end , set flag to i + 1
print s
loop i from 1 to k exclusive , print substring of from position flag to the end
print new line
INF = const int with INF = 0x3f3f3f3f
PI = const double with PI = acos of - 1 . 0
N = const int with N = 100 + 3
n = int
read n
v = int array of size N
ans = long long array of size N
for i = 1 to n inclusive read v [ i ]
for i = 1 to n inclusive
cont = int with cont = 1
j = int with j = v [ i ]
loop while j is not i and cont is less than 103
increment cont
set j to v [ j ]
set ans [ i ] to cont
if ans [ i ] is even then set ans [ i ] to ans [ i ] / 2
mmc = long long with mmc = ans [ 1 ]
for i = 1 to n inclusive
if ans [ i ] is 103
print - 1
set mmc to ( mmc * ans [ i ] ) / __gcd of mmc and ans [ i ]
print mmc
n , x , y = integers and a , b = arrays of integers size 100 and c = array of integer size 500
read n
j = integer with j = 1
for i = 1 to n * n inclusive do the following
read x , y
if a [ x ] is 0 and b [ y ] is 0 do the following
a [ x ] = 1
b [ y ] = 1
c [ j ] = 1
increment j
print c [ 1 ]
for i = 2 to j exclusive print a space and c [ i ]
print a new line
flag = long long with flag = 0
let a be string
define check with takes long long i and k
for long long j = i to i + k exclusive
if s [ j ] ! = s [ 2 * i + k - 1 - j ]
set flag = 1
read s
let n , k be long long integer with n = length of s
read k
if n mod k ! = 0
print NO with newline
for long long i = 0 to n exclusive with increment of n / k , call check with i and n / k
if flag is equal to 1
print NO with newline
else
print YES with newline
create new string s
create new ints n and k
read standard input to s and k
change the value of n to length of s
if n % k is not 0
print " NO \ n " to the standard output
set k to n / k
in a for loop , change st from 0 to n exclusive adding k to st
create integer variable with name dr and value st + k - 1
create strings a and b
start for loop from i = st to dr inclusive , changing a to the sum of a and s [ i ] on each iteration
change the value of b to a
reverse the string b
if a ! = b
print " NO \ n " to the standard output
print " YES \ n "
let the const integer value of maxn = 1 . 5e7 + 5
a = array of integers of length maxn , num = array of integers of length maxn
let n , i , j , h be integers
read n
let g , m , ans be integers with m = 0 , ans = n
for i = 1 to n inclusive
read h
if i equals 1
g is equal to h
g is equal to __gcd ( g , h )
increment num [ h ] by 1
if h is greater than m , m is equal to h
for i = g + 1 to m inclusive
if a [ i ] equals 0
the integer value of cnt = 0
for j = i , j < = m , increment j by i , a [ j ] = 1 , increment cnt by num [ j ]
ans is equal to minimumof ans and n - cnt
if ans equals n
print - 1 and newline
print ans and newline
integer as array m of size 12 = 3 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 2 , 3
a , b = string array
read a , b
integer as a1 , b1
if a is monday then a1 = 1
if a is tuesday then do the following a1 = 2
if a is wednesday then do the following a1 = 3
if a is thursday then do the following a1 = 4
if a is friday then do the following a1 = 5
if a is saturday then do the following a1 = 6
if a is sunday then do the following a1 = 0
if b is monday then do the following b1 = 1
if b is tuesday then b1 = 2
if b is wednesday then make b1 = 3
if b is thursday then do the following b1 = 4
if b is friday then b1 = 5
if b is saturday b1 = 6
if b is sunday then do the following b1 = 0
for i = 0 to less than 12 do the following
if is a1 + m [ i ] modulo 7 is b1 then do the following
n , p = int
v = int vector
s25 , s50 = int stack
read n
for i = 0 to n
read p
append p to v
if v [ 0 ] is not 25
print " NO "
for i = 0 to n
if v [ i ] is 25
append v [ i ] to s25
continue
if v [ i ] is 50
if s25 is empty
print " NO "
append v [ i ] to s50
pop s25
if v [ i ] is 100
if size of s25 is 0
print " NO "
if size of s25 < 3 and size of s50 is 0
print " NO "
if s50 is empty
pop s25
pop s25
pop s25
else
pop s25
pop s50
print " YES "
let a , b , i , j = integers with i = 0 and k = array of integers with size = 4
let ch = array of characters with size = 6
read ch
set a = ( ch [ 0 ] - 48 ) * 10 + ch [ 1 ] - 48
set b = ( ch [ 3 ] - 48 ) * 10 + ch [ 4 ] - 48
set k [ 0 ] = a / 10
set k [ 1 ] = a % 10
set k [ 2 ] = b / 10
set k [ 3 ] = b % 10
if k [ 0 ] is k [ 3 ] and k [ 1 ] is k [ 2 ] print 0
while k [ 0 ] is not equal to k [ 3 ] or k [ 1 ] is not equal to k [ 2 ] do the following
increment i
increment b
ifb is greater than or equal to 60 do the following
set b = 0
if a is 23
set a = 0
else if a is less than 23
incrementa
set k [ 0 ] = a / 10
set k [ 1 ] = a % 10
set k [ 2 ] = b / 10
set k [ 3 ] = b % 10
if k [ 0 ] is k [ 3 ] and k [ 1 ] is k [ 2 ] do the folllowing
print i
exit the loop
create int n , x and cnt , set cnt to 0
read n
if n = 1
read x
if x = 1
for i = 0 to n exclusive
read x
if x = 0 , increment cnt
if cnt greater than 1
print NO and a newline
if cnt = 1
else
print N = and a newline
PI = constant double = acos ( - 1 . 0 )
MODPRIME = constant long long = 1e9 + 7 in long long form
MAXX = constant long long = 1e18 in long long form
MINN = constant long long = - 1e18 in long long form
EPS = constant double = 1e - 9
MAXN = constant integer = 5e5
N , ans = integer
arr = integer array of size MAXN + 5
read N
for i = 0 to N exclusive , read a [ i ]
i = integer = 1
while i < N - 1
cek = boolean = the result of arr [ i ] is not arr [ i - 1 ] and arr [ i ] ! = arr [ i + 1 ]
if cek is false
increase i by 1
else
cprev = integer = arr [ i - 1 ]
j = integer = i + 1
curr = integer = 1
while j < N - 1 and ( arr [ j ] is not arr [ j - 1 ] and arr [ j ] is not arr [ j + 1 ]
increase j by 1
increase curr by 1
if curr is even
ans = bigger value between ans and curr / 2
idx = integer = i
for k = 0 to curr / 2 exclusive
arr [ idx ] = cprev
increase idx by 1
for k = 0 to curr / 2 exclusive
arr [ idx ] = arr [ j ]
increase idx by 1
else
ans = bigger value between ans and ( curr + 1 ) / 2
for k = i to j - 1 inclusive , then arr [ k ] = cprev
i = j
for i = 0 to N exclusive
pritn arr [ i ]
print endline if i is N - 1 else print space character
n = integer
read n
horizontal = boolean of size n + 1
vertikal = boolean of size n + 1
theyareworking = boolean of size n * n + 1
for i = 1 to n inclusive
v , h = integer
read h , v
if horizontal [ h ] is false and vertikal [ v ] is false
theyareworking [ i ] = true
horizontal [ h ] = true
vertikal [ v ] = true
hihi = boolean = false
for i = 1 to n * n inclusive
if theyareworking [ i ] is true
if hihi is false
print i
hihi = true
else
print i
print endline
let p , x , y , i , k be integers
while read x , y
if x is equal to 0 and y is equal to 0
k is equal to 0
p is equal to maximum of absolute value of x and absolute value of y
k is equal to ( p - 1 ) * 4
if x is equal to p and y is greater than 1 - p and y < = p
increment k by 1
else if y is equal to p and x > = - p and x < = p
increment k by 2
else if x is equal to - p and y > = - p and y < = p
increment k by 3
else if y is less than 0 and x is greater than y and x < = - y
increment k by 4
print k and newline
let x , y and sum be ints with sum = 0
read x and y
if x > y and x < = - y
assign - y * 4 to sum
else if y > x and x > = - y
assign - 2 + y * 4 to sum
else if y > = x and x is less than - y
assign - 1 - x * 4 to sum
else if x > y and x < = - y + 1
change sum to - y * 4
else if y < = x and x is greater than - y + 1
set sum to - 3 + x * 4
print sum
declare constant integer MAXN = 1e + 6 + 50
declare integer n
declare integer array num size MAXN
while read n is true
set bytes from num to size of num to value 0
declare integer temp
declare integer m = 0
for i = 1 to n inclusive
read tep
let m be maximum of m and temp
increment num [ temp ]
for i = 0 to m inclusive
if num [ i ] is 0 , end current loop iteration
declare temp = num [ i ] / 2 as integer
increment num [ i + 1 ] by temp
decrement num [ i ] by temp * 2
while num [ m + 1 ] is not 0
declare integer temp = num [ m + 1 ] / 2
increment num [ m + 2 ] by temp
decrement num [ m + 1 ] by temp * 2
increment m
declare ans = 0 as integer
for i = 0 to m inclusive , increment ans by num [ i ]
print ans and newline
n , k = int
read n , k
s = string
c = char
i = 0 , c = ' a ' , while i < n ( incrementing i and c at end of while )
if c > = ( ' a ' + k ) c = ' a '
add c at end of s
print s
define empty function init
call init ( )
n is a new integer
read input to n
create new string s
read from the input to s
for i from 0 to n / 2 exclusive incrementing i
if s [ i ] = ' L '
print i + 1 , " " and n / 2 + i + 1
else
print n / 2 + i + 1 , " " and i + 1
print ' \ n ' to the standard output
create integers n , m
declare log7 with integer x as argument
create integer res with res = 0
if x is 0 , return 1 from function
while x is true
set x to x / 7
increment res
return res from function
declare base10 with integer x as argument , returning integer
create integers spow , res with spow = 1 , res = 0
while x is rue
increment res by spow * ( x % 10 )
set x to x / 10
set spow to spow * 7
return res from function
create map vis from pair of ( integer and integer ) to boolean
create integer ans
declare solve with integer sz as argument , returning void
create integer vector p
for i = 0 to 7 exclusive , add element i to end of p
start loop
create integers x , y
set x to y to 0
for i = 0 to result of run log7 with n as argument exclusive
set x to x * 10
increment x by p [ i ]
for i = result of run log7 with n as argument to sz exclusive
set y to y * 10
increment y by p [ i ]
if n is greater than or equal to result of run base10 with x as argument and m is greater than or equal to result of run base10 with y as argument
if not vis [ make pair from ( x , y ) ]
increment ans
set vis [ make pair from ( x , y ) ] to true
while result of run next_permutation with beginning of p , end of p as arguments is true
read n read m
decrement n
decrement m
create integer sz with sz = result of run log7 with n as argument + result of run log7 with m as argument
if sz is greater than 7
print 0 print newline
run solve with sz as argument
print ans print newline
a , b = string
read a
set b to a
x , y , z = long long int with x = 0 and y = 0 and z = 0
i = long long int
for i = 0 to size of a
if a [ i ] is ' a ' increment x
if a [ i ] is ' b ' increment y
if a [ i ] is ' c ' increment z
if b is a and ( z is x or z is y ) and x is not 0 and y is not 0 and z is not 0
print " YES "
else
print " NO "
declare string s
read s
declare long long integer total = size of s - 2
declare long long integer cont = 0
declare long long integers primer , segun , tercer
for i = 0 to long long integer casted size of s exclusive
if s [ i ] is ' + ' , let primer be i
if s [ i ] is ' = ' , let segun be i - primer - 1
let tercer be total - segun - primer
if tercer is ( segun + primer )
print s and newline
else
if tercer is ( segun + primer + 2 )
remove ( beginning of s + size of s - 1 ) from s
print " | " and s and newline
else if ( tercer + 2 ) is ( segun + primer )
if primer is greater than or equal to 2
print " + "
for i = 0 to long long integer casted segun exclusive , print " | "
print " = "
print newline
else
for i = 0 to long long integer casted primer exclusive , print " | "
print " + "
print " = "
print newline
else
print " Impossible " and newline
integer as n
read n
output n / 2
for i = 1 to less than or equal to n / 2 - 1 do the following
if n modulo 2 is true
output 3
else
output 2
function bigmod with long long arguments a , p and m that returns long long
if p = 0 , return 1 modulo m
declare new long long called x = result of bigmod ( a , p / 2 , m )
change x to x squared % m
if p is odd , assign ( x * a ) modulo m to x
return x modulo m
create an array of long longs m with 256 elements , q with 266 elements and 2d array v with size 10009 by 266
create new strings a and b
read input to a and b
prepend " " to a
start for loop from i = ' a ' to ' z ' inclusive , setting q [ i ] to length of a on each loop iteration
start for loop from i = length of a to 0 inclusive decrementing i
assign value of 1 to m [ a [ i ] ]
in a for loop , change j from ' a ' to ' z ' inclusive , assigning q [ j ] to v [ i ] [ j ] on each iteration
set value of q [ a [ i ] ] to i
declare new long longs c = 0 and an = 1
for i from 0 to length of b - 1 inclusive incrementing i
if m [ b [ i ] ] is equal to 0 , return 0 and print " - 1 "
assign v [ c ] [ b [ i ] ] to c
if c = length of a
increment an
change c to v [ 0 ] [ b [ i ] ]
print an to the standard output
create character array s with size 100005 create character pointer p
create integer x
read s
if ( p is first occurrence of " AB " in s ) and ( first occurrence of " BA " in p + 2 )
print " YES " print newline
else if ( p is first occurrence of " BA " in s ) and ( first occurrence of " AB " in p + 2 )
print " YES " print newline
else
print " NO " print newline
n , k , i , j = integers
read n , k
a = string with a = abcdefghijklmnopqrstuvwxyz
i = 0
while decrement n
print a [ increment i ]
if ( i is k ) i = 0
print new line
str = string
a , r , b , c , d = int
call getline of cin , str
set a to ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' )
set b to ( str [ 1 ] - ' 0 ' ) * 10 + ( str [ 0 ] - ' 0 ' )
set c to ( str [ 3 ] - ' 0 ' ) * 10 + str [ 4 ] - ' 0 '
if c > b and c < = 59
set str [ 3 ] to str [ 1 ]
set str [ 4 ] to str [ 0 ]
print str
noop
else
goto label top
increment a
if a > 23
set str [ 0 ] to ' 0 '
set str [ 1 ] to ' 0 '
set str [ 2 ] to ' 0 '
set str [ 3 ] to ' 0 '
print str
noop
else
set r to a / 10
if r is 0
set str [ 0 ] to ' 0 '
set str [ 1 ] to a mod 10 + 48
set d to ( str [ 1 ] - ' 0 ' ) * 10 + str [ 0 ] - ' 0 '
if d < = 59
set str [ 3 ] to str [ 1 ]
set str [ 4 ] to str [ 0 ]
print str
noop
else
goto top
else
set str [ 0 ] to r + 48
set str [ 1 ] to a mod 10 + 48
set d to ( str [ 1 ] - ' 0 ' ) * 10 + str [ 0 ] - ' 0 '
if d < = 59
set str [ 3 ] to str [ 1 ]
set str [ 4 ] to str [ 0 ]
print str
else
goto top
maxn = const int with maxn = 1e6
in function gcd taking long long a , long long b and returning long long
if b is 0
return a
else
return gcd of b , a mod b
in function lcm taking long long a , long long b and returning long long
return a * b / gcd of a , b
n = int
loop while reading n
ans = long long
if n > 3
set ans to lcm of lcm of ( n - 2 , n - 1 ) , n
ans2 = long long with ans2 = lcm of lcm of ( n - 3 , n - 1 ) , n
ans3 = long long with ans3 = lcm of lcm of ( n - 3 , n - 2 ) , n - 1
set ans to max of max of ans , ans2 , ans3
else
if n is 1
set ans to 1
else if n is 2
set ans to 2
else if n is 3
set ans to 6
print ans
create int n , k , x , y , set x and y to 0
read n
for i = 0 to n inclusive
read k
if k = 0
increment x
else if k = 1
increment y
if n = 1 and y = 1
else if n = 1 and y different from 1
else if n different from 1 and x = 1
else if n different from 1 and x different from 1
print NO and a newline
define constant integer N = 1e6 + 5
define integer constant mod = 1e9 + 7
dp is a new 2d array of integers 5005 by 5005 elements
declare string variable str1
create new string called str2
function solve with int arguments idx1 and idx2 that returns int
return 1 if idx1 is equal to the length of str1 or idx2 is equal to the length of str2
create new integer reference & ret = dp [ idx1 ] [ idx2 ]
return ret if ~ ret
change ret to solve ( idx1 , idx2 + 1 )
if str1 [ idx1 ] is equal to str2 [ idx2 ] , add the result of solve ( idx1 + 1 , idx2 + 1 ) to ret
if ret > = mod , change ret to ret - mod
return ret
read input to str1 and str2
change values of first sizeofdp bytes at the pointer dp to - 1
create new integer called ans = ( - length of str1 + mod )
start for loop from i = 0 to length of str1 exclusive
increase ans by the result of solve ( i , 0 )
if ans > = mod , change ans to ans - mod
print ans and ' \ n '
let a , b , ans be integers with ans = 0
let ch be a character
read a , ch , b
while the condition is true
if a modulo 10 is equal to b / 10 and a / 10 is equal to b modulo 10 , stop
increment b by 1
if b > = 60
increment a by 1
b is equal to 0
if a > = 24 , a is equal to 0
increment ans by 1
print ans and newline
create integer vector array grafo with size 300000
create boolean array chegou with size 300000
create integer vector passou
create integers n , m
declare dfs with integer v as argument , returning void
set chegou [ v ] to true
add element v to end of passou
for i = 0 to size of grafo [ v ] exclusive
create integer adj with adj = grafo [ v ] [ i ]
if not chegou [ adj ] , run dfs with adj as argument
read n read m
for i = 0 to m exclusive
create integers a , b
read a read b
add element b to end of grafo [ a ]
add element a to end of grafo [ b ]
for i = 1 to n inclusive
if not chegou [ i ]
run dfs with i as argument
create integer mini with mini = size of passou - 1
for c = 0 to size of passou exclusive
if size of grafo [ passou [ c ] ] is less than mini
print " NO \ n "
remove all elements from passou
print " YES \ n "
MAXN = constant integer = 105
arr = long long array of size MAXN
visited = boolean array of size MAXN
v = long long vector
flag = boolean
in function gcd with arguments of long long a and long long b and returns a long long
if b is 0 return a other wise return the result of calling gcd with arguments b and a modulo b
in function dfs with argument of integer beginu and integer u that returns a long long
if arr [ u ] is u
if u is not beginu , then flag = true
if visited [ u ] is nonzero
if u is not beginu , then fkag is true
visited [ u ] is 1
return 1 + the result of calling dfs with arguments beginu and arr [ u ]
n = integer
read n
for i = 1 to n inclusive , then read arr [ i ]
for i = 1 to n inclusive
temp = long long = 0
if arr [ i ] is i
temp = 1
else
temp is the result of calling dfs with arguments of i and i
if temp is 0
push back the values of v and insert a new element of 1 at the end of v
else if temp is even
push back the values of v and insert a new element of temp / 2 at the end of v
else
push back the values of v and insert a new element of temp at the end of v
ans = long long = v [ 0 ]
for i = 1 to size of v exclusive
gcdv = long long = the result of calling gcd with argument of v [ i ] and ans
ans = ans * v [ i ]
ans = ans / gcdv
if flag returns true
print - 1
else
print ans
let v be an int vector
let x and sum = 0 be ints
read x
for i = 0 to x exclusive
y = int
read y
push back y in v
min = int = ( the minimum element of v ) - beginning of v
for i = min to x - 1 exclusive
if v at min = v at i + 1 then set min to i + 1
increment sum by x - 1 - min
for i = min to x - 1 exclusive then call iter swap with args v . begin + i , v . begin + i + 1
set int max = ( the maximum element in v ) - beginning of v
for i = max to 0 exclusive , decrementing i
if v at max = v a t i - 1 then set mni to i - 1
increment sum by max
print sum
create long long int a , s , d , f , g
read a , s , d , f and g
create long long int k , l , j , h , n , b , m , set k to 0
if d > s or f < a
print 0
else
if a > d
set j = a
else
assign d to j
if s > f
set h to f
else
assign s to h
set n = h - j
if j < = g and h > = g
print n
else
print n + 1
declare constant integer MAXN = 55
declare integers n , m , area
declare integer array dx = { - 1 , 0 , 1 , 0 }
declare integer array dy = { 0 , 1 , 0 , - 1 }
declare integer array bio size MAXN by MAXN
declare character array grid size MAXN by MAXN
declare valid with integers x , y as arguments , returning boolean
if x is less than 0 or x is greater than or equal to n , return false from function
if y is less than 0 or y is greater than or equal to m , return false from function
return true from function
declare dfs with integers x , y as arguments , returning void
let bio [ x ] [ y ] be 1
for i = 0 to 4 exclusive
declare integer xx = x + dx [ i ]
declare integer yy = y + dy [ i ]
if result of run valid ( xx , yy ) and grid [ xx ] [ yy ] is ' # ' and not bio [ xx ] [ yy ] , run dfs ( xx , yy )
declare nc with no arguments , returning integer
for i = 0 to n exclusive
for j = 0 to m exclusive , let bio [ i ] [ j ] be 0
declare integer bk = 0
for i = 0 to n exclusive
for j = 0 to m exclusive
if grid [ i ] [ j ] is ' . ' , end current loop iteration
if bio [ i ] [ j ] , end current loop iteration
run dfs ( i , j )
increment bk
return bk
read n and m
for i = 0 to n exclusive , read grid [ i ]
for i = 0 to n exclusive
for j = 0 to m exclusive
if grid [ i ] [ j ] is ' # ' , increment area
if area is less than 3
print " - 1 \ n "
else if area is 3
print " 1 \ n "
else
for i = 0 to n exclusive
for j = 0 to m exclusive
if grid [ i ] [ j ] is ' . ' , end current loop iteration
let gird [ i ] [ j ] be ' . '
if result of run nc is greater than 1
print " 1 \ n "
let grid [ i ] [ j ] be ' # '
print " 2 \ n "
create char a [ 1001 ]
create int b , n and p
while read a
m = 0
read b
set len to length of a
n = len / b
if len mod b different from 0
continue
for i = 0 to b exclusive
for j = 0 to n exclusive
set p to n * i + n - j - 1
if a [ j + n * i ] different from a [ p ]
m = 1
break
if m = 1 , break
if m equal to 1
else
arr = array of integers set to length 5000010
n = integer
read n
for i = 0 to n exclusive , read arr [ i + i ]
set arr [ 0 ] to arr [ 1 ]
set arr [ n + 1 ] to arr [ n ]
set ans to 0
strange = boolean set to false
start = integer set to - 1
lef = integer set to - 1
end = integer set to - 1
right = integer set to - 1
mid = integer set to - 1
length = integer set to end - start + 1
for i = 1 to n inclusive
if arr [ i - 1 ] isn ' t arr [ i ] and arr [ 1 + 1 ] isn ' t arr [ i ]
if not strange
set strange to true
set start to i
set left to arr [ i - 1 ]
else
if strange is true
set end to i - 1
set right to arr [ i ]
set length to end - start + 1
set ans = max of ans and length + 1 / 2
set mid to length / 2 + start - 1
for j = start to mid inclusive , set arr [ j ] to left
for j = mid + 1 to end inclusive , set arr [ j ] to right
set strange to false
print ans
for i = 1 to n - 1 inclusive , print arr [ i ]
print arr [ n ]
declare compute taking in const strings & t and & u and returning integer
create int count = 0
for i = 0 to t . length ( ) exclusive
if t [ i ] is equal to u [ i ] , increment count
return count
make strings s and u
read s and u
make string tempstr
for i = 0 to u . length ( ) - 1 exclusive , set tempstr to tempstr + " "
set s to tempstr + s + tempstr
let integer max = 0
for i = 0 to s . length ( ) - u . length ( )
make int temp = compute ( s . substr ( i , u . length ( ) ) , u )
if temp is greater than max , set max to temp
print u . length ( ) - max
let maxn be a constant integer with maxn = 100010
let mo be a constant integer with mo = 1e9 + 7
let ans be a long integer
let f , n , m , h be integers
let a , c , k , sum be integers with a = array of integers of length maxn , c = array of integers of length maxn , sum = array of integers of length maxn
let b , flag , tmp be integers with b = array of integers of length maxn
dp = array of integers of length maxn
let s be a string
let T be a integer
let cas be a integer with cas = 1
while read n , m
n is equal to 2 * n + 1
let ma be a integer with ma = - 1
for i = 0 to n exclusive , read a [ i ]
for i = 1 to n - 1 exclusive
decrement m by 1
decrement a [ i ] by 1
for i = 0 to n exclusive
print a [ i ]
if i is less than n - 1 , print space
print newline
create strings s and t
read s and t
for i = 0 to size of t exclusive , set s to " $ " + s + " $ "
make int ans = 1e9
for i = 0 to s . size ( ) - t . size ( ) + 1 exclusive
make integer cur = 0
for j = 0 to t . size ( ) exclusive
if s [ j + i ] is not equal to t [ j ] , increment cur
set ans to min of ans and cur
let l1 , l2 , r1 , r2 , w be long long
read l1 , r1 , l2 , r2 , w
if l1 is greater than r2 or r1 is greater than l2
print 0
else
if w is greater than or equal to max of l1 , l2 and w is less than or equal to min of r1 , r2
print min of r1 , r2 - max of l1 , l2
else
print min of r1 , r2 - max of l1 , l2 + 1
let n be a integer
a = array of integers of length 200007
b = array of integers of length 200007
while read n
the integer value of p = 1
a [ 1 ] is equal to 1
for i = 2 to n exclusive , read a [ i ]
b [ p + + ] is equal to n
the integer value of t = a [ n ]
if t is not equal to 1
while the condition is true
b [ p + + ] is equal to t
t is equal to a [ t ]
if t is equal to 1 , stop
b [ p ] is equal to 1
for integer i is equal to p , i is greater than 1 , decrement i by 1 , print b [ i ] and space
print b [ i ] and newline
declare integer variables sum , m and n with sum = 0
read n
for i from 1 to n inclusive
read m
add m to sum
if n - sum is equal to min of 1 and n - 1
print " YES "
else
print " NO "
M = const int with M = 1000 + 5
a = int array of size 6
even = int with even = 1
odd = int with odd = 1
for i = 0 to 6
if i is even
set even to even * a [ i ]
else
set odd to odd * a [ i ]
ans = string with ans = if even < odd " Ron " else " Hermione "
if a [ 2 ] is 0 and a [ 3 ] is not 0 set ans to " Ron "
if a [ 0 ] is 0 and a [ 1 ] is not 0 and a [ 2 ] is not 0 and a [ 3 ] is not 0 set ans to " Ron "
print ans
function ch with string argument s that returns integer
create integer variable with name x = 0
return - 100000000 if s [ 0 ] = ' 0 ' and length of s > 1 or length of s > 6 and s ! = " 1000000 "
for i from 0 to length of s exclusive , assign the new value = x * 10 + ( s [ i ] - ' 0 ' ) to x
return x
create new string x
read from the input to x
create integer variable with name l
declare integer variable max = - 1
for i from 1 to l - 1 exclusive incrementing i
in a for loop , change j from i + 1 to l exclusive incrementing j
declare int variables a1 , a2 and a3
change the value of a1 to ch of substring of x from index 0 with length i
change a2 to ch ( substring of s from the start to position j - i )
assign the new value = ch ( x . substr ( j , l - j ) ) to a3
if a1 + a2 + a3 is greater than max , change max to a1 + a2 + a3
print max to the standard output
let MAX be a constant integer MAX = 2e5
pair < pair < long long , long long > , long long > a [ MAX + 9 ]
let n , k , a0 , x , y , m , ans , cnt , t , tmp be long integers
read n
for i = 0 to n exclusive
read k , a0 , x , y , m , the value of t is equal to 0
for j = 0 to k exclusive
if cnt < = MAX , a [ cnt + + ] is equal to { { t , a0 } , i }
tmp is equal to ( a0 * x + y ) modulo m
if tmp is less than a0 and j is not equal to k - 1 , increment t by 1
a0 is equal to tmp
ans is equal to maximum of ans and t
print ans and newline
if cnt < = MAX
sort the values a , a + cnt
declare int variables a , n , m , i , j , p and num ; declare int array t with 200010 elements
read n and m and keep looping
read user input to n consecutive elements of t , starting from the index 1
for i from 1 to n inclusive incrementing i
add t [ i - 1 ] to t [ i ]
assign the new value = t [ i ] / m to num
decrease t [ i ] by num * m
print num
if i ! = n , print ' '
print new line to the standard output
let n , x , a , b , c = long longs
read n
for integer i = 1 to infinity do the following
if ( i * i + 1 ) / 2 is greater than n dothe following
set x = i
exit the loop
for integer i = 1 to x inclusive
set a = i * ( i + 1 ) / 2
set b = ( n - a ) * 2
set c = square root of b
if c * ( c + 1 ) is b and ( b / 2 ) + a is n and a and b do the following
let len be a integer
str = array of characters of length 40
let ans be a long integer
let get_num be a function that accepts integers s , e and returns a long integer value
if e - s is greater than 1 and str [ s ] is equal to 0 , return 1000007
let num be a long integer with num = 0
while s is less than e
num is equal to num * 10 + str [ s ] - 0
increment s by 1
return the value of num
let get_solution be a function that accepts integers a1 , a2 and returns a boolean value
let num1 , num2 , num3 , sum be long integers with sum = 0
num1 is equal to get_num ( 0 , a1 )
num2 is equal to get_num ( a1 , a2 )
num3 is equal to get_num ( a2 , len )
if num1 is greater than 1000000 or num2 is greater than 1000000 or num3 is greater than 1000000 , return false
sum is equal to num1 + num2 + num3
if ans is greater than sum ans is equal to ans else ans is equal to sum
return true
let n be a integer
ans is equal to - 1
read str
len is equal to string length of str
if len is less than 3 or len is greater than 21
print ans and newline
for integer i = 1 to len - 2 inclusive
for integer k = i + 1 to len - 1 inclusive , get_solution ( i , k )
print ans and newline
create integer array d of size 30
create int set ma
make ints a , b , l , and r
read a , b , l , and r
if a is equal to 3 , b is equal to 1 , l is equal to 4 , and r is equal to 10
print 4
create string s
for i = 1 to a , add i - 1 + ' a ' to s
create int x = s . size ( ) - 1
for i = 1 to b , set s to s + s [ x ]
set x to s . size ( ) - 1
for i = 1 to a
set d [ s [ x ] - ' a ' ] to 1
subtract 1 from x
for i = 1 to a
for j = 0 to 26 exclusive
if d [ j ] is equal to 0
set s to s + j + ' a '
set d [ j ] to 1
break loop
set x to s . size ( )
for i = 1 to b , add s [ x ] to s
if r is less than or equal to 2 * ( a + b )
for i = l - 1 to r - 1 , insert s [ i ] - ' a ' into ma
else do
create int xx = l / ( 2 * a + 2 * b )
make int yy = r / ( 2 * a + 2 * b )
if xx is equal to yy
set l to l % ( 2 * a + 2 * b )
set r to r % ( 2 * a + 2 * b )
for i = l - 1 to r exclusive , insert s [ i ] - ' a ' into ma
else if yy is equal to xx + 1
set l to l % ( 2 * a + 2 * b )
set r to r % ( 2 * a + 2 * b )
for i = l - 1 to s . size ( ) exclusive , insert s [ i ] - ' a ' into ma
for i = 0 to r exclusive , insert s [ i ] - ' a ' into ma
else do
for i = 0 to s . size ( ) exclusive , insert s [ i ] - ' a ' into ma
print size of ma
declare boolean function palindrom taking in integer k
let n = integer with value log10 ( k ) + 1
let dig = array of integers size n and i = integer with value 0
while ( K is greater than 0 ) is true do the following
set dig [ increment i ] = k modulo 10
set k = k / 10
let ans = boolean with value true
for integer i = 0 to n / 2 inclusive set ans = ans & dig [ i ] is dig [ n - i - 1 ]
return ans
let p , q = integers
read p , q
let prime = array of boolean size 2000000
set sizeof ( prime ) bytes starting at prime to 0
let sqLIM = integer with value sqrt ( 2000000 )
for integer i = 2 to sqLIM inclusive dothe following
if not prime [ i ] go to start of loop
for integer j = i * i to 2000000 exclusive increment step i set prime [ j ] = false
set prime [ 1 ] = false
let pr , pal , ans = integers with value 0
for integer i = 1 to 2000000 do the following
if palindrom [ i ] is true increment pal
if prime [ i ] is true increment pr
if p * pal is greater than or equal to q * pr set ans = i
read p
str , answ = string , vowels = " AaOoYyEeUuIi "
read str
for i = 0 to size of str exclusive
flag = false
do nothing
for j = 0 to size of vowels exclusive
is char at pos i of str = = vowels [ j ]
flag = true
break
if flag continue
add ' . ' at end of answ
if str [ i ] is uppercase letter
add char ( str [ i ] + ( ' a ' - ' A ' ) ) at end of answ
else
add str [ i ] at end of answ
print answ
declare integer variables n and m
declare float variable k
declare strings skill_name and new_skill
declare integer variable skill_level
read n , m and k
skills is a map of string to int
loop i from 0 to n exclusive
read input to skill_name and skill_level
skill_level = ( ( ( k + 0 . 001 ) * 100 ) * skill_level ) / 100
if skill_level > = 100 , skills . insert ( pair < string , int > ( skill_name , ( skill_level ) ) )
for integer i = 0 to m exclusive
read new_skill
if new_skill is not in the skills , insert new pair < string , int > ( new_skill , 0 ) into skills
print length of skills
it is a new map iterator
moving it through skills , print it - > first and it - > second
n = unsigned long long integer
read n
if ( n < = 127 )
else if ( n < = 32767 )
else if ( n < = 2147483647 )
else if ( n < = 9223372036854775807 )
else
let x , t , a , b , c , d be integers
let e be boolean with e = false
let s be integer with s = 0
read x , t , a , b , c , d
if x = = 0
else
for i = 0 to t exclusive
set s to a - c * i
if s = = x
set e to true
break
for k = 0 to t exclusive
set s to ( a - c * i ) + ( b - d * k )
if s = = x
set e to true
break
else
set s to b - d * k
if s = = x
set e to true
break
if e = = false
else
declare map from string to integer st
let st [ " C " ] be 0
let st [ " C # " ] be 1
let st [ " D " ] be 2
let st [ " D # " ] be 3
let st [ " E " ] be 4
let st [ " F " ] be 5
let st [ " F # " ] be 6
let st [ " G " ] be 7
let st [ " G # " ] be 8
let st [ " A " ] be 9
let st [ " B " ] be 10
let st [ " H " ] be 11
declare string array s size 3
for i = 0 to 3 exclusive , read s [ i ]
declare integer array perm size 3 = { 0 , 1 , 2 }
start loop
declare string a = s [ perm [ 0 ] ]
declare string b = s [ perm [ 1 ] ]
declare string c = s [ perm [ 2 ] ]
delare integer val1 = st [ a ]
declare integer val2 = st [ b ]
declare integer val3 = st [ c ]
while val1 is greater than val2 , increment val2 by 12
while val2 is greater than val3 , increment val3 by 12
declare integer d1 = val2 - val1
declare integer d2 = val3 - val2
if d1 is 3 and d2 is 4
print " minor " and newline
if d1 is 4 and d2 is 3
print " major " and newline
while ( rearrange elements from perm to perm + 3 lexicographically )
print " strange " and newline
create integers x , y , days , work
create boolean arrays asphaltx , asphalty , with asphaltx size 100 , asphalty size 100
create integer array workdays with size 100000
set days to 1
create integer a
read a
for A = 0 to a * a exclusive
read x read y
if asphaltx [ x ] is false and asphalty [ y ] is false
set asphaltx [ x ] to true
set asphalty [ y ] to true
set workdays [ work ] to days
increment work
increment days
for A = 0 to work exclusive
if A is work - 1
print workdays [ A ] print newline
else
print workdays [ A ] print " "
n = long long int
read n
a = long long int array of length n + 5
for i = 1 to n inclusive , read a [ i ]
c = 0 = long long int
for i = 1 to n exclusive
increment c by a [ i ]
j = 1 = long long int
while ( i - 1 ) + j * 2 < n , multiply j by 2
increment a [ i + j ] by a [ i ]
i , n , , ans = integers , a = integer array of size 4 , b = integer array of size 1002
read n
for i = 1 to n
read a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ]
b [ i ] = a [ 1 ] + a [ 2 ] + a [ 3 ] + a [ 4 ]
ans = 1
for i = 2 to n
if ( b [ 1 ] < b [ i ] ) , increment ans
print ans
s = vector of string
b1 = bool array of size 100000
cap = bool array of size 100000
w = string
s1 = string
n = integer
read n
for i = 0 to n exclusive
read s1
for j = 0 to s1 . length ( ) exclusive
if ( s1 [ j ] > = A and s1 [ j ] < = Z ) , s1 [ j ] = s1 [ j ] + a - A
append s1 in s
read w
set all contents of cap to 0
for i = 0 to w . length ( ) exclusive
if ( w [ i ] > = A and w [ i ] < = Z )
cap [ i ] = true
w [ i ] = w [ i ] + a - A
b = bool
set all contents of b1 to 0
for i = 0 to n exclusive
for j = 0 to w . length ( ) exclusive
b = true
if ( j + s [ i ] . length ( ) > w . length ( ) )
b = false
else
for k = j to j + s [ i ] . length ( ) exclusive
if ( w [ k ] is not s [ i ] [ k - j ] ) , b = false
if ( b )
for k = j to j + s [ i ] . length ( ) , b1 [ k ] = true
l = character
read l
for i = 0 to w . length ( ) exclusive
if ( b1 [ i ] )
if ( w [ i ] is not l )
w [ i ] = l
else if ( w [ i ] is not a )
w [ i ] = a
else
w [ i ] = b
for i = 0 to w . length ( ) exclusive
if ( cap [ i ] ) , w [ i ] = w [ i ] + A - a
print w
create integer adj of size 1000 with array of size 1000
declare swap taking in floats & a and & b
if b is less than a
create float temp = b
set b to a
set a to temp
return
declare inside taking in float arrays p of size 2 and s of size 4 with array of size 2 and returning bool
if s [ 0 ] [ 0 ] is equal to s [ 1 ] [ 0 ]
create float l = s [ 0 ] [ 0 ] and u = s [ 2 ] [ 0 ]
swap values of l and u
if p [ 0 ] is less than or equal to u and p [ 0 ] is greater than or equal to 1
set l to s [ 0 ] [ 1 ]
set u to s [ 1 ] [ 1 ]
swap values of l and u
if p [ 1 ] is greater than or equal to 1 and p [ 1 ] is less than or equal to u
return true
otherwise do
return false
else do
return false
else
make floats l = s [ 0 ] [ 1 ] and u = s [ 2 ] [ 1 ]
swap values of l and u
if p [ 1 ] is less than or equal to u and p [ 1 ] is greater than or equal to 1
set l to s [ 0 ] [ 0 ]
set u to s [ 1 ] [ 0 ]
swap values of l and u
if p [ 0 ] is greater than or equal to 1 and p [ 0 ] is less than or equal to u
return true
else
return false
otherwise
return false
make float arrays p1 of size 4 with array of size 2 and p2 of size 4 with array of size 2
for i = 0 to ( 4 ) exclusive
for j = 0 to ( 2 ) exclusive , read p1 [ i ] [ j ]
for i = 0 to ( 4 ) exclusive
for j = 0 to ( 2 ) exclusive , read p2 [ i ] [ j ]
create bool ans = false
for i = 0 to ( 4 ) exclusive
if inside ( p2 [ i ] , p1 ) is truthy , set ans to true
make float array p of size 2 containing { 0 , 0 }
for i = 0 to ( 4 ) exclusive
set p [ 0 ] to p [ 0 ] + p2 [ i ] [ 0 ]
set p [ 1 ] to p [ 1 ] + p2 [ i ] [ 1 ]
set p [ 0 ] to p [ 0 ] * 1 . 0 / 4
set p [ 1 ] to p [ 1 ] * 1 . 0 / 4
if inside ( p , p1 ) is truthy , set ans to true
for i = 0 to ( 4 ) exclusive
make floats x = p1 [ i ] [ 0 ] - p1 [ i ] [ 1 ] and y = p1 [ i ] [ 0 ] + p1 [ i ] [ 1 ]
set p1 [ i ] [ 0 ] to x
set p1 [ i ] [ 1 ] to y
for i = 0 to ( 4 ) exclusive
make floats x = p2 [ i ] [ 0 ] - p2 [ i ] [ 1 ] and y = p2 [ i ] [ 0 ] + p2 [ i ] [ 1 ]
set p2 [ i ] [ 0 ] to x
set p2 [ i ] [ 1 ] to y
for i = 0 to ( 4 ) exclusive
if inside ( p1 [ i ] , p2 ) is truthy , set ans to true
if ans is truthy
print " YES \ n "
else do
show " NO \ n "
n is a new integer
read n from the input
print n / 2 to the standard output
start a loop from i = 0 to n / 2 - 1 exclusive , and print " 2 " on each loop iteration
if n is odd
print " 3 "
else
print " 2 "
declare integer variables n , m and k
read standard input to n , m and k
declare new long long variable mi with value INT_MAX
start for loop from i = 1 to n inclusive incrementing i
declare long long variable a
read from the input to a
if i is odd , assign min of mi and a to mi
if n is even
print 0 and " \ n "
else
ans is a new long long = n / 2
increment ans
assign the new value = m / ans to ans
set ans to ans multiplied by k
set ans to min of mi and ans
print ans and " \ n " to the standard output
long long = ( long long a , long long b )
if a is 0 then do the following return b
return gcd1 ( b modulo a , a )
long long = ( long long base , long long ex )
long long = ans = 1LL , val = base
if ex is greater than 0LL then do the following
if ex & 1LL is true
set val to ( val * val ) modulo 1000000009LL
set ex to ex > > 1LL
return ans
integer = t integer maxn = 1e5 + 10
make boolean visit and visit1 with size of maxn
integer = n , m , x , y , a [ maxn ]
make boolean d and p with size maxn
create vector of adj and v with size maxn
declare function dfs with input start
set visit [ start ] to true
for i = 0 to less than adj [ start ] . size ( ) do the following
integer as pt = adj [ start ] [ i ]
if visit [ pt ] is false then run dfs ( pt )
integer = dfs2 ( integer start )
set visit1 [ start ] to true
for i = 0 to less than v [ start ] . size ( ) do the following
integer = pt = v [ start ] [ i ]
if ! visit1 [ pt ] is true
read n , m
for i = 1 to less than or equal to n do the following
for i = 1 to less than or equal to m do the following
read x , y
add new element y to end of vector adj [ x ]
if a [ x ] is not equal to 1 and a [ y ] then do the following
for i = 1 to less than or equal to n do the following
if ! visit [ i ] and a [ i ] is 1 then do the following dfs ( i
for i = 1 to less than or equal to n do the following
if ! visit1 [ i ] and a [ i ] is 2 then do the following dfs2 ( i
for i = 1 to less than or equal to n do the following
if a [ i ] is not equal to 1 then continue
for j = 0 to less than adj [ i ] . size ( ) do the following
integer as pt = adj [ i ] [ j ]
if visit1 [ pt ] and a [ pt ] is not equal to 1 then do the following visit1 [ i ] = true
for i = 1 to less than or equal to n do the following
if visit1 [ i ] and visit [ i ] is true
output 1
else
output 0
declare long longs n and m
let vis be boolean array with size 10
declare long long variable ans = 0
create integers p1 and p2
declare int array d with size 10
ok is a boolean function
declare long long res1 = 0
for i from 0 to p1 exclusive
multiply res1 by 7
increase res1 by d [ i ]
declare long long res2 = 0
loop i from 0 to p2 exclusive
multiply res2 by 7
increase res2 by d [ p1 + i ]
if res1 > = n or res2 > = m
return false
else
return true
void function dfs with integer argument dep
create integer tmp = dep
if dep is equal to p1 + p2
if ok ( ) returned true , increment ans
return
for integer i = 0 to 7 exclusive
if vis [ i ] is false
set d [ dep ] to i
set vis [ i ] to 1
call dfs with argument dep + 1
set vis [ i ] to 0
set d [ dep ] to - 1
int function cal with int argument x
create integer cnt = 0
while x > 0
divide x by 7
increment cnt by one
return cnt
set sizeof ( vis ) bytes at the pointer vis to 0
set sizeof ( d ) bytes at the pointer d to - 1
read n and m
change p1 to cal ( n - 1 )
change p2 to cal ( m - 1 )
if n is 1 , increment p1
if m is 1 , increment p2
if p1 + p2 is greater than 7
print " 0 "
call dfs with argument 0
print ans
in function read taking a reference to an int x
ch = char with ch = value of getchar
f = bool with f = false
set x to 0
loop while ch is greater than ' 9 ' or less than ' 0 '
if ch equals ' - ' then set f to 1
set ch to result of getchar
loop while ch is greater or equal to ' 0 ' and less or equal to ' 9 '
set x to x * 10 + ch - 48
set ch to result of getchar
if f is not 0 then set x to - x
in function read taking a reference to a long long x
ch = char with ch = result of getchar
f = bool with f = false
set x to 0
loop while ch is greater than ' 9 ' or less than ' 0 '
if ch equals ' - ' then set f to 1
set ch to result of getchar
loop while ch is greater or equal to ' 0 ' and ch is less or equal to ' 9 '
set x to x * 10 + ch - 48
set ch to result of getchar
if f equals true set x to - x
parent = int array of size 150001
ranks = int array of size 150001
sizeedge = long long array of size 150001
size = long long array of size 150001
in function build taking an int n
for i = 0 to n inclusive set parent [ i ] to i and size [ i ] to 1
in function find taking an int x and returning an int
set parent [ x ] to x if parent [ x ] equals x else set it to find of parent [ x ] and return parent [ x ]
in function merge taking two ints x and y
set x to find of x and set y to find of y
if ranks [ x ] is greater than ranks [ y ] then call swap on x and y
if ranks [ x ] equals ranks [ y ] then increment ranks [ y ]
if x does not equal y
set parent [ x ] to y
add size [ x ] to size [ y ]
add sizeedge [ x ] + 1 to sizeedge [ y ]
else
increment sizeedge [ y ]
v , e = int
call read of v
call read of e
call build of v
for i = 0 to e
from , to = int
call read of from
call read of to
call merge of from and to
for i = 1 to v inclusive
if i equals the result of find of i
if sizeedge [ i ] does not equal size [ i ] * ( size [ i ] - 1 ) / 2
call puts of " NO "
call puts of " YES "
x is an integer array of size 2000
n is an integer
read n
i is an integer
for i = 0 to n exclusive , read x [ i ]
a , b , k are integers
for i = 0 to n - 1 exclusive
set a to x [ i ]
set b to x [ i + 1 ]
if a is less than b
for k = 0 to i exclusive
else
else
else
for k = 0 to i exclusive
else
else
s = char array of size 500005
read s
dp1 , dp2 = int array of size 500005 each and idx1 , idx2 = int with idx1 = 0 and idx2 = 00
for i = 0 to strlen of s
if s [ i ] is ' A ' and s [ i + 1 ] is ' B '
set dp1 [ idx1 ] to i then increment idx1
else if s [ i ] is ' B ' and s [ i + 1 ] is ' A '
set dp2 [ idx2 ] to i then increment idx2
flag = bool with flag = false
for i = 0 to idx1
for j = 0 to idx2
if absolute of dp2 [ j ] - dp1 [ i ] is greater than 1
set flag to true
break
if flag is true
print " YES "
else
print " NO "
declare n as integer
declare character array s size 100
while read n is true
declare flag = 1 as integer
for i = 0 to n exclusive , read s [ i ]
for i = 0 to n - 1
if s [ i ] is not ' ? ' and s [ i ] is s [ i + 1 ]
let flag be 0
goto jump point here
if flag is true
for i = 0 to n exclusive
if s [ i ] is ' ? '
if i is 0 or i is n - 1 , go to jump point there
if s [ i + 1 ] is ' ? ' , go to jump point there
if s [ i - 1 ] is s [ i + 1 ] , got to jump point there
mark jump point here
print " No " , newline
exit loop iteration
mark jump point there
print " Yes " , newline
arr = int array of size 10000
v = int vector
brr = int array of size 10000
n = int
read n
for i = 1 to n inclusive
m = int
read m
set arr [ i ] to m
append m to v
idx , cur = int with idx = 1
for i = n - 1 to 0 inclusive decrementing i
if i is n - 1
set cur to v [ i ]
set brr [ idx ] to v [ i ]
else
if cur is not v [ i ]
set brr [ idx ] to v [ i ]
set cur to v [ i ]
increment idx
for i = 1 to n inclusive
for j = 1 to n inclusive
if arr [ i ] is brr [ j ] and arr [ i ] is not 0 and brr [ j ] is not 0
if i is n
print j
else
print j then " "
mark is a new array of booleans with size 4000002
parza is a boolean function with long long argument n
for i = 2 to n inclusive
return false if n can be divided by i without a remainder
return true
declare long long variable with name n
for i from 2 to 4000000 inclusive incrementing i
if mark [ i ] is false
in a for loop , change j from 2 * i to 4000000 inclusive increasing j by i and assigning true to mark [ j ] on each loop
read standard input to n
if parza ( n ) is true
print 1 , new line and 0 to the standard output
start for loop from i = 2 to 4000000 inclusive
if mark [ i ] is false
if n can be divided by i without a remainder
declare new long long called k with value n / i
if parza ( k ) returns true
print 2
print 1 to the standard output
for j = 2 to 4000000 inclusive
if mark [ j ] is false and k modulo j is 0
print i * j to the standard output
create integers i , j , k , m , n , and l and integer array of size 20000
create char arrays a of size 20000 , b of size 20000 , c of size 20000 , and d of size 20000
for i = 0 to 2000 exclusive , set ans [ i ] to 0
read a
read d
set m to strlen ( d )
for i = 0 to m - 1 exclusive , set b [ i ] to ' '
append a to b
set n to length of b
for i = n to m + n - 1 exclusive , set b [ i ] to ' 0 '
set l to m
for i = 0 to n exclusive
for k = i to i + 1 exclusive , set c [ k - 1 ] to b [ k ]
for j = 0 to l exclusive
if d [ j ] is equal to c [ j ] , increment ans [ i ]
sort ans using argument ans + n + 1
print m - ans [ i ]
long long integer as , m , a , d , i , lp , lst , io , ans , rao
long long integer array x size of 300002
read n , m , a , d
set lst to - 1
set lp to 1
for = 1 to less than or equal to m do the following
if lst + d > = x [ i ] and lst is not equal to - 1 then continue
if lp is less than or equal to n and a * lp is less than x [ i ] then do the following
set io to d / a + 1
set rao to minimum of n and ( x [ i ] - 1 ) / a )
ans equals ans plus ( rao - lp + io ) / io
set lst to ( lp + ( ( rao - lp + io ) / io ) * io - io ) * a
minus 1 from i
else
add one to ans
set lst to x [ i ]
set lp to ( lst + d ) / a + 1
set lp to minimum of lp , n + 1
set io to d / a + 1
ans equals ans plus ( n - lp + io ) / io
output ans
a is a new array of integers with 250005 elements
declare new array of integers b with size 505
f = map from integers to integers
declare new integer called n
read n from the input
read n * n elements from the input into a , starting from the index 1
for i = 1 to n * n inclusive increment f [ a [ i ] ]
set b [ 1 ] to a [ 1 ]
create new int to int map iterator itr
decrease f [ b [ 1 ] ]
create new integer idx = 1
start for loop from i = 2 to n squared inclusive
if f [ a [ i ] ] is greater than 0
increment idx by one
change the value of b [ idx ] to a [ i ]
decrement f [ a [ i ] ]
in a for loop , change j from 1 to idx exclusive , decreasing f [ __gcd ( b [ idx ] , b [ j ] ) ] by 2 on each iteration
if idx is equal to n , break the loop
for i = 1 to n inclusive
if i = 1
print b [ i ] to the standard output
else
print ' ' and b [ i ]
print new line
n , p are integers
read n , p
let a be a string
let b be an integer set to 97
for i = 0 to n exclusive , add 97 + i modulo p to a
display a
n = int
s = string
let , any = string
a = array of 128 string
need = array of 128 int
read n
for i = 0 to n exclusive read a [ i ]
read s
read let
for i = 0 to n exclusive
for j = 0 to size of s - size of a [ i ] inclusive
s1 = substring of j from size of a [ i ]
for k = 0 to size of s1 exclusive
if s1 [ k ] is an uppercase letter append ' a ' - ' A ' to it
s2 = a [ i ]
for k = 0 to size of s2 exclusive
if s2 [ k ] is an uppercase letter append ' a ' - ' A ' to it
if s1 is s2
for k = 0 to size of s1 exclusive need [ j + k ] = 1
if let is " a "
any = " b "
else
any = " a "
for i = 0 to size of s exclusive
if need [ i ]
if s [ i ] is let [ 0 ] or let [ 0 ] + ' A ' - ' a '
if s [ i ] is an uppercase letter
s [ i ] = ' A ' - ' a ' + any [ 0 ]
else
s [ i ] = any [ 0 ]
else
if s [ i ] is an uppercase letter
s [ i ] = ' A ' - ' a ' + let [ 0 ]
else
s [ i ] = let [ 0 ]
print s
declare integers n , i , integer arrays a size 1111111 , d size 1111111
declare long long ans = 0
read n
for i = 0 to n exclusive , read a [ i ]
let d [ 1 ] be 1
for i = 2 to n exclusive , let d [ i ] be d [ i / 2 ] * 2
for i = 0 to i + 1 is less than n
increment a [ i + d [ n - i - 1 ] ] by a [ i ]
increment ans by a [ ii ]
print ans and newline
a , ans , n , sum = long long with ans = 0 and sum = 0
s = string
read a then s
set n to size of s
b = long long vector of size n
for i = 0 to n set b [ i ] to s [ i ] - ' 0 '
rep = int vector of size 36001 with all values set to 0
for i = 0 to n
set sum to 0
for j = i to n
increment sum by b [ j ]
increment rep [ sum ]
for i = 0 to n
set sum to 0
for j = i to n
increment sum by b [ j ]
if sum is 0
if a is 0 increment ans by n * ( n + 1 ) / 2
else if a is a multiple of sum and a / sum < 36001
increment ans by rep [ a / sum ]
N , INF = const int with N = 5e6 + 10 and INF = 1e9
n , ans = int and k = int array of size N
read n
for i = 0 to n
w = int
read w
increment k [ w ]
for i = 0 to N - 5
increment k [ i + 1 ] by k [ i ] / 2
increment ans by k [ i ] mod 2
maxn = 100000 = const int
let a , b , n , r = 1 , ans be ints with a , b both arrays of length maxn
read n
read a form 1 to n inclusive
sort a form 1 to n inclusive
for i = 1 to n inclusive
while r < = n and a [ r ] < = a [ i ] , increment r
if r < = n then increment both ans and r
print ans
create integer set ss
create integer array a with size 100010
create integers n , k
read n read k
for i = 1 to n inclusive , read a [ i ]
sort elements from a + 1 to a + n + 1
create integer ans with ans = 0
for i = n to 1 inclusive , decrementing i
if not count of a [ i ] in ss
increment ans
if a [ i ] % k is 0 , insert a [ i ] / k into ss
print ans print newline
integers = n
set int files to 0
set int f to 0
set int sum [ 500 ] to 0
set int index to 0
read n
integers = a
if n is not equal to 0 then do the following
read a
if a is less than 0 then increment f by 1
if f is 3 then do the following
files equals files plus 1
set f to 1
index equals index plus 1
sum [ index ] equals sum [ index ] plus 1
files equals files plus 1
output files , endl
for i = 0 to less than files - 1 then ouput sum [ i ] and a space
output sum [ files - 1 ]
let a be an int array of length 250010
In function gcd which takes ints x and y and returns an int
if x is 0 return y , else return gcd of y mod x and x
let n be an int
read n
for i = 0 to n * n exclusive , read a [ i ]
call sort on a , a + n * n , greater < int > ( )
let ma be a map from int to int
for i to n * n exclusive
let tmp be an int with value i
let x be an int with value a [ i ]
while a [ i + 1 ] is a [ I ] and i + 1 ia less than n * n , increment i
set ma [ x ] to i - tmp + 1
let ans be a vector of ints
let it be an iterator with value ma . end ( )
decrement it
let x be an int with value it - > first
append x to ans
decrement ma [ x ]
if ma [ x ] is 0 , erase x from ma
while ma is not empty
set it to ma . end ( )
decrement it
set x to it - > first
decrement ma [ x ]
if ma [ x ] is 0 , erase x from ma
append x to ans
let len be an int with value ans . size ( )
let g be an int
for i = 0 to len - 1 exclusive
set g to gcd ( x , ans [ i ] )
subtract 2 from ma [ g ]
if ma [ g ] is 0 erase g from ma
let len be an int with value ans . size ( )
for I = 0 to len - 1 exclusive , print ans [ I ] and a space
print ans [ len - 1 ]
create int n
read n
create int a [ n ]
set count25 , count50 and count100 to 0
for i = 0 to n exclusive , read a [ i ]
create int i
for i = 0 to n exclusive
if i = 0 and a [ i ] = 50
break
else if a [ i ] = 25
increment count25
else if a [ i ] = 50
if count25 = 0
print NO and a newline
break
else
decrement count25
increment count50
else if a [ i ] = 100
if count50 > 0 and count25 > 0
decrement count50
decrement count25
else if count25 > = 3
set count25 to count25 - 3
else
break
if i = n , print YES
declare integer n
declare character array str size 1005
read n
read str
for i = 0 to n exclusive
if str [ i ] is str [ i + 1 ] and str [ i ] is not ' ? '
print " No " and newline
for i = 1 to n - 1 exclusive
if str [ i ] is ' ? '
if str [ i - 1 ] is str [ i + 1 ] or str [ i + 1 ] is ' ? '
print " Yes " , newline
if str [ 0 ] is ' ? ' or str [ n - 1 ] is ' ? '
print " Yes " , newline
print " No " , newline
mp = map from long long to long long
let n be a long integer
read n
a = array of long integers of length n + 1
let i be a long integer
for i = 1 to n inclusive , read a [ i ]
let ans be a long integer with ans = 0
let maxx be a long integer with maxx = 0
let j be a long integer with j = 1
for i is equal to 1 , i is less than n
if a [ i + 1 ] is equal to ( a [ i ] + 1 )
increment i by 1
if i is equal to j
increment ans by ( i - j )
if maxx is less than ( i - j ) , maxx is equal to i - j
increment ans by i - j - 1
if maxx is less than ( i - j - 1 ) , maxx is equal to i - j - 1
increment i by 1
j is equal to i
if i is not equal to j
increment ans by i - j - 1
if maxx is less than ( i - j - 1 ) , maxx is equal to i - j - 1
for i is equal to 1 , i < = n
if a [ i ] is equal to i
increment i by 1
stop
if maxx is less than ( i - 2 ) , maxx is equal to i - 2
j is equal to 1000
for i is equal to n , i > = 1
if a [ i ] is equal to j
decrement i by 1
decrement j by 1
stop
if ( 1000 - j - 1 ) is greater than maxx , maxx is equal to 1000 - j - 1
print maxx and newline
create constant integer variable MAXN with value 101
define integer arrays colo and num with size MAXN
mark is a new array of integers with size MAXN
create a map from characters to integers called m
declare new integer variable n
read n
for integer i = 0 to n - 1 inclusive
declare new string variable second
read user input to second
assign m [ second [ 0 ] ] to colo [ i ]
assign second [ 1 ] - ' 1 ' to num [ i ]
create new integer called ans with value 100
for integer i = 0 to ( 1 < < 10 ) exclusive incrementing i
define integer req = __builtin_popcount of i
set the values of n first elements of mark to 0
for j from 0 to 5 exclusive
if i & ( 1 < < j ) ! = 0
in a for loop , change k from 0 to n - 1 inclusive
if colo [ k ] = j set mark [ k ] to mark [ k ] | = ( 1 < < j )
in a for loop , change j from 5 to 10 exclusive incrementing j
if i & ( 1 < < j ) ! = 0
change k from 0 to n - 1 inclusive in a for loop
if num [ k ] = j - 5 , set mark [ k ] to mark [ k ] | = ( 1 < < j )
create boolean able = true
for j from 0 to n - 1 inclusive incrementing j
in a for loop , change k from o to n - 1 inclusive
if colo [ j ] ! = colo [ k ] or num [ j ] ! = num [ k ]
if mark [ j ] is equal to mark [ k ] , change able to false
if able is true , assign min of ans and req to ans
print ans
let A be int array with size 100005
define function get that returns integer
declare char variable c
read c and loop while c < ' 0 ' or c > ' 9 '
declare int x = 0
while c > = ' 0 ' and c < = ' 9 '
change x to x * 10 + c - ' 0 '
read c
return x
Find is a int function with int arguments LEFT , RIGHT and X
while LEFT < = RIGHT
declare integer variable MID = ( LEFT + RIGHT ) / 2
if A [ MID ] is equal to X
return MID
else if A [ MID ] is less than X
change LEFT to MID + 1
else
assign MID - 1 to RIGHT
return - 1
create ints n and k = get ( )
for i from 0 to n exclusive , assign result of get to A [ i ]
create integer MAX = A [ n - 1 ] / k
declare boolean array flag with size 1000005
set sizeof ( flag ) bytes at the pointer flag to 0
declare integer ans = 0
for i = 0 to n exclusive
if flag [ i ] , skip the rest of the loop
declare ints len = 1 and T = i
while A [ T ] < = MAX
assign result of Find ( T + 1 , n - 1 , A [ T ] * k ) to T
if T = - 1 , stop the loop
change flag [ T ] to 1
increment len by one
increase ans by ( len + 1 ) / 2
print ans
in function isprime return type boolean , taking int j
for i = 2 to j exclusive
if not ( j mod i ) then return 0
return 1
make int i = 1 , n
read n
while 1
if not isprime ( n * i + 1 )
print i
increment i
let n be a integer
read n
arr = array of integers of length n
for i = 0 to n exclusive , read arr [ i ]
sort the values arr , arr + n
print arr [ 0 ]
for i = 1 to n exclusive
print space
print arr [ i ]
print newline
n , m , i , j = int , num = array of 105 int , cnt = 0
read n , m
for i = 0 to n exclusive
read num [ i ]
if num [ i ] < = m
num [ i ] = 0
j = i
else
subtract m from num [ i ]
cnt = 1
while cnt
cnt = 0
for i = 0 to n exclusive
if num [ i ] < = m and is not 0
num [ i ] = 0
j = i
else if num [ i ] > m
subtract m from num [ i ]
cnt = 1
print j + 1
let mat be a logical matrix of size 7x7
in int function calc which takes string s
let r = 0 = integer
for i = 0 to 7 exlusive
for j = 0 to 7 exclusive
if s at i is same as s at j and mat at i and j is not 0 then increment r
return r
let n , ans , temp , lans , ltemp be int with ans = temp = lans = ltemp = INT_MAX
read n
let arr , t be long long arrays of size 3 both with all 0
for i = 0 to 7 exclusive
for j = 0 to 7 exclusive , set mat [ i ] [ j ] to false
let hero be a map form string to int
set hero at " Anka " to 0
set hero at " Chapay " to 1
set hero [ " Cleo " ] = 2
set hero [ " Dracul " ] to 3
set hero [ " Dracul " ] tp 4
hero [ " Snowy " ] = 5
set hero at Hexadecimal = 6
let x , y , z , q be strings
for i = 0 to n exclusive
read x , y , z
set mat [ hero [ x ] ] [ hero [ z ] ] to true
read arr at 0 , arra at 1 , arr at 2
sort the first 3 elements of arr
let h be a set of strings
let it be a set string iterator
set t at 2 = arr [ 2 ] / 5
t [ 1 ] = arr [ 1 ]
set t at 0 to arr [ 0 ]
sort the first 3 elements of t
set temp to t [ 2 ] - t [ 0 ]
if temp is less than ans
set ans to temp
call insert on h with arg " aaaaabc "
set t at 2 = arr [ 2 ] / 4
set t at 1 = arr [ 1 ] / 2
set t at 0 to arr at 0
sort the first three elements of arr
set temp = t [ 2 ] - t [ 0 ]
if temp is less than ans
set ans to temp
clear h
insert " aaaabbc " in h
else if temp is same as ans
insert " aaaabbc " in h
set t [ 2 ] = arr [ 2 ] / 3
set t [ 1 ] = arr [ 1 ] / 3
set t at 0 to arr at 0
sort the first 3 elements of t
set tempo to t [ 2 ] - t [ 0 ]
if temp < ans
set ans to temp
clear h
insert " aaaabbc " in h
else if temp is same as ans
insert " aaaabbc " in h
set t [ 2 ] to arr [ 2 ] / 3
set t [ 1 ] to arr [ 1 ] / 2
set t [ 0 ] to arr [ 0 ] / 2
sort the first 3 elements of t
set temp to t [ 2 ] - t [ 0 ]
if temp is less than ans
set ans to temp
clear h
insert " aaabbcc " in h
if temp = ans
insert " aaabbcc " in h
while h is not empty
set q to be q * the first element of h
do loop
set ltemp to calc of q
if ltemp is greater than lans then set lans to ltemp
while the result of calling next_permutation with args start of q and end of q is not 0
erase q from h
print ans and space and lans
let n , a , b , c be unsigned long long
read n , a , b , c
if a < = b - c
print out n / a with newline
else
let ans be unsigned long long with ans = 0
if n > c , set ans to ( n - c ) / ( b - c )
increment ans by ( n - ans * ( b - c ) ) / a
print ans
let n , k be integers
read n and k
let s be a string
read s
let a be a integer with a = 1
for a is less than size of s , increase a by 1
let i be a integer
for i = 0 to size of s + a exclusive
if s [ i ] is not equal to s [ a + i ] , stop
increase i by 1
if a + i is equal to n , stop
for i = 0 to k - 1 exclusive
for j = 0 to a exclusive , print jth element of s
print s and newline
let t be a integer with t = 1
while t is decremented by 1
let s1 , s2 be strings
let cnt be a integer with cnt = 0
let ind be a vector of integers
read s1 , s2
let the boolean value flag is equal to 1
if size of s1 is not equal to size of s2
set flag to 0
for i = 0 to size of s1 exclusive
if s1 [ i ] is not equal to s2 [ i ]
increment cnt by 1
push back i in vector ind
if cnt is greater than 2
set flag to 0
stop
if flag is true
if size of ind is equal to 2
set flag to 0
if flag is true
print YES and newline
print NO and newline
declare long long integers a , b , c , d
define function gys whick takes in long long ints a and b
while b is not 0
create long long c equal to a modulo b
set a to b
set b to c
return a
define inline function gbs with long long parameters a and b
return ( a * b ) / gys ( a , b )
read a , b , c and d
let n be a long long and if n is less than or equal to d set n to d
create integer signal and set it to 1
if n and b are equal set signal to 0
declare long long res = - 1
create integer MAX = 1e9
if signal is true
if c is less than 16
assign 1e8 to MAX
else if c is less than 10
set MAX to 1e7
else if c is less than 6
MAX = 6e6
else if c is less than 3
MAX is equal to 6e5
while MAX is greater than or equal to n
if abs ( n - b ) modulo a equals 0
set res to n
break
n = n + c
else
if a is less than 16
MAX is equal to 1e8
else if 10 is greater than a
MAX = 1e7
else if a is less than 6
MAX is equal to 6e6
else if a is less than 3
MAX is equal to 6e5
iterate while n is less than or equal to MAX
if abs ( n - d ) modulo c equals 0
assign n to res
break
n = n + a
if res is equal to - 1
print - 1
else
print res
let n be an integer
input n
let l be an integer array of length n
let a1 , b1 , b2 , and ans all be integers set to 0 , let a2 be an integer set to 101 , let x be an integer
x is an integer
read x
assign x to l [ i ]
if a2 is at least x
assign x to a2
assign i to b2
if a1 is less than x
assign x to a1
assign i to b1
if b1 is less than b2
set ans to b1 + n - 1 - b2
display ans
else if b1 is greater than b2
set ans to b1 + n - 2 - b2
display ans
l , r and s are long longs with s = 0
create new vector of long longs v
void function rec with long long argument x
if x > = l , add x to the vector v
if x is greater than r , return
call rec ( 10 * x + 4 )
call rec ( 10 * x + 7 )
i , t and p are integers where p = 0
read from the input to l and r
call rec ( 0 )
sort all elements of v
assign l to i
while i < = r
change the value of t to i
while i < = v [ p ] & & i < = r
increase s by ( i - t ) * v [ p ] and increment p
print s and " \ n "
s = string
read s
a , b , c , x , y = long with a = 0 and b = 0 and c = 0 and x = 0 and y = 0
iterate i while s [ i ] is not ' \ 0 '
if s [ i ] is ' | ' and x is not 1 increment a
if s [ i ] is ' | ' and x is 1 and y is not 1 increment b
if s [ i ] is ' | ' and x is 1 and y is 1 increment c
if s [ i ] is ' + ' set x to 1
if s [ i ] is ' = ' set y to 1
set x to a + b
set y to x - c
if y is 0
else if y is - 2
for i = 0 to a inclusive print " | "
print " + "
for i = 0 to b print " | "
print " = "
for i = 0 to c - 1 print " | "
print newline
else if y is 2
if a is not 1
decrement a
else
decrement b
for i = 0 to a print " | "
print " + "
for i = 0 to b print " | "
print " = "
for i = 0 to c inclusive print " | "
print newline
else
print " Impossible "
s = string
read s
let stac be a stack of long long int
let last = - 1 be long long int
let count = 0 be a long long int
for long long int i = 0 to length of s exclusive
if s at i is ' ( '
push i in stac
else
is stack is empty
print - 1 and new line
pop stac
if s at i is # , set last to i , increment count
let k = size of stac be a long long int
while stac is not empty
if stac top > last
print - 1 and new line
pop stac
print 1 and new line count - 1 times
print 1 + k
let p be an integer array of length 105
define function par which takes in integer x as an argument
if p [ x ] is equal to x
return x
or else
return par ( p [ x ] )
let n and m be ints
read in n and m
iterate for m + 1 times , set p [ i ] to 0
let k be an int , set k to 0
let x , y and z be integers
iterate for n times
read in x
if x is equal to 0
increment k
or else
read in y
if p [ y ] is equal to 0 , set p [ y ] to y
iterate for x - 1 times
read in z
if p [ z ] is equal to 0 , set p [ z ] to z
if par ( z ) is not equal to par ( y ) , set p [ par ( z ) ] to y
let temp be an integer , set temp to 0
iterate for m times
if p [ i ] is equal to i , increment temp
if temp is not equal to 0 , decrement temp
print k + temp
n , m = integers
k = integer
debug = bool with debug = false
bl = integer array of size 103
read n
s , a , ss , S , let = strings with a = array of size n
for i = 0 to n exclusive
read a [ i ]
transform ( a [ i ] . begin ( ) , a [ i ] . end ( ) , a [ i ] . begin ( ) , tolower )
read S , let
resize S . size ( ) of ss
transform ( S . begin ( ) , S . end ( ) , ss . begin ( ) , tolower )
for i = 0 to n exclusive
pos = long long with pos = ss . find ( a [ i ] )
while ( pos is not string npos )
for j = 0 to a [ i ] . size ( ) exclusive , bl [ j + pos ] = 1
pos = ss . find ( a [ i ] , pos + 1 )
ans = string with ans = " "
for i = 0 to ss . size ( ) exclusive
if ( bl [ i ] )
if ( ss [ i ] is let [ 0 ] )
if ( ss [ i ] is not a )
if ( isupper ( S [ i ] ) )
ans = ans + A
else
ans = ans + a
else
if ( isupper ( S [ i ] ) )
ans = ans + B
else
ans = ans + b
continue next iteration
if ( isupper ( S [ i ] ) )
ans = ans + toupper ( let [ 0 ] )
else
ans = ans + let
else
ans = ans + S [ i ]
print ans . c_str ( )
let n , count be long integers with count = 0
read n
the integer value of max_i = 200005
the integer value of counter = 0
tuple < long long , long long , long long > data [ max_i ]
for i = 0 to n exclusive
let k , a0 , x , y , m , t , a be long integers with t = 0 , a = 0
read k , a0 , x , y , m
for j = 0 to k exclusive
data [ counter + + ] is equal to make_tuple ( t , a0 , i )
a is equal to ( a0 * x + y ) modulo m
if a is less than a0 and j is not equal to k - 1 , increment t by 1
a0 is equal to a
count is equal to maximum of count and t
print count and newline
sort the values of data , data + counter
arr = int array of size 103
n = int
read n
sort arr from position 0 to n
for i = 0 to n
if i < n - 1
print arr [ i ] then ' '
else
print arr [ i ]
create ints ans and n and int array b of size 20
make bool array a of size 10 with array of size 10
declare check returning bool
make ints i , j , r , l , and tot
for i = 1 to 5
set l and r to 0
for j = 1 to 5
if a [ i ] [ j ] is truthy
increment l
if b [ j ] is truthy , add 1 to r
if l - 1 is greater than r , return false
for i = 1 to 5
set l and r to 0
for j = 1 to 5
if a [ j ] [ i ] is truthy
increment l
if b [ 5 + j ] is truthy , increment r
if l - 1 is greater than r , return false
set tot to 0
for i = 1 to 5
for j = 1 to 5
if a [ i ] [ j ] is truthy , ! b [ i + 5 ] is truthy , and b [ j ] is falsy , increment tot
if tot is greater than 1 , return false
return true
declare dfs taking in integer x
make ints i and sum
if x is equal to 11
if check ( ) returns true
set sum to 0
for i = 1 to 11
if b [ i ] is equal to 1 , add 1 to sum
set ans to min of sum and ans
return
set b [ x ] to 1
call dfs ( x + 1 )
set b [ x ] to 0
call dfs ( x + 1 )
create ints i and y
make char ch
let integer k
read n
set all contents of a to false
for i = 1 to n
read ch and k
if ch is equal to ' R '
set y to 1
else if ch is equal to ' G '
set y to 2
else if ch is equal to ' B '
set y to 3
else if ch is equal to ' Y '
set y to 4
else if ch is equal to ' W '
set y to 5
set a [ y ] [ k ] to true
set all contents of b to 0
set ans to 9999999
end statement
call dfs ( 1 )
show ans
declare const int INF = 0x3f3f3f3f
declare integer variable n
read n
declare integer array row with n + 10 elements
declare long long array ans with n + 10 elements
loop i from 1 to n inclusive , reading row [ i ]
for i = 1 to n inclusive
declare long long cont = 1
create int j = row [ i ]
while cont < 103 and j ! = i
increment cont by one
assign row [ j ] to j
assign cont to ans [ i ]
if ans [ i ] = 0 , change ans [ i ] to 1
if ans [ i ] is even , divide ans [ i ] by 2
create long long mult = ans [ 1 ]
for i from 1 to n inclusive
if ans [ i ] is equal to 103
print - 1
assign ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] ) to mult
print mult
create long longs n and ans
read standard input to n
if n is equal to 1
change the value of ans to 1
else if n is odd
assign ( n - 2 ) * ( n - 1 ) * n to ans
else if n = 2
change ans to 2
else if n modulo 6 is equal to 0
assign the new value = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) to ans
else
set the value of ans to n * ( n - 1 ) * ( n - 3 )
print ans
make long long ints ans = 0 , N , a , and b
read N
while N is greater than 0
read a and b
set ans to max ( ans , a + 1 )
while b is not equal to 1
set b to ( b + 3 ) / 4
add 1 to a
set ans to max of ans and a
decrease N by 1
print ans
s = string
a , b = integer
cx , cy = integers with cx = 0 , cy = 0
read a , b
read s
for i = 0 to ( ( cast to int ) ( s ) . size ( ) )
if cx is a and cy is b
print Yes
if s [ i ] is U
increment cy
else if s [ i ] is D
cy decrement
else if s [ i ] is R
increment cx
else
decrement cx
if cx is a and cy is b
print Yes
if cx
t = integer with t = abs ( a ) / abs ( cx )
for now = t - 1000 to t + 1000
if now < 0 , continue new iteration
first = long long with first = ( cast to long long ) cx * now
second = long long with second = ( cast to long long ) cy * now
for i = 0 to ( ( cast to int ) ( s ) . size ( ) )
if first is a and second is b
print Yes
if s [ i ] is U
increment second
else if s [ i ] is D
decrement second
else if s [ i ] is R
increment first
else
decrement first
if first is a and second is b
print Yes
if cy
t = integer with t = abs ( b ) / abs ( cy )
for now = t - 1000 to t + 1000
if now < 0 , continue next iteration
first = long long with first = ( cast to long long ) cx * now
second = long long with second = ( cast to long long ) cy * now
for i = 0 to ( ( cast to int ) ( s ) . size ( ) )
if first is a and second is b
print Yes
if s [ i ] is U
increment second
else if s [ i ] is D
decrement second
else if s [ i ] is R
increment first
else
decrement first
if first is a and second is b
print Yes
print No
find_len is a long long function with long long argument num
create long long l = 1
for a = 7 to num exclusive multiplying a by 7 , add 1 to l
return l
declare long longs n , m , x , y , res , i and j
read n and m
change x to find_len ( n )
change y to find_len ( m )
change res to 0
if x + y < = 7
for i from 0 to n exclusive
for j from 0 to m exclusive
create vector of long long f with 7 elements , filled with 0
for k = 0 and a = i while k ! = x , incrementing k and dividing a by 7 , increment f [ a % 7 ]
for k = 0 and b = j while k ! = y , incrementing k and dividing b by 7 , increment f [ b % 7 ]
if * max_element ( f . begin ( ) , f . end ( ) ) < = 1 , increment res
print res
n = long integer
while read n
s = string
i , cnt , ar , f = long with cnt = 0 , ar = array of size 150 = { 0 } , f = 0
read s
sort s . begin ( ) and s . end ( )
x = long
for i = 0 to n exclusive
x = s [ i ] - 97
increment ar [ x ]
if ar [ x ] > = 2 , f = 1
if f is 1 or n is 1
else
s , t , x = integers
Read s , t , x
if t is greater than x
print NO and a new line
if ( x - t ) modulo s is 0
print YES and a new line
else if ( x - t - 1 ) modulo s is 0 and x is greater than ( t + s )
print YES and a new line
print NO and a new line
a = character array of length 120 by 120
in function check that returns an integer and takes argument n = integer
flag1 = integer
for i = 1 to n inclusive
set flag1 to 0
for j = 1 to n inclusive
if a [ i ] [ j ] equals .
set flag1 to 1
break
if not flag1 then break
flag2 = integer
for i = 1 to n inclusive
set flag2 to 0
for j = 1 to n inclusive
if a [ j ] [ i ] equals .
set flag2 to 1
break
if not flag2 then break
if flag1 and flag2 both equal 0
else
if flag1
return 1
else
return 2
n = integer
while read n
for i = 1 to n inclusive
for j = 1 to n inclusive read a [ i ] [ j ]
judge = integer with value of the return of function check with argument n
if judge is not 0
if judge equals 1
for i = 1 to n inclusive
for j = 1 to n inclusive
if a [ i ] [ j ] equals .
print i space j
break
else
for i = 1 to n inclusive
for j = 1 to n inclusive
if a [ j ] [ i ] equals .
print j space i
break
else
print - 1
create new integer called n
read standard input to n
declare new string variable s
read user input to s
create integer variable called flag with value 1
declare integer variable count with value 0
for i from 0 to n exclusive incrementing i
if s [ i ] is equal to ' ? '
if value of i is equal to 0 , assign 2 to count
if i = n - 1 , change count to 2
if s [ i + 1 ] = ' ? ' or s [ i - 1 ] = s [ i + 1 ] , set count to 2
else if s [ i ] = s [ i + 1 ]
assign 1 to count
stop the loop
if count = 2
print " Yes "
else
print " No " to the standard output
v is a new vector of long long integers
declare integer t = 0
declare long long integer variable p = 1
primeFactors is a void function with long long int argument n
while n is even
if t is less than 2 , assign p * 2 to p
increment t
change n to n / 2
in a for loop , change i from 3 to the square roof of n inclusive
while n % i = 0
if t is less than 2 , set p to p * i
increment t
change n to n / i
if n is greater than 2
if t is less than 2 , assign p * n to p
increment t
declare new long long integer n
read n from the input
call primeFactors ( n )
if t < = 1
print 1 and 0 to the standard output
else if t = 2
print 2
else
print 1 to the standard output
print p
declare double tmaxmin = 1 bitshift left 20
declare long long t1
declare long long t1
declare long long t0
declare double T
declare long long x1
declare long long x2
declare long long solx1
declare long long solx2
read t1 , t2 , x1 , x2 , t0
while x1 is greater than or equal to 0 and x2 is greater than or equal to 0
let T be ( 1 . 0 * t1 * x1 + t2 * x2 ) / ( x1 + x2 )
if T is less than or equal to t0
decrement x1
else
if T is less than tmaxmin
let tmaxmin be T
let solx2 be x2
let solx1 be x1
decrement x2
print solx1 , " " , solx2 , newline
declare constant integer INF = integer casted 1e9
declare constant double PI = 2 * acosign of 0 . 0
declare constant double eps = 1e - 9
declare constant integer NPOS = - 1
declare constant integer MAX = 105
declare string array arr size MAX
declare integer array have size MAX
declare map from character to integer m
declare integers n , diff , flag , flg
read n
let m [ ' R ' ] be 0
let m [ ' G ' ] be 1
let m [ ' B ' ] be 2
let m [ ' Y ' ] be 3
let m [ ' W ' ] be 4
for i = 0 to n exclusive , read arr [ i ]
declare integer ans = INT_MAX
for col = 0 to 1 bitshift left 5 exclusive
for num = 0 to integer casted ( 1 bitshift left 5 ) exclusive
let flag be 0
for i = 0 to integer casted n exclusive
for j = i + 1 to n exclusive
let flg be 0
if arr [ i ] [ 0 ] is not arr [ j ] [ 0 ]
if ( 1 bitshift left m [ arr [ i ] [ 0 ] ] ) bitwise and col , let flg be 1
if ( 1 bitshift left m [ arr [ j ] [ 0 ] ] ) bitwise and col , let flg be 1
if arr [ i ] [ 1 ] is not arr [ j ] [ 1 ]
if ( 1 bitshift left ( arr [ i ] [ 1 ] - ' 1 ' ) ) bitwise and num , let flg be 1
if ( 1 bitshift left ( arr [ j ] [ 1 ] - ' 1 ' ) ) bitwise and num , let flg be 1
if not flg , let flag be 1
if not flag
declare integer t = result of run __builtin_popcount ( col ) + result of run __builtin_popcount ( num )
let ans be minimum of t ans ans
print ans and ' \ n '
declare integer x
read x
if x is 1
print " - 1 " and newline
print x , " " , x , newline
declare prime taking in integer i and returning bool
for k = 2 to i exclusive
if i % k is 0 , return false
return false
create integer n
read n
for i = 1 to 1000
if prime ( n * i + 1 ) is false
show i
declare long longs a , b , l , r , ans = 100 , T
declare Cal with character c as argument , returning long long
declare count = 0 as long long
declare character array s size 100
for i = 0 to a exclusive , let s [ i ] be ' a ' + i
for i = a to a + b exclusive , let s [ i ] be c
declare integer array have size 26
set bytes from have to 26 * size of integer to value 0
for i = a + b - 1 to b inclusive , decrementing i , let have [ s [ i ] - ' a ' ] be 1
declare long longs i = a + b , j = 0
while i is less than 2 * a + b
while ( have [ j ] ) , increment j
let s [ i ] be j + ' a '
increment i
increment j
for i = 2 * a + b to T exclusive , let s [ i ] be s [ i - 1 ]
set bytes from have to 26 * size of integer to value 0
if l is less than or equal to r
for i = l to r inclusive
if not have [ s [ i ] - ' a ' ]
increment count
let have [ s [ i ] - ' a ' ] be 1
else
for i = 0 to r inclusive
if not have [ s [ i ] - ' a ' ]
increment count
let have [ s [ i ] - ' a ' ] be 1
for i = l to T exclusive
if not have [ s [ i ] - ' a ' ]
increment count
let have [ s [ i ] - ' a ' ] be 1
return count from function
declare long long t
read a and b and l and r
decrement l
decrement r
let T be 2 * ( a + b )
if a is greater than b + 1
let t be 2 * a - b
else
let t be a + 1
if r - l is greater than or equal to T
let ans be t
else
let r be r % T
let l be l % T
for i = 0 to a exclusive , let ans be minimum of ( result of run Cal with ' a ' + i as arguments and ans )
print ans and newline
a , b , c = 0
n , c = int
read n
while decremented value of n is not 0
read x
if x is 25
increment a
else if x is 50 and a is not 0
decrement a
increment b
else if x is 50 and a is 0
else if x is 100 and a is not 0 and b is not 0
decrement a
decrement b
increment c
else if x is 100 and a > = 3 and b is 0
subtract 3 from a
increment c
else
define new constant long long called MAX = 1e5 + 5
new constant long long MOD = 1e9 + 7
new long long constant inf = 1e12 + 5
create long long variable with name n
read standard input to n
declare long long variable with name cur with value 0
for i = 0 to n exclusive
create long longs a and k
read input to k and a
create long long variable tmp = 4
while tmp < a
multiply tmp by 4
increment k by one
assign the new value = max of cur and k to cur
print cur + 1
v = vector of string
n = long long
is = 200 array of bool
read n
for i = 0 to n exclusive
e = string
read e
for k = 0 to ( cast to long long ) e . size ( ) exclusive
if ( e [ k ] > = A and e [ k ] < = Z ) , e [ k ] = e [ k ] - A + a
append e in v
s = string
read s
r = string with r = s
for k = 0 to ( cast to long long ) r . size ( ) exclusive
if ( r [ k ] > = A and r [ k ] < = Z ) , r [ k ] = r [ k ] - A + a
for i = 0 to ( cast to long long ) s . size ( ) exclusive
for j = 0 to n exclusive
if ( i + ( cast to long long ) v [ j ] . size ( ) < = ( cast to long long ) s . size ( ) )
if ( r . substr ( i , ( cast to long long ) v [ j ] . size ( ) ) is v [ j ] )
for k = i to i + ( cast to long long ) v [ j ] . size ( ) exclusive
g = character
read g
for i = 0 to ( cast to long long ) s . size ( ) exclusive
if ( is [ i ] )
if s [ i ] > = A and s [ i ] < = Z
if s [ i ] is g - a + A
if ( g is not a )
s [ i ] = A
else
s [ i ] = B
else
s [ i ] = g - a + A
else
if ( s [ i ] is g )
if g is not a
s [ i ] = a
else
s [ i ] = b
else
s [ i ] = g
print s
make string vector word
make integer vector be and af
create int set g
declare sf taking in string s and returning int
make int n = s . size ( )
if n is greater than or equal to 4 and s . substr ( n - 4 , 4 ) is equal to " lios "
else if n is greater than 5 and s . substr ( n - 5 , 5 ) is equal to " liala "
return 1
else if n is greater than or equal to 3 and s . substr ( n - 3 , 3 ) is equal to " etr "
return 2
else if n is greater than or equal to 4 and s . substr ( n - 4 , 4 ) is equal to " etra "
return 3
else if n is greater than or equal to 6 and s . substr ( n - 6 , 6 ) equals " initis "
return 4
else if n is greater than or equal to 6 and s . substr ( n - 6 , 6 ) equals " inites "
return 5
else do
return - 1
make string s
read s and while it ' s truthy , append s to word
for i = 0 to size of word exclusive
make integer j = sf ( word [ i ] )
if j is equal to - 1
print " NO "
insert j % 2 to g
append j / 2 to be
append j / 2 to af
if size of word is 1
print " YES "
if g . size ( ) is not 1
print " NO "
make integer cnt = 0
for i = 0 to af . size ( ) exclusive
if af [ i ] is not equal to be [ i ]
show " NO "
if af [ i ] is equal to 1 , increment cnt
if cnt is equal to 0 and size of word is not equal to 1
show " NO "
else if cnt is not 1 and cnt is not 0
display " NO "
output " YES "
declare new string called time
read variable time from the input
declare vector of integers t with 4 elements
assign time [ 0 ] - ' 0 ' to t [ 0 ]
set t [ 1 ] to time [ 1 ] - ' 0 '
assign time [ 3 ] - ' 0 ' to t [ 2 ]
set t [ 3 ] to time [ 4 ] - ' 0 '
count is a new integer variable with value 0
in the infinite loop
break if t [ 0 ] = t [ 3 ] and t [ 1 ] is equal to t [ 2 ]
increase t [ 3 ] by 1
if t [ 3 ] is greater than 9
add 1 to t [ 2 ]
assign 0 to t [ 3 ]
if t [ 2 ] is greater than 5
change t [ 1 ] to t [ 1 ] + 1
change t [ 2 ] to 0
change the value of t [ 3 ] to 0
if t [ 0 ] ! = 2 and t [ 1 ] > 9
change t [ 0 ] to t [ 0 ] + 1
change t [ 1 ] to 0
assign 0 to t [ 2 ]
set t [ 3 ] to 0
if t [ 0 ] = 2 and t [ 1 ] > 3
assign the new value = 0 to t [ 0 ]
set t [ 1 ] to 0
set t [ 2 ] to 0
change t [ 3 ] to 0
add 1 to count
print count and " \ n "
create ints a , b and c = 0
declare integers n and x
read input to n
while n ! = 0 , decrement it and continue the loop
read x from the input
if x = 25
increment a
else if x = 50 and a ! = 0
decrement a
increment b by one
else if x is equal to 50 and a = 0
print " NO " to the standard output
else if x = 100 and a ! = 0 and b ! = 0
decrement a
decrement b
increment c
else if x = 100 and a > = 3 and b = 0
change a to a - 3
increment c by one
else
print " NO " to the standard output
print " YES " to the output
N = - 1
s = string
read s
n = size of s
ans = - 1
for tam1 = 1 to n inclusive
for tam2 = 1 to n - tam1 - 1 exclusive
tam3 = n - tam1 - tam2
id = 0
cur , soma = 0
for i = 0 to tam1 exclusive
if tam1 is not 1 and s [ id ] is ' 0 ' and cur is 0 goto fim
cur = 10 * cur + ( s [ id ] - ' 0 ' ) , increment id
if cur > 1000000 goto fim
add cur to soma
cur = 0
for i = 0 to tam2 exclusive
if tam2 is not 1 and s [ id ] is ' 0 ' and cur is 0 goto fim
cur = 10 * cur + ( s [ id ] - ' 0 ' ) , increment id
if cur > 1000000 goto fim
add cur to soma
cur = 0
for i = 0 to tam3 exclusive
if tam3 is not 1 and s [ id ] is ' 0 ' and cur is 0 goto fim
cur = 10 * cur + ( s [ id ] - ' 0 ' ) , increment id
if cur > 1000000 goto fim
add cur to soma
cur = 0
ans = max ( ans , soma )
label fim
continue
print ans
N = const int with N = 110 * 2
n , k , i = int
a = int array of size N
read n then k
len = int with len = 2 * n + 1
cnt = int with cnt = 0
for i = 1 to len inclusive read a [ i ]
for i = 1 to len inclusive
if i is even
if a [ i ] - 1 is greater than a [ i - 1 ] and a [ i + 1 ]
decrement a [ i ]
increment cnt
if cnt is k break
for i = 1 to len print a [ i ] then " "
print a [ len ]
declare character array s size 1000
while read s is true
declare integers a , b , c
declare integer len = string length of s
declare integer cnt = 0
for i = 0 to len exclusive
if s [ i ] is ' + '
let a be cnt
let cnt be 0
else if s [ i ] is ' = '
let b be cnt
let c be len - a - b - 2
else
increment cnt
if a + b is c
for i = 0 to a exclusive , print " | "
print " + "
for i = 0 to b exclusive , print " | "
print " = "
for i = 0 to c exclusive , print " | "
print newline
else if a + 1 + b is c - 1 and c is greater than 1
let a be a + 1
let c be c - 1
for i = 0 to a exclusive , print " | "
print " + "
for i = 0 to b exclusive , print " | "
print " = "
for i = 0 to c exclusive , print " | "
print newline
else if a - 1 + b is c + 1 and a is greater than 1
let a be a - 1
let c be c + 1
for i = 0 to a exclusive , print " | "
print " + "
for i = 0 to b exclusive , print " | "
print " = "
for i = 0 to c exclusive , print " | "
print newline
else if a + b - 1 is c + 1 and b is greater than 1
let b be b - 1
let c be c + 1
for i = 0 to a exclusive , print " | "
print " + "
for i = 0 to b exclusive , print " | "
print " = "
for i = 0 to c exclusive , print " | "
print newline
else
print " Impossible " and newline
f is a int function with int argument n
declare integer s
assign the new value = n / 10 + ( n % 10 ) * 10 to s
return s
declare new character c
create ints n , m , x , y , z and d
read n , c and m from the input
change x to the result of f ( n )
assign the new value = f ( m ) to y
if n > = 6 and n < = 9
change the value of d to ( 9 - n ) * 60 + 60 - m + 1
else if n > = 16 and n < = 19
change d to ( 19 - n ) * 60 + 60 - m + 2
else
if x > = m
set d to x - m
else if n is equal to 5
change d to 4 * 60 + 60 - m + 1
else if n is equal to 15
set d to 4 * 60 + 60 - m + 2
else if n is equal to 23
change the value of d to 60 - m
else
set z to f ( n + 1 )
set d to z + 60 - m
print d to the standard output
create integer n
read n
create integer array a with size 100005
for i = 1 to n inclusive , read a [ i ]
create integer count with count = 1
create integer neg with neg = 0
create integer b with b size 10005
create integer i
set b [ 0 ] to 1
for i = 1 to n inclusive
if a [ i ] is less than 0 , increment neg
if neg is 3
set b [ increment count ] to i
set neg to 1
print count print newline
for j = 1 to count exclusive , print b [ j ] - b [ j - 1 ] print " "
print n + 1 - b [ count - 1 ] print newline
create new constant long long called MAX with value 1000000007
create long long variable with name a
read from the input to a
s is a new string
read variable s from the input
create a map from long longs to long longs called x
all is a new long long with value 0
for integer i = 0 to length of s exclusive incrementing i
declare long long variable with name tot = 0
for j = i to length of s exclusive
increase tot by ( s [ j ] - 48 )
increment x [ tot ]
increment all
t is a new long long variable = 0
start for loop from i = 0 to length of s exclusive
create long long variable with name tot with value 0
start for loop from j = i to length of s exclusive incrementing j
increase tot by s [ j ] - 48
if tot ! = 0 and a modulo tot = 0 , add x [ a / tot ] to t
if tot = 0 and a is equal to 0 , change t to t + all
print t
declare string a
read a
declare integers count_a = 0 , count_c = 0 , count_b = 0
for i = 0 to length of a exclusive
if a [ i ] is ' a '
increment count_a
else if a [ i ] is ' b '
increment count_b
else if a [ i ] is ' c '
increment count_c
if count_a is not count_c and count_b is not count_c
print " NO " and newline
else if count_a is 0 or count__b is 0 or count_c is 0
print " NO " and newline
else
for i = 0 to count_a exclusive
if a [ i ] is not ' a '
print " NO " and newline
for i = count_a to count_a + count_b exclusive
if a [ i ] is not ' b '
print " NO " and newline
print " YES \ n "
let n , k be integers
read n , k
for i = 0 to n - 1 inclusive
if i is greater than k - 1
print ( char ) ( i modulo k + a )
print ( char ) ( i + a )
print newline
create char array a of 1005 elements
in function judge returning int , taking int c and int n
create int flag = n - 1
for i = c to n exclusive
if a [ i ] does not equal a [ flag - i + c ] , return 0
return 1
while reading a is not interrupted
create int n
read n
create int s = length of a
if n greater than s
print " NO "
continue
if s mod n not equals 0
print " NO "
continue
create int pl = s / n
create int ans = 0
create int h = 0
for i = 0 to s exclusive
increase h by pl
create int x = judge ( i , h )
if not x
ans = 1
break
i = h
if ans
print " NO "
else
print " YES "
let n be a integer
read n
let sum be a integer with value 0
for i = 0 to n exclusive
let v be a integer
read v
increment sum by v
if sum is equal to n - 1 + n is equal to 1
print YES and newline
print NO and newline
maxn = 15000001
vis = array of maxn bool
cnt = array of maxn int
gcd = 0
a , n = int
read n
for i = 1 to n inclusive
read a
increment cnt [ a ]
if i is 1
gcd = a
else
gcd = __gcd ( gcd , a )
ans = 0
for i = gcd + 1 to maxn exclusive
if not vis [ i ]
tmp = 0
for j = i to maxn by i
vis [ j ] = true
add cnt [ j ] to tmp
ans = max ( ans , tmp )
if ans is 0
print - 1
else
print n - ans
create integer n
declare solve with integers x , y as arguments , returning integer vector
create integer vector ans initialized with 4
if x is 0
set ans [ 0 ] to y
set ans [ 1 ] to n - y
set ans [ 2 ] to ans [ 0 ] + n
set ans [ 3 ] to ans [ 1 ] + n
else if y is 0
set ans [ 0 ] to x
set ans [ 1 ] to ans [ 0 ] + n
set ans [ 2 ] to n - x
set ans [ 3 ] to ans [ 2 ] + n
else if x is n
set ans [ 2 ] to y
set ans [ 3 ] to n - y
set ans [ 1 ] to ans [ 3 ] + n
set ans [ 0 ] to ans [ 2 ] + n
else
set ans [ 1 ] to x
set ans [ 3 ] to n - x
set ans [ 0 ] to ans [ 1 ] + n
set ans [ 2 ] to ans [ 3 ] + n
return ans from function
create integers x1 , y1 , x2 , y2
read n read x1 read y1 read x2 read y2
if ( x1 is 0 and x2 is 0 ) or ( x1 is n and x2 is n )
print absolute value of ( y1 - y2 ) print " \ n "
else if ( y1 is 0 and y2 is 0 ) or ( y1 is n and y2 is n )
print absolute value of ( x1 - x2 ) print " \ n "
else
create integer vector A with A = result of run solve with x1 , y1 as arguments , set B to result of run solve with x2 , y2 as arguments
create integer mn with mn = 1e9
for i = 0 to 4 exclusive , set mn to minimum of ( mn and A [ i ] + B [ i ] )
print mn print " \ n "
create new int n and int arrays visited with size 150 and matriz with size 150 by 150
function DFS with int argument u
change the value of visited [ u ] to 1
for p from 1 to n inclusive
if visited [ p ] is false and matriz [ u ] [ p ] is true , call DFS of p
declare boolean alguienSabe = false
let m , a , k and cnt be integers with cnt = 0 ; lenguas is an array of integers with size 150 by 150
in a for loop , change i from 1 to 100 inclusive
assign the value of 0 to visited [ i ]
for integer j = 1 to 100 inclusive
assign 0 to matriz [ i ] [ j ]
change the value of lenguas [ i ] [ j ] to 0
read standard input to n and m
for i = 1 to n inclusive
read a
for j from 1 to a inclusive incrementing j
read from the input to k
if alguienSabe is false and k is true , change the value of alguienSabe to true
if k ! = 0 , assign 1 to lenguas [ i ] [ k ]
if i is greater than 1
in a for loop , change z from 1 to i exclusive
if lenguas [ z ] [ k ] is true , change the values of matriz [ i ] [ z ] and matriz [ z ] [ i ] to 1
start for loop from i = 1 to n inclusive incrementing i
if visited [ i ] is false
increment cnt by one
call DFS ( i )
if alguienSabe is true
print cnt - 1 to the standard output
else
print cnt
create ints n , x , r25 = 0 , and r50 = 0
read n
for i = 0 to n exclusive
read x
if x is equal to 25 , increment r25
if x is 50
if r25 is equal to 0
print " NO \ n "
reduce r25 by 1
increase r50 by 1
if x is equal to 100
if r50 = = 0 ? r25 < 3 : r25 < 1
print " NO \ n "
if r50 is greater than 0
reduce r50 by 1
reduce r25 by 1
else do
subtract 3 from r25
print " YES \ n "
create int n
sum = 0
npos = 0
set nneg = 0
create int x [ 100 ] [ 2 ]
read n
for i = 0 to n exclusive
for j = 0 to 2 exclusive , read x [ i ] [ j ]
for i = 0 to n exclusive
if x [ i ] [ 0 ] greater than 0
increment npos
else
add 1 to nneg
for i = 0 to n - 1 exclusive
for j = 1 + 1 to n exclusive
if x [ i ] [ 0 ] > x [ j ] [ 0 ]
create int auxp and auxc
set auxp to x [ i ] [ 0 ]
set x [ i ] [ 0 ] to x [ j ] [ 0 ]
set x [ j ] [ 0 ] = auxp
assign x [ i ] [ 1 ] to auxc
set x [ i ] [ 1 ] = x [ j ] [ 1 ]
assign auxc to x [ j ] [ 1 ]
if npos less than nneg
for i = 0 to 2 * nneg + 1 exclusive , set sum to sum + x [ i ] [ 1 ]
else if npos < nneg
for i = n - 2 * npos + 1 to n exclusive , assign sum + x [ i ] [ 1 ] to sum
else
for i = 0 to n exclusive , set sum = sum + x [ i ] [ 1 ]
print sum
declare doubles a , b , c and d
read variables a , b , c and d from the input
if ( a - b ) is equal to ( b - c ) and ( b - c ) is equal to ( c - d )
print d + ( b - a ) to the standard output
else
if ( b / a ) = ( c / b ) and ( c / b ) is equal to ( d / c )
create new double variable k = d * ( b / a )
if k = k casted to int
print k
else
print 42
else
print 42
create unsigned long long integer variable l
read variable l from the input
if l < = 127
print " byte "
else if l < = 32767
print " short "
else if l < = 2147483647
print " int " to the standard output
else if l < = 9223372036854775807
print " long "
else
print " BigInteger "
t , s , x , i are integers
read t , s , x
if t equals x
for i = 1 to 1000000000 exclusive
if t + s * i equals x or t + s * i + 1 equals x
break
else if t + s * i is greater than x
break
let po be vector of char
let ans be map of char to int
pos = string
read pos
call transform of begin of pos , end of pos , begin of pos , : : toLower
for i = 0 to size of pos exclusive
if ans [ pos [ i ] ] is not zero
continue
else
push . to the back of po
push pos [ i ] to the back of po
for i = 0 to size of po , print po [ i ]
print newline
declare string s
declare integers n , sum = 0
read n
read s
for i = 0 to n exclusive
if s [ i ] is ' < '
increment sum
else
end loop
for i = n - 1 to 0 inclusive , decrementing i
if s [ i ] is ' > '
increment sum
else
end loop
print sum and newline
N = constant integer = 0
a , b are long longs
s = string
v = integer vector
read s
n = integer = length of s
res = string = " "
flag = boolean = false
for i = 0 to n exclusive
if s [ i ] is the character a or flag
add s [ i ] to res
continue
set flag to true
while i is less than n and s [ i ] isn ' t the character a
add s [ i ] - 1 to res
increment i
if i isn ' t n , decrement i
if not flag , set res [ n - 1 ] to the character z
display res
a , b = integer arrays of length 110 both with value of 0
n = integer
read n
for i = 0 to n exclusive read a [ i ]
sum , num , h = integers with value of 0
for i = 0 to n exclusive
if a [ i ] is less than 0 add 1 to num
if num equals 3
set b [ h ] to sum then add 1 to h
set sum to 1
set num to 1
continue
add 1 to sum
set b [ h ] to sum then add 1 to h
print h
for i = 0 to h exclusive
if i is not 0 print a space
print b [ i ]
print a line terminator
a is a new array of integers with 100001 element
declare new integer variable n
read variable n from the input
for i = 1 to n + 1 exclusive , read input to a [ i ]
declare new long long called res = 0
create new integer called t
in a for loop , change i from 1 to n exclusive
in a for loop , change t from 1 to n inclusive multiplying t by 2
change t to t > > 1
change res to the sum of res and a [ i ]
change a [ i + t ] to the sum of a [ i + t ] and a [ i ]
print res
m1 = array of long integers of length 100001
let ans be a long integer
let n , d be long integers
read n
read d
for i = 0 to n exclusive , read m1 [ i ]
let h be a long integer with h = 0
let t be a long integer
ans is equal to 0
for long integer i = 0 to n exclusive
while h is less than n and m1 [ h ] - m1 [ i ] < = d , increment h by 1
let t be a long integer with t = h - i - 1
if t - 1 is greater than 0 , increment ans by t * ( t - 1 ) / 2
print ans and newline
make string s
in function ok with return type boolean and parameter string t
make int msk = 0
for i = 0 to ( cast t size to int ) exclusive
if isupper ( t [ i ] ) then set msk to msk bitwise or 1
if islower ( t [ i ] ) then set msk to msk bitwise or1
if isdigit ( t [ i ] ) then set msk to msk bitwise or 1
return msk is equal to 7
make integer t
read t
for i = 0 to t exclusive
read s
if ok ( s )
print s
continue
make boolean fnd = false
for i = 0 to ( cast s size to int ) exclusive
make string t = s
set t [ i ] to ' 1 '
if ok ( t )
print t
set fnd to true
break
set t [ i ] to ' a '
if ok ( t )
print t
set fnd to true
break
set t [ i ] to ' A '
if ok ( t )
print t
set fnd to true
break
if fnd then continue
if isupper ( s [ 2 ] )
set s [ 0 ] to ' a '
set s [ 1 ] to ' 1 '
print s
continue
if islower ( s [ 2 ] )
set s [ 0 ] to ' A '
set s [ 1 ] to ' 1 '
print s
continue
if isdigit ( s [ 2 ] )
set s [ 0 ] to ' a '
set s [ 1 ] to ' A '
print s
continue
create constant integer N with N = 1e5 + 10
create character arrays ch1 , ch2 with ch1 size N , ch2 size N
create character arrays a , b with a size 105 , b size 105
while read ch1
create integer len with len = string length of ch1
for i = 0 to len exclusive , set ch2 [ i ] to ch1 [ len - 1 - i ]
read a read b
create integer la with la = string length of a
create integer lb with lb = string length of b
if reference to a in ch1 and reference to b in ( reference to a in ch1 + la )
if reference to a in ch2 and reference to b in ( reference to a in ch2 + la )
print " both " print newline
else
print " forward " print newline
else if reference to a in ch2 and reference to b in ( reference to a in ch2 + la )
if reference to a in ch1 and reference to b in ( reference to a in ch1 + la )
print " both " print newline
else
print " backward " print newline
else
print " fantasy " print newline
declare string nineteen
declare integers contN = 0 , contI = 0 , contT = 0 , contE = 0
declare integer array vetor size 4
read nineteen
for i = 0 to length of nineteen exclusive
if nineteen [ i ] is ' n '
increment contN
else if nineteen [ i ] is ' i '
increment contI
else if nineteen [ i ] is ' e '
increment contE
else if nineteen [ i ] is ' t '
increment contT
let contE be contE / 3
if contN is greater than 3
decrement contN
let contN be contN / 2
else
let contN be contN / 3
let vetor [ 0 ] be contI
let vetor [ 1 ] be contT
let vetor [ 2 ] be contE
let vetor [ 3 ] be contN
sort from vetor to vetor + 4
print vetor [ 0 ] and newline
n , m = integers
Read t , s , x
if t is equal to x
print YES
print a new line
if t is equal to x - 1
print NO
print a new line
l , r , m = integers with l = 0 , r = x
while l is less than or equal to r
set m to ( l + r ) / 2
a = integer , set to t + s * m
b = integer , set to t + s * m + 1
if a is equal to x OR b is equal to x
print YES
print a new line
if a is greater than to x OR b is greater than to x
set r to m - 1
set l m + 1
print NO
print a new line
in function solve which takes pointers to ints a , b , and c and returns a bool
if value at a plus value at b is value at c then return true
if value at a minus 1 is 0 and value at a - 1 plus value at b is the value at c + 1
decrement value at b
increment value at c
return true
if value at a - 1 plus value at b is the value at c + 1
decrement value at a
increment value at c
return true
if value at a + 1 plus value at b is the value at c - 1
increment value at a
decrement value at c
return true
return false
in function load which takes constant string reference t and pointers to ints a , b , and c
set value at a to position of first + in t
set value of b to position of first = in t minus value at a minus 1
set value of c to size of t minus value at a minus value at b minus 2
let output be a string of ints a , b , c
return a string with I as first a items followed by + followed by b Is followed by = followed by c Is
let a , b , and c be ints
let t be a string
read t
call function load on t and references to a b and c
if function solve on references to a b and c
print output ( a , b , c )
else
declare new integer n
read input to n
create integer variable k = n / 2 - 1
print n / 2
decrement k and loop further , while k ! = 0
if n is odd
print 3
else
print 2
print new line
n , a = int
read n then a
mina , maxa , mini , maxi = int with mina = a and maxa = 0 and mini = 0 and maxi = 0
for i = 1 to n
read a
if a > maxa
set maxa to a
set maxi to i
if a < = mina
set mina to a
set mini to i
print maxi + ( n - 1 - mini ) - ( if mini < maxi 1 else 0 )
prime is an array of booleans with 1200000 + 4 elements
pali is an array of integers with size 1200000 + 4
declare new array of integers pri with size 1200000 + 4
function sieve
in a for loop , change i from 4 to 1200000 inclusive adding 2 to i and changing prime [ i ] to 1 on each loop
start for loop from i = 3 to square root of 1200000 inclusive increasing i by 2
if prime [ i ] is equal to 0
in a for loop , change j from i * i to 1200000 inclusive adding 2 * i to j , and setting prime [ j ] to 1 on each iteration
change the value of prime [ 0 ] and prime [ 1 ] to 1
function is_Palindrome with int argument n that returns bool
arr is a new array of integers with 10 elements
create new integer variable l = 0
while n is not 0
set arr [ l ] to n modulo 10 and increment l
change n to n / 10
flag is a new boolean variable = 1
for i = 0 to l / 2 inclusive incrementing i
if arr [ i ] ! = arr [ l - i - 1 ]
assign the new value = 0 to flag
stop the loop
if flag is true
return 1
else
call sieve ( )
set pri [ 0 ] to 0
for i from 0 to 1200000 inclusive
if prime [ i ] is equal to 0
set pri [ i ] to pri [ i - 1 ] + 1
else
change the value of pri [ i ] to pri [ i - 1 ]
in a for loop , change i from 1 to 1200000 inclusive
if is_Palindrome ( i ) returned true
assign the new value = pali [ i - 1 ] + 1 to pali [ i ]
else
assign pali [ i - 1 ] to pali [ i ]
declare long long int variables p and q
read standard input to p and q
create boolean flag with value 1
declare integer i
start for loop from i = 1200000 to 0 inclusive decrementing i
if pri [ i ] * q < = p * pali [ i ]
print i and " \ n "
print " Palindromic tree is better than splay tree \ n " to the output
str = string
n , negative = unsigned long long
read str
if str [ 0 ] is -
erase str . begin ( ) from str
negative = 1
if ( str . size ( ) > 19 )
print BigInteger
for i = 0 to str . size ( ) exclusive
n = n * 10
n = n + cast to integer ( str [ i ] - 0 )
n = n + negative
if ( n < = 127 )
print byte
else if ( n < = 32767 )
print short
else if ( n < = 2147483647 )
print int
else if ( n < = 9223372036854775807 )
print long
else
print BigInteger
let a , n , m , i , j , p , num be integers , the 200010th element of integer array t is equal to 0
while read n , m
for i = 1 to n inclusive , read t [ i ]
for i = 1 to n inclusive
increment t [ i ] by t [ i - 1 ]
num is equal to t [ i ] / m
decrement t [ i ] by num * m
print num
if i is not equal to n , print ' '
print newline
let s , t = strings
let l1 , l2 = integers
let p = 10001 arrays of integers of size 26
while ( read s , t ) is true do the following
set l1 = size of s
set l2 = size of t
set sizeof ( p ) bytes starting at p to 0
for integer i = 0 to 26 exclusive set p [ l1 ] [ i ] to - 1
for integer j = l1 to 1 inclusive decrementing
for integer i = 0 to 26 exclusive
if s [ j ] is i + a
set p [ j - 1 ] [ i ] = j
else
set p [ j - 1 ] [ i ] = p [ j ] [ i ]
let ans , l = integers where ans = 1 , l = - 2
for integer i = 0 to l2 exclusive do the following
if l2 is - 2 do the following
if s [ 0 ] is t [ i ]
set l = 0
else
set l = p [ 0 ] [ t [ i ] - a ]
if l is - 1 do the following
set ans = - 1
exit the loop
set l = p [ l ] [ t [ i ] - a ]
if l is - 1 do the following
increment ans
set l = - 2
decrement i
print ans
create integers a , b , c , d , e and f
read a , b , c , d , e and f
if a * c * e < b * d * f or ( c = 0 and d ! = 0 ) or ( a = 0 and b ! = 0 and d ! = 0 )
print " Ron " to the standard output
else
print " Hermione "
declare integer array result size 4 = { 6 , 8 , 4 , 2 }
declare integer n
read n
if n is 0
print " 1 " , newline
else
print result [ n % 4 ] , newline
in the function bigmod that takes long long a , b , m and returns long long
if ( b is 0 ) , return 1 modulo m
x = long long with x = bigmod ( a , b / 2 , m )
x = ( x * x ) modulo m
if ( b modulo 2 ) , x = ( x * a ) modulo m
return x
a = vector of long long
s = long long
vis = array of 4 bool
in the function f that takes long long i
if ( i > 10000000000 ) , return
if ( i ) , append i in a
f ( i * 10 + 4 )
f ( i * 10 + 7 )
f on 0
sort a . begin ( ) and a . end ( )
l , r , i , j , an , k = long long with an = 0
read l , r
i = lower_bound ( a . begin ( ) , a . end ( ) , l ) - a . begin ( )
k = upper_bound ( a . begin ( ) , a . end ( ) , r ) - a . begin ( )
j = max ( k - 1 , i )
an = an + ( a [ i ] - l + 1 ) * a [ i ]
an = an + ( r - a [ j ] ) * a [ k ]
print an
declare const long long INF = 1e9
declare long long variables n and m
read n and m
create long longs cnt1 and cnt2 = 1
for i = 7 to n exclusive multiplying i by 7 , increment cnt1 by one
for i from 7 to m exclusive multiplying i by 7 , increment cnt2
declare long long variable res = 0
if cnt1 + cnt2 < = 7
for i = o while i ! = n
for j = o while j ! = m
create vector of long long called used with 7 elements filled with 0
for a = i , k = 0 , while k ! = cnt1 , increment k and divide a by 7 , incrementing used [ a % 7 ] on each iteration
for a = j , k = 0 , while k ! = cnt2 , increment k and divide a by 7 , incrementing used [ a % 7 ] on each iteration
if max_element of used < = 1 , increment res
print res
declare integer n
declare colors as string
declare freq as map from character to integer
read n
read colors
for i = 0 to n exclusive
increment freq [ colors [ i ] ]
if n is 1 or freq [ colors [ i ] ] is greater than or equal to 2
print " Yes " , newline
print " No " , newline
make int n
read n
make string s
read s
make bool ok = true
let int o = 0
create int z = 0
for i = 0 to s . size ( ) exclusive
if s [ i ] is equal to ' 1 '
increment o and set z to 0
else do
increment z and set o to 0
if o is equal to 2 , set ok to 0
if z is equal to 3 , set ok to 0
if n is equal to 1
if s is " 0 " , set ok to 0
else do
if s [ 0 ] is equal to ' 0 ' and s [ 1 ] is equal to ' 0 ' , set ok to 0
is s [ s . size ( ) - 1 ] is equal to ' 0 ' and s [ s . size ( ) - 1 ] is equal to 0 , set ok to 0
if ok is truthy
print " Yes "
else
print " No "
create integers n , i , array a length 1111111 , ans = 0 , array d length 1111111
read n
assign 1 to d [ 1 ]
for i = 2 to n exclusive , assign d [ i / 2 ] * 2 to d [ i ]
for i = 0 ; i + 1 < n ; i + +
add a [ i ] to a [ i + d [ n - i - 1 ] ]
add a [ i ] to ans
print ans
create const long long int MAXN = 1e5 + 5
let constant long long integer MINN = 1e2
let const int inf = ( 1e9 + 7 )
let ints x1 , x2 , x3 , and x4
declare error
print " yes "
exit function
create int n and int array a of size MAXN
read n
for i = 1 to n , read a [ i ]
for i = 1 to n - 2
for j = 2 to n - 1
if j is equal to i , continue loop
set x1 = a [ i ] , set x2 to a [ i + 1 ] , set x3 to a [ j ] , and set x4 to a [ j + 1 ]
if x2 is less than x1 , swap values of x1 and x2
if x3 is greater than x4 , swap values of x3 and x4
print " no "
str = string
read str
a , b = int
set a to ( str [ 0 ] - 48 ) * 10 + str [ 1 ] - 48
set b to ( str [ 3 ] - 48 ) * 10 + str [ 4 ] - 48
loop infinitely
if b is 59
if a is 23
set a to 0
else
increment a
set b to 0
else
increment b
c , d , e , f = int with c = a / 10 and d = b mod 10 and e = a mod 10 and f = b / 10
if c is d and e is f
print c then e then " : " then f then d
define function solve
declare long longs n and k
read n and k from the input
create new character variable c = ' a '
declare new string variable s with value " "
create integer i with value 0
for while i < k ,
append c to the end of s
increase c by 1
assign the new value = ' a ' to c
while i < n
append c to s
increment c
if c is greater than min of ' z ' and char ( ' a ' + k - 1 ) , change c to ' a '
increment i
print s
declare new long long called t = 1
decrement t and loop further , while t is not 0 , calling function solve on each iteration
kids , candies , input , answer = long long integers
read kids , candies
qkids = queue of long long integer
index = queue of long long integer
for i = 0 to kids exclusive
read input
push input in qkids
push i in index
while ( not qkids . empty ( ) )
if ( qkids . front ( ) < = candies )
pop qkids
pop index
else
push qkids . front ( ) - candies in qkids
push index . front ( ) in index
pop qkids
pop index
answer = back of index
print ( answer + 1 )
let PI a constant double with value acos ( - 1 )
let MAX a constant int with value 2e9 + 7
let MOD be a constant long long with value 1e9 + 7
in function solve
let n an int
read n
let v a vector of ints
for i from 0 to n exclusive
let c an int
read c
append c to v
let s a multiset of ints
let ans an int , ans = 0
for i from 0 to n - 1 exclusive
if v [ i ] < v [ i + 1 ]
increment ans
otherwise , if size of s is not 0
let it be an iterator starting at s
if v [ i + 1 ] > current value of it
increment ans
erase value at it from s
insert v [ i ] into s
otherwise
insert v [ i ] into s
print ans
call solve
declare integer n
declare string a
declare string b
read a and b
declare map mp of strings to ints
set mp [ " monday " ] to 1
set mp [ " tuesday " ] to 2
set mp [ " wednesdya " ] to 3
set mp [ " thursday " ] to 4
set mp [ " friday " ] to 5
set mp [ " saturday " ] to 6
set mp [ " sunday " ] to 0
define int p1 = mp [ a ]
define int p2 = mp [ b ]
if ( p1 + 30 ) mod 7 is p2
print " YES "
if ( p1 + 28 ) mod 7 is p2
print " YES "
if ( p1 + 31 ) mod 7 is p2
print " YES "
print " NO "
n , m , k , a = long long
read n , m , k , a
minn = long long with minn = 20000000000
for i = 0 to n exclusive
read a
if i modulo 2 is 0 , minn = min of a and minn
if n modulo 2
if n / 2 + 1 < = m
x = long long with x = n / 2 + 1
x = m / x * k
if x < minn , print x else minn
else
print 0
else
print 0
new integer called n
declare integer variable with name a
declare vector of integers called b
create vector of integers c
jawab is a new vector of integers
read standard input to n
for i from 0 to n exclusive incrementing i
read from the input to a
push a into b
add a to the end of c
sort c using greater < int > ( ) as a comparator
in a for loop , change i from 0 to n exclusive
for j = 0 to n exclusive incrementing j
if b [ i ] is equal to c [ j ] and i is equal to n - 1
print j + 1 and " \ n "
break
else if b [ i ] = c [ j ]
print j + 1 and " "
break
define constant long long mod = 1000000007
declare strings s and t
new 2d array of long longs f 5001 by 5001
read s and t
create integers a = length of s and b = length of t
new long long variable sum with value 0
decrement o in a for loop from a - 1 to 0 inclusive
in a for loop , change i from b - 1 to 0 inclusive counting down
if f [ o ] [ i ] > = mod , change f [ o ] [ i ] to the remainder of f [ o ] [ i ] divided by mod
change sum to sum + f [ o ] [ 0 ]
if sum > = mod , change the value of sum to sum % mod
print sum
let x , y be integers
read x and y
let d2 be an integer with d2 = x * x + y * y
let the float integer D2 is equal to square root of d2
let the integer n is equal to square root of d2
let res be a float value with res = D2 - n
if x is equal to 0 or y is equal to 0
print black and newline
if x * y is greater than 0
if n modulus 2 is equal to 0
print black and newline
if res is equal to 0
print black and newline
print white and newline
else if x * y is less than 0
if n modulus 2 is equal to 0
if res is equal to 0
print black and newline
print white and newline
print black and newline
t , i = int and a = int array of size 30
s = string
read t then s
if t is 1
print " Yes "
for i = 0 to 29 set a [ i ] to 0
for i = 0 to t increment a [ s [ i ] - ' a ' ]
for i = 0 to 27
if a [ i ] > 1
print " Yes "
print " No "
M = const int with M = 100 + 10
n , m , a , b = int
read n then m then a then b
if m is 1
print " 1 "
else
if ( a - 1 ) mod m is 0
rowa = int with rowa = ( a - 1 ) / m + 1
trow = int with trow = ( n - 1 ) / m + 1
if rowa is trow
print " 1 "
else
if b < = rowa * m
print " 1 "
else
if ( b - a + 1 ) mod m is 0
print " 1 "
else
if b is not n
print " 2 "
else
print " 1 "
else
rowa = int with rowa = ( a - 1 ) / m + 1
rowb = int with rowb = ( b - 1 ) / m + 1
trow = int with trow = ( n - 1 ) / m + 1
if rowa is trow
print " 1 "
else
lastrowa = int with lastrowa = rowa * m
ig b < = lastrowa
print " 1 "
else
if b < = lastrowa + m
print " 2 "
else
if b mod m is 0
print " 2 "
else
if ( b - a + 1 ) mod m is 0
print " 2 "
else
if b is not n
print " 3 "
else
print " 2 "
declare constant integer N = 1e5
declare long long array arr size N + 5
declare long long array dif size N + 5
declare integer n
declare getMax with no arguments , returning long long
declare long long mx1 = dif [ 1 ]
declare long long mx2 = mx1
for i = 2 to n - 1 inclusive , incrementing i by 1
let mx1 be maximum of ( dif [ i ] and mx1 + dif [ i ] )
let mx2 be maximum of mx2 and mx1
return mx2
declare getMin with no arguments , returning long long
declare long long mn1 = dif [ 1 ]
declare long long mn2 = mn1
for i = 2 to n - 1 inclusive , incrementing i by 1
let mn1 be minimum of ( dif [ i ] and mn1 + dif [ i ] )
let mn2 be minimum of ( mn2 and mn1 )
return mn2
read n
for i = 1 to n inclusive , incrementing i by 1 , read arr [ i ]
for i = 1 to n - 1 inclusive , incrementing i by 1
let dif [ i ] be absolute value of ( arr [ i ] - arr [ i + 1 ] )
if i bitwise and 1 , let dif [ i ] be dif [ i ] * - 1
declare long long ans = maximum of result of getMax and - result of getMin
print ans and newline
mod = static integer = 1e9 + 7
n , m are integers , row , col are integer arrays both of size 105 , table is an integer array of sizes 105 and 105 , minn and flag are integers
while read n , m
tmp = integer = 0
call memset with row , 0 , call sizeof with row
call memset with col , 0 , call sizeof with col
for i = 1 to n inclusive
for j = 1 to m inclusive , read table [ i ] [ j ]
if m is at least n
for i = 1 to n inclusive
set min to 0x3f3f3f3f
for j = 1 to m inclusive
if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ]
if minn
add minn to tmp
set row [ i ] to minn
for j = 1 to m inclusive , subtract minn from table [ i ] [ j ]
for j = 1 to m inclusive
set minn to 0x3f3f3f3f
for i = 1 to n inclusive
if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ]
if minn
add minn to tmp
set col [ j ] to minn
for i = 1 to n inclusive , subtract minn from table [ i ] [ j ]
else
for j = 1 to m inclusive
set minn to 0x3f3f3f3f
for i = 1 to n inclusive
if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ]
if minn
add minn to tmp
set col [ j ] to minn
for i = 1 to n inclusive , subtract minn from table [ i ] [ j ]
for i = 1 to n inclusive
set minn to 0x3f3f3f3f
for j = 1 to m inclusive
if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ]
if minn
add minn to tmp
set row [ i ] to minn
iterate m times , subtract minn from table [ i ] [ j ]
set flag to 1
for i = 1 to n inclusive
for j = 1 to m inclusive
if table [ i ] [ j ]
set flag to 0
break
if flag
for i = 1 to n inclusive
for k = 1 to row [ i ] inclusive , print " row " , i
for j = 1 to m inclusive
for j = 1 to col [ j ] inclusive , print " col " , j
else
print - 1
str = string
flag = boolean = false
read str
for i = 0 to length of str exclusive
if str [ i ] is 0
erase the elements of str from i onwards
flag = true
exit the for loop
if flag is false , then str [ 0 ] = 0
lead = integer = 1
for i = 0 to length of str exclusive
if str [ i ] is 0 and lead is nonzero , continue
lead = 0
print str [ i ]
print endline
Create constant integer mo with value 1000000007
Create consant integer inf with value 0x3f3f3f3f
Create double pi with value 3 . 14159265358979323846
Create double e with value 2 . 71828182845904523536
In function read that takes integer reference x
f = int with value 1
set x to 0
call getchar and store result in character ch
while ch < ' 0 ' and ch > ' 9 '
if ch is ' - ' , set f to - 1
call getchar and store the result in ch
while ch is between ' 0 ' and ' 9 ' inclusive
set x to x * 10 + ch - ' 0 '
call getchar and store result in ch
set x to x * f
Let n , m integers
Let s , ss , sss strings
read n and m
read s
for i = n - 1 to 0 inclusive
set ss to substring of s starting at index i
set sss to substring of s starting at index n - i
append ss onto sss
if s equals sss
Print s
Print ss m - 1 times
Print new line
let f be a false boolean
n , t , a , b , da , db = int
read n , t , a , b , da , db
if n = 0
set f to true
else
for i = 0 to t exclusive
if a - i * da = n or b - i * db = n then f = true
for i = 0 to t exclusive
for j = 0 to t exclusive
if a - i * da + b - j * db = n then set f to true
if f
else
create integers flag , gender , ok , t and cnt
cal is a new array of integers with size 10005
declare new string variable s
create an arrays of strings x with 6 elements = " lios " , " liala " , " etr " , " etra " , " initis " , " inites " , and y wth 10005 elements
function cmp with string arguments a and b that returns integer
define integer variables len1 = length of a , and len2 = length of b
in a for loop , change i from 0 to len2 exclusive
if a [ len1 - len2 + i ] ! = b [ i ] , return 0
return 1
function over with string argument s
print s
terminate the process
create new integer called cnt with value 0
loop , reading s from the input
increment cnt by one
change the value of y [ cnt ] to s
change flag to 0
in a for loop , change i from 0 to 6 exclusive
if cmp ( y [ cnt ] , x [ i ] ) returned true
change flag to 1
change the value of cal [ cnt ] to i
if flag = 0 , call over ( " NO " )
if character from the input is equal to ' \ n ' , stop the loop
if cnt = 1 , call over ( " YES " )
start for loop from i = 1 to cnt exclusive
if cal [ i ] % 2 ! = cal [ i + 1 ] % 2 | | cal [ i ] > cal [ i + 1 ] , call over ( " NO " )
change flag to 0
for integer i = 1 to cnt inclusive incrementing i
if cal [ i ] / 2 = 1 , increment flag by one
if flag ! = 1 , call over ( " NO " )
call over ( " YES " )
s = string
read s
len = int with len = length of s
p = pointer to int with p = new int of size len
set all values of len to 0
for i = 0 to len
if s [ i ] is not ' . ' then increment p [ i ]
if i is greater than 0 and i is less than len - 1 and s [ i - 1 ] is s [ i + 1 ]
increment p [ i ]
continue loop
if i is greater than 0 and s [ i - 1 ] is not ' . ' and s [ i - 1 ] is not s [ i ] then increment p [ i ]
if i is less than len - 1 and s [ i + 1 ] is not ' . ' and s [ i + 1 ] is not s [ i ] then increment p [ i ]
if p [ i ] is 3
print " Yes "
print " No "
declare string variable s
read s
create integers ab and ba = 1000000
for integer i = 0 to n - 1 exclusive
if s [ i ] = ' A ' and s [ i + 1 ] is equal to ' B '
change ab to i + 2
break the loop
for integer i = 0 to n - 1 exclusive
if s [ i ] is equal to ' B ' and s [ i + 1 ] is equal to ' A '
assign i + 2 to ba
break the loop
create bool flag = false
for integer i = ab to n - 1 exclusive
if s [ i ] = ' B ' and s [ i + 1 ] is equal to ' A '
set flag to true
stop the loop
for i = ba to n - 1 exclusive
if s [ i ] = ' A ' and s [ i + 1 ] = ' B '
change flag to true
stop the loop
print " YES " if flag is true or " NO " if it is false
create unsigned long long n , s , w , e
read n
if n mod 4 = and n different from 0
set s to 4
else
assign n modulo 4 to s
s = 8 ^ s
set s to s mod 10
print s
let n be an integer
read in n
let v be a vector of integers of size n
iterate for n times , read in v [ i ]
let v1 be a vector of integers , set v1 to v
sort v1 in ascending order
iterate for n times
if i is greater than 0 , print " "
print 1 + ( v1 . end ( ) - upper_bound ( v1 . begin ( ) , v1 . end ( ) , v [ i ] ) )
print a newline
long long function max with long long arguments a and b
if a > = b
return a
else
return b
define function solve
declare new integer variable n
read user input to n
a is a new array of integers with size n
declare new array of long longs m with n elements
new long long variable mx = 0
ans is a new long long with value 0
start for loop from i = 0 to n exclusive
read user input to a [ i ]
declare integer k = 0
in a for loop , change j from 0 to a [ i ] exclusive
declare integer variable with name x
read x from the input
change k to max of k and x
change the value of mx to max of mx and x
assign k to m [ i ]
for i = 0 to n exclusive , change ans to ans + ( ( mx - m [ i ] ) * a [ i ] )
print ans to the standard output
call function solve
let n be a integer
while read n
if n & 1 is true
print n / 2 and newline
the integer value of m = 2
while m < = n , m < < = 1
m > > = 1
print ( n - m ) / 2 and newline
create map A from pair of integer , integer to integer
create integers x , y , k , p , ind with x = 0 , y = 0 , k = 0 , p = 1 , ind = 1
while x is less than or equal to 100 or y is less than or equal to 100
for i = 1 to ind inclusive
increment x by p
set A [ make pair from ( x , y ) ] to k
increment k
for i = 1 to ind inclusive
increment y by p
set A [ make pair from x , y ] to k
increment k
increment ind
set value of p to - 1
create integers a , b
read a read b
print A [ make pair from a , b ] print newline
y , k , n = integers
read y , k , n
x = integers x = k - y
while x < 1 , x = x + k
if x + y > n
print - 1
else
print x
while x + y + k < = n
print ' ' , x + k
x = x + k
print new line
n , m , k , l = long long int
read n , m , k , l
if m > n or l > n - k
print - 1
x = long long int
if ( k + l ) % m = 0
let x = ( k + 1 ) / m
else
let x = ( k + 1 ) / m + 1
if m * x > n
print - 1
else
declare integer n
read n
if n mod 2
print ( n - 1 ) / 2
else
print ( n - ( 1 < < ( 31 - __builtin_clz ( n ) ) ) ) / 2
x , y = integers
while x and y can be read with valid values for integers
if x is 0 and y is 0
print 0
continue
r = integer = the max value of the absolute value of x and the absolute of y and the result minus 1
ans = integer = r * 4
if x - y > = 0 and x + y - 1 > 0
ans = r * 4 + 1
else if x - y < 0 and x + y > = 0
ans = r * 4 + 2
else if x - y < = 0 and x + y < 0
ans = r * 4 + 3
else if x - y > 0 and x + y - 1 < 0
ans = r * 4 + 4
print ans
let len , a be integers with a = array of of integers of length 26
let str be a string
read len , str
for i = 0 to len exclusive , increment a [ str [ i ] - a ] by 1
if len is equal to 1 or a [ max_element ( a , a + 26 ) - a ] > = 2
print Yes and newline
print No and newline
n , i , j = long long
read n
a = vector of n string
for i = 0 to n exclusive read a [ i ]
b = vector of n string
for i = 0 to n exclusive read b [ i ]
for ti = 0 to 4 exclusive
c = vector of n string
c = b
for i = 0 to n exclusive
fpr j = 0 to n exclusive c [ j ] [ n - 1 - i ] = b [ i ] [ j ]
b = c
d = vector of n string
d = b
for i = 0 to n exclusive d [ i ] = b [ n - 1 - i ]
if a is c or d
set int n , sum to 0
create an integer vector v
set character mark to value of +
if mark is not equal to = then do the following
if mark is + then do
set the push_back value of v to 1
add one to sum
if mark is - then do
set the push_back value of v to - 1
minus 1 from sum
take input mark
read n
for i = 0 to less than or equal to v . size ( ) - 1 do the following
if sum is greater than n then do
if v [ i ] is less than 0 then do
if sum - n is less than or equal to n - 1 then do
subtract sum - n from v [ i ]
set sum to n
break
else
subtract n - 1 from v [ i ]
subtract n - 1 from sum
else if the sum is less than n
if v [ i ] is greater than 0 then do
if n - sum is less than or equal to n - 1 then do
v [ i ] equals v [ i ] plus n - sum
set sum to n
break
else
v [ i ] equals v [ i ] plus n - 1
sum equals sum plus n - 1
else
break
if sum is n then do
output v [ 0 ]
for i = 1 to less than or equal to v . size ( ) - 1 do the following
if v [ i ] is greater than 0 then do
output +
else
output -
output the absolute value of v [ i ]
output = n
else
create integers n , m , len , i and mark with mark = 0
let str be a string
read n , m and str
set len to length of str
for i = n - 1 to 0 inclusive
if substr ( 0 , i ) of str is equal to substr ( n - i , n ) of str
set mark to i
break
print str
for m - 1 iterations print substr ( mark ) of str
print newline
let N be a constant integer with N = 300009
let n be a integer
read n
dp = 2d array of integers with 26 rows and 26 columns
for i = 0 to 26 exclusive
for j = 0 to 26 exclusive , dp [ i ] [ j ] is equal to 0
s = array of strings of length n
for i = 0 to n exclusive
read s [ i ]
let sz be a integer with sz = length of s [ i ]
let last_later be a integer with last_later = s [ i ] [ sz - 1 ] - a
let first_later be a integer with first_later = s [ i ] [ 0 ] - a
for j = 0 to 26 exclusive
let res be a long integer with res = 0
for i = 0 to 26 exclusive , res = maximum of res and ( long long ) dp [ i ] [ i ]
print res and newline
let maxn be const int with maxn = 1e4 + 10
let mp be map from string to int
let a , b , c be strings
set mp [ " C " ] to 1
set mp [ " C # " ] to 2
set mp [ " D " ] to 3
set mp [ " D # " ] to 4
set mp [ " E " ] to 5
set mp [ " F " ] to 6
set mp [ " F # " ] to 7
set mp [ " G " ] to 8
set mp [ " G # " ] to 9
set mp [ " A " ] to 10
set mp [ " B " ] to 11
set mp [ " H " ] to 12
read a , b , c
if mp [ a ] > mp [ b ] , call swap of a , b
if mp [ a ] > mp [ c ] , call swap of a , c
if mp [ b ] > mp [ c ] , call swap of b , c
for i = 1 to 100 inclusive
if ( mp [ b ] - mp [ a ] = = 4 and mp [ c ] - mp [ b ] = = 3
else if mp [ b ] - mp [ a ] = = 3 and mp [ c ] - mp [ b ] = = 4
else
update mp [ a ] to mp [ a ] + 12
let tem be string with tem = a
set a to b
set b to c
set c to tem
create boolean f
create list of strings res
create list iterator it
declare string array arr with size 21
declare string array ar with size 21
declare doubles array a with size 21
declare long long array aa with size 21
declare ints n , m and z
create double k
read input to n and m
read input to k
loop i from 0 to n exclusive
read arr [ i ]
read a [ i ]
push arr [ i ] to res
for i = 0 to n exclusive
assign k * a [ i ] to a [ i ]
if a [ i ] is less than 100
set a [ i ] to 0
remove arr [ i ] from res
assign a [ i ] to aa [ i ]
for i from 0 to m exclusive
read ar [ i ]
push ar [ i ] to res
sort res
remove duplicates from res
assign length of res to z
print z
assign 0 to f
print value at it and " "
for integer i = 0 to n exclusive
if value at it = arr [ i ] and f is equal to 0
create int y = a [ i ]
if y = 8177 or y = 115 or y = 231 or y = 434 or y = 463 or y = 492 , increment y by one
print y
change f to 1
if f = 0 , print " 0 "
declare boolean flag
declare integer variables i and n
declare string str
create integer arrays a with size 5 and b with size 100005
create int ans = 0
set sizeof ( a ) bytes at the pointer a to 0
read str
change n to length of str
change flag to false
for i = 0 to n exclusive
if str [ i ] is equal to ' # '
increment a [ 1 ] by one
if a [ 3 ] + a [ 1 ] > a [ 2 ] or i = 0 , change flag to true
assign a [ 2 ] - a [ 3 ] + 1 to ans
else if str [ i ] = ' ( '
increment a [ 2 ]
if i = n - 1 or a [ 3 ] + a [ 1 ] > a [ 2 ] , set flag to true
else
increment a [ 3 ]
if a [ 3 ] + a [ 1 ] > a [ 2 ] or i = 0 , change flag to true
if ans is less than a [ 2 ] - a [ 3 ] + 1 , assign true to flag
if flag is true
print - 1
for i from 1 to a [ 1 ] exclusive , print 1
print a [ 2 ] - a [ 3 ] - a [ 1 ] + 1
nr , pd = long long
read nr
f2p = 1
nrr = 0
pd = 0
for i = 2 to sqrt ( nr ) inclusive
while nr modulo i not zero
if nrr < 2 increment nrr , multiply f2p by i
divide nr by i
increment pd
if nr > 1 increment pd
if pd < = 1
else if pd is 2
else
create int n , x1 , x2 , y1 , y2
read n , x1 , x2 , y1 and y2
set sum1 = 100000 and sum2 to 1000000
if abs of x1 - x2 = n or abs of y1 - y2 equal to n
assign x1 + x2 + y1 + y2 to sum1
sum2 = n - x1 + n - x2 + n - y1 + n - y2
else
set sum1 = abs of y1 - y2 + abs of x1 - x2
print min of sum1 and sum2
create string t
create int k
read k and k
read t
w = 0
for i = 0 to size of t exclusive
set b to true
for j = 0 to size of t exclusiveand for j = 0 to i exclusive
if t [ j ] different from t [ size of t - i + j ] , set b to false
if b is true , set w = 1
for i = 0 to k exclusive
for j = 0 to size of t - w exclusive , print t [ j ]
for i = size of t - w to size of t exclusive , print t [ i ]
print a newline
declare long long n
read n
if n is 0
print 1 , newline
if ( n - 1 ) % 4 is 0
print 8 , newline
else if ( n - 2 ) % 4 is 0
print 4 , newline
else if ( n - 3 ) % 4 is 0
print 2 , newline
else if ( n - 4 ) % 4 is 0
print 6 , newline
i , j , k , cnt , n = integers with cnt = 0
s = string
Read n
Read s
set i to 0
while s [ i ] is equal to <
if i is equal to n , then Terminate the loop
increment cnt
increment i
set j to n - 1
while s [ j ] is equal to >
if j is equal to - 1 , then Terminate the loop
increment cnt
decrement j
print cnt and a new line
x , t , a , b , da , db , first , second = int
read x , t , a , b , da , db
ouput = " NO " = string
if x = 0 then set output to " YES "
for first = 0 , until first < a / da exclusive and first < t , increment first
if output = " YES " exit loop
for second = 0 , until second < b / db and second < t , increment second
if da * first = a - x
set output to " YES "
exit loop
if db * second = b - x
set output to " YES "
exit loop
if da * first + db * second = a + b - x
set output to " YES "
exit loop
if db * first + da * second = a + b - x
set output to " YES "
exit loop
print output
create maps of int to int M and H
declare integer variable len = 0 and integer arrays arr and vis with 100010 elements
create integers vector array V with 100010 elements
dfs is a void function with int argument u
if vis [ u ] is true , return
set vis [ u ] to 1
increment len
for i = 0 to length of V [ u ] exclusive , call dfs ( V [ u ] [ i ] )
declare int variables n , k and ans where ans = 0
read input to n and k
loop i from 1 to n inclusive
read arr [ i ]
increment M [ arr [ i ] ]
sort arr from index 1 to 1 + n
loop i from 1 to n inclusive
set value of H [ arr [ i ] ] to i
for i = 1 to n inclusive
if vis [ H [ arr [ i ] ] ] = 0
change len to 0
call function dfs with argument H [ arr [ i ] ]
increase ans by len / 2
if len & 1 ! = 0 , increment ans
print ans
declare integer l
read l
declare integer array md size 4 = { 8 , 4 , 2 , 6 }
if l is 0
print " 1 " , newline
else
print md [ ( l - 1 ) % 4 ] and newline
create int variables n and m
declare integer variable called menor
read from the input to n and m
set menor to INT_MAX
start for loop from i = 0 to m exclusive
declare int variables a and b
read standard input to a and b
assign the new value = min of menor and b - a + 1 to menor
print menor and " \ n "
print " 0 "
for i = 1 to n exclusive , print " " and i % menor to the standard output
print " \ n " to the standard output
n and k are integers
read n and k
s is a string
alfa is a character vector of size 26
for i = 0 to integer value 26 exclusive , set alfa [ i ] to character value ( ( integer value of character a ) + i )
cont = integer = 0
for i = 0 to integer value n exclusive
add alfa [ cont ] to s
increment cont
if cont equals 26 or cont equals k , set cont to 0
display s
let inf be const int with inf = 0x3f3f3f3f
let maxn be const int with maxn = 110
define max which takes integers a and b as arguments and returns int
if a is greater than b , return a else return b
define min which takes integers a and b as arguments and returns int
if a is greater than b , return b else return a
a = array of integers of size maxn
let i , n be integers
while input is available , read n
set a [ 0 ] to 0 and a [ n + 1 ] to 1001
for i = 1 to n inclusive , read a [ i ]
let l be integer
let maxi be integer with maxi = 1
for l = 0 to n inclusive
let pos be integer with pos = 1
while l is less than or equal to n and a [ l ] + 1 is equal to a [ l + 1 ] , increment l
if l - pos + 1 is greater than maxi , set maxi to l - pos + 1
if maxi is equal to 1
print out 0 with newline
else
print maxi - 2 with newline
n , m = long long
read n , m
a , index = integers with a = array of size n
max = integer with max = INT_MIN
for i = 0 to n exclusive , read a [ i ]
val = double with val = ceil ( a [ 0 ] / m )
for i = 0 to n exclusive
val = ceil of double ( a [ i ] ) / double ( m )
if ( max < = val )
index = i + 1
max = val
n = int and dp = two dimensional int array of sizes 30 and 30
a = string array of size 500000 + 10
read n
for i = 0 to n
u = int with u = a [ i ] [ 0 ] - ' a '
v = int with v = a [ i ] [ size of a [ i ] - 1 ] - ' a '
for j = 0 to 26
if dp [ j ] [ u ] is 0 continue
set dp [ j ] [ v ] to max of dp [ j ] [ v ] , dp [ j ] [ u ] + size of a [ i ] as int
set dp [ u ] [ v ] to max of dp [ u ] [ v ] , size of a [ i ] as int
res = int with res = 0
for i = 0 to 26 set res to max of res , dp [ i ] [ i ]
declare new array of integers a with size 1005
create integer variable n
read n and loop further
for i from 0 to n exclusive , read input to a [ i ]
create new integer variable ok with value 0
start for loop from i = 1 to n exclusive
for j from 0 to n - 1 exclusive incrementing j
max1 is a new integer variable = max of a [ i - 1 ] and a [ i ]
declare integer min1 = min of a [ i - 1 ] and a [ i ]
create integer max2 = max of a [ j ] and a [ j + 1 ]
min2 is a new integer variable with value min of a [ j ] and a [ j + 1 ]
if min1 < min2 and max1 > min2 and max1 < max2 , change ok to 1
if ok is not zero
print " yes " to the standard output
else
print " no "
declare integer n
declare new array of characters chair with size 10000
read input to n
declare integer a
read ( chair + 1 ) from the input
set chair [ 0 ] to ' 0 '
assign ' 0 ' to chair [ n + 1 ]
declare new integer called ans = 0
if n is equal to 1 and chair [ 1 ] is equal to ' 0 '
print " No " to the standard output
if n = 1 and chair [ 1 ] = ' 1 '
print " Yes "
for i = 1 to n inclusive incrementing i
if chair [ i ] = ' 1 ' and ( chair [ i - 1 ] = ' 1 ' or chair [ i + 1 ] = ' 1 ' )
assign 1 to ans
break the loop
if chair [ i ] = ' 0 '
if chair [ i - 1 ] is ' 0 ' and chair [ i + 1 ] is ' 0 '
change ans to 1
break the loop
if ans is equal to 1
print " No "
else
print " Yes " to the standard output
s = string
read s
a , b , c = strings
n = integers with n = s . size ( )
mx = integer with mx = - 1
for i = 0 to n exclusive
for j = i + 2 to n exclusive
a = substr ( 0 , i + 1 ) of s
b = substr ( i + 1 , j - i - 1 ) of s
c = substr ( j , n - j + 1 ) of s
sum = integer with sum = 0
if ( a [ 0 ] is 0 and a . size ( ) is not 1 ) , continue next iteration
if ( b [ 0 ] is 0 and b . size ( ) is not 1 ) , continue next iteration
if ( c [ 0 ] is 0 and c . size ( ) is not 1 ) , continue next iteration
if ( a . size ( ) > 7 ) , continue next iteration
if ( b . size ( ) > 7 ) , continue next iteration
if ( c . size ( ) > 7 ) , continue next iteration
if ( atoi ( a . c_str ( ) ) > 1000000 ) , continue next iteration
if ( atoi ( b . c_str ( ) ) > 1000000 ) , continue next iteration
if ( atoi ( c . c_str ( ) ) > 1000000 ) , continue next iteration
sum = sum + atoi ( a . c_str ( ) )
sum = sum + atoi ( b . c_str ( ) )
sum = sum + atoi ( c . c_str ( ) )
mx = max of mx and sum
print mx
create ints n and s
read from the input to n and s
declare ints x and y
declare integer min with value 101
create new integer min2 with value 101
start for loop from i = 0 to n exclusive
read x and y from the input
if s > x and y < min and y > 0
change min to y
else if s > = x and y = 0
assign the new value = y to min2
if min = 101 and min2 ! = 0
print - 1 to the standard output
else if 100 - min < 100 and min ! = 101
print 100 - min
else if 100 - min2 is equal to 100
print 0
create integers n , i , o , z , with o = 0 , z = 0
read n
create integer array a with size n
for i = 0 to n exclusive
read a [ i ]
if n is 1
if a [ 0 ] is 1
print " YES " print newline
else
print " NO " print newline
else
if a [ i ] is 0
increment z
else
increment o
if n is greater than 1
if ( z is greater than 1 and z is not 0 ) or o is n
print " NO " print newline
else
print " YES " print newline
declare integer n
read n
print n / 2 , newline
while n is not 2 and n is not 3
print 2 , " "
decrement n by 2
print n , newline
integers = n , k
s = string array
read n , k , s
integers = id
for i = 1 to less than or equal to n do the following
set bool flag to true
for j = 0 to less than n do the following
if s [ j ] is not equal to s [ j + i ] then do the following
set flag to false
break
if flag is true
set id to i
break
s1 , s2 = string array
set s1 to s . substr ( 0 , id )
set s2 to s . substr ( id )
for i = 1 to less than or equal to k do the following
output s2
output endl
declare integer variable n
loop , reading n from the input
if n is equal to 0
print 1
break the loop
declare integer variable cnt = n modulo 4
if cnt is equal to 1
print 8
else if cnt is equal to 2
print 4
else if cnt = 3
print 2
else if the value of cnt is 0
print 6 to the standard output
str = string
in function check with parameters integers x , y and return boolean
i and j are integers with i = x , j = y
while i is less than j
if str [ i ] equals str [ j ]
increment i
decrement j
else
return false
return true
k = integer
input str , k
len is an integer set to size of str
if len isn ' t divisible by k
assign len / k to k
assign 0 to i
while i is less than len
if not call check with i , i + k - 1
add k to i
create strings str1 and str2
read str1 and str2
declare int variable len1 = length of str1
declare int variable len2 = length of str2
if len1 ! = len2
print " NO "
declare bool variable flag = false
declare integer variable f = 0
for i = 0 to len1 exclusive
if str1 [ i ] ! = str2 [ i ]
if flag = false
assign i to f
set flag to true
else
swap str2 [ f ] and str2 [ i ]
break the loop
declare int variable temp = result of comparing str1 to str2
if temp ! = 0
print " NO "
else
print " YES "
create a function isTriangular that accepts long integer n
r be a double integer and equals to the square root of 1 + ( n < < 3LL )
if r = = floor ( r )
long integer s equals long integer r
return s > 1LL and ( s - 1LL ) & 1LL = = 0
return 0
create a function sum that accepts long integer n
return ( n * ( n + 1 ) ) > > 1LL
let n be a long integer
while read n
let x be a long inter with x = 1
let possible be a boolean value false
while n - sum of x is greater than 0
let y be a long integer with y = n - sum of x
let m be a long integer
let l be a long integer with l = 1
let r be a long integer with r = y
while l is less than r
shift bitwise the value of l + r by 1Ll
store sum of m in long integer fm
if fm is equal to y
possible is equal to true
stop
if fm is less than y
l is equal to m + 1
r is equal to m
if possible is 1 , stop
if sum ( x ) < < 1LL = = n
set possible to true
stop
increment x by 1
if possible is 1
print YES and new line
else
print NO and new line
n = integer
Read n
sum , x , mx , ans , a , b , c , d = integers with mx = 0 and ans = 1
Read a , b , c , d
set x to a + b + c + d
for i = 1 to n exclusive
Read a , b , c , d
set sum to a + b + c + d
if sum is greater than x , then increment ans
if ans is 0 , then set ans to 1
print ans and a new line
a = long long int array of length 200005
b = long long int array of length 200005
let n , m , ma2 = 0 be ints
read n
for i = 0 to n exclusive
read m
ma = 0 = long long int
for j = 0 to m exclusive
x = long long int
read x
set ma to the max of ma and x
set a at i = ma
set b at i = m
set ma2 to the max of ma2 and a at i
ans = 0 = long long intt
for i = 0 to n exclusive then increment ans by b [ i ] * ( ma2 - a [ i ] )
print ans
declare string array s size 100
declare string array t size 100
declare string suit = " RGBYW "
declare bitcount with integer n as argument , returning integer
declare integer ans = 0
while n is greater than 0
let n be n bitwise and ( n - 1 )
increment ans
return ans from function
declare integer n
read n
declare string set cnt
for i = 0 to n exclusive
read s [ i ]
insert s [ i ] into cnt
declare integer distinct = size of cnt
declare integer ans = 8
for i = 0 to ( 1 bitshift left 10 ) exclusive
declare integer tmin = result of run bitcount ( i )
if tmin is greater than or equal to ans , end loop iteration
remove all elements from cnt
for j = 0 to 10 exclusive
if i bitwise and ( 1 bitshift left j )
for k = 0 to n exclusive
if j is less than 5
if s [ k ] [ 1 ] is ' 1 ' + j
add ' 1 ' to end of t [ k ]
else
add ' 0 ' to end of t [ k ]
else
if s [ k ] [ 0 ] is suit [ j - 5 ]
add ' 1 ' to end of t [ k ]
else
add ' 0 ' to end of t [ k ]
for j = 0 to n exclusive
insert t [ j ] into cnt
let t [ j ] be " "
if size of cnt is distinct , let ans be tmin
print ans and newline
define long long variable n
read variable n from the input
create new long longs x and y
read input to x and y
if n + 1 - x > = y
print " White "
else
print " Black "
in function ra with parameters integers x1 , y1 , x2 , y2 , x3 , y3 and return boolean
if d1 , d2 , and d3 are all equal to 0 , return false
if d1 + d2 equals d3 or d1 + d3 equals d2 or d2 + d3 equals d1 , return true
return false
n , x1 , x2 , x3 , y1 , y2 , y3 are integers
read x1 , y1 , x2 , y2 , x3 , y3
if call ra with x1 , y1 , x2 , y2 , x3 , y3
increment x1
if call ra with x1 , y1 , x2 , y2 , x3 , y3
subtract 2 from x1
if call ra with x1 , y1 , x2 , y2 , x3 , y3
increment x1
increment y1
if call ra with x1 , y1 , x2 , y2 , x3 , y3
subtract 2 from y1
if call ra with x1 , y1 , x2 , y2 , x3 , y3
increment y1
increment x2
if call ra with x1 , y1 , x2 , y2 , x3 , y3
subtract 2 from x2
if call ra with x1 , y1 , x2 , y2 , x3 , y3
increment x2
increment y2
if call ra with x1 , y1 , x2 , y2 , x3 , y3
subtract 2 from y2
if call ra with x1 , y1 , x2 , y2 , x3 , y3
increment y2
increment x3
if call ra with x1 , y1 , x2 , y2 , x3 , y3
subtract 2 from x3
if call ra with x1 , y1 , x2 , y2 , x3 , y3
increment x3
increment y3
if call ra with x1 , y1 , x2 , y2 , x3 , y3
subtract 2 from y3
if call ra with x1 , y1 , x2 , y2 , x3 , y3
create long long l1 , r1 , l2 , r2 , k
read long long l1 , r1 , l2 , r2 , k
create long long tot
if l1 > = l2
if l1 > r2
set tot = 0
else if r1 < = r2
tot = r1 - l1 + 1
if k > = l1 and k < = r1 , decrement tot
else
tot = r2 - l1 + 1
if k > = l1 and k < = r2 , decrement tot
else
if l2 > r1
tot = 0
else if r2 < = r1
tot = r2 - l2 + 1
if k > = l2 and k < = r2 , decrement tot
else
set tot to r1 - l2 + 1
if k > = l2 and k < = r1 , decrement tot
print tot
create an array of int dx with elements 0 , 1 , 0 , - 1
create an array of int dy with elements 1 , 0 , - 1 , 0
create ints n , x , y , xx and yy
declare 2d boolean array vis with size 1001 by 1001
bool function on with int arguments x and y
return true if ( x = 0 or y = 0 or x = n or y = n ) , else return false
declare int ans = INT_MAX
void function dfs with int arguments cx , cy and g
if cx < 0 or cx > n or cy < 0 or cy > n , return
if vis [ cx ] [ cy ] is true , return
if cx is equal to xx and cy = yy
set ans to min of ans and g
return
set vis [ cx ] [ cy ] to true
for integer i = 0 to 4 exclusive
read n , x , y , xx and yy
call function dfs with arguments x , y and 0
print ans
function distance ( get int a , b , x and y , return int )
return ( a - x ) ^ 2 + ( b - y ) ^ 2
function check ( get vector of int cod , return bool )
d1 , d2 , d3 = int
i = 0
for i = 0 to size of cod exclusive
decrement cod [ i ]
d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] )
d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] )
d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] )
increment cod [ i ]
if d1 is 0 or d2 is 0 or d3 is 0 continue
if d1 is d2 + d3 or d2 is d1 + d3 or d3 is d2 + d1 return 1
for i = 0 to size of cod exclusive
increment cod [ i ]
d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] )
d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] )
d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] )
decrement cod [ i ]
if d1 is 0 or d2 is 0 or d3 is 0 continue
if d1 is d2 + d3 or d2 is d1 + d3 or d3 is d2 + d1 return 1
cod = vector of int
i = unsigned int
for i = 0 to 6 exclusive
temp = int
read temp
add temp to end of cod
d1 , d2 , d3 = int
d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] )
d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] )
d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] )
if d1 is d2 + d3 or d2 is d1 + d3 or d3 is d2 + d1
print " RIGHT "
else if check ( cod )
print " ALMOST "
else
print " NEITHER "
create string s
create int n
read s and n
if length of s mod n > 0
set l to length of s / n
for i = 0 to n exclusive
for j = 0 to l / 2 exclusive
if s [ j + i * l ] different from s [ ( i + 1 ) * l - j - 1 ]
create long long integer MOD = 1000000009
into the function pw which takes two long long integers a and b and returns a long long integer
if b is 0 then return 1
if b is 1 then return a % MOD
if b % 2 is true
create long long rs = pw ( a , b - 1 )
return ( rs * a ) % MOD
create long long integer rs = pw ( a , b / 2 )
return ( rs * rs ) % MOD
sm = long long integer vector
into the function solve which takes a and b
if b is 0 then return 0
for i = 0 to 35 exclusive
create long long integer ba = ( 1LL < < i ) & b
if ba is equal to 0 then continue
return sm [ i ] + solve ( a , b - ( 1LL < < i ) ) * pw ( a , ( 1LL < < i ) ) ) % MOD
n , a , b , k = long long integers
read n , a , b , k
s = string
read s
create long long integers X and Y with values 1
for i = o to k exclusive
set X = X * b
set X = X % MOD
for i = 0 to k exclusive
set Y = Y * a
set Y = Y % MOD
set X = X * pw ( Y , MOD - 2 )
set X = X % MOD
add 1 to the end of sm
for i = 0 to 40 exclusive
add sm . back ( ) + sm . back ( ) * pw ( X , ( 1LL < < i ) to end of sm
set sm . back ( ) = sm . back ( ) % MOD
create long long integer st = solve ( X , ( n + 1 ) / k )
create long long integer ans = 0
for i = 0 to k exclusive
create long long integer rs = ( pw ( b , i ) * pw ( a , n - i ) ) % MOD
if s [ i ] is ' - ' then set rs = rs * - 1
set rs = rs * st
set ans = ans + rs
set ans = ans % MOD
if ans is less than 0 then set ans = ans + MOD
print ans
declare integer array a size 500010
declare integer n
read n
for i = 0 to n exclusive , read a [ i ]
declare integer ans initialized with 0
declare integers l , r
for i = 0 to n exclusive
let l be i
let r be i + 1
while r is less than n and a [ l ] is not a [ r ]
increment l
increment r
let l be i + 1
decrement r by 2
declare integer num initialized with 0
while l is less than or equal to r
let a [ l ] be a [ l - 1 ]
let a [ r ] be a [ r + 1 ]
increment l
decrement r
increment num
let ans be maximum of ans and num
print ans and newline
for i = 0 to n - 1 exclusive , print a [ i ] and ' '
print a [ n - 1 ] and newline
let len a constant int with value 1e2 + 5
let mod a constant long long with value 1e9 + 7
let pi a constant double with value acos ( - 1 . 0 )
let n , a , b , c long longs
read n , a , b , and c
if a at most b - c
print n / a
otherwise
if n < b
print n / min ( a , b )
let ans a long long with value 0
subtract b from n
add n / ( b - c ) to ans
set n to n mod ( b - c )
increment ans
add c to n
add n / min ( a , b ) to ans
print ans
i , j , k are integers
s = character array of size 100010
while call gets with s
len = integer = string length of s
for i = 0 to len exclusive
if s [ i ] isn ' t the character a , break
for j = i to len exclusive
if s [ j ] is the character a , break
decrement s [ j ]
if i equals len , set s [ len - 1 ] to the character z
display s
a = char array of size 110 with all values set to 0
n = int
read n
read a
if n is 1
print a
else
cnt = int with cnt = 0
for i = 0 to n
if a [ i ] is ' 0 ' increment cnt
print ' 1 '
print ' 0 ' cnt times
print newline
a = string
b , t = long long , c = 0
read a
b = pos of ' = ' in a
t = b
add 2 to b
b = size of a - b + 1
for i = 0 to t exclusive
if a [ i ] is ' | ' increment c
if c + 1 is b - 1
print ' | '
for i = 0 to size of a - 1 exclusive print a [ i ]
print newline
else if c is b
print a
else if c is b + 2
z = pos of ' + ' in a
if z > 1
for i = 1 to size of a exclusive print a [ i ]
print ' | '
else
for i = 0 to size of a exclusive
if i is z + 1 continue
print a [ i ]
print ' | '
else
create long longs x1 , x2 , y1 , y2 , n
read x1 , x2 , y1 , y2
read n
create int t = 0
for i = 0 to n exclusive
create long longs a , b , c
read a , b , c
if ( a * x1 + b * y1 + c ) GREATER THAN 0 AND ( a * x2 + b * y2 + c ) LESS THAN 0 , increment t
if ( a * x1 + b * y1 + c ) LESS THAN 0 AND ( a * x2 + b * y2 + c ) GREATER THAN 0 , increment t
print t
let s be a string
let a and b be integers
let len be an integer
input s
n is an integer set to length of s
w is an integer array of size n + 10
for i = 0 to length of s exclusive
if s [ i ] is the character (
increment a
else if s [ i ] is the character #
assign 1 to w [ len + 1 ]
decrement a
else if s [ i ] is the character )
decrement a
if a is negative
display - 1
for i = length of s - 1 to 0 inclusive
if s [ i ] is the character )
increment b
else if s [ i ] is the character (
decrement b
else if s [ i ] is the character #
break
if b is negative
display - 1
add a to w [ len ]
for i = 1 to len inclusive , display w [ i ]
in function isPalindrome returning bool , accepting string s
define string sCopy = s
if s equals sCopy
return true
else
return false
declare string s
declare int k
read s
read k
define int n = size of s
define int check = 0
if n mod k equals 0
define int len = n / k
for i = 0 to n exclusive
define string word = s . substr ( i , len )
if isPalindrome ( word ) , increment check
increase i by len - 1
if check equals k
print " YES "
else
print " NO "
print " NO "
let n be a integer
let m be a float value
read n , m
create a vector of integers v
for i = 0 to n exclusive
let x be a integer
read x
push_back x into vector v
for i = 0 to n exclusive , v [ i ] is equal to ceiling of v [ i ] / m
let p , max be integers with p = 0 , max = - 1
for i = 0 to n exclusive
if max < = v [ i ]
p is equal to i + 1
max is equal to v [ i ]
print p and newline
let n be a integer
read n
create a set of strings by name items
for long integer i = 0 to n exclusive
let s1 , s2 be strings
read s1 , s2
reverse the values of s2 from beginning to end
the string value of fS = s1 + s2
create a set of strings by name combs
insert fS into combs
for i = 0 to n exclusive
the string value of ns = fS
for long integer j = 0 to 4 exclusive , ns [ j ] is equal to fS [ ( j + 1 ) modulo 4 ]
fS is equal to ns
insert fS into combs
insert * combs . begin ( ) into items
if i is not equal to n - 1 , read s1
print length of items and newline
f = array of 300030 int
ne = array of 300030 int
n , m = int
read n , m
for i = 0 to n inclusive ne [ i ] = i + 1
l , r , x , t = int
while decrementing m remains > 0
read l , r , x
i = l , while i < = r setting i to t at end of while
if i is not x and not f [ i ] f [ i ] = x
t = ne [ i ]
if i < x
ne [ i ] = ne [ x - 1 ]
else
ne [ i ] = ne [ r ]
for i = 1 to n inclusive
if i is 1
print f [ i ]
else
print space , f [ i ]
print newline
MAXN = 400
INF = 3fffffff in exadecimal
MOD = 100007
a = array of MAXN char
read a
len = length of a
ansl , ansm , ansr = 0
f1 and f2 = false
for i = 0 to len exclusive
if a [ i ] is ' + '
f1 = true
continue
if not f1
increment ansl
continue
if a [ i ] is ' = '
f2 = true
continue
if not f2
increment ansm
continue
increment ansr
if ansl + ansm - ansr is 0
print a
else if ansl + ansm - ansr is 2
if ansl > = 2
for i = 1 to ansl exclusive print " | "
print ' + '
for i = 1 to ansm inclusive print " | "
print ' = '
for i = 1 to ansr + 1 inclusive print " | "
print newline
else if ansm > = 2
for i = 1 to ansl inclusive print " | "
print ' + '
for i = 1 to ansm exclusive print " | "
print ' = '
for i = 1 to ansr + 1 inclusive print " | "
print newline
else if ansl + ansm - ansr is - 2
print " | "
a [ len - 1 ] = null byte
print a
else
let maxn be constant integer with maxn = 111
let n and ans be integers with ans = 1 and r be integer array of length maxn
let vis be boolean array of length maxn and f be boolean with value true
function dfs accepts arguments of integers len , x and root and returns integer
if x element of vis array is true and x is equal to root then return len
if x element of array vis is true
assign f equal to false
return len
x element of vis array is equal to true
call dfs function with arguments len + 1 , r [ X ] and root
read n
for i = 1 to n inclusive , read i element of array r
for i = 1 to n inclusive , and f is true
if i element of array vis is false
call dfs function with argument 0 , i and i and assign the result to integer tmp
if tmp modulo 2 equals to 0 tmp / equals 2
ans is equal to ans * tmp / __gcd ( ans , tmp )
if f is false
print - 1
pring ans
create int array vis of size 30
let int n
read n
let string s
read s
for i = 0 to s . length ( ) exclusive
if vis [ s [ i ] ] is truthy
print " Yes "
set vis [ s [ i ] ] to 1
if n is equal to 1
print " Yes "
else
print " No "
maxn = constant integer set to 100000
a , b = arrays of integers with length of maxn , n , r , and ans = integers with r set to 1
read n
for i = 1 to n inclusive , print a [ i ]
sort a + 1 and a + 1 + n
for i = 1 to n inclusive
while r < = n and a [ r ] < = a [ i ] , increment r by 1
if r < = n , increment ans and r by 1
print ans
create new array of long longs a with size 100001
declare new array of long longs s with 100000 elements
declare long longs n , i , max , min , mm , k and t
read n and loop further
read n elements from the input into a , starting from the index 1
start for loop from i = 1 to n - 1 inclusive incrementing i
change s [ i ] to the absolute value of a [ i ] - a [ i + 1 ]
if i is odd , set the value of s [ i ] to 0 - s [ i ]
set max to s [ n - 1 ]
change min to s [ n - 1 ]
if n - 1 is even
set mm to max
else
change mm to 0 - min
change k from n - 2 to 1 inclusive in a loop , counting down by 1
if max is less than 0
change max to s [ k ]
else
assign max + s [ k ] to max
if min is greater than 0
change min to s [ k ]
else
change min to min + s [ k ]
if k is even and max > mm , set mm to max
if k is odd and 0 - min > mm , set mm to 0 - min
print mm
let x be integer
read x
if x = = 1
call puts of " - 1 "
else
print x , " " , x
create int array a of size 1000900
let int n
read n and while n is truthy
set all contents of a to 0
let int x
for i = 0 to n exclusive
read x
increment a [ x ]
create int temp
create int sum = 0
for i = 0 to 1000900 exclusive
set temp to a [ i ] / 2
set a [ i + 1 ] to a [ i + 1 ] + temp
if a [ i ] is not even , increment sum
print sum
declare constant integer N = 105
declare integer array p size N
declare parent with integer argument , returning integer
declare integers n , m
read n and m
declare indep = 0 as integer
declare x , y , z as integers
for i = 0 to n exclusive
read x
if x is 0
increment indep
else
read y
if p [ y ] is 0 , let p [ y ] be y
for j = 0 to x - 1 exclusive
read z
if p [ z ] is 0 , let p [ z ] be z
if result of run parent with z as argument is not result of run parent with y as argument , let p [ result of run parent ( z ) ] be y
declare set = 0 as integer
for i = 1 to m inclusive
if p [ i ] is i , increment set
if set is not 0 , decrement set
print indep + set , newline
declare parent with integer x as argument , returning integer
if p [ x ] is x , return x from function
return result of run parent ( p [ x ] )
make long long int n
read n
create long long integer array arr of size n
for i = 0 to n exclusive , read arr [ i ]
sort arr using arr + n
create ints i = n - 2 and j = n - 1
make long long integer ans = 0
while i is greater than or equal to 0
if arr [ i ] is less than arr [ j ]
add 1 to ans
subtract 1 from j
decrease i by 1
else do
subtract 1 from i
show ans
create multidimensional integer array d of size 20 x 20
create map mp of string to int
in function check with return type int and parameters int x , int y , int z
if d [ x ] [ y ] is 4 and d [ y ] [ z ] is 3 then return 1
if d [ x ] [ y ] is 3 and d [ y ] [ z ] is 4 then return 2
return 3
for i = 0 to 12 exclusive
for j = 0 to 12 exclusive
if j greater than or equal to i
set d [ i ] [ j ] to j - i
else
set d [ i ] [ j ] to j + 12 - i
for i = 0 to 12 exclusive do insert pair < string , int > ( s [ i ] , i ) into mp
create strings X , Y , Z
create ints a , b , c
read X , Y , Z
set a to mp [ X ]
set b to mp [ Y ]
set c to mp [ Z ]
if check ( a , b , c ) is 1
print " major "
if check ( a , b , c ) is 2
print " minor "
if check ( a , c , b ) is 1
print " major "
if check ( a , c , b ) is 2
print " minor "
if check ( b , a , c ) is 1
print " major "
if check ( b , a , c ) is 2
print " minor "
if check ( b , c , a ) is 1
print " major "
if check ( b , c , a ) is 2
print " minor "
if check ( c , a , b ) is 1
print " major "
if check ( c , a , b ) is 2
print " minor "
if check ( c , b , a ) is 1
print " major "
if check ( c , b , a ) is 2
print " minor "
print " strange "
create constant integer MAX_N with MAX_N = 100 + 10
create 2d character array _map with size MAX_N by MAX_N
create integer arrays row , column with row size MAX_N , column size MAX_N
create integer n
read n
for i = 1 to n inclusive
for j = 1 to n inclusive , read _map [ i ] [ j ]
create integer cnt with cnt = 0
for i = 1 to n inclusive
for j = 1 to n inclusive
if _map [ i ] [ j ] is ' . '
increment cnt
set row [ i ] to j
break loop
if cnt is n
for i = 1 to n inclusive , print i print " " print row [ i ] print newline
set cnt to 0
for j = 1 to n inclusive
for i = 1 to n inclusive
if _map [ i ] [ j ] is ' . '
increment cnt
set column [ j ] to i
break loop
if cnt is n
for j = 1 to n inclusive , print column [ j ] to " " print j print newline
print - 1 print newline
let adj be integer vector of size 101
let dis be int with dis = 0
create boolean array vis of size 101
let n be int
in the function gcd which takes two integers a and b and returns an integer
if b = 0
then return a
call gcd on b and a mod b
in the function lcm which takes two integers a and b and returns an integer
return ( a * b ) / gcd ( a , b )
create integer vector ans
in the function dfs which takes a integer
set vis [ start ] to true
create integer size = size of adj [ start ]
increment dis
for i = 0 to size inclusive
create int v = adj [ start ] [ i ]
if vis [ v ] is false then call dfs on v
let masuk be an integer array of size 101
in the function lakukan
set dis = 0
for int i = 1 to n inclusive
if vis [ i ] is false
set dis to 0
call dfs on i
Add dis to the end of ans
create integer size = ans . size - 1
for i = 0 to size inclusive
if ans [ i ] % 2 is 0 then set ans [ i ] to ans [ i ] / 2
create integer hasil = 1
for i = 0 to size inclusive set hasil = lcm of hasil and ans [ i ]
print hasil
read n
set all content of masuk to 0
set all content of vis to false
for i = 1 to n inclusive
x = integer
read x
increment masuk [ x ]
add x to end of adj [ i ]
create boolean bisa = true
for i = 1 to n inclusive
if masuk [ i ] is not 1 then set bisa = false
if bisa = false
then print - 1 and new line
call lakukan
declare boolean ok
declare integer n , m , i , arrays a and b both with lengths of 10
read n and m
for i = 0 to n exclusive , read a [ i ]
for i = 0 to m exclusive , read b [ i ]
for i = 0 to n exclusive
for j = 0 to m exclusive
if a [ i ] is equal to b [ j ]
if ok , print " "
print a [ i ]
if ok equals false , assign true to ok
print newline
let str be a string
read str
create a empty string res
let k be a long integer with k = str [ 0 ] - 0
let i be a long integer
increment res by str [ 0 ]
for i = 1 to length of str exclusive
if str [ i ] - 0 is equal to k
increment res by str [ i ]
stop
if i is equal to length of str
print res . substr ( 1 ) and newline
increment i by 1
for i is less than length of str , increment i by 1 , increment res by str [ i ]
print res and newline
declare inline bs with unsigned long long pointer V , unsigned long longs k , a as arguments , returning unsigned long long
create unsigned long longs j , i , with j = k / 2 , i = 0
while V [ j ] is not a and i is less than j and j is less than k
if a is less than V [ j ]
set k to j
set j to i + ( j - 1 ) / 2
else
set i to j
set j to ( k - j ) / 2 + j
return j from function
create unsigned long longs n , k , i , j , a , c , with i = 0 , c = 0
create unsigned long long array A with size 100000
create boolean array B with size 100000 with B = { }
read n read k
if k is 1
print n print ' \ n '
while i is less than n
read A [ i ]
increment i
sort elements from A to A + n
set i to 0
while i is less than n
if not B [ i ]
increment c
set a to A [ i ] * k
set j to result of run bs with A , n , a as arguments
if A [ j ] is a , set B [ j ] to true
increment i
print c print newline
create integer vector out
integers = N
read N
set integer reports to 0
set integer neg to 0
for i = 0 to less than N do the following
integers = A
read A
if A is greater than or equal to 0 then do the following
add one to reports
else if neg is 2 then do the following
push_back part of out = reports
set reports to 1
set neg to 1
else
add one to reports
add one to neg
if reports is greater than 0 then do the following out . push_back ( reports
output out . size ( )
for i = 0 to less than out . size ( ) do the following
if i > 0 then print a space
output out [ i ]
output an endline
declare const int N = 1e5 + 5
create character array str with N elements
declare bool variables f1 and f2 and bool array flg with size N
create integer len
inline void function ac
print " YES "
inline void function wa
print " NO "
inline bool function judge1 with int argument x
return true if str [ x ] = ' A ' & & str [ x + 1 ] = ' B ' , or else false
inline bool function judge2 with int argument x
return true if str [ x ] = ' B ' & & str [ x + 1 ] = ' A ' or else false
function check1 with int argument x that returns inline bool
set flg [ x ] to set flg [ x + 1 ] to true
loop i from 0 to len - 1 exclusive
return true if flg [ i ] is false and flg [ i + 1 ] is false and judge2 ( i ) is true
set flg [ x ] and flg [ x + 1 ] to false
return false
check2 is a an inlined bool function with int argument x
change flg [ x + 1 ] and flg [ x ] to true
for integer i = 0 to len - 1 exclusive
return true if flg [ i ] is false and flg [ i + 1 ] is false and judge1 ( i ) is true
assign false to flg [ x + 1 ] and flg [ x ]
return false
read input to str
set len to length of str
set first sizeof ( flg ) bytes at the pointer flg to false
change value of f1 and f2 to false
loop i from 0 to len - 1 exclusive
if f1 is false and judge1 ( i ) is true
invert f1
if check1 ( i ) is true
call ac ( )
if f2 is false and judge2 ( i ) is true
invert f2
if check2 ( i ) is true
call ac ( )
call wa ( )
create new string variable path
read line from the input into path
declare new string output
declare new boolean called flag
start a loop from k = 0 to length of path exclusive , incrementing k
if path [ k ] ! = ' / ' or flag = 0 , change output to output + path [ k ]
if path [ k ] is equal to ' / '
set the value of flag to 1
else
change the value of flag to 0
if flag is true and length of output > 1 , change output to the substring of the output = output itself
print output
n , m , vert , edge = long long int and c = long long int array of size 150005
adj = long long int vector of size 150005
in function dfs taking a long long int v
add size of adj [ v ] to edge
increment vert
set c [ v ] to 1
for j = 0 to size of adj [ v ]
if c [ adj [ v ] [ j ] ] equals 0 then call dfs of adj [ v ] [ j ]
i , x , y = long long int
read n then m
for i = 0 to m
read x then y
append y to adj [ x ]
append x to adj [ y ]
for i = 1 to n inclusive
set vert to 0
set edge to 0
if c [ i ] equals 0
call dfs of i
if vert * ( vert - 1 ) does not equal edge then print " NO " and call exit of 0
print " YES "
let a , b , c , d , r , p , t , and ans be integers , let h be an integer array of length 150
let f be a boolen array of length 30
read in a , b , c , and d
set r to a + b
iterate for a times , set h [ i ] to i
iterate for b times , set h [ a + i } to a
iterate for b times , set h [ r + 1 ] to i
iterate for a times , set h [ r + b + i ] to a + i
iterate for b times , set h [ r + a + i ] to h { r + a ]
if b is greater than or equal to a
for i = r + a to r + r , increment h [ i ]
set r to 2 * r
d is equal to the min of d and c + r
for i = c to d times
set t to h [ ( i - 1 ) % r + 1 ]
if f [ t ] is not true , increment p
set f [ t ] to true
set ans to p
set p to 0
change all values in f to 0
if a - b > 1 and d - c + 1 > a + b
iterate for b times , set h [ a + j ] to h [ b + 1 ]
iterate for a times
let k be an integer
while true
increment k
let flag be a boolean , set flag to true
for i = b + 1 to a + b + j - 1
if h [ i ] is equal to k , set flag to false
if flag is true , break out of the loop
set h [ a + b + j ] to k
iterate for b times , set h [ a + a + b + j ] to h [ a + b + b + 1 ]
for i = c iterate until i = d
set t to h [ ( i - 1 ) % r + 1 ]
if f [ t ] is not true , increment p
set f [ t ] to true
print the min of p and ans
INF = const long long with INF = 9223372036854775807LL
PI = const double with PI = acos of - 1
MAX_N = const int with MAX_N = 1e + 6
ALPH = const int with ALPH = 26
alph = const string with alph = " abcdefghijklmnopqrstuvwxyz "
in function count taking reference to int pos , reference to string s , reference to int xd
l = int with l = size of s
loop while pos < 1
if s [ pos ] is ' | '
increment xd
increment pos
else
break
increment pos
in function print taking int a , int b , int c
for i = 0 to a print " | "
print " + "
for i = 0 to b print " | "
print " = "
for i = 0 to c print " | "
print newline
in function check taking int a , int b , int c and returning bool
if a < = 0 or b < = 0 or c < = 0 return false
return a + b is c
in function solve
s = string
read s
l = int with l = size of s
a , b , c = int
set a , b and c to 0
pos = int with pos = 0
call count of pos , s , a
call count of pos , s , b
call count of pos , s , c
if a + b is c
call print of a , b , c
else
if check of a + 1 , b - 1 , c
call print of a + 1 , b - 1 , c
return
if check of a + 1 , b , c - 1
call print of a + 1 , b , c - 1
return
if check of a - 1 , b + 1 , c
call print of a - 1 , b + 1 , c
return
if check of a , b + 1 , c - 1
call print of a , b + 1 , c - 1
return
if check of a - 1 , b , c + 1
call print of a - 1 , b , c + 1
return
if check of a , b - 1 , c + 1
call print of a , b - 1 , c + 1
return
print " Impossible "
t = int with t = 1
loop t times call solve
create constant integer MAXN = 55
let char array mp of size MAXN with array of size MAXN
make bool vis of size MAXN with array of size MAXN
create constant integer array go of size 4 with array of size 2 containing { 0 , 1 , 0 , - 1 , - 1 , 0 , 1 , 0 }
make ints n , m , and all = 0
declare dfs taking in ints x and y and returning integer
create int ans = 1
for i = 0 to 4 exclusive
create ints xx = x + go [ i ] [ 0 ] and yy = y + go [ i ] [ 1 ]
if mp [ xx ] [ yy ] is equal to ' # ' and vis [ xx ] [ yy ] is falsy
set vis [ xx ] [ yy ] to true
set ans to ans + dfs ( x + go [ i ] [ 0 ] , y + go [ i ] [ 1 ] )
return ans
declare solve
if all is less than or equal to 2 , return - 1
for i = 1 to n
for j = 1 to m
if mp [ i ] [ j ] is equal to ' # '
set mp [ i ] [ j ] to ' . '
create integer t = 0
for k = 0 to 4 exclusive
make ints xx = i + go [ k ] [ 0 ] and yy = j + go [ k ] [ 1 ]
if mp [ xx ] [ yy ] is equal to ' # '
set all contents of vis to 0
set vis [ xx ] [ yy ] to true
set t to dfs ( xx , yy )
break loop
set mp [ i ] [ j ] to ' # '
if t is 0 , return - 1
if t is not all - 1 , return 1
return 2
read n and m
set all contents of mp to ' . '
for i = 1 to n
for j = 1 to m
read mp [ i ] [ j ]
if mp [ i ] [ j ] is equal to ' # ' , increment all
print result of solve ( )
n = integer
s = string
input n , s
one and zero are both integers both set to 0
for i = 0 to n exclusive
if s [ i ] is the character 0
increment zero
else
increment one
if one isn ' t 0 , display 1
for i = 0 to zero exclusive , display 0
display newline
cnt = array of 256 int
word = string
read word
for i = 0 to size of word exclusive increment cnt [ word [ i ] ]
ans = cnt [ ' i ' ]
ans = min ( ans , cnt [ ' t ' ] )
ans = min ( ans , ( cnt [ ' n ' ] - 1 ) / 2 )
ans = min ( ans , cnt [ ' e ' ] / 3 )
print ans
return EXIT_SUCCESS
N = const int with N = 110
n , r , cnt = integers with cnt = array of size N
read n
for i = 0 to n exclusive
read r
for j = 0 to r exclusive
tmp = integer
read tmp
increment cnt [ tmp ]
flag = integer with flag = 0
for i = 0 to N exclusive
if ( cnt [ i ] is n )
if ( not flag )
print i
flag = 1
else
print " "
print new line
create int a [ 1000100 ]
create int n
while read n
while decrement n
create int b
read b
increment a [ b ]
num = 0
for i = 0 to 1000100 - 1 inclusive
assign a [ i ] / 2 + a [ i + 1 ] to a [ i + 1 ]
set a [ i ] = a [ i ] mod 2
set num to num + a [ i ]
print num
create new array of long longs dp with 5000 elements
create a map from long longs to long longs called m
create new long long called n
read from the input to n
create string variable s
read s from the user input
declare long long variable cnt with value 0
for i = 0 to length of s exclusive
if i is not 0
change dp [ i + 1 ] to dp [ i ] + ( s [ i ] - ' 0 ' )
else
set dp [ i + 1 ] to s [ i ] - ' 0 '
in a for loop , change i from 1 to length of s inclusive incrementing i
change j from 1 to i inclusive in a loop , incrementing j
increase m [ dp [ i ] - dp [ j - 1 ] ]
increment cnt by one
if n is equal to 0
declare new long long variable ans2 = m [ 0 ] * 2 * cnt - m [ 0 ] * m [ 0 ]
print ans2 to the standard output
declare new long long ans with value 0
start for loop from i = 1 to the square root of n inclusive incrementing i
if n modulo i = 0 and i ! = sqrt ( n )
change ans to ans + 2 * ( m [ i ] * m [ n / i ] )
else if i is equal to the square root of n
change ans to ans + ( m [ i ] * m [ n / i ] )
print ans to the standard output
declare constant integer inf = 0x3f3f3f3f
declare constant long long linf = 1e18
declare constant integer N = 100000 + 10
declare constant double eps = 1e - 10
declare constant integer mo = 1e9 + 7
declare integers n , m
declare integer array st size N
declare integer vector arrays g size N , r size N
declare boolean arrays vis size N , path size N by 2
declare dfs with integer x , integer vector array g , integer k as arguments , returning void
let vis [ x ] be path [ x ] [ k ] be 1
for i = 0 to size of g [ x ] exclusive
declare integer y = g [ x ] [ i ]
if not vis [ y ]
if st [ y ] is 1
if k is 1 , let path [ y ] [ k ] be 1
end current loop
run dfs with y , g , k as arguments
read n and m
for i = 1 to n inclusive , read st [ i ]
for i = 1 to m inclusive
declare integers x , y
read x and y
add y to end of g [ x ]
add x to end of r [ y ]
for i = 1 to n inclusive
if not vis [ i ] and st [ i ] is 1 , run dfs ( i , g , 0 )
set bytes from vis to size of vis to value 0
for i = 1 to n inclusive
if not vis [ i ] and st [ i ] is 2 , run dfs ( i , r , 1 )
for i = 1 to n inclusive
if path [ i ] [ 0 ] and path [ i ] [ 1 ]
print 1 and newline
else
print 0 and newline
let a be a string
let b and t be long long and equal 0
input value a
let b equal any equal signs in string a
if t equals b
increment b by 2
let b equal a . size ( ) - b + 1 ;
for long long i = 0 to t exclusive
if a [ i ] = = ' | ' , increment c
if c + 1 equals b - 1
print |
for long long i = 0 to a . size ( ) - 1 exclusive , print a [ i ]
else if c equals b
print a and endline
else if c equals b + 2
let z be a long long that equals any + signs in string a
if z is larger than 1
for long long i = 1 to a , size , print a [ i ]
print | and endline
for long long i = 0 to a . size ( )
if i equals z + 1 , continue
print a [ i ]
print | and endline
else statement
print impossible and endline
declare long longs N , M , K , L and res
read N , M , K and L
if K + L is greater than N
set the value of res to - 1
else
if ( K + L ) % M is not zero
change the value of res to ( K + L ) / M + 1
else
set the value of res to ( K + L ) / M
if res * M is greater than N , assign the new value = - 1 to res
print res
declare constant integer MAX = 1e7
declare long long arrays a size MAX , sushu size MAX , huiwen size MAX
declare init with no arguments , returning void
let a [ 1 ] be 1
let a [ 0 ] be 1
for i = 2 to 10000 inclusive
if not a [ i ]
for j = i to i * j is less than MAX , incrementing j , let a [ i * j ] be 1
declare panduan with long long x as argument , returning integer
declare long long w = x
declare long long y = 0
while w is not 0
let y be y * 10 + w % 10
let w be w / 10
if y is x
return 1 from function
else
run init
for i = 1 to MAX exclusive
if a [ i ] is true
let sushu [ i ] be sushu [ i - 1 ]
else
let sushu [ i ] be sushu [ i - 1 ] + 1
if result of run panduan ( i ) is true
let huiwen [ i ] be huiwen [ i - 1 ] + 1
else
let huiwen [ i ] be huiwen [ i - 1 ]
declare long longs p , q
read p and q
for i = MAX - 1 to 0 inclusive , decrementing i
if sushu [ i ] * q is less than or equal to huiwen [ i ] * p
if i is 0
print " Palindromic tree is better than splay tree " and newline
else
print i and newline
make character array s1 and s2 , both of size 10
make integers a and b
read s1 and s2
if s1 [ 0 ] is equal to ' m ' , set a to 1
if s1 [ 0 ] is equal to ' t ' and s1 [ 1 ] is equal to ' u ' , set a to 2
if s1 [ 0 ] is equal to ' w ' , set a to 3
if s1 [ 0 ] is equal to ' t ' AND s1 [ 1 ] is equal to ' h ' , assign 4 to a
if s1 [ 0 ] is equal to ' f ' , assign 5 to a
if s1 [ 0 ] is equal to ' s ' and s1 [ 1 ] is equal to ' a ' , set a to 6
if s1 [ 0 ] is equal to ' s ' and s1 [ 1 ] is equal to ' u ' , set a to 7
if s1 [ 0 ] is equal to ' m ' , assign 1 to b
if s2 [ 0 ] is equal to ' t ' and s2 [ 1 ] is equal to ' u ' , set b to 2
if s2 [ 0 ] is equal to ' w ' , assign 3 to b
if s2 [ 0 ] is equal to ' t ' and s2 [ 1 ] is equal to ' h ' , set b to 4
if s2 [ 0 ] is equal to ' f ' , set b to 5
if s2 [ 0 ] is equal to ' s ' and s2 [ 1 ] is equal to ' a ' , set b to 6
if s2 [ 0 ] is equal to ' s ' and s2 [ 1 ] is equal to ' u ' , set b to 7
if a greater than b , increase b by 7
make integer flag = 0
if ( b - a ) is equal to 2 OR ( b - a ) is equal to 3 OR a is equal to b , set flag to 1
if flag is equal to 1
print " YES "
else
print " NO "
create integers temp , blyat and integer arrays arr , change , cyka with size 6969 each
create integer c
read c
for integer a = 0 to c - 1 with increment a
read blyat
set change [ a ] to blyat
set arr [ a ] to blyat
for integer a = 0 to c - 1 with increment a
set temp to 1
for integer x = 0 to c - 1 with increment x
if change [ a ] less than arr [ x ] then increment temp
set cyka [ a ] to temp
for integer a = 0 to c - 1 with increment a
if a is equal to c - 1 then
print cyka [ a ] and a new line
print cyka [ a ] and " . "
let n be an integer
let a be an integer array of size 107
let t be an integer that equals 0
read n
for int i = 1 to n + 1 , read a [ i ]
if n equals 1
print 0 and endline
for int i = 1 to n + 1
for int j = 1 to n + 1
if absolute value of ( a [ j ] - a [ i ] ) equals absolute value of ( j - i ) AND abs ( i - j ) is greater than equal to t
( a [ i ] equals 1 OR a [ j ] equals 1 ) OR ( a [ i ] equals 1000 OR a [ j ] equals 1000 )
let t equal the absolute value of ( i - j ) + 1
let t equal the absolute value of i - j
if t - 1 is greater or equal to 1
print t - 1 and endline
print 0 and endline
create set of ints amulets
create set of ints taken
create int N
read N
for i = 0 to N exclusive
if i is greater than 0
create string starstar
read starstar
create int A , B
read A and B
create int num = A * 100 + B mod 10 * 10 + B / 10
if not taken . count ( num )
insert num into amulets
for j = 0 to 4 exclusive
insert num into taken
set num to ( num / 1000 ) + ( num * 10 mod 10000 )
print amulets size
n = int
s = two dimensional char array of sizes 150 and 150
r , c = int array of size 150 each
loop while reading n
set all values of r to 0
set all values of c to 0
for i = 1 to n inclusive read s [ i ] + 1
x , y = int
set x and y to 0 each
flag = bool with flag = false
for i = 1 to n inclusive
for j = 1 to n inclusive
if s [ i ] [ j ] equals ' E '
increment r [ i ]
increment c [ j ]
if r [ i ] equals n then set x to 1
if c [ j ] equals n then set y to 1
if both x and y are not 0
print " - 1 "
set flag to true
if x is not 0
for j = 1 to n inclusive
for i = 1 to n inclusive
if s [ i ] [ j ] equals ' . '
print i and j
break the inner loop
else
for i = 1 to n inclusive
for j = 1 to n inclusive
if s [ i ] [ j ] equals ' . '
print i and j
break the inner loop
let s a string
read s
let a , b , and c ints with value 0
for i from 0 to size of s exclusive
if s [ i ] is a , increment a
if s [ i ] is b , increment b
if s [ i ] is c , increment c
let t a string , with t = s
if t not equal to s or a is 0 or b is 0
puts NO
otherwise
if a equals c or b equals c
puts YES
otherwise
puts NO
declare long long integer array a size 100050 with a = { 0 }
declare integers p = 0 , res = 0 , ui = 0
declare integer T
read T
while decrement T , read a [ increment p ]
sort from a to a + p
for i = 0 to p - 1 inclusive
while ui is less than p and a [ ui ] is less than or equal to a [ i ] , increment ui
if ui is less than p , increment res , increment ui
print res and newline
declare constant integer MAXN = 100
declare string array s size MAXN + 2
declare boolean array contenido size MAXN + 2
declare checa with string address w , integer T , string address s , integer N as arguments , returning void
declare integer lim = T - N + 1
declare boolean pasa
declare characters c1 , c2
for i = 0 to lim exclusive
let pasa be true
for j = 0 to N exclusive
let c1 be w [ i + j ]
let c1 be lower case c1
let c2 be s [ j ]
let c2 be lower case c2
if c1 is not c2
let pasa be false
end loop
if pasa is true
for j = 0 to N exclusive , let contenido [ i + j ] be true
declare marca_cambiables with string address w , integer N as arguments , returning void
declare integers T = size of w , M
for i = 1 to N inclusive
let M be size of s [ i ]
if M is less than or equal to T , run checa ( w , T , s [ i ] , M )
declare convierte with string address w , character letra as arguments , returning string
declare string ret = " "
declare integer N = size of w
declare characters cambio = ' a ' , nuevo
if letra is ' a ' , let cambio be ' b '
declare boolean mayuscula
for i = 0 to N exclusive
let mayuscula be ( upper case ( w [ i ] ) is w [ i ] )
if contenido [ i ] is true
if lower case w [ i ] is lower case letra
let nuevo be cambio
else
let nuevo be letra
else
let nuevo be w [ i ]
if mayuscula is true
let nuevo be upper case nuevo
else
let nuevo be lower case nuevo
increment ret by nuevo
return ret from function
declare integer N
read N
for i = 1 to N inclusive , read s [ i ]
declare string w
read w
run marca_cambiables ( w , N )
declare character letter
read letter
print result of run convierte ( w , letter ) , " \ n "
long long int function ceil with long long int arguments n and m
return n / m + 1 if n modulo m is not 0 , or n / m otherwise
declare long long int variables n , m , k and l
read variables n , m , k and l from the input
if m > n or n - k < l , return cout < < - 1 < < endl , 0
create new long long integer called sum = ( ceil of ( l + k ) and m ) * m
if sum is greater than n , return cout < < " - 1 " < < endl , 0
print sum / m
n , s , a , b , c , d = int , pos = 1
read n , a , b , c , d
s = a + b + c + d
decrement n
while decremented value of n is not zero
read a , b , c , d
if a + b + c + d > s increment pos
x = 2D array in strings with 5 rows and 5 columns
f = boolean with false
for i = 1 to 4 exclusive
for i = 0 to 4 exclusive
if x [ i ] [ 4 ] is not equal to 0
for j = 1 to 3 exclusive
if x [ i ] [ j ] is not equal 0 , then set f to true
for j = 1 to 3 exclusive
p = integer , set to i + j
if p is greater than 4 , then set p to p - 4
if x [ p ] [ j ] is not equal 0 , then set f to true
if f is true
print YES new line
print NO new line
a , b , c , d = int
read a , b , c , d
for t = 0 to 20000 exclusive
if t > = b and t > = d and ( t - b ) modulo a is 0 and ( t - d ) modulo c is 0
print t
print - 1
create integer n , i , temp , cnt , res with cnt = - 1 and res = 0
a = int vector
read n
add 0 to the end of a
add 0 to the end of a
for i = 0 to n exclusive
read temp
add temp to the end of a
add 1001 to end of a
for i = 2 to n + 2 inclusive
if a [ i ] is equal to a [ i - 1 ] + 1
add 1 to cnt
if cnt > res then set res = cnt
set cnt = - 1
if cnt > res then set res = cnt
print res and new line
declare map from string to integer mp
declare string array x size 3
read x [ 0 ] , x [ 1 ] , x [ 2 ]
let mp [ " C " ] be 0
let mp [ " C # " ] be 1
let mp [ " D " ] be 2
let mp [ " D # " ] be 3
let mp [ " E " ] be 4
let mp [ " F " ] be 5
let mp [ " F # " ] be 6
let mp [ " G " ] be 7
let mp [ " G # " ] be 8
let mp [ " A " ] be 9
let mp [ " B " ] be 10
let mp [ " H " ] be 11
declare integers a , b
for i = 0 to 3 exclusive
for j = 0 to 3 exclusive
for k = 0 to 3 exclusive
if i is not j and j is not k and i is not k
if mp [ x [ j ] ] is greater than or equal to mp [ x [ i ] ]
let a be mp [ x [ j ] ] - mp [ x [ i ] ]
else if mp [ x [ j ] ] is less than mp [ x [ i ] ]
let a be ( 12 - mp [ x [ i ] ] ) + ( mp [ x [ j ] ] - 0 )
if mp [ x [ k ] ] is greater than or equal to mp [ x [ j ] ]
let b be mp [ x [ k ] ] - mp [ x [ j ] ]
else if mp [ x [ k ] ] is less than mp [ x [ j ] ]
let b be ( 12 - mp [ x [ j ] ] ) + ( mp [ x [ k ] ] - 0 )
if a is 3 and b is 4
print " minor " and newline
else if a is 4 and b is 3
print " major " , newline
print " strange " , newline
declare char variable ch
declare double d
create strings str1 , str2 and str
declare bools bl and bl1
loop , reading n and k from the input
read input to str
change len to 0
for c from 1 to n exclusive
set i to 0 and set j to n - c
while j < n and str [ i ] = str [ j ] , increment i and j
if j = n , set len to c
let tt and tl be strings where tl = " "
set tt to substring of str from 0 with length len
while k ! = 0 , decrement it and continue the loop
print tt and tl
3rd element of integer array cnt is equal to 0
let n be a integer
read n
for i = 0 to n exclusive
let x be a integer
read x
if x is equal to 25 , increment cnt [ 0 ] by 1
if x is equal to 50
if cnt [ 0 ] > = 1
decrement cnt [ 0 ] by 1
increment cnt [ 1 ] by 1
print NO and newline
if x is equal to 100
if cnt [ 1 ] > = 1 and cnt [ 0 ] > = 1
decrement cnt [ 0 ] by 1
decrement cnt [ 1 ] by 1
increment cnt [ 2 ] by 1
else if cnt [ 0 ] > = 3
decrement cnt [ 0 ] by 3
increment cnt [ 2 ] by 1
print NO and newline
print YES and newline
N = const int with N = 1e5 + 10
n , a , m , d = long long
da = long long and t = long long array of size N
in function nextDiv taking long long bound , long long div and returning long long
return bound if bound is a multiple of div else return bound + div - bound mod div
in function nextDiv taking long long bound , long long num , long long div and returning long long
if bound is a multiple of div return bound + num * div
return nextDiv of bound , div + ( num - 1 ) * div
in function prevDiv taking long long bound , long long div and returning long long
return bound if bound is a multiple of div else return bound - bound mod div
in function numDiv taking long long L , long long R , long long div and returning long long
return prevDiv of ( R , div ) / div - prevDiv ( L - 1 , div ) / div
in function numOpen taking long long L , long long R and returning long long , long long pair
realR = long long with realR = min of R , n * a
xx = long long with xx = numDiv of L , realR , a
if xx < = da return { 1m nextDiv of ( L , a ) + d }
noob = long long with noob = xx - da if xx is a multiple of da else xx - xx mod da
nextt = long long with nextt = nextDiv of L , noob , a
if xx is a multiple of da return { xx / da , nextt + d }
return { 1 + xx / da , nextt + d }
in function solve
cur = long long with cur = min of a , t [ 1 ]
pt = long long with pt = 1
ans = long long with ans = 0
loop while pt < = m
if cur is not t [ pt ]
xop = long long , long long pair with xop = numOpen of cur , t [ pt ] - 1
increment ans by xop . first
loop while pt < = m and t [ pt ] < = xop . second increment pt
if pt is m + 1
set cur to nextDiv of xop . second + 1 , a
if n < numDiv of a , xop . second , a break
numLeft = long long with numLeft = n - numDiv of a , xop . second , a
if numLeft > 0 increment ans by numOpen of ( cur , nextDiv of cur , numLeft - 1 , a ) . first
break
set cur to t [ pt ]
if numDiv of a , xop . second , a < n set cur to min of t [ pt ] , nextDiv of xop . second + 1 , a
else
increment ans
neo = long long with neo = pt
loop while pt < m and t [ pt + 1 ] - t [ neo ] < = d increment pt
if pt is m
cur = long long with cur = nextDiv of t [ neo ] + d + 1 , a
if n < numDiv of a , t [ neo ] + d , a break
numLeft = long long with numLeft = n - numDiv of a , t [ neo ] + d , a
if numLeft > 0 increment ans by numOpen of ( cur , nextDiv of cur , numLeft - 1 , a ) . first
break
increment pt
set cur to t [ pt ]
read n then m then a then d
for i = 1 to m inclusive read t [ i ]
set da to numDiv of a , a + d , a
call solve
a , b , c , d , e , f = int
read a then b then c then d then e then f
if d is 0
print " Hermione "
else if c is 0
print " Ron "
else if b is 0
print " Hermione "
else if a is 0
print " Ron "
else if f is 0
print " Hermione "
else if e is 0
print " Ron "
else
if b * d * f > a * c * e
print " Ron "
else
print " Hermione "
declare integer array b size 20 , integers ans , n
declare boolean array a size 10 by 10
declare check with no arguments , returning boolean
declare integers i , j , r , l , tot
for i = 1 to 5 inclusive
let l be r be 0
for j = 1 to 5 inclusive
if a [ i ] [ j ]
increment l
if b [ j ] , increment r
if l - 1 is greater than r , return false from function
for i = 1 to 5 inclusive
let l be r be 0
for j = 1 to 5 inclusive
if a [ j ] [ i ] is true
increment l
if b [ 5 + j ] , increment r
if l - 1 is greater than r , return false from function
let tot be 0
for i = 1 to 5 inclusive
for j = 1 to 5 inclusive
if a [ i ] [ j ] and not b [ i + 5 ] and not b [ j ] , increment tot
if tot is greater than 1 , return false
return true
declare dfs with integer x as argument , returning void
declare integers i , sum
if x is 11
if result of run check is true
let sum be 0
for i = 1 to 11 inclusive
if b [ i ] is 1 , increment sum
let ans be minimum of ( sum and ans )
return from function
let b [ x ] be 1
run dfs ( x + 1 )
let b [ x ] be 0
run dfs with x + 1 as argument
declare integers i , y
declare character ch
declare integer k
read n
set bytes form a to size of a to value of false
for i = 1 to n inclusive
read ch and k
if ch is ' R '
let y be 1
else if ch is ' G '
let y be 2
else if ch is ' B '
let y be 3
else if ch is ' Y '
let y be 4
else if ch is ' W '
let y be 5
let a [ y ] [ k ] be true
set bytes from b to size of b to value 0
let ans be 9999999
end statement
run dfs with 1 as argument
print ans and newline
a , b = integer 2d array of [ 101 ] [ 101 ]
n = integer
read n
for i = 0 to n exclusive
for j = 0 to n exclusive
tmp = character
read tmp
if tmp is E , a [ i ] [ j ] = - 1
flagh , flagl = integers with flagh [ 101 ] = { 0 } , flagl [ 101 ] = { 0 }
flaghs , flagls = integers with flaghs = 0 , flagls = 0
for i = 0 to n exclusive
for j = 0 to n exclusive
if a [ i ] [ j ] is 0
flagh [ i ] = 1
break loop
for i = 0 to n exclusive
if flagh [ i ] is 0
flaghs = - 1
break loop
if flaghs is 0
for i = 0 to n exclusive
for j = 0 to n
if a [ i ] [ j ] is 0
print i + 1 , " " , j + 1
break loop
for i = 0 to n exclusive
for j = 0 to n exclusive
if a [ j ] [ i ] is 0
flagl [ i ] = 1
break loop
for i = 0 to n
if flagl [ i ] is 0
flagls = - 1
break loop
if flagls is 0
for i = 0 to n exclusive
for j = 0 to n exclusive
if a [ j ] [ i ] is 0
print j + 1 , " " , i + 1
break loop
print - 1
create long longs x1 , y1 , x2 and y2
read x1 , y1 , x2 and y2 and keep looping
create new long longs a , b and c
n and ans are integers with ans = 0
read n
for i from 0 to n exclusive
read variables a , b and c from the input
increment ans if a * x1 + b * y1 + c < 0 and a * x2 + b * y2 + c > 0
increment ans if a * x1 + b * y1 + c > 0 and a * x2 + b * y2 + c < 0
print ans
set flag = boolean
set n , i = integers
set str = string
set a = array of integers size 5 , b = array of integers size 100005
set ans = integer
set sizeof ( a ) bytes starting at a to 0
read str
n = length of str
set flag to false
for i = 0 to n exclusive , do the following
if str [ i ] is # do the following
increment a [ 1 ]
if a [ 3 ] + a [ 1 ] is greater than a [ 2 ] or i is 0 set flag = true
set and = a [ 2 ] - a [ 3 ] + 1
else if str [ i ] is ( do the following
increment a [ 2 ]
if i is n - 1 or a [ 3 ] + a [ 1 ] is greater than a [ 2 ] , set flag = true
increment a [ 3 ]
if a [ 3 ] + a [ 1 ] is greater than a [ 2 ] or i is 0 set flag = true
if ans is greater than a [ 2 ] - a [ 3 ] + 1 set flag = true
if flag is true
print - 1
for i = 1 to a [ 1 ] exclusive print 1
print a [ 2 ] - a [ 3 ] - a [ 1 ] + 1
let n , k be integers
read n , k
r = array of integers of length 2 * n + 1
for i = 0 to 2 * n + 1 exclusive , read r [ i ]
for i = 0 to 2 * n + 1 exclusive
print r [ i ] - 1
decrement k by 1
print r [ i ]
if i is equal to 2 * n
print newline
print space
declare constant long long N = 1e9 + 3
declare constant long long MN = 1e9 + 7
declare constant long long MX = - 1e9 - 7
declare n , m , a , b , x , c1 , c2 , cnt as long longs
declare strings s , s1
declare boolean bl = false
declare c as long long
declare pair of long long and long long pr
declare long long vector v
declare map from long long to long long mp
declare long long set st
declare long long set iterator it
declare propblem with long longs n , m as arguments , returning void
declare character c = ' a '
declare long long cnt = 97 + m
while n is true
print c
increment c
if c is cnt , let c be ' a '
decrement n
read n and m
run propblem with n , m as arguments
print " \ n "
create string s , set vowels = aeuiyo , res = " "
read s
for i = 0 to size of s exclusive
if s [ i ] + 0 < 97 , set s [ i ] to s [ i ] + 32
for i = 0 to size of s exclusive
for j = 0 to 6 exclusive
if s [ i ] = vowels [ j ] , break
if j = 5 , set res to res + s [ i ]
for i = 0 to size of res exclusive , print . and res [ i ]
print a newline
n is an integer
read n
integer sum equals n / 2
if n modulo 2 equals 1
print sum and newline
for integer i = 1 to sum exclusive , print 2
print 3 and newline
else
print sum and newline
print 2 and newline
let sushu be a function that accepts int n and returns a integer value
if n equals 1 , return 0
if n equals 2 , return 1
for integer i = 2 , i * i < = n , increment i by 1
if n modulo i equals 0 , return 0
return 1
let n be a integer
read n
for integer m = 1 , the condition is always true , increment m by 1
if not sushu ( n * m + 1 )
print m and newline
stop
n = long long
ans = long long
while read n
if n < = 2
ans = n
else if n and 1
ans = n * ( n - 1 ) * ( n - 2 )
else
if n is not multiple of 3
ans = n * ( n - 1 ) * ( n - 3 )
else
ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 )
print ans
let n be a integer
read n
let a , cnt be integers with cnt = 0
for i = 0 to n exclusive
read a
if a is equal to 0 , increase cnt by 1
if n is equal to 1
if cnt is true
print N0 and newline
print YES and newline
if cnt is equal to 1
print YES and newline
print N0 and newline
make ints n and m
create strings a and b
read n , m , a , and b
if n is greater than m
for i = 0 to n exclusive
if a [ i ] is equal to ' * '
erase index i of a
break loop
if a is b
print " YES "
else do
print " NO "
if n is equal to m
for i = 0 to n exclusive
if a [ i ] is not equal to ' * '
if a [ i ] is not equal to b [ i ] , print " NO " and return 0
print " YES "
create int Now = 0
while a [ Now ] is not equal to ' * '
if a [ Now ] is not equal to b [ Now ] , print " NO " and return 0
increment Now
set Now to m - 1
create int now = n - 1
while a [ now ] is not equal to ' * '
if a [ now ] is not equal to b [ Now ] , print " NO " and return 0
decrease now by 1
reduce Now by 1
print " YES "
spf be a long long array
gcd is a long long function
palindrome is a long long function
modexp is a long long function
sieve is a void function
getFactorization is a vector of long long values
getZarr is a void function
ceil is long long function
return a / b + ( a % b ! = 0 )
n is a long long integer
read n
p [ n ] is a pait of long long integers
for long long i = 0 to n exclusive , print p [ i ] . first and p [ i ] . second
sort p and p + n
for long long i = 0 to n - 1 exclusive
long long r equals 2 to the power p [ i + 1 ] . first - p [ i ] . first ) * 2
long long x equals ceil ( p [ i ] . second , r )
p [ i + 1 ] . second equals max ( p [ i + 1 ] . second , x )
ans is a long long value
o is a long long value equals ceil ( log10 ( p [ n - 1 ] . second ) / log10 ( 4 ) )
if o is 0 , increase o by 1
ans equals o + p [ n - 1 ] . first
print ans and newline
gcd is a long long function
if a equals 0 , return b
if b equals 0 , return a
if a equals b , return a
if a is greater than b , return gcd ( a % b , b )
return gcd ( a , b % a )
palindrome is a long long function
l is a long long value equals 0
long long value h equals s . length ( ) - 1
while h is greater tham l
if s [ l + + ] not equal to s [ h - - ] , return 0
return 1
modexp is a long long function
if b equals 0 , return 1
long long integer temp equals modexp ( a , b / 2 , m )
temp equals ( temp * temp ) modulo m
if b & 1 , return ( temp * ( a % m ) ) modulo m
reurn temp
sieve is a void finction
spf [ 1 ] equals 1
for long long i = 2 to 100001 exclusive , spf [ i ] = i
for long long i = 4 to 100001 exclusive , spf [ i ] = 2
for long long i = 3 to square root of 100001 exclusive
if spf [ i ] equals i
for long long j = i * i to 100001
if spf [ j ] equals j , spf [ j ] = i
getFactorization is a long long fiunction
ret is a vector of long long values
while x is not equal to 1
push spf [ x ] into ret
divide x by spf [ x ]
return ret
getZarr is a void function
long long n equals length of str
L , R , k are long long values
let L , R are 0
for long long i = 1 to n exclusive
if i is greater than R
L , R are equal to i
while R < n and str [ R - L ] equals str [ R ] , increase R by 1
Z [ i ] equals R - L
decrease R by 1
else
k equals i - L
if Z [ k ] is less than R - i + 1
Z [ i ] equals Z [ k ]
else
L equals i
while R < n and str [ R - L ] equals str [ R ] , increase R by 1
Z [ i ] = R - L
decrease R by 1
n , m = int
let lg be a 111x111 boolean matrix
let a be a 111x111 int matrix
let v be a boolean array of size 111 with v [ 0 ] = 0
let zero be a bool array of length 111 with zero [ 0 ] = 0
ex = 0 = int
in void function dfs that takes int i
set v [ i ] to true
for j = 1 to n inclusive
if a [ i ] [ j ] isn ' t 0 and v [ j ] is 0 then call dfs of j
read n , m
for i = 1 to n inclusive
t = int
read t
if t = 0
set zero [ i ] = true
increment ex
while decrementing t
c = int
read c
set lg [ i ] [ c ] to true
for i = 1 to n inclusive
for j = 1 to n inclusive
if i isn ' t j
for k = 1 to m inclusive
if lg [ i ] [ k ] and lg [ j ] [ k ] then set a [ i ] [ j ] to 1
ans = int = 0
for i = 1 to n inclusive
if v [ i ] = 0 and zero [ i ] is not 0
call dfs on i
increment ans
decrement ans
if ans is negative then reset ans to 0
print ans + ex and new line
declare new integers i , j and n and arrays s and k with 2005 elements
read n from the input
read n elements from the standard input into s
set first sizeof ( k ) bytes at the pointer k to 0
start for loop from i = 0 to n exclusive
increment j in a loop from 0 to n exclusive
if s [ j ] > s [ i ] and j ! = i , increment k [ i ]
if s [ j ] is equal to s [ i ] and j = i , increment k [ i ]
start for loop from i = 0 to n exclusive incrementing i
if i is equal to 0
print k [ i ] to the standard output
else
print " " and k [ i ]
print new line
create int s , t , x
while reading s , t , x is not stopped
if x is less than s + t
if x equals s
print " YES "
else
print " NO "
else
if ( x - s ) mod t equals 0 or ( x - s - 1 ) mod t equals 0
print " YES "
else
print " NO "
make ints i and j
make int array vis of size 220 with array of size 220 with { 0 }
make integer array vis1 of size 220 with array of size 220 with { 0 }
make int arrays x of size 5 , y of size 5 , x1 of size 5 , and y1 of size 5
for i = 0 to 4 exclusive , read x [ i ] and y [ i ]
for i = 0 to 4 exclusive , read x1 [ i ] and y1 [ i ]
sort x using x + 4
sort x1 using x1 + 4
sort y using y + 4
sort y1 using y1 + 4
make integer ox = min ( x [ 0 ] , x1 [ 0 ] )
create int oy = min ( y [ 0 ] , y1 [ 0 ] )
if ox is less than 0 , set ox to - ox
if oy is less than 0 , set oy to - oy
for i = x [ 0 ] + ox to x [ 3 ] + ox
for j = y [ 0 ] + oy to y [ 3 ] + oy , set vis [ i ] [ j ] to 1
make integer mid = ( x1 [ 0 ] + ox + x1 [ 3 ] + ox ) / 2
create int s = y1 [ 0 ] + oy
let int t = y1 [ 3 ] + oy
for i = mid to x1 [ 0 ] + ox
for j = s to t , set vis1 [ i ] [ j ] to 1
increment s
decrease t by 1
set s to y1 [ 0 ] + oy
set t to y1 [ 3 ] + oy
for i = mid to x1 [ 3 ] + ox
for j = s to t , set vis1 [ i ] [ j ] to 1
increment s
decrease t by 1
for i = 0 to 220 exclusive
for j = 0 to 220 exclusive
if vis [ i ] [ j ] is equal to 1 and vis1 [ i ] [ j ] is equal to 1
print " YES "
show " NO "
create const integer maxn = 1e5 + 10
make integer array a of size maxn
let bool array vis of size maxn
let integer n
read n
if n is equal to 1
print 1
if n modulo 4 is greater than 1
display - 1
if n & 1 is truthy
set a [ n / 2 + 1 ] to n / 2 + 1
set vis [ n / 2 + 1 ] to 1
set a [ 1 ] to 2
set a [ 2 ] to n
set a [ n ] to n - 1
set a [ n - 1 ] to 1
set vis [ 1 ] , vis [ 2 ] , vis [ n ] , and vis [ n - 1 ] to 1
for i = 1 to n
if vis [ i ] is falsy
create int x
set x to i + 1
set a [ i ] to x
set a [ x ] to n - i + 1
set a [ n - i + 1 ] to n - x + 1
set a [ n - x + 1 ] to i
set vis [ i ] , vis [ x ] , vis [ n - i + 1 ] , and vis [ n - x + 1 ] to 1
set for i = 1 to n
if i is equal to 1
show a [ i ]
else do
show " "
print new line
character = map of string to int
s = string
n , m , k , res , level = double
check = float
read n , m , k
while decrement n
read s and level
check = k * level
if check > = 100 , character [ s ] = check
while decrement m
read s
if character [ s ] > = 100
continue next iteration
else
character [ s ] = 0
iterator it = map from string to integer
print character . size ( )
for it = character . begin ( ) to it is not character . end ( ) , print it - > first , " " , it - > second
create long long mod with mod = 998244353
create integer array a with size 100000
create integer n
read n
for i = 0 to n exclusive , read a [ i ]
set prev_up [ 0 ] to 1
for i = 0 to n exclusive
for j = 1 to 200 inclusive
increment prev_up [ j ] by prev_up [ j - 1 ] , set prev_up [ j ] to prev_up [ j ] % mod
increment prev_notup [ j ] by prev_notup [ j - 1 ] , set prev_notup [ j ] to prev_notup [ j ] % mod
set up [ 0 ] to notup [ 0 ] to 0
for j = 1 to 200 inclusive
set up [ j ] to notup [ j ] to 0
if a [ i ] is not - 1 and a [ i ] is not j , break current loop iteration
increment up [ j ] by prev_up [ j - 1 ] + prev_notup [ j - 1 ] , set up [ j ] to up [ j ] % mod
increment notup [ j ] by prev_up [ j ] + prev_notup [ j ] , set notup [ j ] to notup [ j ] % mod
decrement notup [ j ] by prev_up [ j - 1 ] + prev_notup [ j - 1 ] , set notup [ j ] to notup [ j ] % mod
increment notup [ j ] by prev_notup [ 200 ] - prev_notup [ j ] , set notup [ j ] to notup [ j ] % mod
set prev_up to up
set prev_notup to notup
create long long ans with ans = 0
for i = 1 to 200 inclusive , increment ans by prev_notup [ i ] , set ans to ans % mod
print ( ans + mod ) % mod print newline
empty function fast
call fast ( )
create new string called str
read str from the user input
create new integers no = length of str and j , and an array has with 256 elements filled with 0
declare integers n , i , e and t
chaning j from 0 to no exclusive , increment has [ str [ j ] ]
for j from 0 to no exclusive
set n to ( has [ ' n ' ] - 1 ) / 2
assign the new value = has [ ' i ' ] / 1 to i
assign has [ ' e ' ] / 3 to e
assign the new value = has [ ' t ' ] / 1 to t
print min of ( min ( n , t ) and min ( i , e ) )
i and counter are integers both set to 0
arr is a string
read arr
for i = 0 to ( size of arr ) - 1 exclusive
if arr [ i ] is the character 1 and arr [ i + 1 ] is the character 0
assign ' ' to arr [ i + 1 ]
increment counter
break
if counter is 0
if arr [ 0 ] is the character 0
assign ' ' to arr [ 0 ]
else
assign ' ' to arr [ ( size of arr ) - 1 ]
for i = 0 to size of arr exclusive
if arr [ i ] isn ' t ' ' , display arr [ i ]
display newline
create long long dia [ 10005 ]
create long long n
create long long m and k
read n , m and k
for i = 0 to n exclusive , read dia [ i ]
if n is even
print 0
else
set h to m / ( 1 + ( n - 1 ) / 2 )
MI = dia [ 0 ]
for j = 0 to n exclusive , with increment j = j + 2
if MI > dia [ j ] , set Mi to dia [ j ]
if MI < k * h
print MI
else
print k * h
maxn is a constant integer set to 1e5 + 7
a = integer array of size maxn
b = integer array of size maxn
c = integer array of size maxn
n = integer
read n
read n values into array a
for i = 1 to n exclusive , set b [ i ] to absolute value ( a [ i ] - a [ i + 1 ] )
for i = 1 to n exclusive
if i mod 2
set c [ i ] to b [ i ]
else
set c [ i ] to ( - 1 ) * b [ i ]
for i = 1 to n exclusive
if i mod 2
set a [ i ] to ( - 1 ) * b [ i ]
else
set a [ i ] to b [ i ]
suma , sumb are long longs both set to 0
ansa and ansb are long longs both set to - 0x3f3f3f3f
for i = 1 to n exclusive
add c [ i ] to suma
set ansa to call max with ansa , suma
if suma is negative , set suma to 0
for i = 1 to n exclusive
add a [ i ] to sumb
set ansb to call max with ansb , sumb
if sumb is negative , set sumb to 0
display call max with ansa , ansb
n , m , x = integer with x = 0
k = double
kk = float
s = string
v = map from string to int
iterator it = map from string to int
read n , m , k
while decrement n
read s , x
kk = x * k
if kk > = 100 , v [ s ] = kk
while decrement m
read s
if not v [ s ] , v [ s ] = 0
print v . size ( )
ya = bool with ya = false
sub = char set array of size 250
s = string
read s
if length of s is less than 3
print " No "
for i = 0 to length of s - 2
if s [ i ] is not ' . ' then insert s [ i ] into sub [ i ]
if s [ i + 1 ] is not ' . ' then insert s [ i + 1 ] into sub [ i ]
if s [ i + 2 ] is not ' . ' then insert s [ i + 2 ] into sub [ i ]
if size of sub [ i ] is greater than 2 then set ya to true
if ya is true print " Yes " else print " No "
x , y = integers , increment = integer = 0 , ansx = integer = 0 , ansy = integer = 0 , turns = integer = 0
read x , y
if x is 0 and y is 0
print 0
indefinitely perform the while loop
increase increment by 1
for i = 0 to increment exclusive
increase ansx by 1
if ansx is x and ansy is y
print turns
increase turns by 1
for i = 0 to increment exclusive
increase ansy by 1
if ansx is x and ansy is y
print turns
increase turns by 1
increase increment by 1
for i = 0 to increment exclusive
decrease ansx by 1
if ansx is x and ansy is y
print turns
increase turns by 1
for i = 0 to increment exclusive
decrease ansy by 1
if ansx is x and ansy is y
print turns
increase turns by 1
create integer n
declare long long arrays c and vis with size 105
declare long long variable ans = 1
integer function cnt with int argument x
create integer res = 1
create integer temp = c [ x ]
set vis [ temp ] to 1
while temp ! = x
increment res
set temp to c [ temp ]
change vis [ temp ] to 1
return - 1 if res > = 2 * n
return - 1 if res > = 2 * n
if res is even
return res / 2
else
return res
long long function gcb with long long arguments a and b
if b = 0 , return a
return gcb of b and a modulo b
long long function lcm with long long arguments a and b
return a * b / ( gcb of a and b )
read input to n
set first sizeof ( vis ) bytes at the pointer vis to 0
loop i from 1 to n inclusive , read c [ i ]
declare long long temp
for i = 1 to n inclusive
if vis [ i ] is false , change temp to cnt of i
if temp = - 1
print " - 1 "
assign lcm of ans and temp to ans
print ans
n = long long
while reading n
let a be an int array of length 4 and = 6 , 8 , 4 , 2
if n is not 0
else
print a [ n mod 4 ]
in function fun with argument long long integer x and returns a long long integer
if x < 10 , then return x
r = long long integer = x / 10 + 9
d = long long integer = x
while d > = 10 , then d = d / 10
if d > x modulo 10 , then decrease r by 1
return r
l , r , x , y = long long integer
read l , r
x = the result of calling fun with argument r
y = the result of calling fun with argument ( l - 1 )
print the result of x - y
create long long n , array dia of size 10010 , m , ans = 0 , mis = 100000 , k , need = 0
read n , m , k
for i = 1 to n inclusive
read dia [ n ]
if mis greater than dia [ i ] and i is odd : set mis to dia [ i ]
set need to n / 2 + 1
if n is even or need is greater than m
pass
else
set ans to m / need * k
set ans to min ( mis , ans )
print ans
arr , change , cyka = array of 6969 int , temp , blyat = int
c = int
read c
for a = 0 to c exclusive
read blyat
change [ a ] = blyat
arr [ a ] = blyat
for a = 0 to c exclusive
temp = 1
for x = 0 to c exclusive
if change [ a ] < arr [ x ] increment temp
cyka [ a ] = temp
for a = 0 to c exclusive
if a is c - 1
print cyka [ a ] , newline
else
print cyka [ a ] , space
declare constant int N = 1e5 + 5
create long long array arr with N elements
vis = map from long long to boolean
declare integer variable n
create long long m
read n and m
for i = 0 to n - 1 , read arr [ i ]
declare integer variable ans = 0
for i from 0 to n - 1 inclusive
if vis [ arr [ i ] ] is true , skip the rest of the loop
set vis [ arr [ i ] * m ] to true
increment ans
print ans
create long long const mod = 1000000007
make long long const md = 998244353
declare mypow taking in long long ints a and b and returning long long
create long long int res = 1
set a to a % mod
if b is less than 0 , end function
for loop while b is truthy
if b & 1 is truthy , set res to res * a % mod
set a to a * a % mod
return res
open txt . in for input
open txt . out for output
create int vector v of size 105
make int vector v1 of size 105
create bool array vis of size 105 `
declare dfs taking in long long x
set vis [ x ] to 1
create int u = v [ x ] . size ( )
for i = 0 to u exclusive
if ! vis [ v [ x ] [ i ] ] is truthy , call dfs ( v [ x ] [ i ] )
print fixed and setprecision ( 12 )
create long long n and m
read n and m
make integer ok2 = 0
for i = 1 to n
make long long int x
read x
set ok2 to ok2 | ( x > 0 )
for j = 1 to x
make long long integer y
read y
append y to v1 [ i ]
for i = 1 to n
for j = i + 1 to n
make int u = v1 [ i ] . size ( )
create int ok = 0
make u1 = v1 [ j ] . size ( )
for t = 0 to u exclusive
for t1 = 0 to u1 exclusive
if v1 [ i ] [ t ] is equal to v1 [ j ] [ t1 ] , set ok to 1
if ok is truthy
append j to v [ i ]
append i to v [ j ]
create long long cnt = 0
for i = 1 to n
if ! vis [ i ] is truthy
increment cnt
call dfs with argument i
print cnt - ok2
s = string
i , ans = long long int
read s
ans = 0
for i = 0 to length of s exclusive
if s [ i ] is ' 0 '
ans = i
break
for i = 0 to length of s exclusive
if i ! = ans print s [ i ]
print newline
create string s
create int n , set c to 0
read n and s
while n > 0
if s [ n - 1 ] = >
increment c
else
break
decrement n
set n to length of s
i = 0
while i < n
if s [ i ] = <
increment c
else
break
add 1 to i
print c
let arr be a string
read arr
let t be a integer with t = arr . find ( 0 )
if t is equal to - 1
delete ( length of arr ) - 1 from arr
delete t , 1 from arr
print arr and newline
in int function gcd taking a , b = int
is b = 0 ? then return gdc of b and a mod b , else return a
in int function lcm taking a , b = int
return a / b * gdc of a and b
in long long function powmod taking a , b , MOD = long long
ans = 1 = long long
while b isn ' t 0
if b is even then set ans = ans * a % MOD
set a to a ^ 2 % MOD
divide b by 2
return ans
let p be an int vector of size 200001
let ma be an int and ma be an int array of length 200001
n = int
read n
for i = 1 to n inclusive
mm = int
read mm
mid = 0 = int
for j = 1 to mm inclusive
t = int
read t
push back t into p at i
set ma to the maxmimum betwwen ma and t
set mid to the max of mid and t
set m at i = mid
sum = 0 = long long
for i = 1 to n inclusive
if m at i = ma then go to next iteration
increment sum by 1ll * ( ma - m [ i ] ) * ( size of p at i ) to int
print sum
create constant integer oo = ( int ) 1e9
make const double PI = 2 * acos ( 0 . 0
create const double eps = 1e - 9
declare fix taking in string s and returning string
create string ret = " 99999999999 "
for i = 0 to 4 exclusive
make string tmp = s . substr ( i , 4 - i ) + s . substr ( 0 , i )
set ret to min of tmp and ret
return ret
make integer n
make char c
read n
make map dic from strings to ints
create bool flag = false
make integer mx = 0
for whatever = 0 to n exclusive
make string s = " "
for i = 0 to 4 exclusive
read c
set s to s + c
make char t = s [ 2 ]
set s [ 2 ] to s [ 3 ]
set s [ 3 ] to t
set s to fix ( s )
if dic . find ( s ) is equal to dic . end ( ) , set dic [ s ] to 0
increment dic [ s ]
if whatever is not equal to n - 1 , read c and c
print dic . size ( )
long double integer n
read n
if n is less than or equal to 127 then do the following
else if n is less than or equal to 32767 then do the following
else if n is less than or equal to 2147483647 then do the following
else if n is less than or equal to 9223372036854775807 then do
else
Max_N = 200005
n = int
s = string
read n , s
ant = 0
for i = 0 to n exclusive
if s [ i ] is not ' < ' break
increment ant
for i = n - 1 down to 0 inclusive
if s [ i ] is not ' > ' break
increment ant
print ant
remain , i , n , x = int with remain = 0 and a , b = int array of size 200001 and all values set to 0 each
loop while reading n then x
for i = 1 to n inclusive read a [ i ]
for i = 1 to n inclusive
set b [ i ] to ( a [ i ] + remain ) / x
set remain to ( a [ i ] + remain ) mod x
for i = 1 to n inclusive
if i < n
print b [ i ] and " "
else
print b [ i ]
declare string variable s
declare integer m
read s
declare integer variables l and r = 0
for integer i = 0 to length of s exclusive
if s [ i ] = ' ( '
increment l and r
else
decrement l
if r is greater than 0 , decrement r
if l is less than 0
print - 1
if s [ i ] is equal to ' # ' , assign 0 to r and increment m by one
if r ! = 0
print - 1
for integer i = 0 to m - 1 exclusive , print 1
print l + 1
a , i , j , ans , n and sum are long longs with ans and sum = 0 ; arr with size 4100 and find with 50000 elements are long long arrays
s is a new string variable
read input to a and s
assign length of s to n
for i = 0 to n exclusive , assign s [ i ] - ' 0 ' to arr [ i ]
for i = 0 to n exclusive
change sum to 0
in a for loop , change j from i to n exclusive
add arr [ j ] to sum
increment find [ sum ]
if a is equal to 0
set ans to n * ( n + 1 ) * find [ 0 ] - find [ 0 ] * find [ 0 ]
else
for i from 0 to n exclusive
change sum to 0
for j from i to n exclusive incrementing j
change sum to sum + arr [ j ]
if sum ! = 0 , a modulo sum = 0 and a / sum < = n * 9 , add find [ a / sum ] to ans
print ans to the standard output
e is a new 2d array of integers 5010 by 5010
declare new strings s and t
cnt and sum are long longs with sum = 0
read user input to s and t
start for loop from i = 0 to length of s exclusive , changing e [ 0 ] [ i + 1 ] to s [ i ] - ' a ' on each loop
in a loop , change i from 0 to length of t exclusive and assign t [ i ] - ' a ' to e [ i + 1 ] [ 0 ] on each iteration
for integer r = 1 to length of t inclusive
if e [ 0 ] [ 1 ] = e [ r ] [ 0 ]
increment e [ r ] [ 1 ]
increment sum by one
start for loop from c = 2 to length of s inclusive
set cnt to 0
in a for loop , change r from 1 to length of t inclusive
if e [ 0 ] [ c ] = e [ r ] [ 0 ]
change the value of e [ r ] [ c ] to cnt + 1
set sum to ( sum + e [ r ] [ c ] ) % 1000000007LL
set cnt to ( cnt + e [ r ] [ c - 1 ] ) % 1000000007LL
print sum to the standard output
long long integer as , m , a , d , array t of size 100005 , pt , pa , da , ans , sa , sl
create readf function
read n , m , a , d
for i = ( 1 ) to less than or equal to ( m ) do the following
set m to unique ( t + 1 , t + m + 1 ) - t - 1
create function solve
set pt to pa
set da to d / a + 1
set ans to 0
if pt is less than or equal to m then do the following
set sa to minimum of ( t [ pt ] / a , n ) - pa + 1
if sa is greater than 0 then do the following
set sl to ( sa + da - 1 ) / da
ans equals ans plus sl
pa equals pa plus ( sl - 1 ) * da
if t [ pt ] is less than or equal to pa * a + d and pt is less or equal to m then add one to pt
set pa to ( pa * a + d ) / a + 1
else
add one to ans
integer as tmp = pt
if t [ pt ] is less than or equal to t [ tmp ] + d and pt is less or equal to m add one to pt
set pa to t [ tmp ] + d ) / a + 1
if pa is less than or equal to n then do the following ans + = ( n - pa + 1 + da - 1
run readf function
run solve function
let t1 , t2 , x1 , x2 , t0 , Min , ans1 , ans2 , j be long integers with Min = 0 , ans1 = 0 , ans2 = 0
let Max , aa be double values with Max = 1000
read t1 , t2 , x1 , x2 , t0
if t1 is equal to t2 and t2 is equal to t0
print x1 and space and x2 and newline
else if t1 is equal to t0
print x1 and space and 0 and newline
else if t2 is equal to t0
print 0 and space and x2 and newline
Max is equal to t2 - t0
Min is equal to x2
ans1 is equal to 0
ans2 is equal to x2
for i = 1 to x1 inclusive
j is equal to i * ( t1 - t0 ) / ( t0 - t2 )
if i * ( t0 - t1 ) modulo ( t2 - t0 ) is not equal to 0 , increment j by 1
aa is equal to 1 . 0 * ( t1 * i + t2 * j ) / ( i + j ) - t0
if j > = 0 and j < = x2 and aa is less than Max
Max is equal to aa
Min is equal to i + j
ans1 is equal to i
ans2 is equal to j
if j > = 0 and j < = x2 and aa is equal to Max and ( i + j ) is greater than Min
Max is equal to aa
Min is equal to i + j
ans1 is equal to i
ans2 is equal to j
print ans1 and space and ans2 and newline
declare integer array a size 150000
declare integer n
while read n
for i = 0 to n exclusive , read a [ i ]
sort from a to a + n
for i = 0 to n exclusive
if i is 0
print a [ i ]
else
print ' ' , a [ i ]
print newline
a = vector integer array of size 200005
maxval = vector integer array of size 200005
n , m , x , ultimate = integers with ultimate = 0
read n
for i = 1 to n
read m
for j = 0 to m exclusive
read x
append x in a [ i ]
maxval [ i ] = max of maxval [ i ] and x
ultimate = max of maxval [ i ] and ultimate
ans = long long with ans = 0
for i = 1 to n
print ans
declare string s
new array of integers zlicz with size 3
character variable with name wz with value ' a '
read s from the input
for integer i = 0 to length of s exclusive incrementing i
if s [ i ] ! = wz
if ( s [ i ] - wz = 1 ) and ( wz ! = ' c ' )
set wz to s [ i ]
assign 1 to zlicz [ wz - ' a ' ]
else
print " NO "
else
increment zlicz [ wz - ' a ' ] by one
if ( zlicz [ 0 ] = 0 ) or ( zlicz [ 1 ] = 0 )
print " NO " to the standard output
if ( zlicz [ 2 ] = zlicz [ 0 ] ) or ( zlicz [ 2 ] = zlicz [ 1 ] )
print " YES "
else
print " NO "
create integer n
read n
let a be an vector integer array of size n
read n values into array a
let res be an int with res = 0
create integer head = 0
for i = 1 to n exclusive
if a [ i ] is equal to a [ i - 1 ]
create integer tar = i - 1
set res = max of res and tar - head
create integer len = ( tar - head ) / 2
for j = head to head + len inclusive set a [ j ] = a [ head ]
for j = head + len + 1 to i exclusive assign a [ i ] to a [ j ]
set head to i
create integer tar = n - 1
set res to max of res and tar - head
create integer len = ( tar - head ) / 2
for j = head to head + len inclusive set a [ j ] = a [ head ]
for j = head + len + 1 to n exclusive set a [ j ] = a [ n - 1 ]
print res / 2 and new line
for i = 0 to n exclusive print a [ i ] and new line if i + 1 is equal to n else print a [ i ] and " "
create long long variables m , h1 , a1 , x1 , h2 , a2 , x2 , y2 , y , p1 , p2 , t1 and t2
read input to m , h1 , a1 , x1 , y , h2 , a2 , x2 and y2
for i from 1 to 1e7 inclusive
declare long long ans1 = ( ( ( h1 * x1 * 1LL ) + y ) % m )
declare long long ans2 = ( ( ( h2 * x2 * 1LL ) + y2 ) % m )
change h1 to ans1 and h2 to ans2
if a1 is equal to ans1
if p1 = 0
assign i to p1
else if t1 = 0
change t1 to i - p1
if a2 is equal to ans2
if p2 is false
change p2 to i
else if t2 = 0
change t2 to i - p2
if p1 is false or p2 is false , return ! ( cout < < - 1 < < endl )
for i from 1 to 1e7 inclusive
if p1 is equal to p2 , return ! ( cout < < p1 < < endl )
if p1 is less than p2
increase p1 by t1
else
add t2 to p2
print - 1
declare a 64 bit integer named a
read in a
declare a string named s
read in s
declare a 64 bit integer named n and set the value to the length of string s
declare a 64 bit integer array named cumm of size n + 1
declare a 64 bit integer array named ans with a value of 0
position 0 of cumm is equal to 0
declare a 64 bit integer named count0 with a value of 0
loop through the code n times
if position i of s is equal to 0 , increment count0
position i of cumm is equal to the sum of position i - 1 of cumm and the decimal number of the char in s [ i - 1 ] - 48
let value be a map from 64 bit integer to 64 bit integer
iterate for n times , and increment the value in position cumm [ j ] - cumm [ i ] of value
if a is equal to 0
print ( n * ( n + 1 ) ) * value [ 0 ] - value [ 0 ] * value [ 0 ] and a new line
terminate the program
if cumm [ j ] - cumm [ i ] is equal to 0 execute next iteration of code
print ans and a new line
create integers x , y
read x read y
create integers tx , ty
set tx to absolute value of x , set ty to absolute value of y
create integer mx with mx = maximum of ( tx and ty ) - 1
if ( x is 0 and y is 0 ) or ( x is 1 and y is 0 )
print 0 print newline
create integer ans with ans = 0
if x is greater than or equal to 0 and y is greater than or equal to 0
if tx is greater than or equal to ty
set ans to ( mx * 4 ) + 1
else
set ans to mx * 4 + 2
else if x is less than 0 and y is greater than or equal to 0
if tx is greater than ty
set ans to mx * 4 + 3
else
set ans to mx * 4 + 2
else if x is less than or equal to 0 and y is less than or equal to 0
if tx is greater than or equal to ty
set ans to mx * 4 + 3
else
set ans to mx * 4 + 4
else if x is greater than or equal to 0 and y is less than 0
if ty is greater than or equal to tx
set ans to mx * 4 + 4
else
set ans to mx * 4
if ty is less than or equal to ( tx - 2 ) , increment ans
print ans print newline
a = array of unsigned long long size 2000000
b = array of unsigned long long size 2000000
n = integer
declare boolean function judge with integer n as an argument
for i = 0 to n exclusive
if a [ i ] is a [ i + 1 ] return true
return false
while ( read n ) is true do the following
set sizeof ( a ) bytes starting at a to 0
for i = 0 to n exclusive do the following
read a [ i ]
inceement b [ a [ i ] ]
call sort on a and a + n
set ans = integer value 0
for i = 1 to 2000000 exclusive do the following
set b [ i ] = b [ i - 1 ] / 2
set b [ i - 1 ] = b [ i - 1 ] modulo 2
set ans = ans + b [ i - 1 ]
print ans
let solve be a void function
let n , i , j , d be long integers
read n , d
arr = array of long integers of length n
for long integer i = 0 to n exclusive , read arr [ i ]
if n is less than 3
print 0 and newline
return value
let l , r be long integers with l = 0 , r = 2
let sum be a long integer with sum = 0
while l is less than n - 2 and r is less than n
if arr [ r ] - arr [ l ] < = d
increment sum by ( r - l - 1 ) * ( r - l ) / 2
increment r by 1
increment l by 1
if r - l is equal to 1 , increment r by 1
print sum and newline
let t be a long integer with t = 1
while t is decremented by 1 , call solve function
tab = long long array of size 100001
T = int
loop while reading T
set all values of tab to 0
num = int with num = 0
p = int with p = 1
for i = 1 to T inclusive read tab [ i ]
sort tab from index 1 to T + 1
for i = 1 to T - 1 inclusive
loop while p < = T
if tab [ p ] > tab [ i ]
increment p
increment num
break
else
increment p
print num
declare new array of long longs a with size 100001
s is a new array of long longs with 100000 elements
create long longs n , i , max , min , mm , k and t
read n and keep looping
read n items from the input to a , starting from the index 1
start for loop from i = 1 to n - 1 inclusive incrementing i
set s [ i ] to abs ( a [ i ] - a [ i + 1 ] )
if i is odd , change the value of s [ i ] to 0 - s [ i ]
assign the new value = s [ 1 ] to max
assign the new value = s [ 1 ] to min
assign the new value = 0 - min to mm
start for loop from k = 2 to n - 1 inclusive
if max is less than 0
change max to s [ k ]
else
assign the new value = max + s [ k ] to max
if min is greater than 0
assign the new value = s [ k ] to min
else
set min to min + s [ k ]
if k is even and max > mm , change mm to max
if k is odd and 0 - min > mm , change mm to 0 - min
print mm
declare constant integer MAXN = 2e5 + 5
declare integer N
declare long longs M , P , H
declare long long arrays A size MAXN , B size MAXN
read N
for i = 0 to N exclusive
read A [ i ]
for j = 0 to A [ i ] exclusive
read P
let B [ i ] be maximum of B [ i ] and P
let M be maximum of M and B [ i ]
for i = 0 to N exclusive , increment H by A [ i ] * ( M - B [ i ] )
print H and ' \ n '
create int n , sum
read n
for i = 1 to 1000 inclusive
create int k = 0
set sum to n * i + 1
for j = 2 to sum exclusive
if sum modulo j is 0
set k to 1
break
if k equals 1
print i
break
declare integers tmp , min1 , max1 , sum_n , index_max and index_min
declare new 2d array of integers arr1 with size 1000 by 1000
arr3 is a new array of characters with size 100
declare new array of integers arr with 10000 elements
void function display_vector with integer vector argument v
start for loop from i = 0 to length of v exclusive , printing v [ i ] and " " on each loop iteration
print a new line
void function speed
min_max is a void function with integers vector argument v and int argument l
change the value of min1 to INT_MAX
change the value of max1 to INT_MIN
in a for loop , change i from l to length of v exclusive
if v [ i ] < = min1
change the value of min1 to v [ i ]
assign i to index_min
if v [ i ] > = max1
set max1 to v [ i ]
change index_max to i
function sum_v with vector of int argument v that returns integer
puth the sum of all elements of v into sum_n
return sum_n
is_it_sorted_acs is a boolean function with vector of int argument v
create boolean variable test1 = false
for i from 0 to length of v - 1 exclusive
if v [ i + 1 ] < = v [ i ]
change test1 to false
return test1
change test1 to true
return test1
boolean function is_it_sorted_des with vector of integers argument v
declare new boolean test1 = false
in a for loop , change i from 0 to length of v - 1 exclusive
if v [ i + 1 ] > = v [ i ]
assign false to test1
return test1
change the value of test1 to true
return test1
call speed ( )
declare new string s
read from the input to s
create integers cn , ci , ce and ct = 0
in a for loop , change i from 0 to length of s exclusive incrementing i
if s [ i ] is equal to ' n '
increment cn
else if s [ i ] is equal to ' i '
increment ci by one
else if s [ i ] = ' e '
increment ce
else if s [ i ] is equal to ' t '
increment ct by one
change cn to ( cn - 1 ) / 2
divide ce by 3
print min ( min ( cn , ct ) , min ( ce , ci ) )
create int n
read n
create long long int a , b , c , d
read a , b , c , d
set sum to a + b + c + d
count = 1
for i = 1 to n exclusive
read a , b , c and d
if a + b + c + d > sum , increment count
print count
declare new constant integer MAXN with value 1000 * 100 + 10
arr is an array of integers with size MAXN
create long longs n and d
integer function bs with int arguments t and i
create new integer variable l = i and r = n
while r - l > 1
create integer mid with value ( r + l ) / 2
if arr [ mid ] - t < = d
change l to mid
else
change r to mid
return l
declare long long ans with value 0
read input to n and d
in a for loop , change i from 0 to n exclusive , reading input to arr [ i ]
for integer i = 0 to n exclusive
k is a new integer with value = bs ( arr [ i ] , i ) - i
change ans to the sum of ans and ( 1LL * k * ( k - 1 ) ) / 2
print ans to the standard output
let N = 1e5 + 1 be a long long const
let n , arr be long long with arr an array of length N
read n
set arr [ 0 ] to 0
for i = 1 to N exclusive then set arr [ i ] to arr [ i - 1 ] + i
for i = 1 to N exclusive
if the binary search of arr + 1 , arr + N , n - arr [ i ] isn ' t 0
print YES and new line
print NO and new line
declare integers remain , i , n and x with remain = 0 , and arrays of integers a and b with size 200001
loop , reading n and x from the input
read n new elements to a from the input , starting from the index 1
in a for loop , change i from 1 to n inclusive
set the value of b [ i ] to ( a [ i ] + remain ) / x
assign ( a [ i ] + remain ) modulo x to remain
for i from 1 to n inclusive incrementing i
if i is less than n
print b [ i ] and " "
else
print b [ i ] to the standard output
create int n and flag , set flag to 0
create char s [ 105 ]
read n
read s
for i = 0 to n exclusive
if s [ i ] = s [ i + 1 ] and s [ i ] different from ?
assign 0 to flag
break
if s [ i ] equal to =
if s [ i - 1 ] = s [ i + 1 ] or s [ i + 1 ] = ?
if s [ 0 ] = = or s [ n - 1 ] = ? , assign 1 to flag
if flag different from 0
print Yes and a newline
else
print NO and a newline
N = 300005
M = 15000010
a = array of N int
num = array of M int
vis = array of M boole
n = int
while read n
maxgcd = 0
for i = 0 to n exclusive
read a [ i ]
maxgcd = __gcd ( maxgcd , a [ i ] )
for i = 0 to n exclusive increment num [ a [ i ] / maxgcd ]
maxsub = 0
for i = 2 to M exclusive
if not vis [ i ]
thissub = 0
for j = i to M by i exclusive
vis [ j ] = true
add num [ j ] to thissub
maxsub = max ( maxsub , thissub )
if not maxsub
print - 1
else
print n - maxsub
fill vis with false
fill num with 0
n , x , y = integers
Read n , x , y
if x + y is less than or equal to n + 1
print White and a new line
print Black and a new line
let ints n and k
read n and k
create string s = " "
for i = 0 to n exclusive , add ( char ) ' a ' + ( i % k ) to s
print s
hpy , atky , defy , hpm , atkm , defm , h , a , d , ans = integers
read hpy , atky , defy , hpm , atkm , defm , h , a , d
for t = 1 to hpm
cans = integer with cans = max ( ceil ( ( hpm + defm * t - atky * t ) / double ( t ) ) * a , 0 . 0 )
hdc = integer with hdc = max ( t * atkm - t * defy - hpy + 1 , 0 )
cans = cans + ( hdc / t ) * min ( d , t * h ) + min ( d , ( hdc % t ) * h )
if t is 1
ans = cans
else
ans = min of ans and cans
print ans
PI = const double with PI = acos of - 1 . 0
eps = const double with eps = 1e - 6
INF = const int with INF = 0x3f3f3f3f
N = const int with N = 2e5 + 5
a , b = string
loop while reading a then b
flag = bool with flag = true
tag = bool with tag = true
ch1 , ch2 , ch3 , ch4 = char
kk = bool with kk = true
if size of a is not size of b
set kk to false
else
for i = 0 to size of a
if a [ i ] is not b [ i ] and flag is true
set flag to false
set ch1 to a [ i ]
set ch2 to b [ i ]
else if a [ i ] is not b [ i ] and tag is true
set tag to false
set ch3 to a [ i ]
set ch4 to b [ i ]
else if a [ i ] is not b [ i ]
set kk to false
break
if kk is false
print " NO "
else
if tag or flag is true
print " NO "
else if ch1 is ch4 and ch2 is ch3
print " YES "
else
print " NO "
function win ( no args , no return value )
function reflect ( get address of vector of string a , return nothing )
N = size of a
for i = 0 to N exclusive reverse a [ i ]
function rot ( get address of vector of string a , return nothing )
N = size of a
for x = 0 to n / 2 exclusive
for y = x to N - x - 1 exclusive
tmp = a [ x ] [ y ]
a [ x ] [ y ] = a [ y ] [ N - 1 - x ]
a [ y ] [ N - 1 - x ] = a [ N - 1 - x ] [ N - 1 - y ]
a [ N - 1 - x ] [ N - 1 - y ] = a [ N - 1 - y ] [ x ]
a [ N - 1 - y ] [ x ] = tmp
N = int
read N
a and b = vector of N string
for i = 0 to N exclusive read a [ i ]
for j = 0 to N exclusive read b [ j ]
for j = 0 to 2 excluisve
reflect ( a )
for i = 0 to 4 exclusive
rot ( a )
if a is b win ( )
set const int N to 2e5 + 7
set const long double pi to 3 . 14159265359
set const long long INF to 1e9
set const long double eps to 1e - 9
integers = n , s [ N ] , r [ N ] , p [ N ] , l [ N ]
set n to 4
for i = 1 to less than or equal to n do the following
read l [ i ] , s [ i ] , r [ i ] , p [ i ]
if p [ i ] is true
if l [ i ] or s [ i ] or r [ i ] is true
output YES
for i = 1 to less than or equal to n do the following
if i is 1 then do
if l [ i ] is 1 then do
if p [ 4 ] is true
output YES \ n
if s [ i ] is 1 then do
if p [ 3 ] is true
output YES \ n
if r [ i ] is 1 then do
if p [ 2 ] is true
output YES \ n
if l [ i ] is 1 then do
if p [ 1 ] is true
output YES \ n
if s [ i ] is 1 then do
if p [ 4 ] is true
output YES \ n
if r [ i ] is 1 then do
if p [ 3 ] is true
output YES \ n
if l [ i ] is 1 then do
if p [ 2 ] is true
output YES \ n
if s [ i ] is 1 then do
if p [ 1 ] is true
output YES \ n
if r [ i ] is 1 then do
if p [ 4 ] is true
output YES \ n
else
if l [ i ] is 1 then do
if p [ 3 ] is true
output YES \ n
if s [ i ] is 1 then do
if p [ 2 ] is true
output YES \ n
if r [ i ] is 1 then do
if p [ 1 ] is true
output YES \ n
output NO
MOD is a new long long variable = 1000000007
declare new long long called N
read N
create vector of long longs A with 1000500 elements filled with zeroes
res is a new long long variable with value 0
create new long long variable a
for i = 0 to N exclusive incrementing i
read a
increment A [ a ]
for i from 0 to length of A exclusive
if A [ i ] is greater than 0 , increase A [ i + 1 ] by A [ i ] / 2
if A [ i ] is odd , increment res
print res to the standard output
let ints x and y
create char c
print x
read c
read y
if x is less than 5 or if x is equal to 6 and y is greater than 59
if y - x is greater than or equal to 9 * x
print 0 , x + 1 , " : " , and ( x + 1 ) * 9 + ( x + 1 )
else do
print 0 , x , " : " , and x + ( 9 * x )
else if x is greater than or equal to 5 and x is less than or equal to 9
print " 10 : 01 "
else if x is greater than or equal to 16 and x is less than 19 or if x is equal to 15 and y is greater than or equal to 51
print " 20 : 02 "
else if x is equal to 23
if y is greater than or equal to 32
print " 00 : 00 "
otherwise
print " 23 : 32 "
else if x is equal to 11 or x is equal to 22
if y - x is less than or equal to 0
print x + 1 , " : " , and x + 10
else
print x , " : " , and x
else if x is equal to 10
if y is greater than or equal to 1
print " 11 : 11 "
else do
print " 10 : 01 "
else if x is greater than or equal to 12 and x is less than or equal to 15
if y - x is greater than or equal to 9 * ( x - 10 ) - 9
print x + 1 , " : " , and ( x - 10 + 1 ) * 9 + ( x - 10 + 2 )
else
print x , " : " , and x + ( ( x - 11 ) * 9 )
else
if x is equal to 20
if y is greater than or equal to 2
print " 21 : 12 "
else do
print " 20 : 02 "
else if x is equal to 21
if y is greater than or equal to 12
print " 22 : 22 "
else
print " 21 : 12 "
indice_max and indice_min = int
n = int
read n
arrayi = array of n int
i = int
for i = 0 to n exclusive read arrayi [ i ]
indice_max = max element of arrayi - arrayi
for i = n - 1 down to 0 inclusive
if arrayi [ i ] = = min element of arrayi
indice_min = i
break
s = indice_max + n - 1 - indice_min
if indice_max > i decrement s
print s
declare character array a with size 1005
read a
create integer n = length of a
declare integer variable flag = 0
loop i from 1 to n - 2 inclusive
declare characters A = a [ i - 1 ] , B = a [ i ] and C = a [ i + 1 ]
if A = ' . ' or B = ' . ' or C = ' . ' , skip the rest of the loop
if A ! = B and A ! = C and B ! = C
change flag to 1
break the loop
if flag is not 0
print " Yes "
else
print " No "
n , N , i = long long
n = 1
vec = vector of long long
while n < 10000 put n * ( n + 1 ) / 2 at end of vec , increment n
read N
if N is 1
print " NO "
for i = 0 to 99999 exclusive
if binary_search ( start of vec , end of vec , N - vec [ i ] )
print " YES "
print " NO "
a , b , s = integers
read a , b , s
ans = integer set to s - absolute value of a - absolute value of b
if ans > = 0 and ans modulo 2 is 0
print " Yes "
else
print " No :
let mod be a constant integer with mod = 1e9 + 7
dp = 2d array of integers with 5005 rows and 5005 columns
let a , b be strings
read a , b
let len1 be a integer with len1 = length of a
let len2 be a integer with len2 = length of b
for i = 1 to len1 inclusive
for j = 1 to len2 inclusive
dp [ i ] [ j ] is equal to ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) modulo mod
let ans be a long integer with ans = 0
for i = 1 to len1 inclusive , ans is equal to ( ans + dp [ i ] [ len2 ] ) modulo mod
print ans and newline
str = string
read str
i = integer
for i = 0 as long as i is less than size of str and str [ i ] is the character a with increment i + 1
for j = 1 to size of str exclusive
if str [ j ] is the character a , break
decrement str [ j ]
if i equals size of str , set str [ ( size of str ) - 1 ] to the character z
print str
declare a , b , c , d , e , f as unsigned integers
read a , b , c , d , e , f
if d is 0
print " Hermione " , newline
else if c is 0
print " Ron " , newline
else if b is 0
print " Hermione " , newline
else if a is 0
print " Ron " , newline
else if f is 0
print " Hermione " , newline
else if e is 0
print " Ron " , newline
else if ( a * c * e is less than b * d * f )
print " Ron " , newline
else
print " Hermione " , newline
EPS = 1e - 9
INFF = 1000000000000000005
l1 , r1 , l2 , r2 , k = long long
read l1 , r1 , l2 , r2 , k
ml = max ( l1 , l2 )
mr = min ( r1 , r2 )
t = mr - ml + 1
if k > = ml and < = mr increment t
print 0 if t < = 0 else t
i , j , t , s , L , c , b = integers with L = 0 and a = array of 55 integers
Read t
set s = 0 and c = 0
for i = 0 to t exclusive
increment c
Read b
if b is less than 0 , then increment s
if s is 3
set a [ L + + ] to c - 1
set c to 1
set s to 1
if c is not 0 , then set a [ L + + ] to c
print L and new line
for i = 0 to L exclusive
if i is not 0 , then print " "
print a [ i ]
print a new line
let n , k , a be integers
read n
let ans be integer with ans = 0
for i = 0 to n exclusive
read k , a
if 1 = = a , increment k
while a ! = 1
if a % 4 ! = 0
update a to a / 4 + 1
else
a = a / 4
increment k
set ans to k if k > ans else ans
print ans
in function po taking a long long n and returning a long long
res = long long with res = 1
loop n times set res to res * 10
return res
in function mid_num taking two long longs n and d and returning a long long
if d is less than 3 then return 0
set n to n / 10
set n to n mod po of d - 2
return n
in function find_digit taking a long long n and returning a long long
d = int with d = 0
loop while n is not 0
set n to n / 10
increment d
return d
l , r , ans = long long with ans = 0
read l then r
d1 , d2 = long long with d1 = find_digit of l and d2 = find_digit of r
dd1 , dd2 = long long with dd1 = d1 + 1 and dd2 = d2 - 1
if d1 is greater than 1
if dd1 is less or equal to dd2 then increment ans by po of ( dd2 - 1 ) - po of ( dd1 - 2 )
if d1 is less than d2
x = long long with x = r / po of ( d2 - 1 )
mid = long long with mid = mid_num of r and d2
if r mod 10 is greater or equal to x
increment ans by mid + 1
else
increment ans by mid
increment ans by ( x - 1 ) * po of ( d2 - 2 )
if l is less than r
y = long long with y = l / po of ( d1 - 1 )
increment ans by ( 9 - y ) * po of ( d1 - 2 )
mid = long long with mid = mid_num of l and d1
if l mod 10 is less or equal to y
increment ans by po of ( d1 - 2 ) - mid
else
increment ans by po of ( d1 - 2 ) - mid - 1
if d1 is d2 and ans is greater than 0
set l to r + 1
y = long long with y = l / po of ( d1 - 1 )
decrement ans by ( 9 - y ) * po of ( d1 - 2 )
mid = long long with mid = mid_num of l and d1
if l mod 10 is less or eqaul to y
decrement ans by po of ( d1 - 2 ) - mid
else
decrement ans by po of ( d1 - 2 ) - mid - 1
else
if d2 is greater than 1
if dd1 is less or equal to dd2 then increment ans by op of ( dd2 - 1 ) - po of ( dd1 - 2 )
x = long long with x = r / po of ( d2 - 1 )
mid = long long with mid = mid_num of r and d2
if r mod 10 is greater or equal to x
increment ans by mid + 1
else
increment ans by mid
increment ans by ( x - 1 ) * po of ( d2 - 2 )
increment ans by 9 - l + 1
else
increment ans by r - l + 1
if l is r
if r mod 10 is r / po of ( d1 - 1 )
set ans to 1
else
set ans to 0
print ans
declare new integers n , k and j with j = 0
read n and k
declare string variables x and y
for i from 0 to n exclusive
if i is less than k
change x to x + ' a ' + i
else
change x to the sum of x and ' a ' + j
increment j by one
if j is equal to k , set j to 0
print x to the standard output
declare ints n and t
read user input to n and t
new string variable s
read variable s from the input
define new integer called pointPos = - 1
declare integer variable with name start = - 1
start for loop from i = 0 to length of s exclusive incrementing i
if pointPos ! = - 1 and s [ i ] - ' 0 ' > = 5
set start to i
break
if s [ i ] is equal to ' . ' , set the value of pointPos to i
if start ! = - 1
define new boolean called next with value true
while start > pointPos and next and t > 0
if start - pointPos is equal to 1
create integer variable nextVal = s [ start - 2 ] - ' 0 ' + 1
if nextVal is equal to 10
set the value of s [ start - 2 ] to ' 0 '
else
assign nextVal + ' 0 ' to s [ start - 2 ]
set the value of next to false
else
create integer variable nextVal with value s [ start - 1 ] - ' 0 ' + 1
if nextVal < 5 or t - 1 = 0 , assign false to next
assign the new value = nextVal + ' 0 ' to s [ start - 1 ]
decrement start
decrement t
remove elements from the start + 1 to the end of s
if * ( - - s . end ( ) ) = = ' . ' , remove last element of s
change start to pointPos - 1
while next and start > = 0
if start is equal to 0
insert ' 0 ' to the start of s
set start to 1
declare integer variable with name nextVal and value s [ start - 1 ] - ' 0 ' + 1
if nextVal is equal to 10
assign ' 0 ' to s [ start - 1 ]
else
assign the new value = nextVal + ' 0 ' to s [ start - 1 ]
set next to false
decrement start
print s to the standard output
create int n and d
read n , d
jokes = ( n - 1 ) * 2
create int x and time_ , set time_ to jokes * 5
for i = 0 to n exclusive
read x
assign time_ + x to time_
if time_ greater than d
print - 1
else
print jokes + ( d - time_ ) / 5 and a newline
a is a new array of integers with size 1005
declare new integer n
loop , reading n from the input
start for loop from i = 0 to n exclusive , reading a [ i ]
declare new integer called ok = 0
for integer i = 1 to n exclusive
start for loop from j = 0 to n - 1 exclusive incrementing j
max1 is a new integer with value max of a [ i - 1 ] and a [ i ]
min1 is a new integer variable = min of a [ i - 1 ] and a [ i ]
max2 is a new integer variable with value max of a [ j ] and a [ j + 1 ]
declare integer min2 with value min of a [ j ] and a [ j + 1 ]
if min1 < min2 and max1 > min2 and max1 < max2 , change ok to 1
if ok is not 0
print " yes " to the standard output
else
print " no " to the standard output
create new variables a , b , c and d of type integer
read input to b , a , d and c
for i = 0 to a + b inclusive
if ( c + i * d - a ) % b = 0 and c + i * d > = a
print c + i * d
print - 1
n , m , k = long long integers
read n , m , k
a with n = long long vector
mn = long long integer set to 1e9
for i = 0 to n exclusive
read a [ i ]
if i modulo 2 is 0 , set mn to minimum of mn and a [ i ]
if n modulo 2 is 0
print 0
print minimum of m / n / 2 + 1 * k and mn
mod = const long long with mod = 1e9 + 7
N = const int with N = 1e5 + 5
in function gcd taking long long a , long long b and returning long long
if b return gcd of b , a mod b else return a
declare function pwr taking long long x , long long y and returning long long
declare function isprime taking long long x and returning bool
a , b = int array of size N each
rr = int , int map
in function getnumber taking long long d , long long x and returning long long
ans = long long with ans = 0
return ans
l , r = long long
read l then r
set rr [ 0 ] to 4
set rr [ 1 ] to 7
d , d2 , x , y = long long with d = 0 and d2 = 0 and x = l and y = 0
loop while x
increment d
set x to x / 10
t = long long with t = getnumber of d , y then increment y
loop while t < l
if y > = pwr of 2LL , d
increment d
set y to 0
set t to getnumber of d , y then increment y
ans = long long with ans = ( t * ( min of ( t , r ) - l + 1 ) )
t1 = long long with t1 = t
loop while t < r
set t1 to t
if y > = pwr of 2LL , d
increment d
set y to 0
set t to getnumber of d , y then increment y
increment ans by ( t * ( ( t if t < = r else r ) - t1 ) ) ;
print ans
in function pwr taking long long x , long long y and returning long long
ans = long long with ans = 1
set x to x
loop while y > 0
if y bitwise - and 1 set ans to x * ans
set x to x * x
set y to y / 2
return ans
in function isprime taking long long x and returning bool
if x < 2 return false
if x < 4 return true
if x is even or a multiple of 3 return false
iterate i from 5 while i * i < = x incrementing i by 6
if x is a multiple of a or a multiple of ( i + 2 ) return false
return true
create integer array A of size 100 X 100
create integer array B of size 26000
create vector integer array NEB of size 27000
let yy be integer with yy = 0
create integer arrays vis , low , malow , tim , F of sizes 27000 each
create integer t = 1
create integer uu = 0
create integer vector check
in the function dfs which takes a integer s
set low [ s ] = t
set vis [ s ] = 1
set tim [ s ] = t
add 1 to t
create integer pp = 0
for i = 0 to NEB [ s ] . size exclusive
create integer l = NEB [ s ] [ i ]
if F [ s ] is not equal to 1
if vis [ l ] is equal to 1
set low [ s ] to minimum of low [ s ] and tim [ l ]
add 1 to pp
set F [ l ] = s
call dfs with argument l
create integer u = s
set low [ u ] = minimum of low [ u ] and low [ l ]
set malow [ w ] to maximum of malow [ u ] and low [ l ]
create integer u = s
is s = yy and pp > 1
set uu = 1
add s to the end of check
else if ss is not equal to yy and malow [ u ] > = tim [ u ]
set uu to 1
add s to end of check
n , m = integers
read n and m
create integer no = 0
for i = 1 to n inclusive
for j = 1 to m inclusive
c = char
read c
if c is equal to #
increment no
set A [ i ] [ j ] to 1
set B [ ( m + 1 ) * i + j ] = 1
set yy = ( m + 1 ) * i + j
for i = 1 to 2700 exclusive
for j = 0 to 4 exclusive
if i + P [ j ] > = 0 and B [ i + P [ j ] ] = 1 then add i + P [ j ] to the end of NEB [ i ]
call dfs on yy
if no < 3
then print - 1
if uu is 1
print 1 and new line
print 2
declare is_vowel with character ch as argument , returning boolean
declare strings vowels = " AEIOUY "
return first index of ch in vowels is not end of string
declare string s
read s
declare integer vector d
add 0 to end of d
for i = 0 to length of s exclusive
if result of run is_vowel ( s [ i ] ) is true , add ( i + 1 ) to end of d
add ( length of s + 1 ) to end of d
declare integer mx = 0
print mx and newline
s = string
n = int
read n
read s
if n is 1 and s [ 0 ] is ' 0 '
print " No "
v = vector of int
for i = 0 to n - 1 exclusive
if s [ i ] is ' 1 ' and s [ i + 1 ] is ' 1 '
print " No "
if s [ i ] is ' 0 ' add i at end of v
if s [ n - i ] is ' 0 ' add n - 1 at end of v
flag = int
for i = 0 to size of v exclusive
s [ v [ i ] ] = ' 1 '
flag = 1
for j = 0 to n - 1 exclusive
if s [ j ] is ' 1 ' and s [ j + 1 ] is ' 2 ' flag = 0
if flag
print " No "
s [ v [ i ] ] = ' 0 '
print " Yes "
declare tri with long long k as argument , returning long long
return k * ( k + 1 ) / 2 from function
declare long long n
read n
declare boolean flag = false
for i = 1 to square root of ( n * 2 ) inclusive
declare long long k = n - result of run tri with i as argument
declare long long l = i
declare long long r = square root of ( n * 2 )
while l is less than or equal to r
declare long long m = ( l + r ) bitshift right 1
if result of run tri ( m ) is less than k
let l be m + 1
else if result of run tri ( m ) is greater than k
let r be m - 1
else
let flag be true
end loop
if flag is true , end loop
if flag is true
print " YES " and newline
else
print " NO " and newline
let Hy , Ay , Dy be integers
let Hm , Am , Dm be integers
let Hs , As , Ds be integers
read Hy , Ay , and Dy
read Hm , Am , and Dm
read Hs , As , and Ds
let resp be an integer with resp = the maximum supported integer value
let mas be an integer with mas = call max with arguments Hm + Dm - Ay + 1 , 1
let maxi be an integer with maxi = call max with arguments Am - Dy , 1
let A , D , H be integers
for i = 0 to 1000 inclusive
for j = 0 to 1000 inclusive
if ( Ay + i ) - ( Dm ) is at most 0 , continue
let P be an integer with P = 0
let r be an integer with r = Hm / ( ( Ay + i ) - Dm )
if Hm modulo ( ( Ay + i ) - ( Dm ) ) doesn ' t equal 0 , increment r
add ( As * i ) to P
add ( Ds * j ) to P
add call max ( r * call max ( Am - Dy - j , 0 ) - Hy + 1 , 0 ) * Hs to P
if P is less than resp
assign P to resp
assign i to A
assign j to D
assign ( r * ( Am - Dy ) ) to H
if resp is negative
display 0
display resp
declare integer variables n and m
read standard input to n and m
create an int / int pair aux
create new integer variable ans with value n
for integer i = 0 to m exclusive
read variables aux . first and aux . second from the input
change the value of ans to min of ans and aux . second - aux . first + 1
print ans and ' \ n ' to the standard output
declare new integer variable p = 0
for i = 0 to n exclusive
if i is true , print " "
print p
change the value of p to ( p + 1 ) modulo ans
print ' \ n ' to the standard output
create long long ints t1 , t2 , x1 , x2 , t0 , res_x , and res_y
read t1 , t2 , x1 , x2 , and t0
make doubles t and ct = 1e99
while x1 is greater than or equal to 0 and x2 is greater than or equal to 0
set t to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if t is less than t0
decrease x1 by 1
continue loop
if t is less than 0
set ct to t
set res_x to x1
set rex_y to x2
decrease x2 by 1
print res_x , ' ' , and res_y
s = string
read s
countT = int with countT = 0
countE = int with countE = 0
countN = int with countN = 0
countI = int with countI = 0
for i = 0 to length of s
if s [ i ] is ' t ' increment countT
if s [ i ] is ' e ' increment countE
if s [ i ] is ' n ' increment countN
if s [ i ] is ' i ' increment countI
ans = int with ans = countE / 3
if countI < ans set ans to countI
if countT < ans set ans to countT
if ( countN - 1 ) / 2 < ans set ans to ( countN - 1 ) / 2
print ans
declare new long long variable mod with value 1e9 + 9
new array of characters s with size 500005
long long function power with long long arguments a and b
create long long variable ret = 1
change a to a modulo mod
while b is not 0
if b & 1 is not 0 , change ret to ret * a % mod
change a to a squared modulo mod
set b to b > > 1
return ret
declare long long variables n , a , b and k
read n , a , b and k from the user input
read input an store it into s
read input into s
declare new long long called t with value ( n + 1 ) / k
declare new long long u = power ( b , k ) * power ( power ( a , k ) , mod - 2 ) % mod
assign ( power ( u , t ) + mod - 1 ) % mod * power ( u - 1 + mod , mod - 2 ) % mod to t
if u = 1 , assign ( n + 1 ) / k to t
declare long long variable with name ans with value 0
for i = 0 to k exclusive incrementing i
declare long long variable tmp
assign the new value = power ( a , n - i ) * power ( b , i ) % mod
assign tmp * t % mod to tmp
if s [ i ] = ' + '
change the value of ans to ( ans + tmp ) % mod
else
change ans to ans - tmp + mod
change the value of ans to ans modulo mod
print ans
let n , i , cnt be long integers with cnt = 0
let s be a string
read n
read s
for i = 0 to n exclusive
if s [ i ] is equal to <
increment cnt by 1
stop
for i is equal to n - 1 , i > = 0 , decrement i by 1
if s [ i ] is equal to >
increment cnt by 1
stop
print cnt and newline
n , k = int
t , s = string
read n , k , t
l = 1 , for cnt = 0 to k exclusive
ok = true
i = int , j = 0
for l = l to length of s exclusive
ok = true
for i = l to length of s and for j = 0 to length of t
if s [ i ] ! = t [ j ]
ok = false
break
if ok break
for i = j to length of t append t [ i ] to s
l = length of s - length of t + 1
print s
create long longs a , b
declare solve with long long x as argument , returning long long
create long longs ans , f , e , xx , with ans = 0 , xx = x
if x is less than 10 , return x from function
set e to x % 10
while x is true
set f to x % 10
set x to x / 10
if f is less than or equal to e
set ans to 9 + xx / 10
else
set ans to 8 + xx / 10
return ans from function
read a read b
print result of run solve with b as argument - result of run solve with ( a - 1 ) as argument , print newline
declare strings a , b , c and d
declare long long btong
read input to a and b
set c to a and d to b
if c ! = d
print " NO "
else
for s from 0 to length of a exclusive
if a [ s ] ! = b [ s ] , increment btong
if btong is equal to 2
print " YES "
else
print " NO "
x , y = integers
read x , y
a = string
read a
len = integer with len = a . length ( )
rx , ry = integer with rx = 0 , ry = 0
for i = 0 to len exclusive
if a [ i ] is U , ry = ry + 1
if a [ i ] is D , ry = ry - 1
if a [ i ] is R , rx = rx + 1
if a [ i ] is L , rx = rx - 1
tx , ty , nx , ny = integers with tx = 0 , ty = 0 , nx = 0 , ny = 0
for i = 0 to len exclusive
if rx and ry
tx = ( x - nx ) modulo rx
ty = ( y - ny ) modulo ry
if not tx and not ty and ( x - nx ) / rx is ( y - ny ) / ry and ( x - nx ) / rx > = 0
else if rx and not ry
tx = ( x - nx ) modulo rx
if not tx and ( x - nx ) / rx > = 0 and ny is y
else if not rx and ry
ty = ( y - ny ) modulo ry ;
if not ty and ( y - ny ) / ry > = 0 and nx = = x )
else
if nx is x and ny is y
if a [ i ] is U , ny = ny + 1
if a [ i ] is D , ny = ny - 1
if a [ i ] is R , nx = nx + 1
if a [ i ] is L , nx = nx - 1
cycles = int
read cycles
a = two dimensional bool array of sizes 100 and 100 with all values set to 0
point = int with point = 1
i = int with i = 0
loop while cycles > 0
if cycles < i
set i to 0
increment point
set a [ i ] [ point ] to 1
set [ point ] [ i ] to 1
decrement cycles by i
increment i
if i > = point and cycles > 0
set i to 0
increment point
print point + 1
for i = 0 to point inclusive
for j = 0 to point inclusive print a [ i ] [ j ]
print newline
declare integer a
declare string vector pr initialized with 1
read a
add " Washington " to end of pr
add " Adams " to end of pr
add " Jefferson " to end of pr
add " Madison " to end of pr
add " Monroe " to end of pr
add " Adams " to end of pr
add " Jackson " to end of pr
add " Van Buren " to end of pr
add " Harrison " to end of pr
add " Tyler " to end of pr
add " Polk " to end of pr
add " Taylor " to end of pr
add " Fillmore " to end of pr
add " Pierce " to end of pr
add " Buchanan " to end of pr
add " Lincoln " to end of pr
add " Johnson " to end of pr
add " Grant " to end of pr
add " Hayes " to end of pr
add " Garfield " to end of pr
add " Arthur " to end of pr
add " Cleveland " to end of pr
add " Harrison " to end of pr
add " Cleveland " to end of pr
add " McKinley " to end of pr
add " Roosevelt " to end of pr
add " Taft " to end of pr
add " Wilson " to end of pr
add " Harding " to end of pr
add " Coolidge " to end of pr
add " Hoover " to end of pr
add " Roosevelt " to end of pr
add " Truman " to end of pr
add " Eisenhower " to end of pr
add " Kennedy " to end of pr
add " Johnson " to end of pr
add " Nixon " to end of pr
add " Ford " to end of pr
add " Carter " to end of pr
add " Reagan " to end of pr
print pr [ a ] and " \ n "
n , k = integers
read n , k
s = string set to " "
for i = 0 to n exclusive , increment s by the character cast of the integer cast of ' a ' + i modulo k
print s
n , m = integer
g = bitset of size 100 and set to contain the byte form of 100
u = boolean array of size 100
in function dfs with argument integer k that returns nothing
if u [ k ] is nonzero , then end the function here
u [ k ] = 1
for i = 0 to m exclusive
if g [ k ] [ i ] is nonzero
for j = 0 to n exclusive
if g [ j ] [ i ] and j is not k and u [ j ] is nonzero , then call dfs with argument j
k , x = integers , ans = integer = 0
read n , m
c = boolean = 0
for i = 0 to n exclusive
read k
if k is nonzero , then c = 1
while looping decrease k by 1
read x
g [ i ] [ x - 1 ] = 1
for i = 0 to n exclusive
if u [ i ] is false
call dfs with argument i
increase ans by 1
print the result of ans - c
let n , s , x , y be integers
let max be a integer with max = - 1
read n and s
s is equal to s * 100
for i = 0 to n exclusive
read x , y
let num be a integer with num = 1
let price be a integer with price = x * 100 + y
if price is greater than s , proceed to next
let cents be a integer with cents = price modulo 100
let change be a integer with change = 100 - cents
if change equals 100 , change = 0 else change = change
if change is greater than max , max is equal to change
print max and newline
str = string
read str
h , m , h1 = integer
h = ( str [ 0 ] - 0 ) * 10 + ( str [ 1 ] - 0 )
h1 = ( str [ 1 ] - 0 ) * 10 + ( str [ 0 ] - 0 )
m = ( str [ 3 ] - 0 ) * 10 + ( str [ 4 ] - 0 )
if h is 23 and m > = h1
print 00 : 00
else if str [ 1 ] > = 6
h = ( str [ 0 ] - 0 + 1 ) * 10
m = str [ 0 ] - 0 + 1
print h , " : 0 " , m
else if ( str [ 1 ] is 5 and m > = h1 )
h = ( str [ 0 ] - 0 + 1 ) * 10
m = str [ 0 ] - 0 + 1
print h , " : 0 " , m
else if ( m > = h1 )
str [ 1 ] = str [ 1 ] + 1
print str [ 0 ] , str [ 1 ] , " : " , str [ 1 ] , str [ 0 ]
else
print str [ 0 ] , str [ 1 ] , " : " , str [ 1 ] , str [ 0 ]
bool function same with long long arguments a and b
if a and b are both > 0 , return true
if both a and b are less than 0 , return true
return false
declare long long variables x1 , y1 , x2 and y2
read user input to x1 , y1 , x2 and y2
define new integer n
read n from the input
define new integer called res = 0
in a for loop , change i from 0 to n exclusive
define long longs a , b and c
read a , b and c
define long long s1 = a * x1 + b * y1 + c
s2 is a new long long variable with value a * x2 + b * y2 + c
if the result of same ( s1 , s2 ) is false , increment res by one
print res
create ints n and m
create bool array use with 20 elements
void function calc with int arguments len1 , len2 , cur , t and integer reference & ans
if cur is equal to len1 + len2
increment ans by one
else if cur = len1
loop i from 0 to 7 exclusive
if use [ i ] is false and i < m
set use [ i ] to 1
call function calc with arguments len1 , len2 , cur + 1 , i and ans
set use [ i ] to 0
else if cur is greater than len1
loop i from 0 to 7 exclusive
if use [ i ] is false and t * 7 + i < m
set use [ i ] to 1
call calc with arguments len1 , len2 , cur + 1 , t * 7 + i and ans
set use [ i ] to 0
else
loop i from 0 to 7 exclusive
if use [ i ] is false and t * 7 + i < n
change use [ i ] to 1
call calc with arguments len1 , len2 , cur + 1 , t * 7 + i and ans
change use [ i ] to 0
read n and m
create integers len1 and len2 = 0 , N = n and M = m , then decrement n and m
while n is not 0
increment len1 by one
divide n by 7
while m is not 0
increment len2 by one
divide m by 7
set len1 to max of len1 and 1
set len2 to max of len2 and 1
assign N to n and M to m
if len1 + len2 is greater than 7
print 0
else
set value of sizeof ( use ) bytes at the pointer use to 0
create integer ans = 0
call calc with arguments len1 , len2 , 0 , 0 and ans
print ans
n = int
read n
s = string
read s
c = int with c = 0
v = int with v = size of s
if v is 1
print s
iterate i while s [ i ] is not 0
if s [ i ] is ' 0 ' increment c
print ' 1 '
print ' 0 ' c times
print newline
in the function binaria that takes integer x , reference n and returns integer
l , r = integers with l = 1 , r = sqrt ( n ) + 1
while l < = r
mid = integer with mid = ( l + r ) / 2
if mid * ( mid + 1 ) is x
return 1
else if mid * ( mid + 1 ) < x
l = mid + 1
else
r = mid - 1
n = integer
read n
flag = bool with flag = false
for i = 1 to sqrt ( n * 2 )
if binaria ( 2 * n - i * ( i + 1 ) , n )
flag = true
break loop
if not flag
else
n = integer
read n
s , l , t = integer with s = 500 , l = 0 , t = 0
ln , sn = integers
for i = 1 to n + 1 exclusive
read t
if t > l
l = t
ln = i
if t < = s
s = t
sn = i
count = integer with count = ln - 1 + n - sn
if sn < ln , decrement count
print count
n , m = integers
_k = string
read n , m , _k
k = integer with k = string to integer ( _k . c_str ( ) + 2 )
res = map from string to integer
for i = int ( 0 ) to int ( n ) exclusive
s = string
x = integer
read s and x
x = x * k / 100
if x < 100 , continue next iteration
res [ s ] = x
for i = int ( 0 ) to int ( m ) exclusive
s = string
read s
if res . find ( s ) is res . end ( ) , res [ s ] = 0
print res . size ( )
let s , t be characters with s = array of characters of length 100005 , t = array of characters of length 100005
vis = 2d array of integers with 2 rows and 150 columns
while read s and t
memset of vis , 0 , length of vis
let n , m , flag , gc be integers with flag = 0 , gc = 0 , n = string length of s , m = string length of t
if n is not equal to m
print NO and newline
for i = 0 , s [ i ] is true , increment i by 1
increment vis [ 0 ] [ s [ i ] ] by 1
increment vis [ 1 ] [ t [ i ] ] by 1
for i = 0 to 150 exclusive
if vis [ 0 ] [ i ] is not equal to vis [ 1 ] [ i ]
increment flag by 1
stop
if flag is equal to 0
if n is equal to 1
print YES and newline
for i = 0 to n exclusive
if s [ i ] is not equal to t [ i ] , increment gc by 1
if gc is equal to 2
print YES and newline
print NO and newline
print NO and newline
double integer = x
read x
if x is less than or equal to 127 then do the following
else if x is less than or equal to 32767 then do the following
else if x is less than or equal to 2147483647 then do the following
else if x is less than or equal to 9223372036854775807 then do the following
else
make integer n
read n
make list of strings L1
while n decrements
make strings s and s1
read s and s1
add s1 to s
swap s [ 2 ] and s [ 3 ]
add s to itself
push s onto L1
make characters c1 and c2
read c1 and c2
make iterator to list < string > p = L1 . begin ( ) , p1
for p ; p is not equal to L1 . end ( ) ; increment p
set p1 to p
increment p1
for p1 ; p1 is not equal to L1 . end ( ) ;
make string s2 = * p1 , s3 = * p
for i = 0 to 4 exclusive
if s3 . substr ( 0 , 4 ) equals s2 . susbtr ( i , 4 )
L1 . erase ( p1 incremented )
goto line1
increment p1
line1 : ;
print L1 size
create const int N = 1e5 + 5
create const long long mod = 998244353
declare 3d long long array dp with size N by 201 by 3
let a be int array with size N
declare integer variable n
read n
for i from 1 to n + 1 exclusive , read input to a [ i ]
set sizeof ( dp ) bytes at the pointer dp to 0
for i = 1 to 201 exclusive
if a [ 1 ] = - 1 or a [ 1 ] = i , set dp [ 1 ] [ i ] [ 2 ] to 1
create long long sum = 0
for i = 2 to n inclusive
assign 0 to sum
for integer j = 200 to 1 inclusive , decrementing j
if a [ i ] = - 1 or a [ i ] = j , change dp [ i ] [ j ] [ 0 ] to sum
assign ( sum + dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] ) % mod to sum
for j from 1 to 201 exclusive
change sum to 0
for integer j = 1 to 200 inclusive
if a [ i ] = - 1 or a [ i ] = j , set dp [ i ] [ j ] [ 2 ] to sum
declare long long variable ans = 0
print ans
d is a new array of integers with size 30
create new set of unique integers called ma
create integers a , b , l and r
read user input to a , b , l and r
if a = 3 and b = 1 and l = 4 and r = 10
print 4
s is a new string variable
for integer i = 1 to a inclusive , increase s by i - 1 + ' a '
declare new integer x with value length of s - 1
loop through i from 1 to b inclusive , changing s to the sum of s and s [ x ]
change x to length of s - 1
start for loop from i = 1 to a inclusive incrementing i
d [ s [ x ] - ' a ' ] = 1
decrement x by one
for i from 1 to a inclusive
change j from 0 to 26 exclusive in a loop
if d [ j ] is equal to 0
change s to s + j + ' a '
change d [ j ] to 1
break the loop
change x to length of s - 1
for i from 1 to b inclusive , increase s by s [ x ]
if r < = 2 * ( a + b )
start for loop from i = l - 1 to r - 1 inclusive , inserting s [ i ] - ' a ' into ma on each iteration
else
create new integer called xx with value l / ( 2 * a + 2 * b )
declare integer variable yy = r / ( 2 * a + 2 * b )
if xx is equal to yy
set l to l % ( 2 * a + 2 * b )
assign the new value = r % ( 2 * a + 2 * b ) to r
in a for loop , change i from l - 1 to r exclusive , pushing s [ i ] - ' a ' into ma on each loop
else if yy = xx + 1
assign the new value = l % ( 2 * a + 2 * b ) to l
assign r % ( 2 * a + 2 * b ) to r
in a for loop , change i from l - 1 to length of s exclusive , inserting s [ i ] - ' a ' into ma on each loop iteration
insert s [ i ] - ' a ' into ma in a loop for i from 0 to r exclusive
else
in a for loop , change i from 0 to length of s exclusive , pushing s [ i ] - ' a ' to ma
print length of ma
ch = array of 300000 char
n = int
while read n
read ch
num = 0
for i = 0 to n exclusive
if ch [ i ] is ' < '
increment num
else
break
if num is n
print num
continue
for i = n - 1 down to 0 inclusive
if ch [ i ] is ' > '
increment num
else
break
print num
let n , L , a be 64 bit integers
read n , L , a
if n equals 0
print L / a and newline
t = array of 64 bit integers of length n
l = array of 64 bit integers of length n
for i = 0 to n exclusive , read t [ i ] , l [ i ]
the 64 bit integer value of c = t [ 0 ] / a
increment c by ( L - ( t [ n - 1 ] + l [ n - 1 ] ) ) / a
print c and newline
create 3d long long array DP with size 100005 by 205 by 2 , create long long arrays sum1 , sum2 with sum1 size 205 , sum2 size 205
create long long array ar with size 100005
create long long N
read N
for i = 0 to N exclusive , read ar [ i ]
if ar [ 0 ] is - 1
set sum1 [ 0 ] to 0
for i = 1 to 200 inclusive
set DP [ 0 ] [ i ] [ 0 ] to 1
set sum1 [ i ] to sum1 [ i - 1 ] + DP [ 0 ] [ i ] [ 0 ]
else
set DP [ 0 ] [ ar [ 0 ] ] [ 0 ] to 1
set sum1 [ 0 ] to 0
for i = 1 to 200 inclusive , set sum1 [ i ] to sum1 [ i - 1 ] + DP [ 0 ] [ i ] [ 0 ]
for i = 1 to N exclusive
if ar [ i ] is - 1
for j = 1 to 200 inclusive
increment DP [ i ] [ j ] [ 0 ] by sum1 [ j - 1 ]
set DP [ i ] [ j ] [ 0 ] to DP [ i ] [ j ] [ 0 ] % 998244353
increment DP [ i ] [ j ] [ 1 ] by DP [ i - 1 ] [ j ] [ 0 ]
set DP [ i ] [ j ] [ 1 ] to DP [ i ] [ j ] [ 1 ] % 998244353
increment DP [ i ] [ j ] [ 0 ] by sum2 [ j - 1 ]
set DP [ i ] [ j ] [ 0 ] to DP [ i ] [ j ] [ 0 ] % 998244353
for j = 1 to 200 inclusive
increment DP [ i ] [ j ] [ 1 ] by ( sum2 [ 200 ] - sum2 [ j - 1 ] + 998244353 )
set DP [ i ] [ j ] [ 1 ] to DP [ i ] [ j ] [ 1 ] % 998244353
else
increment DP [ i ] [ ar [ i ] ] [ 0 ] by ( sum1 [ ar [ i ] - 1 ] ) + ( sum2 [ ar [ i ] - 1 ] )
set DP [ i ] [ ar [ i ] ] [ 0 ] to DP [ i ] [ ar [ i ] ] [ 0 ] % 998244353
increment DP [ i ] [ ar [ i ] ] [ 1 ] by DP [ i - 1 ] [ ar [ i ] ] [ 0 ]
set DP [ i ] [ ar [ i ] ] [ 1 ] to DP [ i ] [ ar [ i ] ] [ 1 ] % 998244353
increment DP [ i ] [ ar [ i ] ] [ 1 ] by ( sum2 [ 200 ] - sum2 [ ar [ i ] - 1 ] + 998244353 )
set DP [ i ] [ ar [ i ] ] [ 1 ] to DP [ i ] [ ar [ i ] ] [ 1 ] % 998244353
set sum1 [ 0 ] to 0
set sum2 [ 0 ] to 0
for j = 1 to 200 inclusive
set sum1 [ j ] to sum1 [ j - 1 ] + DP [ i ] [ j ] [ 0 ]
set sum1 [ j ] to sum1 [ j ] % 998244353
set sum2 [ j ] to sum2 [ j - 1 ] + DP [ i ] [ j ] [ 1 ]
set sum2 [ j ] to sum2 [ j ] % 998244353
print ( sum2 [ 200 ] ) % 998244353 print newline
return 0 from function
create long longs n , i , e and t = 0
declare new array of characters chr with size 1001
read chr
for as = 0 to length of chr exclusive
if chr [ as ] is equal to ' n ' , increment n by one
if chr [ as ] = ' i ' , increment i by one
if chr [ as ] is equal to ' e ' , increment e by one
if chr [ as ] = ' t ' , increment t by one
print min ( e / 3 , min ( ( n - 1 ) / 2 , min ( i , t ) ) ) and a new line
i , n , m , cash , count , need , flag , c50 , c25 = int with cash = 0 and count = 0 and flag = 1
read n
mp = int , int map
loop n times
read m
if m is not 25 and flag
set need to m - 25
set c25 to need / 25
set c50 to need / 50
if c50
if mp [ 50 ]
decrement mp [ 50 ]
else if mp [ 25 ] > 1
decrement mp [ 25 ] by 2
else
set flag to 0
continue
decrement need by 50
decrement c25 by 2
if c25
if mp [ 25 ]
decrement mp [ 25 ]
else
set flag to 0
continue
increment mp [ m ]
if flag
print " YES "
else
print " NO "
let s be a string
read s
let i , n , a , b , c be integers with i = 0 , a = 0 , b = 0 , c = 0 , n = length of s
while i is less than n and s [ i ] is equal to a , increment i by 1 , increment a by 1
while i is less than n and s [ i ] is equal to b , increment i by 1 , increment b by 1
while i is less than n and s [ i ] is equal to c , increment i by 1 , increment c by 1
if i is less than n
print NO and newline
if a is greater than 0 and b is greater than 0 and ( c is equal to a or c is equal to b )
print YES and newline
print NO and newline
n , ma , m , ans , x , y , i , k = long long
read n
set ma to 0
set m to 0
for i = 1 to n inclusive
read x then y
set ma to max of ma , x
set k to 0
set ans to 1
loop while ans < y
set ans to ans * 4
increment k
set m to max of m , k + x
if m is ma increment m
print m
n , m , k = long long
read n then m then k
if k is greater than ( n - 1 ) + ( m - 1 )
print - 1
res = long long with res = - 1
if k is less or equal to 5000000
for a = 0 to k inclusive
b = long long with b = k - a
if a is greater than n - 1 or b is greater than m - 1 then continue
set res to max of res and ( n / ( a + 1 ) ) * ( m / ( b + 1 ) )
else
for i = 0 to 2
for x = 1 to 1000 inclusive
a = long long with a = min of min of k and n - 1 and n / x - 1
if a is less than 0 or a is greater than n - 1 then continue
b = long long with b = k - a
if b is less than 0 or greater than m - 1
set res to max of res and ( n / ( a + 1 ) ) * ( m / ( b + 1 ) )
call swap on n and m
print res
n = integer
read n
if n is 0
print 1
else if n modulo 4 is 0
print 6
else if n modulo 4 is 1
print 8
else if n modulo 4 is 2
print 4
else if n modulo 4 is 3
print 2
n is an integer
chair be a character array of size 10000
read n
a is an integer
read input as chair + 1
let chair [ 0 ] be 0
let chair [ n + 1 ] be 0
let ans be integer with ans = 0
if n = 1 and chair [ 1 ] = 0 ,
print No and new line
if n = 1 and chair [ 1 ] = 1
print Yes and new line
for integer i = 1 to n inclusive
if chair [ i ] = 1 and either chair [ i - 1 ] = 1 or chair [ i + 1 ] = 1
let ans be 1
stop
if chair [ i ] = 0 ,
if chair [ i - 1 ] = 0 and chair [ i + 1 ] = 0 ,
let ans be 1
stop
if ans equals 1 ,
print No and new line
else
print yes and newline
vv = long long vector
flag = bool with flag = 0
ans = long long
l , r = int
in function solve taking long long i
if i > 1e10 as long return
if i append i to vv
call solve of i * 10 + 4
call solve of i * 10 + 7
call solve of 0
read l then r
for i = 0 to size of vv
if vv [ i ] > = l
if vv [ i ] > = r
increment ans by ( vv [ i ] * ( r - l + 1 ) )
break
else
increment ans by ( vv [ i ] * ( vv [ i ] - l + 1 ) )
set l to vv [ i ] + 1
if l > r break
print ans
declare ints hpy , ay and dy
declare integers hpm , am and dm
declare integer variables h , a and d
read hpy , ay and dy
read hpm , am and dm
read h , a and d
declare integer variable sol = 1123123123
for integer j = 0 to 10000 inclusive
for integer k = 0 to 10000 inclusive
break if a * j + d * k is greater than sol
declare integer ly = max of 0 and am - ( dy + k )
declare integer lm = max of 0 and ( ay + j ) - dm
if ly is 0 and lm = 0
continue the loop
else if ly = 0
assign min of sol and a * j + d * k to sol
else if lm = 0
go to the start of the loop
else
declare integer turns = ( hpm + lm - 1 ) / lm
create integer z = turns * ly - hpy + 1
set z to max of z and 0
assign min of sol and a * j + d * k + z * h to sol
print sol and ' \ n '
t1 , t2 , x1 , x2 , t0 = long long int
read t1 then t2 then x1 then x2 then t0
if t1 is t2
print x1 and x2
maxa , maxb = long long int
set maxa to 0
set maxb to x2
closest = long double with closest = t2
for i = 1 to x1 inclusive
j = long long int with j = ( t0 - t1 ) * i
set j to ceil of 1 . 0 * j / ( t2 - t0 )
if j > x2 continue
comp = long double with comp = t1 * i + t2 * j
set comp to comp / ( i + j )
if comp < t0 continue
if comp < closest
set closest to comp
set maxa to i
set maxb to j
if comp is closest
if maxa + maxb < i + j
set maxa to i
set maxb to j
print maxa and maxb
create integer array freq with size 130
create integer vector v
create strings s , t
read s read t
for i = 0 to minimum of ( size of s and size of t ) exclusive
if s [ i ] is not t [ i ] , add element i to end of v
increment freq [ s [ i ] ]
if size of v is greater than 2 or size of v is 1 or size of s is not size of t
print " NO "
else if size of v is 2
if s [ v [ 0 ] ] is t [ v [ 1 ] ] and s [ v [ 1 ] ] is t [ v [ 0 ] ]
print " YES "
else
print " NO "
else
for i = ' a ' to ' z ' inclusive
if freq [ i ] is greater than 1
print " YES "
print " NO "
declare int variables n , s , x , y , ans , k and sw
read n and s and keep looping
set ans to - 1
multiply s by 100
for integer i = 1 to n inclusive incrementing i
read x and y from the input
change sw to ( 100 - y ) mpdulo 100
change y to the sum of y and x * 100
assign the sum of y and sw to y
change k to s / y
if k is equal to 0 , go to the start of the loop
change the value of ans to max of ans and sw
print ans
create integer n
read from the input to n
declare new string s
read from the input to s
count1 is a new integer with value 0
declare new integer variable count0 with value 0
in a for loop , change i from 0 to length of s exclusive incrementing i
if s [ i ] is equal to ' 1 '
increment count1 by one
else
increment count0
create new string output with value " 1 "
if count1 = 0
assign " 0 " to output
else
for integer i = 1 to count0 inclusive , append ' 0 ' to output
print output to the stdout
declare integer n
while read n is true
declare integer flag
if n % 2 is 0
let flog be n / 2
print flog and newline
for i = 0 to flog exclusive
print 2
if i is not flag - 1 , print " "
if i is flag - 1 , print newline
if n % 2 is not 0
if n is 3
print 1 , newline
print 3 , newline
if n is greater than 3
let flog be n / 2
print flog , newline
for i = 0 to flog exclusive
if i is not flog - 1 , print 2 , " "
if i is flog - 1 , print 3 , newline
let a , b , c , d , k be long integers
read a , b , c , d and k , a = maximum of a and c , b = minimum of b and d
print maximum of b - a + ( k is greater than b or k is less than a ) , 0LL and newline
declare fastscan taking in integer & x and returning nothing
create bool neg = false
create register integer c
set x to 0
set c to getchar ( )
if c is equal to ' - '
set neg to true
set c to getchar ( )
for c to c > 47 and c < 58 , set x to ( x < < 1 ) + ( x < < 3 ) + c - 48
if neg is truthy , set x to the result of x * - 1
create char arrays s1 of size 100005 , s2 of size 100005 , a of size 2 , b of size 2
create integers l1 , l2 , i , j = 0 , cnt = 0
read s1 and s2
set l1 to the length of s1
set l2 to the length of s2
if l1 is not equal to l2
print " NO "
else
for i = 0 to 11 exclusive
if s1 [ i ] is not equal to s2 [ i ]
increment cnt
set a [ j ] to s1 [ i ]
set b [ j ] to s2 [ i ]
increment j
if cnt is greater than 2
print " NO "
if a [ 1 ] is equal to b [ 0 ] and a [ 0 ] is equal to b [ 1 ]
print " YES "
else
print " NO "
let hor be an integer array = from 0 to 23 inclusive
let mie be an int array = 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32
let maohao be a char
let h , m be ints
read h , maohao and m
for i = 0 to 16 exclusive
if hor [ i ] is h and mie [ i ] > m or hor [ i ] > h
if hor [ i ] < 10 then print 0
print hor [ i ] and :
if mie [ i ] < 10 then print 0
print mie [ i ]
print 00 : 00
declare gcd with long longs a , b as arguments , returning long long
if b is true , return result of run gcd with b and a % b as arguments
return a from function
declare lcm with long longs a , b as arguments , returning long long
return ( a * b ) / result of run gcd ( a , b )
declare fastPow with long longs a , b as arguments , returning long long
declare ret = 1 as long long
while b is greater than 0
if b bitwise and 1 , let ret = ret * a
let a be a * a
let b be b bitshift right 1
return ret from function
declare SieveOfErathostenes with long long n as argument , returning long long vector
declare boolean array prime size n + 1
declare long long vector a
set bytes from prime to n + 1 to value true
for p = 2 to p * p is less than or equal to n , incrementing p
if prime [ p ] is true
for i = p * p to n inclusive , incrementing i by p , let prime [ i ] be false
for p = 2 to n inclusive
if prime [ p ] is true , add p to end of a
return a from function
declare integers n , s , max = 0 , c = 1 , a , b , total , d
read n and s
for i = 0 to n exclusive
read a and b
if a is greater than s or ( a is s and b is greater than 0 )
let c be c bitwise and 1
else
let c be c bitwise and 0
let total be 100 - b
if total is 100 , let total be 0
let max be max if max is greater than total , else total
if c is true , let max be - 1
print max and newline
fast = inst static with fast = call lambda function that return 0
n , m = int
read n
high = long long vector of size n with all values set to 0
freq = int vector of size n with all values set to 0
highest , val = long long with highest = 0
for i = 0 to n
read m
set freq [ i ] to m
for j = 0 to m
read val
set high [ i ] to max of high [ i ] , val
set highest to max of highest , high [ i ]
ans = long long with ans = 0
for i = 0 to n increment ans by freq [ i ] * ( highest - high [ i ] )
print ans
dp = array of 5555 by 5555 long long int
sum = array of 5555 long long int
s , t = string
read s , t
lens = lenght of s
lent = lenght of t
for i = 1 to lens inclusive
for j = 1 to lent inclusive
ans = 0
for i = 1 to lens inclusive
for j = 1 to lent inclusive ans = ( ans + dp [ i ] [ j ] ) modulo 1000000007
print ans
declare long long n
declare new long long variables x and y
read n from the user input
read from the input to x and y
define new long long m with value min of x and y
declare new long long tx = x - m
create new long long called ty = y - m
create long long w with value m - 1 + tx + ty
set the value of m to min of n - x and n - y
assign n - x - m to tx
assign n - y - m to ty
declare long long variable with name b = m + 1 + tx + ty
if w is less than b
print " White "
else
print " Black "
create integers hm , am , dm
declare wins with integers hy , ay , dy as arguments , returning boolean
create integer damy with damy = maximum of 0 and ay - dm
create integer damm with damm = maximum of 0 and am - dy
if damy is 0 , return false from function
if damm is 0 , return true from function
( hm + damy - 1 ) / damy is less than ( hy + damm - 1 ) / damm
create integers hy , ay , dy
read hy read ay read dy read hm read am read dm
create integers h , a , d
read h read a read d
for s = 0 to 20000 exclusive
for id = 0 to id * d is less than or equal to s and id is less than or equal to 100 , incrementing id
for ia = 0 to ia * a + id * d is less than or equal to s and ia is less than or equal to 200 , iincrementing ia
create integer ih with ih = ( s - ia * a - id * d ) / h
if result of run wins with hy + ih , ay + ia , dy + id as arguments is true
print s print ' \ n '
declare character arrays a and b with size 3
declare strings str1 and str2
read str1 and str2 and keep looping
create integer count
change a [ 0 ] to ' \ 0 '
change b [ 0 ] to ' \ 0 '
declare integer index = 0
if length of str1 = 1 or length of str1 ! = length of str2
print " NO "
skip the rest of the loop
for i = 0 to length of str1 exclusive
if str1 [ i ] = str2 [ i ]
go to the start of the loop
else
increment count
if count is greater than 2
print " NO "
stop the loop
set a [ index ] to str1 [ i ]
set b [ index ] to str2 [ i ]
increment index by one
change a [ index ] to ' \ 0 '
change b [ index ] to ' \ 0 '
if count is greater than 2 , go to the start of the loop
if a [ 0 ] is equal to b [ 1 ] and b [ 0 ] is equal to a [ 1 ]
print " YES "
else
print " NO "
s1 , s2 = string
v [ 30 ] = int = vector int
in function bs that takes int alph and int p
if the size of v [ alph ] is 0 then return - 1
let l = 0 = int , r = int = size of v [ alph ]
while l < r
let mid = int = ( 1 + r ) / 2
if v [ alph ] [ mid ] < p
set l to mid + 1
else
set r = mid
if l is the size of v at alph then return v [ alph ] [ 0 ]
retrun v [ alph ] [ 1 ]
read s1 and s2
for i = 0 to s1 length , add i to the end of v [ s1 [ i ] - ' a ' ]
let cnt = 0 = int , and pnt = the length of s1 = int
int i = 0 to s2 . length
let idx be an integer = result of ( s2 [ i ] - ' a ' , pnt )
if idx is - 1
set cnt to - 1
exit loop
if idx < pnt then increment cnt
set pnt to idx + 1
print cnt
ada is a new array of integers with size 10005
create integer variable n
read from the input to n
declare string variable with name s
read s from the user input
if n = 1
print " Yes "
in a for loop , change i from 0 to n exclusive incrementing i
x is a new character variable = s [ i ]
create integer variable xx
add 1 to ada [ xx ]
satu is a new integer variable = 0
start for loop from i = 97 to 122 inclusive incrementing i
if ada [ i ] is greater than 1
print " Yes "
print " No " to the standard output
b = array of 101 int
a = array of 101 vector of int
function Find ( get int x , return int )
if b [ x ] is x
return x
else
b [ x ] = Find ( b [ x ] ) , return b [ x ]
function Union ( get int x , y , return nothing )
x = Find ( x )
y = Find ( y )
b [ y ] = x
check = array of 101 bool
n , m = int
read n , m
ans = 0
fill b with - 1
for i = 0 to n exclusive
t = int
read t
if t is 0 increment ans
for j = 0 to t exclusive
x = int
read x
put x at end of a [ i ]
b [ x ] = x
for i = 0 to n exclusive
if size of a [ i ] > 0
x = a [ i ] [ 0 ]
cnt = 0
for i = 1 to m inclusive
if b [ i ] ! = - 1 b [ i ] = Find ( b [ i ] )
for i = 1 to m inclusive
if b [ i ] ! = - 1 and not check [ b [ i ] ]
check [ b [ i ] ] = true
increment cnt
if cnt > 0 decrement cnt
print ans + cnt
in int function gdc that takes a , b = int
let n , x , max_ = 0 , s = 0 , k = 1 be ints
read n
for i = 0 to n exclusive
if i = 0
read x
increment max_ by x
read x
increment max_ by x
read x
increment max_ by x
read x
increment max_ by x
else
read x
increment s by x
read x
increment s by x
read x
increment s by x
read x
increment s by x
if s > max_ then increment k
reset s to 0
print k
in int function gcd that takes a = int and b = int
if b = 0
return a
else
return gcd of b and a mod b
n = long double
read n
if n < = 127
print byte
else if n < = 32767
else if n < = 2147483647
else if n < = 9223372036854775807
else
create long long n
declare cpr taking in long long n and returning bool
if n is equal to 1 or n is equal to 0 , return false
if n is equal to 2 , return true
if n % 2 is equal to 0 , return false
for i = 3 while i * i is less than or equal to n by increasing by 2
if n % i is equal to 0 , return false
return true
read n
set idx to 1
loopo indefinitely
if cpr ( n * idx + 1 ) returns true
increment idx
otherwise
show idx
let INF be const long long with INF = 9223372036854775807LL
let PI be const long double with PI = acos of - 1
let MAX_N be const integer with MAX_N = 1e + 6
let ALPH be const integer with ALPH = 26
let alph be const string with alph = " abcdefghijklmnopqrstuvwxyz "
define count which takes integer pos , string s and integer xd as arguments
let l be integer with l = size of s
while pos is less than l
if element at index pos in s is equal to ' | '
increment xd
increment pos
else
break
increment pos
define print which takes integer a , b , and c as argument
for i = 0 to a exclusive , print out |
print +
for i = 0 to b exclusive , print |
print =
for i = 0 to c exclusive , print |
print out newline
define check which takes integer a , b , c as arguments
if a is less than or equal to 0 or b is less than or equal to 0 or c is less than or equal to 0 , return false
return a + b is equal to c
define solve
let s be string
read s
let l be integer with l = size of s
let a , b , c be integers
set a = b = c = 0
let pos be integer with pos = 0
call count with pos , s , a
call count with pos , s , b
call count with pos , s , c
if a + b is equal to c
call print with a , b , c
else
if check of a + 1 , b - 1 , c is not equal to 0
call print of a + 1 , b - 1 , c
return
if check of a + 1 , b , c - 1 is not equal to 0
cal print of a + 1 , b , c - 1
return
if check of a - 1 , b + 1 , c is not equal to 0
call print of a - 1 , b + 1 , c
return
if check of a , b + 1 , c - 1 is not equal to 0
call print of a , b + 1 , c - 1
return
if check of a - 1 , b , c + 1 is not equal to 0
call print of a - 1 , b , c + 1
return
if check of a , b - 1 , c + 1 is not equal to 0
call print of a , b - 1 , c + 1
return
print out Impossible with newline
let t be integer with t = 1
while t is greater than zero , decrement t and call solve
let n be a integer
read n
ar = array of integers of length n + 1
for i = 2 to n inclusive , read ar [ i ]
create a stack of integers by name s
the integer value of i = n
push n into s
while the condition is true
push ar [ i ] into s
i is equal to ar [ i ]
if i equals 1 , stop
print s . top ( )
pop s
while s . empty ( ) is not equal to true
print space and s . top ( )
pop s
print newline
in function gcd taking int i , intj and returning int
if j is 0 return i
return gcd of j , i mod j
a , b , c , d = int
read a then b then c then d
if ( b - d ) is not a multiple of gcd of c , - a
print " - 1 "
else
for i = 0 to 1e6
if ( b - d + a * i ) is a multiple of c and ( b - d + a * i ) / c > = 0
print b + a * i
break
void function fastIo , blank
s = string
indx = integer
in int function check that takes string temp
let i be an int
for i = 0 to length of s inclusive
if i different indx and i + 1 diffenrent indx and i different indx + 1
if substring of s between i and 2 is same as temp
set indx to i
return 1
call fastIo ( )
read s
indx = - 2
ans = integer = check of " AB "
increment ans by check of " BA "
if ans is 2
else
set ans to 0
set indx to - 2
set ans to check of " BA "
increment asn by check of " AB "
if ans is 2
else
bool function isIN with reference to the vector of ints argument & disk and int argument element
for i from 0 to length of disk exclusive
if disk [ i ] is equal to element , return true
return false
declare ints n and m
read input to n and m
declare vector of ints called rstr
declare integer variable v
for i from 0 to n exclusive
read v
push v to rstr
declare vector of ints disk
create integer ans = 0
for i from 0 to n exclusive
if isIN ( disk , rstr [ i ] ) returned true
increment ans
skip the rest of the loop
else if length of disk < m
push rstr [ i ] into disk
else
declare integer variables ind = 0 , mx = i + 1 and k
loop j from 0 to m exclusive
loop k from to n exclusive
if disk [ j ] = rstr [ k ]
if k is greater than mx
set mx to k
set ind to j
break the loop
if k = n
assign j to ind
break the loop
if mx = INT_MAX , set ind to 0
assign rstr [ i ] to disk [ ind ]
print n - ans
declare integers n and m
declare integer menor
read in n and m
menor is equal to the maximum value an integer variable can store
loop through the code m times
declare integers a and b
read in a and b
the value of menor is equal to the smaller amount of the values menor or b - a + 1
print the value of menor and skip a line
print 0
loop through the code n - 1 times and print the remainder of i divided by menor
print a new line
let i , j , k , rest , n be long long integers
let ch , ch1 be characters
read n , k
assign n - k to rest
assign the character a to ch
print ch
add 1 to ch
assign the character a to ch1
for i = 0 , j = 0 as long as i is less than rest with increment i , increment j
print ch1
add 1 to ch1
if j equals k
assign the character a to ch1
assign 0 to j
print newline
N = const long long = 100005
dp , f = long long arrays of length N
dpback = long long array of length N
g = long long vector of length N
gback = long long vector of length N
in void function go taking p = long long
if dp at p = 1 then return
set dp at p to 1
if f at p isn ' t 1
for long long i = 0 to size of g at p , call go on g [ p ] [ i ]
in void fucntion goback taking p = long long and first = bool
if dpback at p = 1 then return
if first isn ' t 0 ot f at p isn ' t 1
dpback at p = 1
for long long i = 0 to size of gback at p then call goback on goback [ p ] [ i ] and false
n , m = long long
read n , m
read the first n elements of f
for long long i = 0 to m exclusive
x , y = long long
read x , y
decrement x
decrement y
push back x into g at y
push back y into gback at x
for long long i = 0 to n exclusive
if f at i = 2 then call go on i
if f at i = 1 then call goback on i and true
for long long i = 0 to n exl
ans = long long , are dp [ i ] 1 and dpback [ i ] = 1 ? then set ans = 1 , else set ans = 0
mod = constant long long = 998244353
maxn = constant integer = 2e5
t = integer
n , a , b , c are long longs
read n
read a , b , c
one , two are long longs with one = a , two = b - c
sum1 = long long = n / one , yu1 = long long = n mod 1 , ci = long long
while yu1 / b is positive
set ci to ( yu1 - c ) / 2
set yu1 to yu1 - ci * two
add ci to sum1
yu2 = long long = n , sum2 and ans are long longs both set to 0
while yu2 / b is positive
set ci to ( yu2 - c ) / two
set yu2 to yu2 - ci * two
add ci to sum2
add yu2 / one to sum2
set yu2 to yu2 mod one
set ans to call max with ans , sum2
set ans to call max with sum1 , ans
print ans
create long long int mod = 1000000007
create long long ints l and r
let p be long long int array with size 18
let ct be long long int array with size 19
init is a void function
assign 1 to p [ 0 ]
for i = 1 to 17 inclusive , change p [ i ] to 10ll * p [ i - 1 ]
set ct [ 1 ] to 9
set ct [ 2 ] to 9
for i from 3 to 18 inclusive , set ct [ i ] to 9 * p [ i - 2 ]
long long int function calc with long long int argument num
declare vector of integers called digits
create long long int n = num
while num ! = 0
push num % 10 into digits
divide num by 10
if there is only one element in digits , return n - 1
create integer l = length of digits
declare long long int ans = 0
for integer i = l - 1 to 0 inclusive decrementing i
if i is equal to l - 1
if digits [ i ] > 1 , add ( digits [ i ] - 1 ) * ( p [ l - 2 ] ) to ans
else if i = 0
if digits [ l - 1 ] is less than digits [ 0 ] , increase ans by 1
else if digits [ i ] > 0
increase ans by ( digits [ i ] ) * ( p [ i - 1 ] )
for integer i = 0 to l exclusive increment ans by ct [ i ]
return ans
call init ( )
read l and r
print calc ( r + 1 ) - calc ( l )
integer array = n , d [ 111 ]
array a size 111 , s , t = string
create character variable
read n
for i = 1 to less than or equal to n do the following
read a [ i ]
for j = 0 to less than a [ i ] . size ( ) do the following
if a [ i ] [ j ] is greater than or equal to a then subtract 32 from a [ i ] [ j ]
read s
set t to s
read lucky
if lucky is greater than or equal to a then subtract 32 from lucky
integers = sl = s . length ( )
for i = 0 to less than sl do the following
if s [ i ] is greater than or equal to a then subtract 32 from s [ i ] , d [ i ] = 1
for i = 0 to less than sl do the following
for j = 1 to less than or equal to n do the following
integers l = a [ j ] . length ( )
if i + l is less than or equal to sl and s . substr ( i , l ) is a [ j ] then do the following
for k = 0 to less than l do the following
if s [ i + k ] is lucky then do the following
if lucky is A then do the following
set t [ i + k ] to b if d [ i + k ] is true or else d [ i + k ] = B )
else
set t [ i + k ] to b if d [ i + k ] is true or else d [ i + k ] = A )
else
set t [ i + k ] to lucky + 32 if d [ i + k ] is true else t [ i + k ] = lucky
create strings a , b
create integers judge , judge2 , ab , ba with judge = 0 , judge2 = 0 , ab = 0 , ba = 0
read a
set b to a
for i = 0 to size of a exclusive
if ( a [ i ] is ' A ' and a [ i + 1 ] is ' B ' ) and ab is less than 1
increment judge
set a [ i ] to a [ i + 1 ] to ' c '
increment ab
if ( a [ i ] is ' B ' and a [ i + 1 ] is ' A ' ) and ba is less than 1
increment judge
set a [ i ] to a [ i + 1 ] to ' c '
increment ba
set ab to 0
set ba to 0
set a to b
for i = size of a - 1 to 0 inclusive , decrementing i
if ( a [ i ] is ' A ' and a [ i + 1 ] is ' B ' ) and ab is less than 1
increment judge2
set a [ i ] to a [ i + 1 ] to ' c '
increment ab
if ( a [ i ] is ' B ' and a [ i + 1 ] is ' A ' ) and ba is less than 1
increment judge2
set a [ i ] to a [ i + 1 ] to ' c '
increment ba
if judge2 is 2 or judge2 is 2
print " YES " print newline
else
print " NO " print newline
declare constant integer maxn = 2e6 + 10
declare integer arrays pri size maxn , pal size maxn , c size 10
declare boolean array vis size maxn
declare check with integer k as argument , returning boolean
declare integer cnt = 0
while k is true
let c [ increment cnt ] be k % 10
let k be k / 10
for i = 0 to cnt exclusive
if c [ i ] is not c [ cnt - i - 1 ] , return false from function
return true
declare init with no arguments , returning void
set bytes from vis to size of vis to value false
set bytes from pri to size of pri to value 0
set bytes from pal to size of pal to value 0
let pal [ 1 ] be 1
for i = 2 to maxn exclusive
let pri [ i ] be pri [ i - 1 ]
let pal [ i ] be pal [ i - 1 ]
if vis [ i ] is false
increment pri [ i ]
for j = 2 to j * i is less than maxn , incrementing j , let vis [ i * j ] be true
if result of run check ( i ) is true , increment pal [ i ]
run init
declare long longs p , q , ans = 0
read p , q
for i = maxn - 1 to i is greater than or equal to 1 ad not ans , decrementing i
if ( q * pri [ i ] is less than or equal to p * pal [ i ] , let ans be i
print ans and newline
x1 , y1 , x2 , y2 = long long
n , a , b , c = int
while read x1 , y1 , x2 , y2 , n
num = 0
while n is not 0 , decrement n
read a , b , c
i , j = long long
i = a * x1 + b * y1 + c
j = a * x2 + b * y2 + c
if i > 0 and j > 0 or i < 0 and j > 0 increment num
print num
declare constant long long MAXN = 100 * 1000
declare long long array arr size MAXN + 10 , long longs n , d
declare bs with long long x as argument , returning long long
declare long longs l = x , r = n
while r - l is greater than 1
declare long long mid = ( l + r ) / 2
if arr [ mid ] - arr [ x ] is less than or equal to d
let l be mid
else
let r be mid
return l from function
read n and d
for i = 0 to n exclusive , read arr [ i ]
declare long long ans = 0
for i = 0 to n exclusive
declare long long k = result of run bs ( i ) - i
increment ans by k * ( k - 1 ) / 2
print ans and newline
declare pair of integer and integer array dragon size 1001
declare s , n , x , y , i = 0 as integers
read s and n
while increment i is less than or equal to n
read x and y
let dragon [ i - 1 ] be make pair with x and y
sort from dragon to dragon + n
for j = 0 to n exclusive
if s is less than or equal to first element of dragon [ j ]
print " NO " , and ' \ n '
increment s by second element of dragon [ j ]
print " YES " , ' \ n '
create long long ints xa , ya , xb , and yb
read xa , ya , xb , and yb
make integer n
read n
make long long ints a , b , and c
create integer ans = 0
for i = 0 to n exclusive
read a , b , and c
if b is equal to 0
if - c is greater than min ( xa * a , xb * a ) and - c is less than max ( xa * a , xb * a ) , set ans to ans + 1
otherwise
create long long integers y1 and y2
set y1 to - a * xa - c
set y2 to - a * xb - c
if y1 is greater than ya * b and y2 is less than yb * b or if y1 is less than ya * b and y2 is greater than yb * b , increment ans
show ans
n , m , a , d , i , j , r , x , y are long longs with r = 0
read n , m , a , d
v = long long vector of size m + 1
for i = 1 to m inclusive , read v [ i ]
set i to j to 1
set x to ( d / a ) + 1
while i is at most m and j is at most n
set y to j * a
if v [ i ] is greater than y
set y to ( ( call min with n * a , v [ i ] ) - y ) / a
set y to ( y / x ) + 1
add y to r , add x * y to j
set y to ( j - x ) * a + d + 1
while i is at most m and v [ i ] is less than y , increment i
else
increment r
set y to v [ i ] + d
while i is at most m and v [ i ] is at most y , increment i
set j to ( y / a ) + 1
while i is at most m
increment r
set y to v [ i ] + d
while i is at most m and v [ i ] is at most y , increment i
if j is at most n
assign n - j to j
add ( j / x ) + 1 to r
display r
D = array of 10 by 20 by 2 long long
w = string
function d ( get int i , j , k return long long )
if D [ i ] [ j ] [ j ] ! = - 1 return D [ i ] [ j ] [ k ]
if j is 1
if i is 0 and k is 0 return 9
if i is 0 and k is 1
return w [ size of w - 1 ] - ' 0 '
else if k is 1
return i < = w [ size of w - 1 ] - ' 0 '
else
return 1
cont = 0
return D [ i ] [ j ] [ k ] = cont
function F ( get long long x , return long long )
fill D with - 1
l = stringstream
get x from l
put w in l
return d ( 0 , size of w , 1 )
l , r , i , j = long long , ans = 0
read l , r
ans = F ( r ) - F ( l - 1 )
print ans
create pair array of int and int a of size 10001
declare drom taking in int r and returning integer
if a [ r ] . first is not 0
create int u = r
set r to a [ r ] . first
if a [ r ] . second is not 0
set a [ r ] . second to min of a [ r ] . second and a [ u ] second
else do
set a [ r ] . second to a [ u ] . second
set a [ u ] . first to 0
else
return r
set r to return value of drom ( r )
return r
make ints n , t , and l
read n and t
while t is not equal to 0
make ints x , y , and z
read x , y , and z
set a [ x ] . first to y
set a [ x ] . second to z
decrease t by 1
for i = 1 to n
make int m = drom ( i )
if m is not equal to i
set a [ i ] . first to m
set a [ i ] . second to a [ m ] . second
else do
set first value of a [ i ] to 0
for i = 1 to n
if a [ i ] . first is not equal to 0 , increment l
print l
for i = 1 to n
if a [ i ] . first is not equal to 0 , print i , " " , a [ i ] . first , " " , and a [ i ] . second
create long long array x of size 1000 * 100 + 5
make long long ints n , d , and ans = 0
declare f taking in int k and returning long long
make long long ints l = k and r = n
while r - 1 > 1 is truthy
create long long ints mid = ( l + r ) / 2
if x [ mid ] - x [ k ] is less than or equal to d
set l to mid
else do
set r to mid
return l
read n and d
for i = 0 to n exclusive , read x [ i ]
for i = 0 to n exclusive
make long long int k = f ( i ) - i
add k * ( k - 1 ) / 2 to ans
print ans
x , t , a , b , da , db = imntegers
read x , t , a , b , da , db
create an integr l with l = b
create an integer flag = 0
if x = 0 set flag = 1
for i = 0 to t exclusive
set b = l
for j = 0 to t exclusive
if x = a + b or x = a or x = b
set flag = 1
break
set b = b - db
set a = a - da
if flag = 1
integers = l1 , l2 , l3 , l4 , p1
integers = s1 , s2 , s3 , s4 , p2
integers = r1 , r2 , r3 , r4 , p3 , p4
read l1 , s1 , r1 , p1
read l2 , s2 , r2 , p2
read l3 , s3 , r3 , p3
read l4 , s4 , r4 , p4
if l1 or s1 or r1 or l2 or r4 or s3 is true
if p1 is true
write yes to stdout
if l2 or s2 or r2 or r1 or s4 or l3 is true
if p2 is true
write yes to stdout
if l3 or r3 or s3 or l4 or r2 or s1 is true
if p3 is true
write yes to stdout
if l4 or r4 or s4 or l1 or r3 or s2 is true
if p4 is true
write yes to stdout
write NO to stdout
let q , p1 , p2 be long integers with p1 = - 1 , p2 = - 1
read q
for long integer i is equal to 2 , i * i < = q , increment i by 1
if not q modulo i
if p1 is equal to - 1
p1 is equal to i
q is equal to q / i
if q modulo i is equal to 0 and p2 is equal to - 1
p2 is equal to i
q is equal to q / i
stop
if p2 is not equal to - 1
if q is equal to 1
print 2 and newline
print 1 and newline and p1 * p2 and newline
else if p1 is not equal to - 1
print 2 and newline
print 1 \ n0 \ n and newline
pa is an array of int - int pairs with 10005 elements
maxn is a new integer variable = 0x3f3f3f3f
declare ints n , m , k and count
read m and n and keep looping
assign the value of 0 to the count and k
start for loop from i = 0 to n exclusive , read variables pa [ i ] . first and pa [ i ] . second from the input on each loop iteration
while k is not m
sort n elements of pa
if m is greater than pa [ 0 ] . first
if pa [ 0 ] . second ! = 0 , assign m to k
change m to m + pa [ 0 ] . second
pa [ 0 ] . first = maxn
increment count
else
stop the loop
if count ! = n
print " NO "
else
print " YES "
f , g = unsigned long long array of size 19 each
in function get_f
set f [ 1 ] and f [ 2 ] to 9
for i = 3 to 18 inclusive set f [ i ] to f [ i - 1 ] * 10
in function get_g
set g [ 0 ] to 1
for i = 1 to 18 inclusive set g [ i ] to g [ i - 1 ] * 10
in function cal taking a string n and returning an unsigned long long
len = int with len = length of n
if len is 1 then return n [ 0 ] - ' 0 '
first = int with first = n [ 0 ] - ' 0 '
last = int with last = n [ len - 1 ] - ' 0 '
ret = unsigned long long with ret = 0
for i = 1 to len increment ret by f [ i ]
for i = 1 to first increment ret by g [ len - 2 ]
s = string with s = n without the first char
p = unsigned long long with p = 1 + ( 1 if length of s is 0 else the parsed long long value of s ) )
if first is less or equal to last
increment ret by p
else
increment ret by p - 1
return ret
call get_f
call get_g
l , r = string
read l then r
ret = unsigned long long with ret = cal of r - cal of l
if l [ 0 ] is l [ length of l - 1 ] then increment ret
print ret
n = int
read n
total = int with total = 0
for i = 0 to n
x = int
read x
if x is 0 then increment total
if ( n is 1 and total is 0 ) or ( total is 1 and n is not 1 )
print " YES "
else
print " NO "
s = string
a , b = int
len = int
read s
n = int with n = length of s
w = int array of size n + 10
for i = 0 to length of s
if s [ i ] is ' ( '
increment a
else if s [ i ] is ' # '
increment len and set w [ len ] to 1
decrement a
else if s [ i ] is ' ) '
decrement a
if a is less than 0
print - 1
for i = length of s - 1 to 0 inclusive decrementing i
if s [ i ] is ' ) '
increment b
else if s [ i ] is ' ( '
decrement b
else if s [ i ] is ' # '
break
if b is less than 0
print - 1
increment w [ len ] by a
for i = 1 to len inclusive print w [ i ]
s is an array of characters with 110 elements
declare new integer n
create integer count1 with value 0
create new integer count0 = 0
read standard input to n
for i from 0 to n exclusive incrementing i
read s [ i ] from the user input
if s [ i ] = ' 1 ' , increment count1
if s [ i ] = ' 0 ' , increment count0 by one
if count0 = 0 or count0 = 1
if count1 is true , print 1 to the standard output
start for loop from i = 0 to count0 exclusive , print 0 to the standard output on each loop
print new line
else if count1 ! = 0
print 1
for i = 0 to count0 exclusive , print 0 to the standard output
print new line to the standard output
i , j , count = 0 , n , m , save = 0 , sav , last = long long integers
read n , m
a [ n ] = long long integers
for = 0 to less than n input array a
set count to 0
if array a [ i ] is greater than 0 then do the following
subtract m from a [ i ]
add one to count
if save is less than or equal to count then do the following
set sav to i
set save to count
output save + 1
declare integer array a size 100 by 100
declare integer sum = 0
declare integer array s size 100
declare integers i , j
declare integers n , v , m
read n , v
for i = 0 to n exclusive
read m
declare integer flag = 0
for j = 0 to m exclusive
read a [ i ] [ j ]
if a [ i ] [ j ] is less than v , let flag be 1
if flag is 1
let s [ sum ] be i + 1
increment sum
print sum and newline
if sum is not 0
for i = 0 to sum - 1 exclusive , print s [ i ] and " "
print s [ sum - 1 ] and newline
isPrime is a bool function with int argument n
in a for loop , change i from 2 to n exclusive incrementing i
if n % i is equal to 0 , return false
return true
create integer n
read variable n from the input
in a for loop , change i from 1 to 1001 exclusive incrementing i
if isPrime ( n * i + 1 ) is false
print i
let INF be const integer with INF = 0x3f3f3f3f
let n , m be integers
read n , m
let ans , ar be array of size 105 by 105 with ans = ar = { 0 }
for i = 1 to n inclusive
for j = 1 to m inclusive
read ans [ i ] [ j ]
set ar [ i ] [ j ] to ans [ i ] [ j ]
let mins , sum be integers with mins = INF and sum = 0
let temp be integer array of size 6 by 200 with temp = { 0 }
for i = 1 to n inclusive
set mins to INF
for j = 1 to m inclusive , set mins to min of mins , ans [ i ] [ j ]
set temp [ 1 ] [ i ] to mins
for j = 1 to m inclusive , set ans [ i ] [ j ] to ans [ i ] [ j ] - mins
for j = 1 to m inclusive
set mins to INF
for i = 1 to n inclusive , set mins to min of mins , ans [ i ] [ j ]
set temp [ 2 ] [ j ] to mins
for i = 1 to n inclusive , decrement ans [ i ] [ j ] by mins
for j = 1 to m inclusive
set mins to INF
for i = 1 to n inclusive , set mins to min of mins , ar [ i ] [ j ]
set temp [ 3 ] [ j ] to mins
for i = 1 to n inclusive , set ar [ i ] [ j ] to ar [ i ] [ j ] - mins
for i = 1 to n inclusive
set mins to iNF
for j = 1 to m inclusive , mins = min of mins , ar [ i ] [ j ]
temp [ 4 ] [ i ] = mins
for j = 1 to m inclusive , decrement ar [ i ] [ j ] by mins
let flag1 , flag2 be integers with flag1 = flag2 = 0
for i = 1 to n inclusive
for j = 1 to m inclusive
if ans [ i ] [ j ] ! = 0
set flag1 to 1
break
for i = 1 to n inclusive
for j = 1 to m inclusive
if ar [ i ] [ j ] ! = 0
set flag2 to 0
break
if flag1 = = 1 and flag2 = = 1
print - 1
else if flag1 = = 0 and flag2 = = 0
sum1 = sum2 = integer = 0
for i = 1 to n inclusive
increment sum1 by temp [ 1 ] [ i ]
increment sum2 by temp [ 4 ] [ i ]
for j = 1 to m inclusive
increment sum1 by temp [ 2 ] [ j ]
increment sum2 by temp [ 3 ] [ j ]
if sum1 > sum2
print sum2
for i = 1 to n inclusive
for j = 1 to temp [ 4 ] [ i ] , print row , i
for j = 1 to m inclusive
for i = 1 to temp [ 3 ] [ j ] inclusive , print col , j
else
print sum1
for i = 1 to n inclusive
for j = 1 to temp [ 1 ] [ i ] , print " row " , i
for j = 1 to m inclusive
for i = 1 to temp [ 2 ] [ j ] inclusive , print " col " , j
else if flag1 = = 1
let sum2 be integer with sum2 = 0
for i = 1 to n inclusive , increment sum2 by temp [ 4 ] [ i ]
for j = 1 to n inclusive , increment sum2 by temp [ 3 ] [ j ]
print sum2
for i = 1 to n inclusive
for j = 1 to temp [ 4 ] [ i ] inclusive , print " row " , i
for j = 1 to m inclusive
for i = 1 to temp [ 3 ] [ j ] inclusive , print " col " , j
else if flag2 = = 1
sum1 = int = 0
for i = 1 to n inclusive , increment sum1 by temp [ 4 ] [ i ]
for j = 1 to n inclusive , increment sum1 by temp [ 3 ] [ j ]
print sum1
for i = 1 to n inclusive
for j = 1 to temp [ 1 ] [ i ] inclusive , print " row " , i
for j = 1 to m inclusive
for i = 1 to temp [ 2 ] [ j ] inclusive , print " col " , j
create string s
read s
for i = 0 to ( length of s ) - 1 exclusive
create integer i2 = i + 1
if s [ i ] = A and s [ i2 ] = B
for j = 0 to length of s - 1 exclusive
let j2 be a int with j2 = j + 1
if s [ j ] = B and s [ j2 ] = A
if i is not equal to j and i is not equal to j2 and i2 ! = j and i2 is not equal to j2
declare NO with no arguments , returning void
print " No "
exit program with code 0
declare YES with no arguments , returning void
print " Yes "
exit program with code 0
declare integer n
read n
declare s as string
read s
for i = 0 to n - 1 exclusive
if s [ i ] is not ' ? ' and s [ i ] is s [ i + 1 ] , run NO
for i = 0 to n exclusive
if s [ i ] is ' ? '
if i is 0 or i is n - 1 , run YES
if s [ i + 1 ] is ' ? ' , run YES
if s [ i - 1 ] is s [ i + 1 ] , run YES
run NO
N , M , K , L , res are long longs
read N , M , K , L
if M is greater than N or L + K is greater than N
set res to - 1
else
if not ( ( L + K ) mod M )
set res to ( L + K ) / M
else
set res to ( L + K ) / M + 1
if res * M is greater than N , set res to - 1
print res
let n be a integer
read n
if n modulo 2 equals 0
the integer value of x = n / 2
print x and newline
for i = 1 to x exclusive , print 2
print 2 and newline
the integer value of x = n / 2
print x and newline
for i = 1 to x exclusive , print 2
print 3 and newline
create int array d of size 30
create integer set ma
make ints a , b , l , and r
read a , b , l , and r
if a is equal to 3 and b is equal to 1 and l is equal to 4 and r is equal to 10
print 4
make string s
for i = 1 to a , add i - 1 + ' a ' to s
let int x = s . size ( ) - 1
for i = 1 to b , set s to s + s [ x ]
set x to s . size ( ) - 1
for i = 1 to a
set d [ s [ x ] - ' a ' to 1
decrease x by 1
for i = 1 to a
for j = 0 to 26 exclusive
if d [ j ] is equal to 0
set s to s + j + ' a '
set d [ j ] to 1
break loop
set x to s . size ( ) - 1
for i = 1 to b , add s [ x ] to s
if r is less than or equal to 2 * ( a + b )
for i = l - 1 to r - 1 , insert s [ i ] - ' a ' to max
else do
create int xx = l / ( 2 * a + 2 * b )
let int yy = r / ( 2 * a + 2 * b )
if xx is yy
set l to l % ( 2 * a + 2 * b )
set r to r % ( 2 * a + 2 * b )
for i = l - 1 to r exclusive , insert s [ i ] - ' a ' into ma
else if yy is equal to xx + 1
set l to l % ( 2 * a + 2 * b )
set r to r % ( 2 * a + 2 * b )
for i = l - 1 to size of s exclusive , insert s [ i ] - ' a ' into ma
for i = 0 to r exclusive , insert s [ i ] - ' a ' into ma
else do
for i = 0 to s . size ( ) exclusive , insert s [ i ] - ' a ' into ma
print ma . size ( )
n , m = int
check_1 , check_2 = int with check_1 = 0 and check_2 = 0
s = char array of size 200001
t = char array of size 200001
ch = char array of size 2 with value " * "
read n then m
read s then t
if s contains ch
if m > = n - 1
iterate i while s [ i ] is not ' * '
if s [ i ] is t [ i ]
continue
else
print " NO "
increment check_1
for i = n - 1 , j = m - 1 while s [ i ] is not ' * ' decrementing both i and j
if s [ i ] is t [ i ]
continue
else
print " NO "
increment check_2
if check_1 is m - check_2
print " YES "
for i = check_1 to m - check_2
if t [ i ] is a letter
continue
else
print " NO "
print " YES "
else
print " NO "
else if s is t
print " YES "
else
print " NO "
node = long long
N = const long long with N = 150005
vp = vector of long long
vis = long long array of size N
mp = map from long long to long long
in the function dfs that takes long long n
increment node
mp [ vp [ n ] . size ( ) ] = n
vis [ n ] = 1
for i = 0 to vp [ n ] . size ( ) exclusive
if not vis [ vp [ n ] [ i ] ] , dfs on vp [ n ] [ i ]
n , m = long long
read n , m
a , b = long long
for i = 0 to m exclusive
read a , b
append b in vp [ a ]
append a in vp [ b ]
for i = 1 to n
if not vis [ i ]
node = 0
dfs on i
if mp . size ( ) is 1 and vp [ i ] . size ( ) is node - 1
clear mp
continue next iteration
else
print NO
new line
print YES
new line
create new integers n and m
declare new string variables a and b
read n , m , a and b from the input
if n is greater than m
for integer i = 0 to n exclusive
if a [ i ] = ' * '
erase 1 element at the position i from a
stop the loop
if a is equal to b
print " YES " to stdout
else
print " NO " to standard output
if n = m
in a for loop , change i from 0 to n exclusive incrementing i
if a [ i ] ! = ' * '
if a [ i ] ! = b [ i ] , return puts ( " NO " ) , 0
print " YES "
create integer Now = 0
while a [ Now ] is not ' * '
if a [ Now ] ! = b [ Now ] , return puts ( " NO " ) , 0
increment Now by one
assign the new value = m - 1 to Now
now is a new integer = n - 1
while a [ now ] ! = ' * '
if a [ now ] ! = b [ Now ] , return puts ( " NO " ) , 0
decrement now by one
decrement Now
print " YES " to stdout
create constant integer M = 50 + 5
into the function lead0 that takes string s and returns a boolean
create integer slen = length of s
if slen > 1
if s [ 0 ] = 0 then return true
return false
into the function ston that takes string s as argument and returns a long long integer
create an integer slen with slen = s . length ( )
create a long long integer num with num = 0
for i = 0 to slen exclusive
set num = num * 10 + s [ i ] - ' 0 '
if num > 1000000
set num = 1000000 + 1
break
return num
s = string
read s
creare an integer slen with slen = length of s
create a long long integer ans with ans = - 1
for i = 0 to slen - 2 exclusive
for j = i + 1 to slen - 1 exclusive
t1 , t2 , t3 = string
set t1 = t2 = t3 = " "
for k = 0 to i inclusive then set t1 = t1 + s [ k ]
for k = i + 1 to j inclusive set t2 = t2 + s [ k ]
for k = j + 1 to slen exclusive set t3 = t3 + s [ k ]
create boolean lead01 = lead0 ( t1 )
create boolean lead02 = lead0 ( t2 )
create boolean lead03 = lead0 ( t3 )
create a long long integer num1 = ston ( t1 )
create a long long integer num2 = ston ( t2 )
create a long long integer num3 = ston ( t3 )
if lead01 = false and lead02 = false and lead03 = false
if num1 < = 1000000 and num2 < = 1000000 and num3 < = 1000000
if num1 + num2 + num3 > ans then set ans = num1 + num2 + num3
print ans
MAXN = const int with MAXN = 200
bad = string , bool map
change = bool array of size MAXN
n = int
read n
for i = 0 to n
s = string
read s
for t = 0 to length of s
if s [ t ] > = ' A ' and s [ t ] < = ' Z ' set s [ t ] to ' a ' + s [ t ] - ' A '
set bad [ s ] to true
u = string
lucky = char
read u then lucky
for i = 0 to length of u
cur = string
for t = i to length of u
if bad [ cur ]
for j = i to t inclusive set change [ j ] to true
for i = 0 to length of u
if change [ i ]
if u [ i ] is lucky
if lucky is ' a '
set u [ i ] to ' b '
else
set u [ i ] to ' a '
else if u [ i ] - ' A ' + ' a ' is lucky
if lucky is ' a '
set u [ i ] to ' B '
else
set u [ i ] to ' A '
else if u [ i ] > = ' A ' and u [ i ] < = ' Z '
set u [ i ] to lucky - ' a ' + ' A '
else
set u [ i ] to lucky
n = int
read n
if n = 1
print - 1
else
print n and space and n
create int n , x1 , y1 , x2 and y2
read n , x1 , y1 , x2 and y2
set a to 0
set b to 0
if x1 equal to 0 and y1 > = 0
assign y1 to a
else
set a to a + n
if y1 = n and x1 greater than 0
a = a + x1
other
a = a + n
if x1 equal to n and y1 > 0
set a = a + n - y1
otherwise
a = a + n
if y1 equal to 0 and x1 > 0 , a = a + n - x1
if x2 equal to 0 and y2 > = 0
b = y2
else
assign b + n to b
if y = n and x2 > = 0
b = b + x2
else
set b = b + n
if x equal to n and y2 > = 0
b = b + n - y2
otherwise
b = b + n
if y equal to 0 and x2 > = 0 , assign b + n - x2 to b
set l1 to abs of a - b
assign 4 * n - l1 to l2
print minimum between l1 and l2
q = integer with q = 0
l , r , s , p = integer array of size 5
for i = 1 to 4 , read l , r , s , p
if p [ 1 ] is 1
if p [ 2 ] is 1
if p [ 3 ] is 1
if p [ 4 ] is 1
if q is 1
else
n , i , j , k , l = long long
st = string
read st
l = size of st
t = long long with t = 0
for i = 0 to l exclusive
if ( st [ i ] is 0 )
st [ i ] = a
increment t
break loop
if ( t is 0 )
for i = 1 to l exclusive , print st [ i ]
else
for i = 0 to l exclusive
if ( st [ i ] is a )
else
print st [ i ]
print new line
create new const integers N = 2e5 + 10 and INF = 1e9 + 7
function in that returns integer
declare integer variable ret
read ret from the user input
return ret
declare new long longs n and MAXall and arrays MAX and sz with size N
read standard input to n
start for loop from i = 0 to n exclusive
put the result of in ( ) into sz [ i ]
create integer v with value 0
for j = 0 to sz [ i ] exclusive , put the max of v and in ( ) to v
set MAX [ i ] to v
if v is greater than MAXall , change the value of MAXall to v
declare new long long variable ans = 0
start for loop from i = 0 to n exclusive , adding ( MAXall - MAX [ i ] ) * sz [ i ] to ans on each iteration
print ans and ' \ n '
let n be an integer
input n
if 1 equals n
print - 1
else
print n , " " , n
let MAX be a constant integer equal to 2e5
a [ MAX + 9 ] be a pair of pair of long long values
read n
for integer i = 0 to n exclusive
read k , a0 , x , y , m and t equals 0
for integer j = 0 to k exclusive
if cnt less than or equal to MAX , a [ cnt + + ] = { { t , a0 } , i }
tmp equals ( a0 * x + y ) modulo m
if tmp is less than a0 and j is not equal to k - 1 , increase t by 1
a0 equals temp
ans equals maximum of ans , t
print ans and new line
if cnt is less than or equal to MAX
sort from a to a + cnt
hor = array of 100 int
ver = array of 100 int
hasil = vector of int
fill hor with 0
fill ver with 0
n = int
read n
for i = 1 to pow ( n , 2 ) inclusive
h , v = int
read h , v
if hor [ h ] is 0 and ver [ v ] is 0
hor [ h ] = 1
ver [ v ] = 1
add i to end of hasil
for i = 0 to size of hasil - 1 exclusive print hasil [ i ] and space
print hasil [ size of hasil - 1 ]
create string s and t
create int l1 and l2
create integer p [ 10001 ] [ 26 ]
while read s and t
l1 = size of s
set l2 to size of t
set p to all 0
for i = 0 to 26 exclusive , assign - 1 to p [ l1 ] [ i ]
for j = l1 to 1 inclusive
for i = 0 to 26 exclusive
if s [ j ] = i + a
set p [ j - 1 ] [ i ] to j
else
p [ j - 1 ] [ i ] = p [ j ] [ i ]
set ans to 1 and l to - 2
for i = 0 to l2 exclusive
if l = - 2
if s [ 0 ] = t [ i ]
assign 0 to l
else
set l to p [ 0 ] [ t [ i ] - a ]
if l equal to - 1
set ans to - 1
break
else
set l = p [ l ] [ t [ i ] - a ]
if l equal to - 1
increment ans
set l to - 2
decrement i
print ans
declare long long int variables h1 , h2 , u1 and u2
read h1 , h2 , u1 and u2 from the input
declare new integer called n
read user input to n
declare int arrays a , b and c with n + 5 elements
read n new elements into a , b and c in a loop
declare integer variable ans with value 0
start for loop from i = 0 to n exclusive
create new long long integers v1 = a [ i ] * h1 + b [ i ] * h2 + c [ i ]
new long long integer v2 = a [ i ] * u1 + b [ i ] * u2 + c [ i ]
if ( v1 > 0 and v2 < 0 ) or ( v1 < 0 and v2 > 0 ) , increment ans
print ans to the standard output
maxn = const int with maxn = 3 * ( 1e5 ) + 100
maxnn = const int with maxnn = ( ( 1 . 5 ) * ( 1e7 ) + 100 ) as int
n = int
a = int array of size maxn
cnt = int array of size maxnn
pri = int array of size maxnn
ips = bool array of size maxnn
p = int with p = 0
in function init taking int n
for i = 2 to n inclusive
if isp [ i ] is 0 increment p then set pri [ p ] to i
iterate j from 1 while j < = p and i * pri [ j ] < = n
set isp [ i * pri [ j ] ] tp 1
if i is a multiple of pri [ j ] break
in function ispri taking int n and returning bool
if n is 1 return 0
for i = 2 to n / i inclusive
if n is a multiple of i return 0
return 1
call init of maxnn
loop while reading n
set all values of cnt to 0
gcdd = int with gcdd = a [ 0 ]
for i = 1 to n set gcdd to __gcd of gcdd , a [ i ]
maxx = int with maxx = - 1
for i = 0 to n
set a [ i ] to a [ i ] / gcdd
iterate j from 1 while j < = p and pri [ j ] * pri [ j ] < = a [ i ]
if a [ i ] is a multiple of pri [ j ] increment cnt [ pri [ j ] ]
set maxx to max of maxx , cnt [ pri [ j ] ]
loop while a [ i ] is a multiple of pri [ j ] set a [ i ] to a [ i ] / pri [ j ]
if a [ i ] > 1 increment cnt [ a [ i ] ]
set maxx to max of maxx , cnt [ a [ i ] ]
if maxx is 0
print - 1
else
print n - maxx
maxn , inf are constant integers with maxn = 3e5 + 1 , inf = 1 . 5e7 + 10
n , gcd , t are integers with t = 0
a = integer array of size maxn , b and prime are integer arrays both of size inf
in function GCD with parameters integers m , n and return integer
if m is less than n , call swap with m , n
if n equals 0
return m
else
return call GCD with n , m modulo n
input n
for i = 1 to n inclusive
input a [ i ]
set gcd to call GCD with a [ i ] , gcd
for i = 1 to n inclusive , increment b [ a [ i ] / gcd ]
for i = 2 to inf - 1 inclusive
if prime [ i ] is false
h = integer = 0
for j = i to inf exclusive with increment j + i , set prime [ j ] to 1
set to to call max with t , h
output n - t if t , otherwise output - 1
create string str
read input to str
if there is no " AB " or " BA " in the str
print " NO "
declare size_t pos = index of " AB " in str
if there is substring " BA " after pos + 2 in str
print " YES "
declare size_t posn = index of " BA " in str
if there is substring " AB " after posn + 2 in str
print " YES "
print " NO "
MAX , n , m , M , var = long long , max , check , total = 0
read n
for i = 0 to n exclusive
read m
for j = 0 to m exclusive
read var
if var > max max = var
if check is 0
MAX = max
M = m
max = 0
increment check
else
if MAX > max
add abs ( MAX - max ) * m ) to total
max = 0
add m to M
else
add abs ( MAX - max ) * M ) to total
MAX = max
max = 0
add m to M
print total
n = integer
read n
a = b = integer array of size n
for i = 0 to n exclusive , then read a [ i ] , b [ i ]
c = integer = n
for i = 0 to n exclusive
for j = 0 to n exclusive
if a [ i ] is b [ j ] and i is not j
decrease c by 1
exit the for loop
print c
create an const integer MAXN with MAXN = 100000 + 10
a = array of integer of size MAXN
string = s
n = integer
read n , s
create a boolean flag with flag = false
for i = 0 to n exclusive
increment a [ s [ i ] - ' a ' ]
if a [ s [ i ] - ' a ' ] > 1 or n = 1 then set flag = true
if flag is true then print YES else print NO
create constant integer variable with name N = 150
declare integer arrays x , y and info with size N , and a variable n
integer function color_to_id with char argument ch
if ch = ' R ' , return 1
if ch is equal to ' G ' , return 2
if ch = ' B ' , return 3
if ch = ' Y ' , return 4
if ch is equal to ' W ' , return 5
function count_one with int argument x that returns int
create integer variable called cnt with value 0
while x
change cnt to the sum of cnt and x & 1
change x to x > > 1
return cnt
bool function check with int argument sta
for i = 0 to n exclusive incrementing i
change info [ i ] to 0
set info [ i ] to info [ i ] | ( 1 < < ( x [ i ] - 1 ) ) & sta
change the value of info [ i ] to info [ i ] | ( 1 < < ( y [ i ] - 1 + 5 ) ) & sta
in a for loop , change j from 0 to i exclusive
return false if info [ i ] = info [ j ] and ( x [ i ] ! = x [ j ] or y [ i ] ! = y [ j ] )
return true
declare string variable with name str
read n and loop further
for i = 0 to n exclusive incrementing i
read input to str
change the value of x [ i ] to color_to_id ( str [ 0 ] )
set y [ i ] to str [ 1 ] - ' 0 '
define integer ans with value 10
for integer i = 0 to 1 < < 10 exclusive
declare new integer variable n_one with value = result of count_one ( i )
if n_one > = ans , go to the start of the loop
if check ( i ) returned true , set the value of ans to n_one
print ans
let N a constant int with value 2e6 + 10
let n , a , m and d long longs
let t a long long array of length N
read n , m , a , and d
let x and ma long longs with x = d / a + 1 and ma = 0
for i from 1 to m , read t [ i ] and set ma to max of ma and t [ i ]
set t [ m + 1 ] to max of n * a + d + d and ma + d + d
let ans and now long longs with ans = 1 and now = min ( t [ 1 ] , a ) + d
let cur long long with value now / a + 1
for i from 1 to m + 1
if t [ i ] > now
if cur > n
for j from i to m + 1
if t [ j ] > now , increment ans and set now to t [ j ] + d
end loop
if t [ i ] at most cur * a
increment ans
set now to t [ i ] + d
set cur to now / a + 1
otherwise
let tmp a long long with value min ( t [ i ] / a , n ) - cur
add tmp / x + 1 to ans
add ( tmp / x + 1 ) * x to cur
set now to cur * a - a + d mod a
if t [ i ] > now
increment ans
set now to t [ i ] + d
set cur to now / a + 1
print ans - 1
declare Mul with long longs a , n , m as arguments , returning long long
declare r = 0 as long long
while n is true
if n bitwise and 0x1 , let r be ( r + a ) % m
let a be ( a bitshift left 1 ) % m
let n be n bitshift right 1
return r from function
declare Pow with long longs a , n , m as arguments , returning long long
declare r = 1 as long long
while n is true
if ( n bitwise and 0x1 ) let r = result of run Mul with r , a , m as arguments
let a = Mul ( a , a , m )
let n be bitshift right 1
return r from function
declare long long vector sz
declare long long vector id
declare create with long long v as argument , returning void
let id [ v ] be v
let sz [ v ] be 1
declare find with long long v as argument , returning long long
declare i as long long
for i = v to i is not id [ i ] , setting i to id [ i ] , let id [ i ] be id [ id [ i ] ]
return i from function
declare unite with long longs v , w as arguments , returning void
declare i , j as long longs
for i = v to i is not id [ i ] , setting i to id [ i ] , let id [ i ] be id [ id [ i ] ]
for j = 2 to j is not id [ j ] , settiing j to id [ j ] , let id [ j ] be id [ id [ j ] ]
if i is j , return from function
if sz [ i ] is less than sz [ j ]
let id [ i ] be j
increment sz [ j ] by sz [ i ]
else
let id [ j ] be i
increment sz [ i ] by sz [ j ]
declare n , m as long longs
read n and m
resize id to size n + m
resize sz to size n + m
for i = 0 to n + m exclusive , run create with i as argument
for i = 0 to n exclusive
declare long long k
read k
for j = 0 to k exclusive
declare a as long long
read a
decrement a
run unite with i + m , a as arguments
declare cnt = 0 as long long
for i = 0 to m exclusive
if sz [ run find ( i ) ] is not 1
for j = m to m + n exclusive
if ( run find ( j ) is not run find ( i ) )
increment cnt
run united with j , i as arguments
print cnt and newline
print n and newline
create integer n
read n
set n to n = = 0 ? 0 : 1 + ( n - 1 ) % 4
create array x containing { 1 , 8 , 4 , 2 , 6 }
print x [ n ]
in the function gcd that takes long long int a , b and returns long long int
tmp = long long int
while ( b is not 0 )
tmp = a modulo b
a = b
b = tmp
return a
in the function lcm that takes long long int a , b and returns long long int
return ( a * b ) / gcd ( a , b )
n = long long int
i , j , k , mx = long long int with mx = 0
read n
for i = n - 5 to n
for j = i to i > 0 and j < = n
for k = j to j > 0 and k < = n , mx = max ( mx , lcm ( i , lcm ( j , k ) ) )
print mx
declare integers s , n , x , y , k = 0
declare multimap from integer to integer v
declare multimap from integer to integer iterator it
read s and n
for i = 0 to n exclusive
read x and y
insert ( make pair from ( x , y ) ) into v
for it = beginning of v to it is not end of v , incrementing it
if s is greater than first element of it
let s be s + second element of it
else
let k be 1
end loop
if k is 0
print " YES " and newline
else
print " NO " and newline
declare hui with integers a , b as arguments , returning boolean
if a / 10 is b % 10 and a % 10 is b / 10
return true from function
else
return false from function
declare string s
declare integers h = 0 , h1 , m = 0 , f = 0
read s
let h be ( s [ 0 ] - ' 0 ' ) * 10 + s [ 1 ] - ' 0 '
let h1 be 0
let m be ( s [ 3 ] - ' 0 ' ) * 10 + s [ 4 ] - ' 0 '
if result of run hui with h , m as arguments is true , increment m by 1
for h is less than or equal to 23 , incrementing h
for m is less than or equal to 59 , incrementing m
if result of run hui ( h , m ) is true
if h is 0 and m is 0
print h , h , " : " , m , m , newline
else if h is less than 10 and m is greater than or equal to 10
print 0 , h , " : " , m , newline
else if h is greater than or equal to 10 and m is less than 10
print h , ' : ' , 0 , m , newline
else
print h , " : " , m , newline
let f be 1
end loop
let f be 1 , end loop
if h is 23 , let h be - 1
increment h1
if h1 is greater than 0 , let m be 0
in function next that returns an unsigned long long and takes argument x = unsigned long long
if x is less than 10 then if x is less than or equal to 4 then return 4 else if x is less than or equal to 7 then return 7 else return 44
a , b , y = unsigned long longs with a having value of x mod 10 and b having value of ( x / 10 ) mod 10
if a is less than or equal to 7
set y to ( the return of function next with argument x / 10 ) * 10
else
set y to ( the return of function next with argument x / 10 + 1 ) * 10
if y + 4 is greater than or equal to x then return y + 4
return y + 7
l , r , m , suma = unsigned long longs with suma having value of 0
read l and r
while l is less than or equal to r
set m to the return of function next with argument l
if m is less than r
increase suma by ( m - 1 + 1 ) * m
set l to m + 1
else
increase suma by ( r - l + 1 ) * m
set l to r + 1
print suma
let numberOfStudents be a integer
let studentsRate be a integer
let result be a integer with result = 1
read numberOfStudents
arr = array of integers of length 2000
for x = 0 to numberOfStudents exclusive
read studentsRate
arr [ x ] is equal to studentsRate
for x = 0 to numberOfStudents exclusive
result is equal to 1
for y = 0 to numberOfStudents exclusive
if arr [ x ] is less than arr [ y ] , increment result by 1
if x is equal to numberOfStudents - 1
print result and newline
print result and space
hit = map from int to int
n , a , temp , flag = integers with a = array of size 100005 , flag = 0
read n
for i = 0 to n exclusive
read temp
increment hit [ temp ]
if ( temp is 50 )
if ( hit [ 25 ] > = 1 )
decrement hit [ 25 ]
continue next iteration
flag = 1
else if ( temp is 100 )
if ( hit [ 50 ] > = 1 and hit [ 25 ] > = 1 )
decrement hit [ 50 ]
decrement hit [ 25 ]
continue next iteration
else if ( hit [ 25 ] > = 3 )
hit [ 25 ] = hit [ 25 ] - 3
continue next iteration
flag = 1
if ( flag is 0 )
else
create long long n
create long long ans
while n is being read
if n equals 1
assign 1 to ans
else if n equals 2
assign 2 to ans
else if n equals 3
assign 6 to ans
else if n bitwise and 1
assign n * ( n - 1 ) * ( n - 2 ) to ans
else
if n mod 3 is not equal to 0
assign n * ( n - 1 ) * ( n - 3 ) to ans
else
assign ( n - 1 ) * ( n - 2 ) * ( n - 3 )
print ans
array a of size 10 , day1 , day2 = string
set a [ 1 ] to monday
set a [ 2 ] to tuesday
set a [ 3 ] to wednesday
set a [ 4 ] to thursday
set a [ 5 ] to friday
set a [ 6 ] to saturday
set a [ 7 ] to sunday
read day1 , day2
integer as num1 = 0 , num2 = 0 , i = 0 , j = 0
for = 1 to less than or equal to 7 do the following
if day1 is a [ i ] then do the following num1 = i
for = 1 to less than or equal to 7 do the following
if day2 is a [ i ] then num2 = i
if num2 is less than num1 then add 7 to num2
integer as sum = num2 - num1
if sum is 0 , 2 or 3 then do the following
else
declare long long variables x and y
exgcd is a long long function with long long arguments a and b
if b = 0
assign 1 to x
assign 0 to y
return a
declare long long d = exgcd ( b , a % b )
declare long long variable t = x
change x to y
set y to t - a / b * y
return d
create long longs m , h1 , a1 , x1 , y1 , h2 , a2 , x2 and y2
declare long longs p1 , p2 , q1 and q2
loop , reading m , h1 , a1 , x1 , y1 , h2 , a2 , x2 and y2 from the input
change p1 , p2 , q1 and q2 to 0
change i from 1 to 2 * m inclusive in a loop
set h1 to ( h1 * x1 + y1 ) % m
if h1 is equal to a1
if p1 = 0
assign i to p1
else if q1 is equal to 0
assign i - p1 to q1
break the loop
for i = 1 to 2 * m inclusive
set h2 to ( h2 * x2 + y2 ) % m
if h2 = a2
if p2 = 0
set p2 to i
else if q2 = 0
assign i - p2 to q2
stop the loop
declare long long d = exgcd ( q1 , - q2 )
create long long c = p2 - p1
if d = 0
print " - 1 " to stdout
go to the start of the loop
if c % d ! = 0
print " - 1 " to stdout
skip the rest of the loop
if p1 = 0 or p2 is equal to 0
print " - 1 " to stdout
skip the rest of the loop
if q2 = 0 and q1 = 0 and p1 ! = p2
print " - 1 " to stdout
skip the rest of the loop
if ( q2 = 0 and p2 - p1 < 0 ) is true or ( q1 = 0 and p1 - p2 < 0 ) is true
print " - 1 " to standard output
skip the rest of the loop
declare long long variable k = c / d
multiply x by k
multiply y by k
if d is less than 0 , invert the sign of d
if x < 0 or y < 0
start infinite loop
add q2 / d to x
add q1 / d to y
if x > = 0 and y > = 0 , stop the loop
if x > 0 and y > 0
start infinite loop
subtract q2 / d from x
decrease y by q1 / d
if x < 0 or y < 0
add q2 / d to x
add q1 / d to y
break
create long long ans = x * q1 + p1
print ans
create character c
create integers n , i , t , e and set to 0
while read c do
if c is equal to ' n ' then
increment n
else if c is equal to ' i ' then
increment i
else if c is equal to ' t ' then
increment t
else if c is equal to ' e ' then
increment e
create integer cont with cont = 0
for integer k = i to 1 with decrement k
if n is greater than or equal to 2 * k + 1 and t greater than or equal to k and e greater then or equal to 3 * k then increment cont
print cont
declare cmp with integers a , b as arguments , returning boolean
return a is greater than b
create constant integer MAXN with MAXN = 1e5
create integer array a with size MAXN
create map mp from integer to integer
create integers n , k
read n read k
for i = 0 to n exclusive
read a [ i ]
increment mp [ a [ i ] ]
sort elements from a to a + n using cmp to compare
create integer cnt with cnt = 0
for i = 0 to n exclusive
if mp [ a [ i ] ] is 0
break current loop iteration
else
if a [ i ] % k is 0
create integer cur with cur = a [ i ] / k
increment cnt by maximum of ( mp [ a [ i ] ] and mp [ cur ] )
set mp [ a [ i ] ] to mp [ cur ] to 0
else
increment cnt by mp [ a [ i ] ]
set mp [ a [ i ] ] to 0
print cnt print newline
N = const integer with N = 1e4 + 5
a = integer array of size N
n , m , k = long long
read n , m , k
mi = integer with mi = 1e8
for i = 0 to n exclusive
read a [ i ]
if i modulo 2 is 0 , mi = min of mi and a [ i ]
if n modulo 2 is 0 , return print 0 , new line , 0
x = long long with x = m / ( ( n + 1 ) / 2
x = x * k
print min ( x , 1ll * mi )
n , m = long longs
read n and m
let a1 and b1 be long longs with value 1
let x and y be long longs with value 7
while x is less than n
x is 7 times itself
increment a1
while y is less than m
y is 7 times itself
increment b1
let ans be long long with value 0
if a1 plus b1 is greater than 7
print 0
else
for i = 0 to n exclusive
fir j = 0 to m exclusive
let long long ma be 0
temp ( 7 , 0 ) is long long vector
let long long a equal i
let long long b equal j
let long long z equal a1
while z is z less than 1
increment temp element with a mod 7 by 1
set ma to max of ma and temp element with a mod 7
a equals a divided by 7
z equals b1
while z is z less than 1
increment temp element b mod 7 by 1
set ma to max of ma and temp element with b mod 7
b equals b divided by 7
if ma = 1 increment ans
print ans
create integer n
read n
if n modulo 2 is truthy
print n / 2
else
divide n by 2
create int d = 0
while ( 1 < < d ) is less than or equal to n , increment d
subtract d by 1
set n to n - ( 1 < < d )
show n
create integers n , i , rez , sum , sum1 , integer array DP of sizes 2 , 2 , and 205 , integer array A of size 100005 , and create integers cr , j
in function f that takes in arguments integer address a , integer b , and return f
a is assigned the sum of a and b
if a is greater than or equal to 998244353 , subtract 998244353 from a
input n
for i = 1 to n inclusive , input A [ i ]
if A [ 1 ] doesn ' t equal - 1
Dp [ 1 ] [ 1 ] [ A [ 1 ] ] is set to 1
else
for i = 1 to 200 inclusive , set Dp [ 1 ] [ 1 ] [ i ] to 1
assign 1 to cr
for i = 2 to n inclusive
assign 1 - cr to cr
if A [ i ] doesn ' t equal - 1
for j = 1 to 200 inclusive
if a [ i ] is equal to j
call function f with arguments Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ]
call function f with arguments Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 1 ] [ j ]
if A [ i ] is greater than j
call function f with arguments Dp [ cr ] [ 1 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ]
call function f with arguments Dp [ cr ] [ 1 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 1 ] [ j ]
set Dp [ 1 - cr ] [ 1 ] [ j ] and Dp [ 1 - cr ] [ 0 ] [ j ] to 0
else
assign 0 to sum
for j = 1 to 200 inclusive , call function f with arguments sum , Dp [ 1 - cr ] [ 0 ] [ j ]
assign 0 to sum1
for j = 1 to 200 inclusive
call function f with arguments Dp [ cr ] [ 0 ] [ j ] , sum
call function f with arguments Dp [ cr ] [ 0 ] [ j ] , Dp [ 1 - cr ] [ 1 ] [ j ]
call function f with arguments sum , 998244353 - Dp [ 1 - cr ] [ 0 ] [ j ]
call function f with arguments Dp [ cr ] [ 1 ] [ j ] , sum1
call function f with arguments sum1 , Dp [ 1 - cr ] [ 1 ] [ j ]
call function f with arguments sum1 , Dp [ 1 - cr ] [ 0 ] [ j ]
set Dp [ 1 - cr ] [ 0 ] [ j ] and Dp [ 1 - cr ] [ 1 ] [ j ] to 0
for i = 1 to 200 inclusive , call function f with arguments rez , Dp [ cr ] [ 0 ] [ i ]
create strings a and b
while cin > > a is truthy
create bool f = false
if the length of a is less than 3
print " No "
continue to the next loop iteration
for i = 0 to the length of a
set b to the value of a . substr ( i , 3 )
if b [ 0 ] is not equal to ' . ' and b [ 1 ] is not equal to ' . ' and b [ 2 ] is not equal to ' . '
if b [ 0 ] is not equal to b [ 1 ] and b [ 1 ] is not equal to b [ 2 ] and b [ 2 ] is not equal to b [ 0 ]
set f to true
break loop
make b an empty string
if f is truthy
print " Yes "
else
print " No "
create integers n , k and x
declare integer variable ans = 0 and an integer array a with size 105
s is a new set of unique integers
t is a new set of unique integers
read input to n and k
for i = 0 to n exclusive , read input to a [ i ]
for i = 0 to n exclusive
set x to a [ i ]
if there is no x in s
increment ans by one
insert x into s
if length of s = k + 1
change t to s
remove x from t
loop j from i + 1 to n exclusive
if length of t = 1 , break the loop
remove a [ j ] from t
remove first element of t from s
print ans
len = integer
s = string
read s
len = length of s
for i = 0 to len - 2 exclusive
vc = vector of character
append s [ i ] in vc
append s [ i + 1 ] in vc
append s [ i + 2 ] in vc
sort vc . begin ( ) and vc . end ( )
if vc [ 0 ] is A and vc [ 1 ] is B and vc [ 2 ] is C
print Yes
print No
declare new constant long long N with value 1005
new long long variables n and p
create arrays of long longs indeg , outdeg , nxt and diam with size N
read input to n and p
in a for loop , change i from 1 to p inclusive incrementing i
create new long longs u , v and w
read u , v and w from the user input
increment indeg [ v ]
increment outdeg [ u ] by one
change nxt [ u ] to v
assign w to diam [ u ]
declare new long long called ans with value 0
start for loop from i = 1 to n inclusive , adding 1 if ( outdeg [ i ] > 0 and indeg [ i ] = 0 ) to ans on each loop
print ans and ' \ n ' to the standard output
for i from 1 to n inclusive incrementing i
if outdeg [ i ] > 0 and indeg [ i ] = 0
declare long long idx with value i and val = 1e9
while outdeg [ idx ] is not 0
change val to min of val and diam [ idx ]
change the value of idx to nxt [ idx ]
print i , " " , idx , " " , val and ' \ n '
declare ints n and k , and int arrays a , b and mark with 1010 elements ; mark is filled with 0
read from the input to n
read n values from the input to a [ i ] and b [ i ] , starting from the index 1
in a for loop , change i from 1 to n inclusive
for j from 1 to n inclusive
if i ! = j
if a [ i ] is equal to b [ j ] , assign 1 to mark [ i ]
ans is a new integer variable = 0
in a for loop , change i from 1 to n inclusive
if mark [ i ] is false , increment ans
print ans and " \ n " to the standard output
let x be long long int
read x
if x < = 1
print - 1 with newline
else
print x + ' ' + x with newline
ch = character array of size 1005
n = integer
read n , ch + 1
ch [ 0 ] = ch [ n + 1 ] = 0
flag = integer = 0
if n is 1 and ch [ 1 ] is 0
else if n is 1 and ch [ 1 ] is 1
for i = 1 to n inclusive
if ch [ i ] is 1 and either ch [ i - 1 ] is not 0 or ch [ i + 1 ] is not 0
flag = 1
exit the for loop
if ch [ i ] is 0 and both of the following are true : if ch [ i - 1 ] is 0 and ch [ i + 1 ] is 0
flag = 1
exit the for loop
if flag is nonzero
else
n , a , b , c , ans = long long
read n , a , b , c
ans = n / a
print ans
n = integer
in function is_x1 that takes integers a , b and return integer
if b equals 0 and a is greater than or equal to 0 and a is less than or equal to n , return 1
in function is_x2 that takes integers a , b and return integer
if b equals n and a is greater than or equal to 0 and a is less than or equal to n , return 3
in function is_y1 that takes integers b , a and return is_y1
if b equals 0 and a is greater than or equal to 0 and a is less than or equal to n , return 4
in function is_y2 that takes integers b , a and returns integer
if b equals n and a is greater than or equal to 0 and a is less than or equal to n , return 2
let t be an integer
let x1 , x2 , y1 , y2 , j be integers
read n , x1 , y1 , x2 , y2
let value1 , value2 , val , a , b be integers with val = 0
for i = 0 to 2 exclusive
if i is equal to 0
assign x1 to a and assign y1 to b
else
assign x2 to a and assign y2 to b
assign 1 to j
while val is false
if j equals 1
set val to call function is_x1 with arguments a , b
else if j equals 2
set val to call function is_y1 with arguments a , b
else if j equals 3
set val to call function is_x2 with arguments a , b
else if j equals 4
set val to call function is_y2 with arguments a , b
increment j
if i equals 0
assign val to value1
else
assign val to value2
assign 0 to val
if value1 equals value2
if value1 equals 1 or value1 equals 3
display absolute value of x1 - x2
else
display absolute value of y1 - y2
else if ( value1 equals 1 and value2 equals 2 ) or ( value1 equals 2 and value2 equals 1 )
if value1 equals 1
display ( n - x1 ) + y2
else
display ( n - x2 ) + y1
else if ( value1 equals 1 and value2 equals 4 ) or ( value1 equals 4 and value2 equals 1 )
if value1 equals 1
display x1 + y2
else
display x2 + y1
else if ( value1 equals 2 and value2 equals 3 ) or ( value1 equals 3 and value2 equals 2 )
if value1 equals 2
display ( n - y1 ) + ( n - x2 )
else
display ( n - y2 ) + ( n - x1 )
else if ( value1 equals 3 and value2 equals 4 ) or ( value1 equals 4 and value2 equals 3 )
if value1 equals 3
display x1 + n - y2
else
display x2 + n - y1
else if ( value1 equals 1 and value2 equals 3 ) or ( value1 equals 3 and value2 equals 1 )
display call function min with arguments x1 + n + x2 , n - x1 + n + n - x2
else if ( value1 equals 2 and value2 equals 4 ) or ( value1 equals 4 and value2 equals 2 )
display call function min with arguments y1 + n + y2 , n - y1 + n + n - y2
x , y = long long integers
declare exgcd that takes two arguments , long long integers a and b
if b is 0
set x to 1
set y to 0
return a
d = long long integer set to exgcd of b and a modulo b
t = long long integer set to x
set x to y
set y to t - a / b * y
return d
m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 = long long integers
p1 , p2 , q1 , q2 = long long integers
while reading m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , and y2
set p1 , p2 , q1 , q2 to 0
for i = 1 to 2 * m inclusive
set h1 to h1 * x1 + y1 modulo m
if h1 is a1
if p1 is 0
set p1 to i
else if q1 is 0
set q1 to i - p1
break
for i = 1 to 2 * m inclusive
set h2 to h2 * x2 + y2 modulo m
if h2 is a2
if p2 is 0
set p2 to i
else if q2 is 0
set q2 to i - p2
break
d = long long integer set to exgcd of q1 and - q2
c = long long integer set to p2 - p1
if d is 0
puts " - 1 "
continue
if c modulo d
puts " - 1 "
continue
if p1 is 0 or p2 is 0
puts " - 1 "
continue
if q2 is 0 and q1 is 0 and p1 ! = p2
puts " - 1 "
continue
if q2 is 0 and p2 - p1 < 0 or q1 is 0 and p1 - p2 < 0
puts " - 1 "
continue
k = long long integer set to c / d
multiply x by k
multiply y by k
if d < 0 , set d to - d
if x < 0 or y < 0
while 1 exists
add q2 / d to x
add q1 / d to y
if x > = 0 and y > = 0 , break
if x > 0 and y > 0
while 1 exists
subtract q2 / d from x
subtract q1 / d from y
if x < 0 or y < 0
add q2 / d to x
add q1 / d to y
break
ans = long long integer set to x * q1 + p1
print ans
x , t , a , b , Da , Db , total = integers , total = 0
right = boolean false
aa , bb = integers
read x , t , a , b , Da , Db
let aa = 0
let bb = 0
for int i 0 to t inclusive
for int i = 0 to t inclusive
let total = aa + bb
if total equals x
let right = true
exit for loop
let bb = b - Db * i
if true , exit for loop
let aa = a - Da * i
let bb = 0
if true
else
x , y = integers
Read x , y
if x is 0 and y is 0
print 0 and a new line
if x is 1 and y is 0
print 0 and a new line
if x is 1 and y is 1
print 1 and a new line
if y is 1 and - 1 is less than or equal to x and x is less than or equal to 0
print 2 and a new line
if ( x is - 1 and - 1 is less than or equal to y and y is less than or equal to 1
print 3 and a new line
if ( y is - 1 and - 1 is less than or equal to x and x is less than or equal to 2 )
print 4 and a new line
z = integer , set to maximum value of absolute value of x and absolute value of y
if x is z and y is - z + 1
print 4 * z - 4 and a new line
if x is z and y is not - z )
print 4 * z - 3 and a new line
if y is z
print 4 * z - 2 and a new line
if x is - z
print 4 * z - 1 and a new line
print 4 * z + 0 and a new line
a = integer array of size 100001
n = integer
read n
for i = 1 to n + 1 exclusive , read a [ i ]
res = long long with res = 0
t = integer
for i = 1 to n exclusive
for t = 1 to i + t < = n with t = t * 2
;
t = right shift t 1 place
res = res + a [ i ]
a [ i + t ] = a [ i + t ] + a [ i ]
print res
create integers N , K
create integer array A with size 100005
create integer vector ans
declare searchFor with integer x as argument , returning integer
create integer left with left = 0
create integer right with right = size of ans - 1
while left is less than or equal to right
create integer mid with mid = ( left + right ) / 2
if x is greater than ans [ mid ]
set left to mid + 1
else if x is less than ans [ mid ]
set right to mid - 1
else
return mid from function
return - 1 from function
read N read K
for i = 0 to N exclusive , read A [ i ]
sort elements from A to A + N
add element A [ 0 ] to end of ans
for i = 1 to N exclusive
if A [ i ] % K is 0
create integer temp with temp = A [ i ] / K
create integer pos with pos = result of run searchFor with temp as argument
if pos is - 1 , add element A [ i ] to end of ans
else
add element A [ i ] to end of ans
print size of ans print newline
let n , i , x , y , j longs with x and y = 0
read n
let a array of longs of length n
read the first n values of a
for i = 0 to n exclusive
set x and y to 0
for j from i + 2 to n exclusive
increment x
otherwise
increment y
if x and y nonzero
empty statement
s = string
read s
cont1 , cont2 , cont3 = int with cont1 = 0 and cont2 = 0 and cont3 = 0
i = int with i = 0
iterate i while i < size of s and s [ i ] is ' a ' increment cont1
continue iterating i while i < size of s and s [ i ] is ' b ' increment cont2
continue iterating i while i < size of s and s [ i ] is ' c ' increment cont3
if cont1 or cont2 is 0 or i is not size of s
print " NO "
else
if cont1 is cont3 or cont2 is cont3
print " YES "
else
print " NO "
new integer constant called inf = 0x3f3f3f3f
create constant integer maxn with value 110
function max with int arguments a and b that returns int
return a if a > b , else b
function min with int arguments a and b that returns integer
return a if a > b , else return b
create new array of integers a with maxn elements
create ints i and n
read n and keep looping
assign the new values : 0 to a [ 0 ] and 1001 to a [ n + 1 ]
read n elements into a starting from the index 1
create integer l
declare new integer maxi with value 1
start for loop from l = 0 to n inclusive incrementing l
create new integer called pos = l
while l < = n and a [ l ] + 1 is a [ l + 1 ]
if l - pos + 1 is greater than maxi , assign l - pos + 1 to maxi
if maxi is equal to 1
print " 0 "
else
print maxi - 2
let maxn be a constant integer with maxn = 1e5 + 5
let mx be a constant integer with mx = 1e6 + 5
let mod be a constant integer with mod = 1e9 + 7
let n , d be long integers
a = array of long integers of length maxn
st = array of long integers of length maxn
while read n , d
for i = 1 to n inclusive , read a [ i ]
let top be a integer with top = 1
let ans be a long integer with ans = 0
let tail be a integer with tail = 0
for i = 1 to n inclusive
increment tail by 1
while top < = tail and a [ tail ] - a [ top ] is greater than d , increment top by 1
let res be a integer with res = tail - top
increment ans by ( long long ) res * ( res - 1 ) / 2
print ans and newline
sx , sy , ex , ey , n = integers
cnt = integers with cnt = 0
x , y = integers with x = 0 , y = 0
dist = integers with dist = 0
fl , chng = bool with fl = false , chng = false
in the function chk
if cnt is 0 and x is ex and y is ey
swap sx and ex , swap sy and ey
chng = true
read n
read sx , sy , ex , ey
while x < n
increment x
if chng is false , call chk
if x is sx and y is sy
increment cnt , fl = true
else if x is ex and y is ey
increment cnt , fl = false
break loop
if fl , increment dist
while y < n
increment y
if chng is false , call chk
if x is sx and y is sy
increment cnt , fl = true
else if x is ex and y is ey
increment cnt , fl = false
break loop
if fl , increment dist
while x > 0
decrement x
if chng is false , call chk
if x is sx and y is sy
increment cnt , fl = true
else if x is ex and y is ey
increment cnt , fl = false
break loop
if fl , increment dist
while y > 0
decrement y
if chng is false , call chk
if x is sx and y is sy
increment cnt , fl = true
else if x is ex and y is ey
increment cnt , fl = false
break loop
if fl , increment dist
if sx is ex and sy is ey , dist = 0
print min of dist and 4 * n - dist
declare desperate_optimization with integer precision as argument , returning void
set cout flag ios : : fixed
set cout flag ios : showpoint
set cout precision to precision
create maps ms , vis from long long to integer
create constant integer N with N = 1e5
create long long array arr with size N + 5
declare hora with integer tc as argument , returning void
create long longs n , k
read n read k
for i = 0 to n exclusive
read arr [ i ]
set ms [ arr [ i ] ] to 1
create integer tot with tot = 0
for i = 0 to n exclusive
create integer ctr with ctr = 0
if vis [ arr [ i ] ] is 0
set vis [ arr [ i ] ] to 1
create long long x with x = arr [ i ]
increment ctr
while ms [ x * k ] and vis [ x * k ] is 0
set vis [ x * k ] to 1
set x to x * k
increment ctr
set x to arr [ i ]
while x % k is 0 and ms [ x / k ] and vis [ x / k ] is 0
set vis [ x / k ] to 1
set x to x / k
increment ctr
increment tot by ( ctr + 1 ) / 2
print tot print ' \ n '
run desperate_optimization with 10 as argument
create integer ntc with ntc = 1
for tc = 1 to ntc inclusive , run hora with tc as argument
create a map from strings to integers called character
create string s
declare double variables n , m , k and res
create floats check and level
read input to n , m and k
while n ! = 0 , decrement it and continue the loop
read input to s and level
set check to k * level
if check > = 100 , change character [ s ] to check
decrement m and loop further , while m is not 0
read s
if character [ s ] > = 100
skip the rest of the loop
else
set character [ s ] to 0
create map iterator it
print length of character
moving it through character , print it - > first , " " and it - > second
let s be a string
input s
let l be an integer with l = the length of s
for i = 0 to l exclusive
for j = 0 to 3 exclusive
for k = 0 to 3 exclusive
for p = 0 to 3 exclusive
if j is unequal to k and j is unequal to p and k is unequal to p
c1 = character = the character A + j
c2 = character = the character A + k
c3 = character = the character A + p
if s [ i ] equals c1 and s [ i + 1 ] equals c2 and s [ i + 2 ] equals c3
declare const int maxn = 110
declare an array of integers a with maxn elements
declare an array of long longs b with size maxn
declare an array of booleans vis with size maxn
dfs is a int function with int arguments u , s and l
if u is equal to s
assign l + 1 to l
return l
if vis [ u ] is true and u ! = s , return - 1
set vis [ u ] to 1
if a [ u ] is equal to s
return the result of dfs ( a [ u ] , s , l )
else
return the result of dfs ( a [ u ] , s , l + 1 )
long long function gcd with int arguments aa and bb
if bb is equal to 0 , return aa
return gcd ( bb , aa % bb )
declare int variable n
loop , reading n from the input
for i from 1 to n inclusive , read a [ i ]
set first sizeof ( vis ) bytes at the pointer vis to false
declare integer variable k = 0
declare integer variable flag = 1
loop i from 1 to n inclusive
if vis [ i ] is false
assign true to vis [ i ]
declare int variable tmp = dfs ( a [ i ] , i , 1 )
if tmp ! = - 1
if tmp is even
assign tmp / 2 to b [ k ] and increment k
else
set b [ k ] to tmp and increment k
else
change flag to 0
stop the loop
if flag is false
print " - 1 "
else
declare long long p = b [ 0 ] , e and gbs
loop i from 0 to k exclusive
change e to gcd ( p , b [ i ] )
change gbs to p * b [ i ] / e
assign gbs to p
print p
create int m
read m
if m is equal to 0
print " 1 \ n "
if m modulo 4 is 1 , print " 8 \ n "
if m % 4 is equal to 2 , print " 4 \ n "
if m modulo 4 is 3 , print " 2 \ n "
if m % 4 is 0 , print " 6 \ n "
create int a [ 1000 ] , n , b [ 1000 ] , ans , r , o , f , set f to 1
read n
for i = 1 to n inclusive , read a [ i ]
for i = 1 to n inclusive
for a [ i ] less than 0
if o > = 2
increment ans
b [ ans ] = r
set r = 0
assign 1 to o
set f = 1
else
increment o
add 1 to r
print ans + 1
for i = 1 to ans inclusive , print b [ i ] , " "
print n - f + 1
print a newline
s1 , s2 = character array of size 100005 and a , b = character array of size 2
l1 , l2 , i , j0 , cnt = integers with j = 0 , cnt = 0
read s1 , s2
l1 = length of string ( s1 )
l2 = length of string ( s2 )
if l1 is not l2
else
for i = 0 to l1 exclusive
if s1 [ i ] is not s2 [ i ]
increment cnt
a [ j ] = s1 [ i ]
b [ j ] = s2 [ i ]
increment j
if cnt > 2
if a [ 1 ] is b [ 0 ] and a [ 0 ] is b [ 1 ]
else
create string s
read s
create long long integers i , j
create booleans x , y , z , yy , with x = true , y = true , z = true , yy = true
for i = 1 to size of s - 1 exclusive
set x to true
set y to true
set z to true
if s [ i ] is ' A ' , set x to false
if s [ i ] is ' B ' , set y to false
if s [ i ] is ' C ' , set z to false
if s [ i - 1 ] is ' A ' , set x to false
if s [ i - 1 ] is ' B ' , set y to false
if s [ i - 1 ] is ' C ' , set z to false
if s [ i + 1 ] is ' A ' , set x to false
if s [ i + 1 ] is ' B ' , set y to false
if s [ i + 1 ] is ' C ' , set z to false
if x is false and y is false and z is false
set yy to false
break loop
if yy is false
print " Yes " print newline
else
print " No " print newline
create integer list array graph with size 101
create integers n , e , size , create integer arrays l , incoming , with l size 101 , incoming size 101
create long long integer ans
create boolean array visited with size 101
declare gcd with long long integers a , b as arguments , returning long long integer
if a is less than b
return result of run gcd with b , a as arguments
else if b is 0
return a from function
else
return result of run gcd with b , a % b as arguments
declare dfs with integers vertex , level as arguments , returning void
if visited [ vertex ] is true
if level % 2 is 0
set l [ increment size ] to level / 2
else
set l [ increment size ] to level
else
set visited [ vertex ] to true
run dfs with front of graph [ vertex ] , level + 1 as arguments
return from function
read n
for i = 1 to n inclusive
read e
add element e to end of graph [ i ]
increment incoming [ e ]
for i = 1 to n inclusive
if incoming [ i ] is not 1
print " - 1 " print newline
for i = 1 to n inclusive
if not visited [ i ] , run dfs with i , 0 as arguments
set ans to l [ 0 ]
for i = 1 to size exclusive , set ans to ( ans * l [ i ] ) / result of run gcd with ans , l [ i ] as arguments
print ans print newline
M is a constant long long set to 1e5
MOD is a constant long long set to 998244353
PI is a constant double set to 3 . 14159265358979323846
a , b are strings
read a , b
i and ans are both long longs both set to 0
while i is less than length of a
c = long long = 0
for long long j = 0 to length of b exclusive
if i + j is at least length of a , break
if a [ i + j ] equals b [ j ] , increment c
increment i
set ans to call max with ans , c
set i to 0
while i is less than length of b
c = long long = 0
for long long j = 0 to length of a exclusive
if i + j is at least length of b , break
if b [ i + j ] equals a [ j ] , increment c
increment i
set ans to call max with ans , c
display ( length of b ) - ans
create strings a , b
read a read b
if size of a is not size of b
print " NO " print newline
create integer vector r
for i = 0 to size of a exclusive
if a [ i ] is not b [ i ] , add element i to end of r
if size of r is not 2
print " NO " print newline
if a [ r [ 0 ] ] is b [ r [ 1 ] ] and a [ r [ 1 ] ] is b [ r [ 0 ] ]
print " YES " print newline
else
print " NO " print newline
create const int MAX = 2e5
create pair of pair and long long a of size MAX + 9
create long long ints n , k , a0 , x , y , m , ans , cnt , t , and tmp
read n
for i = 0 to n exclusive
read k , a0 , x , y , and m and set to 0
for j = 0 to k exclusive
if cnt is less than or equal to MAX , set a [ cnt + + ] to { { t , a0 } , i }
set tmp to ( a0 * x + y ) % m
if tmp is less than a0 and j is not equal to k - 1 , increment t
set a0 to tmp
set ans to max of ans and t
if cnt is less than or equal to MAX
sort a using a + cnt
declare const int N = 2e5 + 100
ma and mb are maps of long long to long long
p is an array of long long / long long pairs with N elements
create integers vector v1 and an array of integer vectors v with N elements
s is a set of long longs
a , b , i , n , p , q , t and x are integers with i , p , q and x = 0
pr is an array of int / int pairs with 1000 elements
read t
set n to t
decrement t and loop further , while t ! = 0
read a and b
set pr [ i ] to make_pair ( a , b )
increment i
if a is greater than 0
increment p by one
else
increment q
sort first n elements of pr
print x
create new double tmaxmin = 1 < < 20
create long long t1
new new long long called t2
create long long variable with name t0
new double T
declare long long x1
new long long x2
create new long long solx1
declare long long variable solx2
read variables t1 , t2 , x1 , x2 and t0 from the input
while x1 and x2 are both greater than or equal to 0
change the value of T to ( 1 . 0 * t1 * x1 + t2 * x2 ) / ( x1 + x2 )
if T is less than t0
decrement x1
else
if T is less than tmaxmin
change the value of tmaxmin to T
change the value of solx2 to x2
assign x1 to solx1
decrement x2 by one
print solx1 , " " and solx2 to the output
let len , a = int with a = arrya of length 30
str = string
read len and str
for i = 0 to len exclusive , increment a [ str [ i ] - ' a ' ]
if len is 1 or a [ ( max element of a ) - a ] > = 2
else
a , b , s = integer
read a , b , s
d = integer = absolute value of a + absolute value of b
if d > s or d modulo 2 is not s modulo 2
print No
else
print Yes
create string s
read s
create long long n with n = length of s
create long long array x with size 3
for i = 1 , _b = n - 2 to i is less than or equal to _b , incrementing i
set bytes from x to size of x to value 0
if s [ i - 1 ] is not ' . ' , increment x [ s [ i - 1 ] - ' A ' ]
if s [ i ] is not ' . ' , increment x [ s [ i ] - ' A ' ]
if s [ i + 1 ] is not ' . ' , increment x [ s [ i + 1 ] - ' A ' ]
if x [ 0 ] is 1 and x [ 1 ] is 1 and x [ 2 ] is 1
print " Yes " print newline
print " No " print newline
let ints n and s
read s and n
create int arrays x of size n and y of size n
for i = 0 to n exclusive , read x [ i ] and y [ i ]
for i = 0 to n - 1 exclusive
for j = 0 to n - 1 exclusve
if x [ j ] is greater than x [ j + 1 ]
swap values of x [ j ] and x [ j + 1 ]
swap values of y [ j ] and y [ j + 1 ]
for i = 0 to n exclusive
if s is less than or equal to x [ i ]
print " NO "
add y [ i ] to s
print " YES "
declare string array a size 105 , declare strings ts , st
declare integer arrays type size 105 , visit size 105 , integer N
declare character lucky
declare lower with character address now as argument , returning character
if now is greater than or equal to ' A ' and now is less than or equal to ' Z ' , return now - ' A ' + ' a ' from function
return now from function
declare upper with character address now as argument , returning character
if now is greater than or equal to ' a ' and now is less than or equal to ' z ' , return now - ' a ' + ' A '
return now from function
read N
for i = 1 to N inclusive
read a [ i ]
read ts
read lucky
let lucky be lower case ( lucky )
declare string st = ts
for i = 0 to size of st exclusive
let type [ i ] be ( st [ i ] is greater than or equal to ' a ' and st [ i ] is less than or equal to ' z ' )
let st [ i ] be lower case st [ i ]
set bytes from visit to size of visit to value 0
for i = 0 to size of st exclusive
for j = 1 to N inclusive
if size of st - i is greater than or equal to size of a [ j ]
if substring of st from i to size of a [ j ] is a [ j ]
for k = 0 to size of a [ j ] exclusive , let visit [ i + k ] be 1
for i = 0 to size of ts exclusive
if visit [ i ] is true
if lower case ( ts [ i ] ) is lucky
if lucky is ' a '
let ts [ i ] be ' b ' is type [ i ] is true , else ' B '
else
let ts [ i ] be ' a ' if type [ i ] is true , else ' A '
else
let ts [ i ] be lower case ( lucky ) if type [ i ] is true , else upper case ( lucky )
print ts and newline
in the function seieve
empty long long function maxx with 2 long long arguments
empty long long function minn with 2 long long arguments
new constant long long mod with value 1000000007
declare constant long long limits with value 1e18
primes is a new array of long longs with 1000001 element initialized with 0
declare long long variables t , i , j , k , n , m , o and p where j = 0
read t from the input
create string variable s
read variable s from the input
create new vector of characters v
arr is an array of long longs with 200005 elements initialized with 0
for i from 0 to length of s exclusive incrementing i
if length of v = 0 or last character of v ! = s [ i ]
push s [ i ] to the end of v
add 1 to the last element of arr
else
increase the last element of arr by 1
create long long variable sm = 0
in a for loop , change i from 0 to length of v - 1 exclusive incrementing i
if character at the position i in v is ' > ' and character at the position i + 1 in v is ' < '
change arr [ i ] to 0
change the value of arr [ i + 1 ] to 0
change i to the sum of i and 1
else
add arr [ i ] to sm
increase sm by the value of arr [ length of v - 1 ]
print sm
function seieve
create new long longs i and p
change primes [ 0 ] to 1
assign 1 to primes [ 1 ]
increment p in a loop from 2 while p squared < = 1000000
if primes [ p ] = 0
in a for loop , change i from p * 2 to 1000000 inclusive increasing i by p and setting primes [ i ] to 1 on each iteration
long long function maxx with long long arguments a and b
return a if a > b or b otherwise
minn is a long long function with long long arguments a and b
return a if a < b or b otherwise
declare integers c , b , a
read c , b , a
if a is c
print " NO "
if ( ( not ( ( a - c ) % b ) or not ( ( a - c - 1 ) % b ) ) and a is not c + 1 )
print " YES "
else
print " NO "
create string ak
read ak
create integer sz = ak . size ( )
create integers f1 = 0 , f2 = 0 , f3 = 0 , f4 = 0 , and i
for i = 0 to sz exclusive
if ak [ i ] is equal to ' A ' and ak [ i + 1 ] is equal to ' B ' and f1 is equal to 0
set f1 to 1
increment i
continue to the next loop iteration
if ak [ i ] is equal to ' B ' and ak [ i + 1 ] is equal to ' A ' and f1 is equal to 1 , set f2 to 1
for i = 0 to sz exclusive
if ak [ i ] is equal to ' B ' and ak [ i + 1 ] is equal to ' A ' and f3 is equal to 0
set f3 to 1
increment i
continue to the next loop iteration
if ak [ i ] is equal to ' A ' and ak [ i + 1 ] is equal to ' B ' and f3 is equal to 1 , set f4 to 1
if f1 is equal to 1 and f2 is equal to 1
print " YES "
if f3 is equal to 1 and f4 is equal to 1
print " YES "
print " NO "
prime is an array of booleans with 1000001 element
function SieveOfEratosthenes with int argument n
set first sizeof ( prime ) bytes at the pointer prime to true
change p in a loop , incrementing by 1 , from 2 , while p squared < = n
if prime [ p ] = true
in a for loop , change i from p * p to n inclusive adding p to i , and setting prime [ i ] to false on each iteration
call SieveOfEratosthenes ( 1000001 )
define integer variable n
read variable n from the input
in a for loop , change i from 1 to 1000001 inclusive
if prime [ i * n + 1 ] is true
else
print i
break
maxn = const int with maxn = 105
num = integer array of size maxn
s = string
read s
n = integer
l = integer with l = s . size ( )
set all contents of num to 0
zheng , fu = integer with zheng = 0 , fu = 0
zuida = int with zuida = 1
pos = integer
num [ 1 ] = 1
increment zheng
increment zuida
for i = 1 to l
if s [ i ] is +
num [ increment zuida ] = 1
increment zheng
else if s [ i ] is -
num [ increment zuida ] = - 1
increment fu
else if s [ i ] is =
pos = i
break loop
a = string with a = s . substr ( pos + 2 )
ss = stringstream , call ss on a
right shift ss n times
flag = bool with flag = false
for i = 1 to zuida exclusive
if n is zheng - fu )
flag = true
break loop
while n > zheng - fu and num [ i ] > 0 and num [ i ] < n
increment zheng
increment num [ i ]
while ( n < zheng - fu and num [ i ] < 0 and abs ( num [ i ] ) < n )
increment fu
decrement num [ i ]
if n is zheng - fu , flag = true
if flag
print num [ 1 ]
for i = 2 to zuida exclusive
if num [ i ] < 0
print - and - num [ i ]
else
print + and num [ i ]
print =
print n
else
N , INF = const int with N = 1e3 + 10 and INF = 1e9 + 7
rate = int , int pair array of size N
n = int
in function cmp taking int , int pair a , int , int pair b and returnign bool
if a . first is b . first return a . second < b . second
return a . first > b . first
read n
for i = 0 to n
a , b , c , d = int
read a then b then c then d
increment a by b
increment a by c
increment a by d
set rate [ i ] to { a , i }
sort rate from position 0 to n using cmp
for i = 0 to n
of rate [ i ] . second is 0
print i + 1
create string s
ok is a boolean function with int arguments i and j
return false if j - i > 1 and s [ i ] = ' 0 '
return false if j - i is greater than 8
declare integer variable x with value 0
for k from i to j exclusive , change x to x * 10 + s [ k ] - ' 0 '
return x < = 1000000
function calc with int arguments i and j that returns integer
declare new integer variable x with value 0
in a for loop , change k from i to j exclusive , setting x to x * 10 + s [ k ] - ' 0 ' on each loop
return x
read variable s from the input
declare new integer called ans = - 1
for integer i = 1 to length of s exclusive
start for loop from j = i + 1 to length of s exclusive incrementing j
create new integer sum with value 0
if ok of 0 and i returned true
add the result of calc ( 0 , i ) to sum
else
go to the start of the loop
if the result of ok ( i , j ) is true
increase sum by the result of calc ( i , j )
else
go to the start of the loop
if ok ( j , length of s ) is true
increase sum by the result of calc ( j , length of s )
else
skip the rest of the loop
assign the new value = max of ans and sum to ans
print ans and " \ n " to the standard output
the constant integer value of MAX = 100005
create a vector of integers by name f and has values MAX , - 1
create a vector of integers by name fr and has values MAX , - 1
create a vector of boolean values by name valid and has values MAX , 1
the boolean value of ans = 1
let n be a integer
the integer value of lastValid = 1
read n
if n equals 1
print 1 and newline
if n & 1 is true
f [ n / 2 + 1 ] is equal to n / 2 + 1
valid [ n / 2 + 1 ] is equal to 0
f [ 1 ] is equal to 2 , f [ n ] is equal to n - 1
fr [ 2 ] is equal to 1 , fr [ n - 1 ] is equal to n
valid [ 2 ] is equal to valid [ n - 1 ] is equal to 0
for integer i = 2 to n / 2 inclusive , increment i by 1
let x , y be integers with x = f [ i ] , y = fr [ i ]
if x is not equal to - 1 and y equals - 1
fr [ i ] is equal to n + 1 - x
f [ n + 1 - x ] is equal to i
valid [ i ] is equal to 0
else if y is not equal to - 1 and x equals - 1
f [ i ] is equal to n + 1 - y
valid [ n + 1 - y ] is equal to 0
fr [ n + 1 - y ] is equal to i
if f [ i ] is equal to - 1
the boolean value update = 1
for integer j = lastValid to n inclusive
if valid [ j ] is true
if i equals j
update is equal to 0
proceed to next
f [ i ] is equal to j
fr [ j ] is equal to i
valid [ j ] is equal to 0
if update is true , lastValid is equal to j
stop
f [ n + 1 - i ] is equal to n + 1 - f [ i ]
fr [ f [ n + 1 - i ] ] is equal to n + 1 - i
valid [ n + 1 - f [ i ] ] is equal to 0
for integer i = 1 to n and ans inclusive , increment i by 1
if f [ f [ i ] ] is not equal to n + 1 - i , ans is equal to 0
if ans equals 0
print - 1 and newline
let x , y , days , work be integers
asphaltx = array of boolean values of length 100 , asphalty = array of boolean values of length 100
workdays = array of integers of length 100000
the value of days is equal to 1
let a be a integer
read a
for A = 0 to a * a exclusive
read x , y
if asphaltx [ x ] is equal to false and asphalty [ y ] is equal to false
set asphaltx [ x ] to true
set asphalty [ y ] to true
workdays [ work ] is equal to days
increment work by 1
increment days by 1
for A = 0 to work exclusive
if A is equal to work - 1
print workdays [ A ] and newline
print workdays [ A ] and space
declare constant double PI = acos ( - 1 . 0 )
declare constant double eps = 1e - 6
create const int INF = 0x3f3f3f3f
gcd is a int function with int arguments a and b
return b if a % b = 0 , or gcd of b and a % b
create int n
declare const int maxn = 60
declare string variables a and b
read a and b
declare int num = 0
declare an array of characters aa with size 10
create int j = 0
declare integer variable len1 = length of a and len2 = length of b
if len1 ! = len2
print " NO "
else {
for integer i = 0 to len1 exclusive
if a [ i ] ! = b [ i ]
increment j and set aa [ j ] to a [ i ]
increment j and set aa [ j ] to b [ i ]
increment num
if num is greater than 2 , break the loop
if num = 2 and aa [ 0 ] = aa [ 3 ] and aa [ 1 ] = aa [ 2 ]
print " YES "
else
print " NO "
declare integer variables x and y
declare bool arrays xasphalt and yasphalt with size 69
days and wrkdsz are integers with days = 1 , and workdays is an array of integers with 6969 elements
create int a
read input to a
for integer A = 0 to a * a exclusive
read input to x and y
if xasphalt [ x ] = false and yasphalt [ y ] = false
change xasphalt [ x ] to true
change yasphalt [ y ] to true
change workdays [ wrkdsz ] to days
increment wrkdsz by one
increment days by one
for A from 0 to wrkdsz exclusive
if A is equal to wrkdsz - 1
print workdays [ A ] and " \ n "
else
print workdays [ A ] and " "
create new constant long integer mod with value 1000000007
declare strings s and t
f is a new 2d array of integers with size 5001 by 5001
read from the input to s and t
define new integer called a
declare integer variable with name sum = 0
start the loop for o from a - 1 to 0 inclusive decrementing by 1
for i = b - 1 to 0 inclusive counting down
if f [ o ] [ i ] > = mod , change the value of f [ o ] [ i ] to f [ o ] [ i ] modulo mod
change sum to the sum of sum and f [ o ] [ 0 ]
if sum > = mod , change sum to the remainder of sum divided by mod
print sum
declare integer arrays spf size integer casted 1 . 5e7 + 9 , cnt size integer casted 1 . 5e7 + 9
declare sieve with long long n as argument , returning void
let spf [ 0 ] be spf [ 1 ] be 1
for i = 2 to n inclusive
if spf [ i ] is 0
for j = i to n inclusive , incrementing j by i
if spf [ j ] is 0 , let spf [ j ] be i
fun sieve with 1 . 5e7 as argument
declare integer n
read n
declare integer vector a size n
for i = 0 to n exclusive , read a [ i ]
declare integer g = a [ 0 ]
for i = 1 to n exclusive , let g be result of run __gcd ( g , a [ i ] )
declare ans = 0
for i = 0 to n exclusive
declare integer num = a [ i ] / g
while num is not 1
declare integer f = spf [ num
while num % f is 0 , let num be num / f
increment cnt [ f ]
let ans be maximum of ans and cnt [ f ]
let ans be n - ans
if ans is n
print - 1 and newline
else
print ans and newline
create constant integer inf = 0x3f3f3f3f
create constant integer maxn = 110
in the function max which takes a and b integers and returns their max value
return a if a > b else return b
in the function min which takes two integers a and b and returns a integer
return b if a > b else return a
create an integer array a of size maxn
i , n = integers
while entered value of n is valid
read n values into the array a
l = integer
maxi = integer with value 1
for l = 0 to n - 1 exclusive
create integer pos = l
while l < n - 1 and a [ l ] + 1 = a [ l + 1 ] increment l
if l - pos + 1 > maxi then set maxi = l - pos + 1
create integer cnt1 = 1
if a [ 0 ] is 1
for i = 0 to maxi - 1 exclusive
if a [ i ] + 1 is not equal to a [ i + 1 ]
then break
add 1 to cnt1
create integer cnt2 = 1
if a [ n - 1 ] is equal to 1000
for i = 0 to maxi - 1 exclusive
if a [ n - 1 - i ] - 1 is not equal to a [ n - 1 - i - 1 ]
break
add 1 to cnt2
if cnt1 = maxi or cnt2 = maxi
print maxi - 1 and new line
print maxi - 2
a = array of integers of length 102000
b = array of integers of length 102000
mymap = map from int to int
let n be a integer
read n
let m be a integer with m = - 1
for i = 1 to n inclusive
read a [ i ]
read mymap [ a [ i ] ] by 1
m is equal to maximum of m and mymap [ a [ i ] ]
print n - m and newline
let b be integer array with size 1000000
declare integers n and k
read n and k
declare vector of integers variable v
declare int variable cnt = 0
for integer i = 0 to n exclusive
declare int x
read x
push x into v
if k = 1
print n
for i = 0 to length of v exclusive
declare integer variable y = v [ i ]
assign 1 to b [ i ]
if y % k is not 0 , go to the start of the loop
declare integer x = y / k
declare integer variable p = lower_bound ( v . begin ( ) , v . end ( ) , x ) - v . begin ( )
if v [ p ] is equal to x
assign b [ p ] + 1 to b [ i ]
assign 0 to b [ p ]
declare int variable ans = 0
loop i from 0 to n exclusive , increase ans by ( b [ i ] + 1 ) / 2
print ans
declare new integers n and t
loop , reading n and t from the input
ans is a new integer with value 100010
for i = 0 to t exclusive incrementing i
create integers l and r
read l and r
assign the new value = min of ans and r - l + 1 to ans
print ans
for integer i = 0 to n exclusive
if i is true , print " "
print i % ans to the standard output
print a new line
n = int
a = int
b = int vector
c = int vector
jawab = int vector
read n
for i = 0 to n
read a
append a to b
append a to c
sort c using greater of type int
for i = 0 to n
for j = 0 to n
if b [ i ] is c [ j ] and i is n - 1
print j + 1
break
else if b [ i ] is c [ j ]
print j + 1 then " "
break
maxn = 1000005
Next = vector of long long
function init ( no args , no return value )
t = long long
Q = queue of long long
push 0 into Q
while Q is not empty
t = first item of Q
pop first item of Q
if t > 10 ^ 11 continue
add t at end of Next
push t * 10 + 4 into Q
push t * 10 + 7 into Q
function bisearch_L ( get long long val , return int )
L = 0 , R = size of Next - 1 , mid = int , res = size of Next - 1
while L < = R
mid = ( L + R ) / 2
if Next [ mid ] < = val
res = mid
L = mid + 1
else
R = mid - 1
return res
function bisearch_R ( get long long val , return int )
L = 0 , R = size of Next - 1 , mid = int , res = 0
while L < = R
mid = ( L + R ) / 2
if Next [ mid ] > = val
res = mid
R = mid - 1
else
L = mid + 1
return res
function f ( get long long L and R , return long long )
res = 0
posL = bisearch_R ( L )
posR = bisearch_R ( R )
posRL = bisearch_L ( R )
if Next [ posL ] > = R return ( R - L + 1 ) * Next [ posL ]
add ( Next [ posL ] - L + 1 ) * Next [ posL ] to res
add ( R - Next [ posRL ] ) * Next [ posR ] to res
for i = posL to posRL exclusive add ( Next [ i + 1 ] - Next [ i ] ) * Next [ i + 1 ] to res
return res
L , R = long long
init ( )
while read L and R print f ( L , R )
define long long ints x1 , y1 , x2 and y2
create ints n and ans where ans = 0
read user input to x1 , y1 , x2 , y2 and n
start for loop from i = 0 to n exclusive
declare new long long int variables a , b and c
read a , b and c from the input
if a * x1 + b * y1 + c < 0 and a * x2 + b * y2 + c > 0 , increment ans
increment ans if a * x1 + b * y1 + c > 0 and a * x2 + b * y2 + c < 0
print ans to the standard output
n , m , i , l , c = integers with c = 0
read n , m
a = integer array of size n
for i = 0 to n exclusive
read a [ i ]
if ( a [ i ] < = m )
l = i
a [ i ] = 0
else
a [ i ] = a [ i ] - m
if ( a [ i ] < 0 ) , a [ i ] = 0
i = 0
while ( c < n )
for i = 0 to n exclusive
if ( a [ i ] is 0 )
increment c
else if ( a [ i ] < = m )
l = i
a [ i ] = 0
c = 0
else
a [ i ] = a [ i ] - m
if ( a [ i ] < 0 ) , a [ i ] = 0
c = 0
l = i
increment l
print l
create a map from strings to integers called ans
declare integers n and m
create double kk
read n , m and kk
declare integer variable k = kk * 100 . 0 + 0 . 5 casted to integer
loop i from 0 to n exclusive
declare string variable s
declare int variable x
read s and x
skip the rest of the loop if x * k is less than 10000
set ans [ s ] to k * x / 100
loop i from 0 to m exclusive
declare string s
read input to s
if ans is empty , set ans [ s ] to 0
print length of ans
declare integers a , b , d , k
declare c as character
read a , c , b
let k be a
let d be ( ( k % 10 ) * 10 )
let k be k / 10
increment d by k
if b is less than d and d is less than 60
if a is greater than 9 and d is greater than 9
print a , " : " , d , newline
else if a is less than 10 and d is greater than 9
print " 0 " , a , " : " , d , newline
else if a is greater than 9 and d is less than 10
print a , " : 0 " , d , newline
else
print " 0 " , a , " : 0 " , d , newline
else
if a is less than 23
mark jump point Loop
increment a
let k be a
let d be ( ( k % 10 ) * 10 )
let k be k / 10
incremend d by k
if d is less than 60 and d is greater than 9
if a is greater than 9
print a , " : " , d , newline
else
print " 0 " , a , " : " , d , newline
else if d is less than 60 and d is less than 10
if a is greater than 9
print a , " : 0 " , d , newline
else
print " 0 " , a , " : 0 " , d , newline
else
go to jump point Loop
else
print " 00 : 00 \ n "
create long a , b , c , d , e , f
read a , b , c , d , e , f
set num1 to a * c * e
assign b * d * f to num2
if num1 = 0 and num2 = =
if c = 0 and d > 0
else if a * c = 0 and b * d > 0
else
else if num2 > num1
else
print Hermione and a newline
create int dp [ 110 ] [ 110 ]
create int n , i , j and k
read n
set dp [ 1 ] [ 2 ] to 1
set dp [ 2 ] [ 1 ] = 1
for i = 3 to 100 inclusive
for j = 1 to i exclusive
sum = 0
for k = 1 to j exclusive
if dp [ k ] [ i ] = 1 and dp [ k ] [ j ] = 1 , increment sum
if sum < = n
set n to n - sum
assign 1 to dp [ i ] [ j ]
set dp [ j ] [ i ] to 1
if n = 0 , break
if n = 0 , break
ans = i
print i
for i = 1 to ans inclusive
for j = 1 to ans inclusive , print dp [ i ] [ j ]
print a newline
numberOfStudents = integer
studentsRate = integer
result = integer = 1
read numberOfStudents
arr = integer array of size 2000
for x = 0 to numberOfStudents exclusive , increase x by 1 at the start of the loop
read studentsRate
arr [ x ] = studentsRate
for x = 0 to numberOfStudents exclusive , increase x by 1 at the start of the loop
result = 1
for y = 0 to numberOfStudents exclusive , increase y by 1 at the start of the loop
if arr [ x ] < arr [ y ] , then increase result by 1
if x is numberOfStudents - 1
print result
else
print result
declare constant integer N = 200
declare integer k , integer array mark size N by N
declare f with integer val as argument , returning void
set bytes from mark to size of mark to value 1 - val
for i = 0 to k exclusive
for j = i to k - i exclusive
if i % 2 is 0 , let mark [ i ] [ j ] be val
for i = k - 1 to 0 exclusive , decrementing i
for j = i to k - 1 - i inclusive , decrementing j
if ( k - 1 - i ) % 2 is 0 , let mark [ i ] [ j ] be val
for j = 0 to k exclusive
for i = j to k - j exclusive
if j % 2 is 0 , let mark [ i ] [ j ] be val
for j = k - 1 to 0 exclusive , decrementing j
for i = j to k - 1 - j inclusive , decrementing i
if ( k - 1 - j ) % 2 is 0 , let mark [ i ] [ j ] be val
read k
if k % 2
print - 1 and newline
else
for i = 0 to k exclusive
run f with i % 2 as argument
for r = 0 to k exclusive
for c = 0 to k exclusive , print ' w ' if mark [ r ] [ c ] is true , else ' b '
print newline
if i is less than k - 1 , print newline
s is an array of strings with size 8
new integer variable t
read from the input to t
decrement t and loop further , while t is not 0
in a for loop , change i from 0 to 8 exclusive , read from the input to s [ i ] on each loop iteration
create new integer variable k1x with value 0
define integer variable k1y = 0
define new integer variable k2x = 0
create new integer variable k2y = 0
declare integer t = 0
for i from 0 to 8 exclusive
increment j in a loop from 0 to 8 exclusive
if s [ i ] [ j ] = ' K '
if t is equal to 0
assign i to k1x
change the value of k1y to j
increment t by one
else
set k2x to i
change k2y to j
increment t
if t is equal to 2 , break
if t is equal to 2 , break
new boolean f with value false
set f to true if abs ( k2x - k1x ) % 4 = 0 and abs ( k2y - k1y ) % 4 = 0
if f is true
print " YES "
else
print " NO "
integers = n , m
read n , m
create integer vector of arr
integers = max = - 1
integers = index = - 1
for i = 0 to less than n do the following
integers = x
read x
if x is greater than max then do the following
set max to x
set index to i + 1
add new element x to end of vector arr
if m is greater than or equal to max then do the following
output n
else
integers = index = - 1
integers = count = 0
integer i = 0
for = 0 to less than n do the following
if arr [ i modulo n ] is greater than 0 then do the following
subtract m from arr [ i modulo n ]
if arr [ i modulo n ] is less than or equal to 0 then do the following count + +
if count is n then break
output i modulo n + 1
create int f , mi , ma , pos , pos1 , n , a , set f = 0 , pos = 0 , pos1 = 0
read n
for i = 0 to n exclusive
read a
if i = 0
mi = a
set ma = a
else
if a > ma
set ma = a
pos = i
if a < = mi
set mi equal to a
assign 1 to pos1
if pos1 < pos , set f = 1
print n - 1 - pos1 + pos - f and a newline
create new string n
read n from the user input
declare new ints a , b and c = 0
declare new booleans power1 and power2 , with value of both = true
start for loop from i = 0 to length of n exclusive incrementing i
if power1 and power2 are false , increment c
if power1 is false
if n [ i ] ! = ' = ' and power2 is true
increment b
else
assign false to power2
if n [ i ] ! = + ' + ' and power1 is true
increment a
else
assign false to power1
if a + b ! = c and a + b + 2 ! = c and a + b ! = c + 2
print " Impossible \ n " to the standard output
else
if a + b is equal to c
print ' | ' a times
print ' + ' to the standard output
print ' | ' b times
print ' = ' to the standard output
print ' | ' to the output stream c times
print ' \ n ' to the standard output
else if a + b + 2 is equal to c
print ' | ' in a loop a + 1 times
print ' + ' to the standard output
in a for loop , print ' | ' b times
print ' = '
in a loop , print ' | ' c - 1 times
print ' \ n '
else if a + b = c + 2
declare string variable with name cad with value " "
if a is greater than 1
start for loop from i = 0 to a - 1 exclusive , printing ' | ' on each iteration
else
print ' | '
print ' + '
if a = 1 and b > 1
in a for loop , print ' | ' to the stdout b - 1 times
else if b = 1
print ' | ' to the standard output
else
print ' | ' b times in a for loop
print ' = '
for integer i = 0 to c + 1 exclusive , print ' | '
print ' \ n '
y , k , n = int
read y , k , n
x = k - y = int
while x < 1 then increment x by k
if x + y > n
print - 1 and new line
else
print x
while x + y + k < = n
print space and x + k
increment x by k
print new line
make ints t , s , and x
read t , s , and x
set x to x - t
if x is less than s and x is not equal to 0
show " NO "
else if x modulo s is equal to 0 or x modulo s is equal to 1
show " YES "
otherwise
print " NO "
create integer n
read from the input to n
create string s
read standard input to s
if s = " 0 "
print " 0 "
create integer variable with name zer = 0
in a for loop , change i from 0 to length of s exclusive incrementing i
if s [ i ] = ' 0 ' , increment zer
print " 1 "
for i from 0 to zer exclusive , print " 0 " to the standard output
print new line to the standard output
s = string
read s
nC , iC , eC , tC , disC = int with nC = 0 and iC = 0 and eC = 0 and tC = 0 and disC = 0
for c = 0 to length of s
if s [ c ] is ' n '
increment nC
else if s [ c ] is ' i '
increment iC
else if s [ c ] is ' e '
increment eC
else if s [ c ] is ' t '
increment tC
loop while nC and eC and iC and tC are all greater than 0
decrement nC by 3
decrement iC
decrement eC by 3
decrement tC
if nC and eC and iC and tC are all greater or equal to 0 increment disC
increment nC
print disC
Grades = char array of size 200005
let lfp , zp , n , i , t , last be integers with lfp = - 1
let carryFlag , pf be boolean with carryFlag = false , pf = false
read n , t , Grades [ 1 ]
for i = 1 to n inclusive
if Grades [ i ] = = ' . '
increment i
break out of for loop
while Grades [ i ] and t > 0
if Grades [ i ] is greater than or equal to ' 5 '
set lfp to i
break
increment i
while ( - lfp ) is not zero and t > 0 and pf is false
if Grades [ lfp - 1 ] = = ' . '
set Grades [ lfp - 1 ] to 0
increment Grades [ lfp - 2 ]
update last to lfp - 2
set pf to true
else
update Grades [ lfp ] to 0
increment Grades [ lfp - 1 ]
update last to lfp - 1
set lfp to - 1
decrement t
if Grades [ last ] > ' 9 '
let c be integer with c = 1
set Grades [ last ] to ' 0 '
decrement last
while c is not zero
set c to 0
if Grades [ last ] = = ' . '
set Grades [ last ] to ' \ 0 '
increment Grades [ last - 1 ]
decrement last by 2
set pf to true
else if last = = ' \ 0 '
set carryFlag to true
set Grades [ 0 ] to ' 1 '
break
else
increment Grades [ last ]
if Grades [ last ] > ' 9 '
if not pf
set Grades [ last ] to ' \ 0 '
else
set Grades [ last ] to ' 0 '
decrement last
set c to 1
if Grades [ last ] > = ' 5 ' , set lfp to last
else if Grades [ last ] > = ' 5 '
set lfp to last
if carryFlag is true
print out first element of Grades
else
print out second element of Grades
hor = integer with hor = { 0 , 1 , 2 , 3 , 4 , 5 , 10 , 11 , 12 , 13 , 14 , 15 , 20 , 21 , 22 , 23 }
mie = integer with mie = { 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 }
maohao = character
h , m = integer
read h , maohao , m
for i = 0 to 15
if ( hor [ i ] is h and mie [ i ] > m ) or hor [ i ] > h
if ( hor [ i ] < 10 ) , print 0
print hor [ i ] , :
if mie [ i ] < 10 , print 0
print mie [ i ]
print 00 : 00
in the function ascending that takes integer i , j and returns bool
return ( i < j )
in the function descending that takes integer i , j and returns bool
return ( i > j )
dp = long long 2d array of size [ 5050 ] [ 5050 ]
mod = long long with mod = 1000 * 1000 * 1000 + 7
s1 , s2 = strings
read s1 , s2
set all contents of dp to 0
for i = s1 . size ( ) - 1 down to 0
for j = s2 . size ( ) - 1 down to 0
dp [ i ] [ j ] = dp [ i ] [ j + 1 ]
dp [ i ] [ j ] = dp [ i ] [ j ] modulo mod
ret = integer with ret = 0
print ret modulo mod
make constant ints N = 5e5 and inf = 1e9
create map m of chars to ints
create int n and int arrays tmp of size N , x of size N , and y of size N
declare Ok taking in int cur and returning bool
for i = 0 to n exclusive
set tmp [ i ] to 0
set tmp [ i ] to tmp [ i ] | ( 1 < < ( x [ i ] - 1 ) ) & cur
set tmp [ i ] to tmp [ i ] | ( 1 < < ( y [ i ] - 1 + 5 ) ) & cur
for j = 0 to i exclusive
return true
read n
for i = 0 to n exclusive
make string s
read s
set x [ i ] to M [ s [ 0 ] ]
set y [ i ] to s [ 1 ] - ' 0 '
create integer res = 10
for i = 0 to ( 1 < < 10 ) exclusive
make integer cur = _builtin_popcount ( i )
if cur is greater than or equal to res , continue loop
if Ok ( i ) is truthy , set res to cur
n , p = integers
s , t , a , b = strings
ma = map < pair < string , string > , bool >
read n
for i = 0 to n exclusive
if i is not equal to 0 then read s
read s and t
if ma [ { s , t } ] then continue
set ma [ { s , t } ] to 1
set a = b = " "
set a = a + t [ 0 ]
set a = a + s [ 0 ]
set b = b + t [ 1 ]
set b = b + s [ 1 ]
set ma [ { a , b } ] = 1
set a = b = " "
set a = a + t [ 1 ]
set a = a + t [ 0 ]
set b = b + s [ 1 ]
set b = b + s [ 0 ]
set ma [ { a , b } ] = 1
set a = b = " "
set a = a + s [ 1 ]
set a = a + t [ 1 ]
set b = b + s [ 0 ]
set b = b + t [ 0 ] ;
set ma [ { a , b } ] = 1
increment p
define long longs n , q , a , g , k , p , sum , t1 and l1 where k , p and sum = 0
read n , q and a from the input
create new long long called w = q
if n is equal to 0
print q / a to the standard output
else
for i from 0 to n exclusive incrementing i
create long longs t and l
read t and l from the input
if k = 0
assign sum + ( t / a ) to sum
change the value of t1 to t and l1 to l
create long long variable h = t1 + l1
change the value of k to 1
else
define long long variable h = t1 + l1
change g to t - h
set p to g / a
assign sum + p to sum
change the value of k to 1
if i is equal to n - 1
change the value of sum to sum + ( ( w - t - l ) / a )
else
change t1 to t and l1 to l
print sum to the standard output
gcd of inta a int b
if b is equal to 0
return a
gcd of b , a modulo b
let n be a integer
while read n
let cnt be a integer , cnt = 0
if n is equal to 1 , increase cnt by 1
while n is decreased by 1
let b be a integer
read b
if b is equal to 0 , increase cnt by 1
if cnt is equal to 1
print YES
print NO
print newline
isPrime is a new array of booleans with 10000000 elements
create new vector of integers prime
for i from 2 to 10000000 exclusive incrementing i
if isPrime [ i ] is false
in a for loop , change j from 2 * i to 10000000 exclusive adding i to j and assigning 1 to isPrime [ j ] on each loop iteration
push i to the vector prime
create new long long variable q
read user input to q
if q is less than 10000000
if isPrime [ q ] is false
print 1 , new line and 0
create new vector of long longs v
start for loop from i = 0 to length of prime exclusive incrementing i
while q % prime [ i ] is 0
push prime [ i ] into v
divide q by prime [ i ]
if length of v is equal to 0
print 1 , new line and 0 to the standard output
else
if q ! = 1 , push q into v
if length of v is equal to 2
print 2
else
print 1 , new line and v [ 0 ] * v [ 1 ]
n , k = int
read n then k
s = string
read s
i = int with i = n - 1
req = string with req = s
loop while i is greater than 0
done = bool with done = true
for j = 0 to n - 1
if s8j ] is not s [ i + j ]
set done to false
break the for loop
if done is true then set req to substring of s starting at n - i and the length of i
decrement i
append req to s k - 1 times
print s
declare string variable with name s
read s
declare new integer called a = 0
for i from 0 to length of s exclusive incrementing i
if s [ i ] is equal to ' 1 ' , add 1 to a
if a = length of s
remove all symbols of s except first
print s
else
for i from 0 to length of s exclusive incrementing i
if s [ i ] is equal to ' 0 '
rase all symbols of s from the start to index i
print s
break
M = constant integer with value of 1010
t1 , t2 , x1 , x2 , t0 = long long integers
read t1 , t2 , x1 , x2 , t0
if t2 equals t0 and t1 equals t0
print x1 space x2
else
if t2 equals t0
print 0 space x2
else
if t1 equals t0
print x1 space 0
else
a = long long integer with value of t0 minus t1
b = long long integer with value of t2 minus t0
ans1 = long long integer with value of 0
ans2 = long long integer with value of x2
for y1 = 1 to x1 inclusive
y2 = long long integer with value of a * y1 / b + ( ( a * y1 ) mod b does not equal 0 )
if y2 is less than or equal to x2
f1 = long long integer with value t1 * y1 + t2 * y2
d1 = long long integer with value of y1 + y2
f2 = long long integer with value of t1 * ans1 + t2 * ans2
d2 = long long integer with value of ans1 + ans2
if f1 * d2 is less than d1 * f2
set ans1 to y1
set ans2 to y2
else
if f1 * d2 equals d1 * f2
if y1 + y2 is greater than ans1 + ans2
set ans1 to y1
set ans2 to y2
print ans1 space ans2
let spf be an array of long long integers of size 100001
prototype function gcd which takes in long long integers a and b as arguments
prototype function palindrome which takes in string s as an argument
prototype function modexp which takes in long long integers a , b , and m as arguments
prototype function sieve
prototype function getFactorization which takes in long long integer x as an argument
prototype function getZarr which takes in string str and an array of long long integers Z as arguments
define function ceil which takes in long long integers a and b as arguments
return a / b + ( a % b ! = 0 ) from the function
let n be a long long integer
read in n
let p be an array of n pairs that stores two long long integers
read in n values into p [ i ] . first and p [ i ] . second
sort the beginning to the n + p position of array p in ascending order
let ans be a long long integer and set its value to INT_MIN
iterate for n times
let x be a long long integer and set its value to ceil ( log10 ( p [ i ] . second ) / log10 ( 4 ) )
set ans to the max of ans and x + ( p [ i ] . first )
if ans is equal to p [ i ] . first , increment ans
print ans
define function gcd which takes in long long integers a and b as arguments
if a is equal to 0 , return the value of b
if b is equal to 0 , return the value of a
if a is equal to b , return the value of a
if a is greater than b , return the greatest common denominator of a % b and b
return the greatest common denominator of a and b % a
define function palindrome which takes in string s as an argument
let l be a long long integer and set its value to 0
let h be a long long integer and set its value to s . length ( ) - 1
while h is greater than 1
if s [ l + + ] is not equal to s [ h - - ] , return a value of 0
return a value of 1
define function modexp which takes in long long integers a , b , and m as arguments
if b is equal to 0 , return a value of 1
let temp be a long long integer and set its value to modexp ( a , b / 2 , m )
set temp to ( temp * temp ) % m
if b and 1 are true , return ( temp * ( a % m ) ) % m
return the value of temp
define function sieve
set spf [ 1 ] to 1
for i = 2 to i < 100001 , set spf [ i ] to i
iterate for i = 4 , to i < 100001 and increment i by 2 every loop , set spf [ i ] to 2
for i = 3 to i * i < 100001
if spf [ i ] is equal to i
for j = i * i to j < 100001 , increment j by i every loop
if spf [ j ] is equal to j , set spf [ j ] to i
define function getFactorization which takes in long long integer x as an argument
let ret be a vector of long long integers
while x is not equal to 1
add a new element to ret with a value of spf [ x ]
set x to x / spf [ x ]
return the value of ret
define function getZarr which takes in string str and an array of long long integers Z as arguments
let n be a long long integer and set its value to str . length ( )
let L , R , and k be long long integers
set the values of L and R to 0
for i = 1 to i < n
if i is greater than R
set L and R to i
while R is less than n and str [ R - L ] is equal to str [ R ] , increment R
set Z [ i ] to R - L
decrement R
or else
set k to i - L
if Z [ k ] is less than R - i + 1
set Z [ i ] to Z [ k ]
or else
set L to i
while R is less than n and str [ R - L ] is equal to str [ R ] , increment R
set Z [ i ] to R - L
decrement R
declare and array of long longs o with 100 elements and long long variables n , m and j where j = 0
create long double k
let s be string array with size 100
let s be an array of pairs of string / long long with size 100
read n , m and k
loop i from 0 to n exclusive
read input to s [ i ] and o [ i ]
if k * o [ i ] + 1e - 8 rounded down > = 100
c [ j ] . first = s [ i ]
c [ j ] . second = k * o [ i ] + 1e - 8 rounded down
increment j
for i from 0 to m exclusive
read input to s [ i ]
declare boolean variable flag = true
for integer k = 0 to j exclusive
if c [ k ] . first is s [ i ] , assign false to flag
if flag is true
c [ j ] . first = s [ i ]
c [ j ] . second = 0
increment j
print j
for i from 0 to j exclusive , print c [ i ] . first , " " and c [ i ] . second
PI = const double with PI = acos on - 1 . 0
EPS = const double with EPS = ( 1e - 10 )
INF = const long long integer with INF = 0x3f3f3f3f
mod = const long long with mod = ( 1e9 ) + 7
in the function my_mod that takes long long int num , mod and returns long long int
ret = long long integer with ret = num modulo mod
while ( ret < 0 ) , ret = ret + mod
return ret
in the function gcd that takes long long int a , b and returns long long int
return if a is 0 , b else gcd ( b modulo a , a )
k = integer
read k
ans = integer array of size [ 205 ] [ 205 ]
set all contents of ans to 0
cnt = integer with cnt = 1
for ( k )
for i = 0 to i < = k and i < cnt
ans [ i ] [ cnt ] = 1
ans [ cnt ] [ i ] = 1
k = k - i
increment cnt
print cnt
for i = 0 to cnt exclusive
for j = 0 to cnt exclusive , print ans [ i ] [ j ]
print new line
N = const int = 150
let x [ N ] , y [ N ] , info [ N ] , n be ints
in int function color_to_id taking char ch
if ch = ' R ' then return 1
if ch = ' G ' then return 2
if ch = ' B ' then return 3
if ch = ' Y ' then return 4
if ch = ' W ' then return 5
in int function count_one taking x
cnt = 0 = int
while x isn ' t 0
increment cnt by x & 1
x = x bit right shift 1
return cnt
in bool function check taking sta = int
for i = 0 to n exclusive
set info [ i ] = 0
info [ i ] bitwise or ( 1 bitwise left shift ( x [ i ] - 1 ) ) bitwise and sta
info [ i ] bitwise or ( 1 bitwise left shift ( y [ i ] - 1 + 5 ) ) bitwise and sta
for j = 0 to i exclusive
if info [ i ] = info [ j ] and ( x [ i ] is not x [ j ] or y [ i ] is not y [ j ] )
return true
str = string
while reading n
for i = 0 to n exclusive
read str
set x [ i ] = color_to_id of str [ 0 ]
y [ i ] = str [ 1 ] - ' 0 '
ans = 10 = int
for i = 0 to 1 bitwise left shit 10
n_one = count_one ( i ) = int
if n_one > = ans then go to next iteration
if check ( i ) then set ans to n_one
print ans
define integers n and k
read n and k
define string s
read into s
define ints i and j
for i from 1 to n ( exclusive ) by 1
define Boolean flag and set it to 1
for j by 1 from i to n ( exclusive )
if s [ j ] isn ' t s [ j - 1 ]
set flag to 0
break out of loop
if flag , then break
if i is n
while k is nonzero , decrement k and print s
print a newline
set i to n - 1 - 1
print s
decrement k
while k isn ' t 0 , decrement it and
for int l from i + 1 to n ( exclusive ) by 1 , print s [ l ]
print newline
create unsigned long long integers n , a , x , maxim , cmax , cnt and total with total = 0
set maxim to 0
cmax = 0
cnt is equal to 0
read n
read a
for j = 0 to j = a exclusive
read x
set maxim to max to maxim and x
if maxim is greater than cmax
total = total + ( maxim - cmax ) * cnt
assign maxim to cmax
else
total = total + ( cmax - maxim ) * a
cnt is equal to cnt + a
set maxim to 0
print total
create int array counter of size 4005 * 10
let int a
make char array str of size 4005
read a
read str
let int = strlen ( str ) and integer arrays cs of size 4005 and temp of size 4005
set cs [ 0 ] to 0
for i = 0 to len exclusive , set temp [ i + 1 ] to str [ i ] - 48
for i = 1 to len , set cs [ i ] to cs [ i - 1 ] + temp [ i ]
for i = 1 to len
for j = i to len , increment counter [ cs [ j ] - cs [ i - 1 ] ]
make long long int ans = 0
if a is 0
for i = 0 to 37000 exclusive , set ans to ans + ( ( long long ) counter [ 0 ] * ( long long ) counter [ i ] )
for i = 1 to 37000
if a modulo i is 0
print ans
let a , b , c be integers
let s be a string
while read s
let len be a integer with len = length of s
let i be a integer
let flag be a integer with flag = 1
if s [ 0 ] is not eqaul to a
print NO and newline
proceed to next
a is equal to 1
b is equal to c is equal to 0
for i = 1 to len exclusive
if s [ i ] is equal to a
increment a by 1
else if s [ i ] is equal to c
flag is equal to 0
stop
stop
for i , i is less than len , increment i by 1
if s [ i ] is equal to b
increment b by 1
else if s [ i ] is equal to a
flag is equal to 0
stop
stop
for i , i is less than len , increment i by 1
if s [ i ] is equal to c
increment c by 1
flag is equal to 0
stop
if flag is equal to 0
print NO and newline
else if b is equal to 0
print NO and newline
if c is equal to a or c is equal to b
print YES and newline
print NO and newline
create integer n , array a with size 105
create map mp of char to int
read n
set mp [ ' R ' ] to 5
set mp [ ' G ' ] to 6
set mp [ ' B ' ] to 7
set mp [ ' Y ' ] to 8
set mp [ ' W ' ] to 9
for i = 0 to n exclusive
create stirng s
read s
create ints c , v
set c to mp [ s [ 0 ] ]
set v to s [ 1 ] - ' 0 ' - 1
set a [ i ] to ( 1 bitwise shift left c ) bitwise or ( 1 bitwise shift left v )
sort a [ 0 : n )
set n to unique ( a , a + n ) - a
create integer ans = 11
for int mask = 0 ; msk less than ( 1 bitwise shift left 10 ) ; increment msk
create bool f = true
for i = 0 to n exclusive
for j = i + 1 to n exclusive
create int t = a [ i ] bitwise XOR a [ j ]
if ( msk bitwise and t ) equals 0
set f to false
break
if not f , break
if f , set ans to min ( ans , __builtin_popcount ( msk ) )
print ans
create character array s with size 100003
create character pointer c
read s
if ( set c to first occurrence of " AB " in s ) is not NULL and first occurrence of " BA " in c + 2 is not null
print " YES " print newline
if ( set c to first occurrence of " BA " in s ) is not NULL and first occurrence of " AB " in c + 2 is not null
print " YES " print newline
print " NO " print newline
the constant double value of PI = acos ( - 1 )
the constant integer value of MAX = 2e9 + 7
the constant long integer value of MOD = 1e9 + 7
let solve be a void function
let n , m , k , l be long integers
read n , m , k , l
the long integer value of dif = n - k
if dif is less than l
print - 1 and newline
return nothing
let h be a long integer , if k modulo m equals 0 , h = k / m else h = k / m + 1
the long integer value of r = h * m - k
if r > = l
if h * m < = n
print h and newline
print - 1 and newline
return nothing
let t be a long integer , if l modulo m equals 0 the value of t is equal to l / m else t is equal to l / m + 1
if ( t + h - 1 ) * m < = n and ( t + h - 1 ) * m - k > = l
print t + h - 1 and newline
else if ( t + h ) * m < = n
print t + h and newline
print - 1 and newline
call the solve function
create int n
read n
let int k
let int p
if n is less than 4
if n is equal to 1
set k to 1
else if n is equal to 2
set k to 2
else if n is equal to 3
set k to 3
else if n is equal to 0
print 1
else do
set k to n % 4
if k is equal to 1
set p to 8
else if k is equal to 2
set p to 4
else if k is equal to 3
set p to 2
else if k is equal to 0
set p to 6
print p
declare long long x
read x
if fail bit on cin is false
if x is less than or equal to 127
print " byte " and newline
else if x is less than or equal to 32767
print " short " and newline
else if x is less than or equal to 2147483647
print " int " and newline
else
print " long " and newline
else
print " BigInteger " and newline
integer as n
read n
integer as max = - 1
for i = 0 to less than n do the following
make k a long integer
make a a long integer
read k , a
set long m to 1
integer as mcnt = 0
if m is true do the following
if m is greater than or equal to a then break
multiply m by 4
add one to mcnt
if a is 1 then mcnt = 1
integer as real_k = k + mcnt
if real_k is greater than max then do the following max = real_k
output max
;
declare locale loc
declare integers a , b
declare long long s
read a , b , s
if s is greater than or equal to absolute value of a + absolute value of b and ( s - ( absolute value of a + absolute value of b ) % 2 is 0 )
print " Yes "
print " \ n "
else
print " No "
print " \ n "
declare constant integer N = 2e5 + 10
declare long long integers n , a , b , k , MOD = 1e9 + 9
declare fast_power with long longs base , power as arguments , returning long long
declare long long result = 1
while power is greater than 0
if power % 2 is 1 , let result be ( result * base ) % MOD
let base be ( base * base ) % MOD
let power be power / 2
return result from function
read n , a , b , k
declare string s
read s
declare integer l = ( n + 1 ) / k - 1
declare long long integer val = ( b * result of run fast_power ( a , MOD - 2 ) ) % MOD
declare long long integer valp = result of run fast_power ( val , k )
declare long long integer ans = 0
declare long long integer geo
if valp is not 1
let geo be ( result of run fast_power ( valp , l + 1 ) - 1 ) % MOD + MOD
let geo be geo * result of run fast_power ( ( valp - 1 ) % MOD + MOD , MOD - 2 ) % MOD
let geo be geo % MOD
else
let geo be l + 1
for i = 0 to k exclusive
declare long long integer calc = result of run fast_power ( b , i ) * result of run fast_power ( a , n - i ) % MOD
if s [ i ] is ' - '
let ans be ( ans - ( geo * calc % MOD ) ) % MOD + MOD
else
let ans be ( ans + ( geo * calc % MOD ) % MOD )
let ans be ans % MOD
print ans and newline
a = integer array of size 105
in function summ with parameters integers l , r and return long long
ans = long long set to 0
for i = l to r inclusive , add a [ i ] to ans
return ans
declare an integer n
input n
sum = long long set to 0
ans = integer set to 0
for i = 1 to n inclusive
read a [ i ]
add a [ i ] to sum
if a [ i ] is 0 , increment ans
if sum is 0
if ans is n
else
for i = 1 to n exclusive
if call summ with 1 , i isn ' t 0 and call summ with i + 1 , n isn ' t 0
print YES , newline , 2
print 1 , " " , i
print i + 1 , " " , n
break
else
print 1
print 1 , " " , n
n = int
while read n
a = array of 101 int
for i = 0 to n exclusive read a [ i ]
num = 0
t = 0
b = array of 101 int
line = 0
for i = 0 to n exclusive
if a [ i ] < 0 and t is 2
b [ line ] = num , increment line
num = 1
t = 1
else
if a [ i ] < 0 increment t
increment n
b [ line ] = num , increment line
print line
for i = 0 to line
if i equal line - 1
print b [ i ]
else
print b [ i ] and space
declare character arrays a size 10005 , b size 1000005
while read a is true
read b
declare integer ans
declare integer len = string length of a
declare integer kk = string length of b
declare x = 0 , y = 0 as integers
for ans = 1 , incrementing ans
declare s = 0 as integer
for i = 0 to len exclusive
if a [ i ] is b [ y ]
increment y
increment s
if y is kk
end loop
else if s is 0
let ans be - 1
end loop
if ans is greater than or equal to 50000
let ans be 960000
end loop
print ans and newline
Emp_Lang = vector of long integers of size 500
visited = array of boolean values of length 500
let DFS be a void function which accepts long integer a
visited [ a ] is equal to true
for long integer i = 0 to Emp_Lang [ a ] . size ( ) exclusive
if not visited [ Emp_Lang [ a ] [ i ] ] , Depth First Search of Emp_Lang [ a ] [ i ]
let n , m be long integers
read n , m
let analphabet be a long integer with analphabet = 0
for long integer i = 0 to n exclusive
let lang be a long integer
read lang
for long integer j = 0 to lang exclusive
analphabet is equal to 1
let id be a long integer
read id
push_back id + 200 value in Emp_Lang [ i ]
push_back i value in Emp_Lang [ id + 200 ]
let components be a long integer with components = 0
for long integer a = 0 to n exclusive
if not visited [ a ]
increment components by 1
Depth First Search of a
print components - analphabet and newline
dp = long long array of size 26 and width 26
n = long long
read n
st = string
for i = 0 to 26 exclusive , and increase i by 1 at the start of the loop
for j = 0 to 26 exclusive , and increase j by 1 at the start of the loop , then print dp [ i ] [ j ] = - 1e18 in long long form
for i = 0 to n exclusive and increase i by 1 at the start of the loop
read st
f = long long = st [ 0 ] - a
l long long = st [ size of st in long long for - 1 ] - a
le = long long = size of st in long long form
dp [ l ] [ l ] = greater vakue between dp [ l ] [ l ] and dp [ l ] [ f ] + le
for i = 0 to 26 exclusive . and increase i by 1 at the start of the loop
if i is l , then continue
dp [ i ] [ l ] is greater value between dp [ i ] [ l ] and dp [ i ] [ f ] + le
dp [ f ] [ l ] = greater value between dp [ f ] [ l ] and le
ans = long long = 1e18 in long long form
for i = 0 to 26 exclusive and increase i by 1 at the start of the loop , then ans = greater value between ans and dp [ i ] [ i ]
if ans < 0
print 0
else
declare long long variables n , x , y , bx , by , wx and wy
read n from the user input
read x and y from the input
change the value of wx to x - 1
set the value of wy to y - 1
change the value of bx to n - x
change by to n - y
if n = x and n is equal to y
print " Black "
else if x and y are both 1
print " White "
else
if wx < = by and wy < = bx
print " White "
else
print " Black "
create const long long oo = 4000000000000000000LL
make long long ints n , m , a , and d
create long long array t of 100100
read n , m , a , and d
for i = 0 to m exclusive , read t [ i ]
set t [ m + + ] to oo - 1
create long long ans = 0
make long long k = ( d / a + 1 ) * a
let long long last_start = - d - 1
for i = 0 to m exclusive
if t [ i ] is less than or equal to last_start + d , continue loop
make long long first_ai
if last_start + d is less than d
set first_ai to a
else if last_start + d is greater than or equal to n * a
set first_ai to oo
else
set first_ai to ( ( last_start + d ) / a + 1 ) * a
if t [ i ] is less than first_ai
set last_start to t [ i ]
increment ans
else do
set last_start to first_ai
increment ans
make long long int steps
if t [ i ] is greater than n * a
set steps to ( n * a - last_start ) / k
else do
set steps to ( t [ i ] - last_start ) / k
add steps * k to last_start
add steps to ans
if t [ i ] is less than or equal to last_start + d
continue loop
else do
set last_start = t [ i ]
increment ans
display result of ans - 1
make long long int mod = 1e9 + 9
create ints d , x , and y
declare fastexp taking in long long ints b and p and returning long long integer
if p is 0 , return 1
create long long int ans = fastexp ( b , p / 2 ) % mod
if p modulo 2 is truthy
return the result of ( ( 1LL * b * ans % mod ) * 1LL * ans ) % mod
else do
return the result of ( 1LL * ans * ans + mod ) % mod
make long long ints a , n , b , and k
create string s
make long long integers v1 , v2 , v3 , and sum = 0
read n , a , b , and k
read s
for h = 0 to k exclusive
if s [ h ] equals ' + '
set v1 to fastexp ( a , n - h ) % mod
set v2 to fastexp ( b , h ) % mod
set v3 to ( v1 * v2 + mod ) % mod
set sum to ( sum % mod + v3 % mod + mod ) % mod
else do
set v1 to fastexp ( a , n - h )
set v2 to return value of fastexp ( b , h )
set v3 to ( v1 * v2 + mod ) % mod
set sum to ( sum % mod - v3 % mod + mod ) % mod
create long long int v1 = ( n + 1 ) / k
make long long integer inv_a = fastexp ( a , mod - 2 ) % mod
make long long integer vv = ( ( inv_a % mod ) * ( b % mod ) + mod ) % mod
let long long integer vl1 = ( ( fastexp ( vv , k ) % mod ) ) % mod
if vl1 is 1
create long long int ans = ( ( v1 * sum ) + mod ) % mod
display ans
create long long integer vl4 = fastexp ( vl1 , vl ) % mod
set vl4 to ( vl4 - 1 + mod ) % mod
set vl4 to ( vl4 * sum + mod ) % mod
make long long integer vl2 = ( ( ( vl1 + mod ) % mod ) - 1 + mod ) % mod
create long long integer vl3 = ( vl4 * ( fastexp ( vl2 , mod - 2 ) ) + mod ) % mod
print the result of vl3 % mod
let n , k , a , ans , and temp be integers , set ans to 1
read in n
decrement n
read in k and a
if a is equal to 1
set tmp to k + 1
or else
set tmp to k
while a is greater than 1
set a to ( a - 1 ) / 4 + 1
increment tmp
if ans is less than tmp , set ans to tmp
print ans
create vector of integers a
declare new long long variables n and z with z = 0
read from the input to n
in a for loop , change i from 1 to n inclusive incrementing i
if ( i * ( i + 1 ) ) / 2 < = n
push ( ( i + 1 ) * i ) / 2 into a
else
stop the loop
start for loop from i = 0 to length of a exclusive
if binary_search of n - a [ i ] in a returned true
print " YES " to the standard output
increment z by one
break
if z = 0 , print " NO "
function solve ( get long long N , return long long )
cnt = 0
for n = 1 to 9 inclusive
if n < = N increment cnt
for n = 11 to 99 by 11 inclusive
if n < = N increment cnt
w = 100 , while w + 1 < = N multiplying w by 10
for n = 1 to 9 inclusive
v = w * n + ( w - 10 ) + n
if v < = N
add w / 10 to cnt
else
if N modulo 10 > = n increment cnt
add ( N - n * w ) / 10 to cnt
return cnt
return cnt
l , r = long long , while read l and r print solve ( r ) - solve ( l - 1 )
declare new long longs n and i
read n from the input
declare string s
read user input to s
if n = 1
if s [ 0 ] is equal to ' 0 '
print " No \ n "
else
print " Yes \ n "
create long long variable f with value 0
for i from 1 to n - 1 exclusive
if s [ i ] = ' 0 '
if s [ i - 1 ] is equal to ' 1 ' or s [ i + 1 ] = ' 1 '
go to the start of the loop
else
set f to 1
else
if s [ i - 1 ] and s [ i + 1 ] are not equal to ' 1 '
skip the rest of the loop
else
assign 1 to f
if s [ 0 ] and s [ 1 ] have the same value , set f to 1
if s [ n - 1 ] = s [ n - 2 ] , assign 1 to f
if f = 0
print " Yes \ n "
else
print " No \ n "
declare integer array isprime size 4000000
declare long long array prime size 2000000
declare integer cnt = 0
declare integer fac = 1
declare getprime with no arguments , returning void
fo ri = 2 to 4000000 exclusive , let isprime [ i ] be 1
let prime [ 1 ] be 0
for i = 2 to 4000000 exclusive
if not isprime [ i ] , break current loop iteration
for j = i * 2 to 4000000 exclusive , incrementing i by j , let isprime [ j ] be 0
let prime [ increment cnt ] be i
declare integer isPrime with long long n as argument
if n is less than 4000000 , return isprime [ n ]
for i = 0 to prime [ i ] * prime [ i ] is less than or equal to n , incrementing i
if n % prime [ i ] is 0 , return 0
return 1 from function
declare long long num
execute getprime
while read num
declare integer sum = 0
let fac be 1
declare long long tem = num
if isPrime ( num ) or num is 1
print 1 , newline , 0 , newline
break current loop iteration
for i = 0 to cnt exclusive
if num % prime [ i ] is 0
while num % prime [ i ] is 0
if sum is less than or equal to 2 , let fac be fac * prime [ i ]
increment sum
let num be num / prime [ i ]
if sum is greater than or equal to 2 , break loop
if sum is greater than or equal to 2 , end loop
if sum is greater than or equal to 2 and num is not 1
print 1 , newline
print fac , newline
else
print 2 and newline
M = const integer with M = 10010
a = integer array of size M
n , m , k = long long integers
read n , m , k
min_v = long long integer with min_v = 1E + 9
for i = 1 to n
read a [ i ]
if i modulo 2 is 1 and a [ i ] < min_v , min_v = a [ i ]
if n modulo 2 is 0
else
x = long long integer with x = 2 * m / ( n + 1 )
y = long long integer with y = x * k
ans = long long integer with ans = if y > min_v , min_v else y
print ans
let n , a , b , c , d , sum , sum1 , ans be integers
read n
read a , b , c , d
sum1 is equal to a + b + c + d
ans is equal to n
for i = 1 to n exclusive
read a , b , c , d
sum is equal to a + b + c + d
if sum < = sum1 , decrement ans by 1
print ans and new line
n , t = integer
while n and t can be read as valid integers
if t < 10
while looping decrease n by 1 , print t
else
if n is 1
print - 1
else
print 1
decrease n by 1
while looping decrease n by 1 , print 0
print endline
declare new string variable sentence
create an array of characters split with size 110
read the input to sentence
copy sentence into array split
create new integer variable track
declare new integer n_count with value 0
i_count is a new integer variable = 0
declare integer e_count = 0
declare integer variable with name t_count = 0
declare new integer nineteen_count with value 0
start for loop from i = 0 to length of sentence exclusive incrementing i
if split [ i ] is equal to ' n ' , increment n_count
if split [ i ] = ' i ' , increment i_count by one
if split [ i ] = ' e ' , increment e_count
if split [ i ] = ' t ' , increment t_count by one
if n_count > = 3 and i_count > = 1 and e_count > = 3 and t_count > = 1
increment nineteen_count by one
decrease n_count by 3
subtract 1 from i_count
change e_count to e_count - 3
decrease t_count by 1
looping infinitely
if n_count > = 2 and i_count > = 1 and e_count > = 3 and t_count > = 1
increment nineteen_count
subtract 2 from n_count
decrease i_count by 1
decrease e_count by 3
change t_count to t_count - 1
else
break the loop
print nineteen_count to the standard output
declare constant integer mod = 1e9 + 7
create constant integer maxn = 1e6 + 5
power is a long long int function with long long int arguments base , exp and mod
create new long long integer res with value 1
while exp is not 0
if exp is odd , change the value of multiply res by base
multiply base by base
change res to the remainder of res divided by mod
change base to base modulo mod
change the value of exp to exp divided by 2
return res
declare long long int variables n , m and k
read user input to n , m and k
create new long long integer called ans with value mod
for i from 1 to n inclusive
declare long long integer variable x
read variable x from the input
if i is odd , set ans to min of ans and x
if n is even , change the value of ans to 0
set m to m * 2
divide m by ( n + 1 )
print min of ans and m * k and " \ n " to the standard output
create const integer INF = 0x3f3f3f3f
let int n
read n
let int array row of size n + 10
create long long integer array ans of size n + 10
for i = 1 to n , read row [ i ]
for i = 1 to n
create long long int cont = 0
let int j = row [ i ]
while cont is less than 102 and j is not equal to i
increment cont
set j to row [ j ]
if cont is greater than 1 , increase cont by 1
set ans [ i ] to cont
if row [ i ] is equal to i , set ans [ i ] to 2
if ans [ i ] modulo 2 is equal to 0 , set ans [ i ] to ans [ i ] / 2
create bool flag = true
let long long mult = ans [ 1 ]
for i = 1 to n
if ans [ i ] is equal to 103
print - 1
set mult to ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] )
print mult if flag is truthy or - 1 if not truthy
declare long long variables a , b , c , d , i and j
read a , b , c and d from the user input
for i from 0 to 100 inclusive
in a for loop , change j from 0 to 100 inclusive incrementing j
if b + a * i is equal to d + c * j
print b + a * i to the standard output
print " - 1 " to the output
a = string
n = integer
read a , n
l is an integer set to length of a
if l modulo n
display NO
assign l / n to n
for i = 0 with condition i is less than l with increment add n to i
end = integer = i + n - 1
begin = integer = i
while begin is at most end
if a [ begin ] equals a [ end ]
increment begin
decrement end
else
display NO
display YES
declare long long MOD = 1000000007
declare long long vector primes
declare sieve_of_eratosthenes with long long n as argument , returning void
resize primes to size n
for i = 2 to n exclusive , let primes [ i ] be i
for i = 2 to i * i is less than n , incrementing i
if primes [ i ] is true
for j = i * i to n exclusive , incrementing j by i , let primes [ j ] be 0
for i = 1 to n exclusive
if primes [ i ] is i
let primes [ i ] be primes [ i - 1 ] + 1
else
let primes [ i ] be primes [ i - 1 ]
declare long long vector pa
declare long long vector t
declare p with long long a as argument , returning boolean
remove all elements from t
while a is greater than 0
add ( a % 10 ) to end of t
let a be a / 10
for i = 0 to size of t / 2 exclusive
if t [ i ] is not t [ long long casted size of t - 1 - i ] , return false from function
return true
declare P , Q as long long
read P and Q
declare MX = 1300000 as long long
run sieve_of_eratosthenes ( MX )
resize pa to size MX , filling new empty with 0
for i = 1 to size of pa exclusive
if result of run p with i as argument is true
let pa [ i ] be pa [ i - 1 ] + 1
else
let pa [ i ] be pa [ i - 1 ]
for i = MX - 1 to 0 exclusive , decrementing i
if Q * primes [ i ] is less than or equal to P * pa [ i ]
print i and newline
print " Palindromic tree is better than splay tree " and newline
l1 , l2 , r1 , r2 , k , m = unsigned long long with m = 0
read l1 , r1 , l2 , r2 , k
if ( not ( r2 < l1 or r1 < l2 ) )
if ( l1 < = l2 )
if ( r1 < = r2 )
m = r1 - l2 + 1 - ( k > = l2 and k < = r1 )
else
m = r2 - l2 + 1 - ( k > = l2 and k < = r2 )
else
if ( r1 < = r2 )
m = r1 - l1 + 1 - ( k > = l1 and k < = r1 )
else
m = r2 - l1 + 1 - ( k > = l1 and k < = r2 )
declare new integer variables l1 , l2 and l3
declare new integer variables j and i , and an arrays of integers a , b , c and d with 5 elements
dx is a new array of int with 4 elements = 1 , 0 , - 1 , 0
let dy be a new array of integers with 4 values = 0 , 1 , 0 , - 1
in a for loop , change i from 1 to 3 inclusive and read a [ i ] and b [ i ] from the input on each loop
if l1 + l2 is equal to l3 or l1 + l3 is equal to l2 or l2 + l3 = l1
if l1 ! = 0 and l2 ! = 0 and l3 ! = 0
print " RIGHT "
in a for loop , change i from 1 to 3 inclusive
change c [ 1 ] to a [ 1 ] , c [ 2 ] to a [ 2 ] and c [ 3 ] to a [ 3 ]
change d [ 1 ] to b [ 1 ] , value of d [ 2 ] to b [ 2 ] and d [ 3 ] to b [ 3 ]
for j from 0 to 4 exclusive incrementing j
assign a [ i ] + dix [ j ] to c [ i ]
assign b [ i ] + diy [ j ] to d [ i ]
if l1 + l2 = l3 or l1 + l3 is equal to l2 or l2 + l3 = l1
if none of l1 , l2 and l3 is 0
print " ALMOST " to the standard output
print " NEITHER " to the standard output
declare new integer k
read variable k from the input
while k > 0
create integer variable first_row = - 1
create new integer called second_row
first_col is a new integer = - 1
create new integer variable second_col
start for loop from i = 0 to 8 exclusive incrementing i
for integer j = 0 to 8 exclusive incrementing j
declare character variable c
read from the input to c
if c is equal to ' K '
if first_col = - 1
change the value of first_row to i
assign j to first_col
else
change the value of second_col to j
set second_row to i
create new integer called dif_row = second_row - first_row
declare new integer dif_col = second_col - first_col
if dif_row is less than 0 , multiply dif_row by - 1
if dif_col is less than 0 , set dif_col to dif_col multiplied by - 1
if dif_col and dif_row modulo 4 are both 0
print " YES "
else
print " NO "
decrement k
declare constant integer maxn = 1e2 + 20
declare integer n
declare string arrays s size maxn , t size maxn , x size maxn
declare is with no arguments , returning boolean
for i = 0 to n exclusive
if s [ i ] is not t [ i ] , return 0 from function
return 1 from function
declare rotate with no arguments , returning void
for i = 0 to n exclusive
let x [ i ] be " "
for j = 0 to n exclusive , increment x [ i ] by s [ j ] [ n - i - 1 ]
for i = 0 to n exclusive , let s [ i ] be x [ i ]
declare solve with no arguments , returning boolean
for i = 0 to 2 exclusive
for i = 0 to n exclusive , reverse sort ( beginning of s [ i ] to end of s [ i ] )
for j = 0 to 4 exclusive
if result of run is , is true , return 1 from function
run rotate
read n
for i = 0 to n exclusive , read s [ i ]
for i = 0 to n exclusive , read t [ i ]
declare boolean f = 0
let f be f bitwise or result of run solve
for i = 0 to n - i - 1 exclusive , swap values between s [ i ] and s [ n - i - 1 ]
let f be f bitwise or result of run solve
print " Yes " if f is true , else " No " , print newline
create long long vector prime of size 10000005 and value 0
declare mM taking in long long ints a , b , and mod and returning long long
create long long res = 0
set a to a % mod
while b is truthy
if b & 1 is truthy , set res to ( res + a ) % mod
set a to ( 2 * a ) % mod
move bits of b 1 place to the right
return res
declare fpow taking long long ints first , second , and p and returning long long integer
set first to first % p
make long long res = 1
while second is truthy
if second & 1 is truthy , set res to ( res * first ) % p
set res to res % p
if res is less than 0 , set res to ( res + p ) % p
set second to second > > 1
set first to ( first * first ) % p
if first is less than 0 , set first to ( first + p ) % p
set first to first % p
return res
declare inv taking in long long int n and returning long long
return the result of fpow ( n , 1000000007 - 2 , 1000000007 )
declare modmul taking in long long ints first and second and returning long long
return ( ( first % 1000000007 ) * ( second % 1000000007 ) ) % 1000000007
declare modadd taking in long long ints first and second and returning long long integer
create long long temp = first % 1000000007 + second % 1000000007
set temp to temp % 1000000007
if temp is less than 0 , set temp to ( temp + 1000000007 ) % 1000000007
return temp
declare sieve
set prime [ 1 ] to 1
for i = 2 to 10000005 exclusive
if prime [ i ] is falsy
for j = i to 10000005 exclusive
if ! prime [ j ] is truthy , set prime [ j ] to i
create long long integer t
set t to 1
while t - - is truthy
create long long integer n
read n
make string vector s of size n
for i = 0 to n exclusive , read s [ i ]
make string w
create char tc
read w and tc
make long long vector check of size w . size ( ) and value 0
for i = 0 to n exclusive
for j = 0 to w . size ( ) exclusive
create string s1 = w . substr ( j , s [ i ] . size ( ) )
create bool ok = true
if size of s1 is less than size of s [ i ]
set ok to false
else do
make string temp = s [ i ]
if s1 is not equal to temp , set ok to false
if ok is truthy
for k = j while k < j + s [ i ] . size ( ) , set check [ k ] to 1
for i = 0 to w . size ( ) exclusive
if check [ i ] is truthy
create char temp = w [ i ]
if temp is greater than or equal to ' A ' and temp is less than or equal to ' Z '
set temp to temp - ' A '
else do
subtract ' a ' from temp
add ' a ' to temp
if temp is equal to tc and tc is equal to ' a '
if w [ i ] is greater than or equal to ' a ' and w [ i ] is less than or equal to ' z '
set w [ i ] to ' b '
else do
set w [ i ] to ' B '
else if temp is equal to tc and tc is not equal to ' a '
if w [ i ] is greater than or equal to ' a ' and w [ i ] is less than or equal to ' z '
set w [ i ] to ' a '
otherwise
set w [ i ] to ' A '
else
if w [ i ] is greater than or equal to ' a ' and w [ i ] is less than or equal to ' z '
set w [ i ] to tc
else do
set w [ i ] to tc - ' a ' + ' A '
new long longs rest = 0 , t , cou = 0 , minn = 1e7 , index = 1e8
a is an 2d array of long longs with size 105 by 2
read t and cou and keep looping
for integer i = 0 to t exclusive incrementing i
read from the input to a [ i ] [ 0 ] and a [ i ] [ 1 ]
if a [ i ] [ 1 ] ! = 0 and a [ i ] [ 0 ] < cou
change minn to min of minn and a [ i ] [ 1 ]
else if a [ i ] [ 0 ] < = cou
assign min of index and a [ i ] [ 1 ] to index
set rest to 100 - minn
if rest is equal to 100 or minn = 1e7
if index ! = 0
print " - 1 " to the standard output
else
print 0
else
print rest
create long longs t1 , t2 , x1 , x2 , t0 , res_x and res_y
read user input to t1 , t2 , x1 , x2 and t0
declare doubles t and ct with ct = 1e99
while x1 > = 0 & & x2 > = 0
change the value of t to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 )
if t is less than t0
decrement x1 by one
go to the start of the loop
if t is less than ct
assign t to ct
assign x1 to res_x
change the value of res_y to x2
decrement x2
print res_x , ' ' and res_y to the output stream
declare integers n , i
declare string str
read n
read str
declare integer flag = 0
declare integer count = 0
for i = 0 to i is less than i and flag is 0
if str [ i ] is not ' > '
increment count
else
let flag be 1
let flag be 0
for i = n - 1 to i is greater than or equal to 0 and flag is 0 , decrementing i
if str [ i ] is not ' < '
increment count
else
let flag be 1
print count and ' \ n '
let ans , n , mx be integers with ans = 0 , mx = 0
the boolean value of inc = 1
read n
arr = array of integers of length n + 1
for i = 1 to n inclusive , read arr [ i ]
if arr [ n ] is equal to n
mx is equal to n - 1
for i = 1 to n inclusive
if 1000 - arr [ i ] is equal to n - i , mx is equal to maximum of mx and n - i
if arr [ i ] is equal to i and i is greater than 1 , mx is equal to maximum of mx and i - 1
for i = 1 to n inclusive
if i is less than n and arr [ i ] + 1 is equal to arr [ i + 1 ]
let st , en be integers with st = i , en = - 1
for integer j = i + 1 to n inclusive
if arr [ j ] is equal to arr [ j - 1 ] + 1
proceed to next
en is equal to j - 1
stop
if en is equal to - 1 , en is equal to n
mx is equal to maximum of mx and en - st - 1
print mx and newline
n , m , i , j = int , l = 0
read n
i = 1 , while true incrementing i at end of while
j = n * i + 1
for k = 2 to j exclusive
if j is multiple of k
l = 1
break
if l is 1
print i
break
let n , d be integers
read n , d
create a vector v of integers with values n , 0
for i = 0 to n exclusive
let point be a integer
read point
v [ i ] is equal to point
let result be a long integer with result = 0
for integer right is equal to 0 , left is equal to 0 , right is less than n , increment right by 1
while v [ right ] - v [ left ] is greater than d , increment left by 1
result is equal to result + ( long long ) ( right - left ) * ( right - left - 1 ) / 2
print result and newline
declare new integer n
create new int called n
read n from the input
new integer variable thomasT with value 0
temp is a new integer with value 0
for i from 0 to 4 exclusive incrementing i
read temp from the input
change thomasT to the sum of thomasT and temp
studentTS is a new array of integers with size n - 1
assign 0 to the first n - 1 elements of studentTS
start for loop from i = 0 to n - 1 exclusive
in a for loop , change j from 0 to 4 exclusive
read variable temp from the input
change studentTS [ i ] to the sum of studentTS [ i ] and temp
sort studentTS from 0 to n - 1
create new integer variable ans with value 1
for i = 0 to n - 1 exclusive
if studentTS [ i ] is greater than thomasT , increment ans
print ans
vec = int vector array of size 3
like = string and int map
diff , ans , a , b , c = int and mat = two dimensional int array of sizes 10 and 10
in function cal returning an int
sum , i , j , k = int with sum = 0
for i = 0 to 3
for j = 0 to size of vec [ i ]
return sum
in function count taking an int now
if now is 7
if size of vec [ 0 ] and size of vec [ 1 ] and size of vec [ 2 ] are all not 0
if x [ 2 ] - x [ 0 ] is less than diff
set diff to x [ 2 ] - x [ 0 ]
set ans to cal
else if x [ 2 ] - x [ 0 ] is diff
set ans to max of ans and cal
return
for i = 0 to 3
append now to vec [ i ]
call count of now + 1
remove last value of vec [ i ]
set like [ " Anka " ] to 0
set like [ " Chapay " ] to 1
set like [ " Cleo " ] to 2
set like [ " Troll " ] to 3
set like [ " Dracul " ] to 4
set like [ " Snowy " ] to 5
set like [ " Hexadecimal " ] to 6
n , i = int
name1 , str , name2 = string
loop while reading n
set diff to ( 1 bitshift right by 31 ) - 1
for i = 0 to 3 clear vec [ i ]
set all values of mat to 0
for i = 0 to n
read name1 then str then name2
increment mat [ like [ name1 ] ] [ like [ name2 ] ]
read a then b then c
call count of 0
print diff and ans
create new array of integers cnt with 101 element
create string variable s
read user input to s
change i from 0 to length of s exclusive in a loop , incrementing cnt [ s [ i ] - ' a ' ] on each iteration
let a , b = strings
let c , d , cnt = integers
let flag = integer
while ( read a , b ) is true do the following
if the size of a is less than the size of b do the following
continue at the beginning of the loop
set flag to 1
sent cnt to 0
for i = 0 to the size of a exclusive , do the following
if a [ i ] is not equal to b [ i ] and cnt is 0 do the following
increment cnt
set c to i
else if a [ i ] is not equal to b [ i ] and cnt is 1 do the following
increment cnt
set d to i
else if a [ i ] is not equal to b [ i ] and cnt is 2 do the following
set flag to 0
exit the loop
if flag is 0
continue at the beginning of the loop
if cnt is 1 do the following
continue at the beginning of the loop
if a [ c ] is b [ d ] and a [ d ] is b [ c ]
else
signed long long int a , b , c , d , k , q , l and ou
read from the input to a , b , c , d and k
set q to max of a and c
set l to min of b and d
change ou to l - q + 1
if q < = k < = l decrement ou by one
if ou is less than 0 , set ou to 0
print ou
str1 = array of characters of length 10010
str2 = array of characters of length 10010
dp = 2d array of integers with 5050 rows and 5050 columns respectively
read str1 + 1
read str2 + 1
the integer value of lenth1 = string length of ( str1 + 1 )
the integer value of lenth2 = string length of ( str2 + 1 )
let i , j be integers
the integer value of sum = 0
for i = 1 to lenth1 inclusive
for j = 1 to lenth2 inclusive
dp [ i ] [ j ] is equal to dp [ i ] [ j - 1 ]
if str1 [ i ] is equal to str2 [ j ]
dp [ i ] [ j ] is equal to ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) modulo 1000000007
sum is equal to ( sum + dp [ i - 1 ] [ j - 1 ] + 1 ) modulo 1000000007
print sum and newline
create long longs n , m , k , cnt and mn with value of mn = 1e9
read variables n , m and k from the input
start for loop from i = 0 to n exclusive incrementing i
create new integer variable x
read the data from the input to x
if i is even , change mn to min of mn and 1ll * x
change cnt to m / ( ( n + 1 ) / 2 )
change the value of cnt to cnt multiplied by k
create long long variable ans with value min of cnt and mn
if n is even , set ans to 0
print ans to the standard output
a , b , rev , i = integers
st = string
read st
a = ( st [ 0 ] - 48 ) * 10 + ( st [ 1 ] - 48 )
b = ( st [ 3 ] - 48 ) * 10 + ( st [ 4 ] - 48 )
rev = ( st [ 1 ] - 48 ) * 10 + ( st [ 0 ] - 48 )
if a is 23 and b < 32
print 23 : 32
else if a is 23 and b > = 32
print 00 : 00
else if rev > b and rev < = 59
print st [ 0 ] , st [ 1 ] , " : " , rev
else
for i = 1
if st [ 1 ] - 48 + i > = 1 and st [ 1 ] - 48 + i < = 5
print st [ 0 ] st [ 1 ] - 48 + i , : , st [ 1 ] - 48 + i , st [ 0 ]
break loop
else if st [ 1 ] - 48 + i is 10
print st [ 0 ] - 48 + 1 , 0 : 0 , st [ 0 ] - 48 + 1
break loop
else
continue next iteration
n , m , inds = integers with inds = - 1
s , t = strings
read n , m , s , t
for i = 0 to n exclusive
if ( s [ i ] is * ) , inds = 1
if ( inds is - 1 and s is not t )
if ( m + 1 < n )
for i = n - 1 , j = m - 1 down to i > = 0 and j > = 0
if ( s [ i ] is t [ j ] )
s [ i ] = *
else if s [ i ] is *
break loop
else
for i = 0 to s . size ( ) exclusive
if ( s [ i ] is t [ i ] )
s [ i ] = *
else if ( s [ i ] is *
break loop
for i = 0 to n exclusive
if ( s [ i ] is * or s [ i ] is ' ' )
continue next iteration
else
k = integer
read k
while k > 0
first_row = integer = - 1
second_row = integer
first_col = integer = - 1
second_col = integer
for i = 0 to 8 exclusive
for j = 0 to 8 exclusive
c = character
read c
if c is K
if first_col is - 1
first_row = i
first_col = j
else
second_col = j
second_row = i
dif_row = integer = second_row - first_row
dif_col = integer = second_col - first_col
if dif_row < 0 , then dif_row = dif_row * - 1
if dif_col < 0 , then dif_col = dif_col * - 1
dif = integer = dif_col + dif_row
if dif_col modulo 4 is 0 and dif_row modulo 4 is 0
else
decrease k by 1
par is a integer array of size 200001
v is a vector of integers
n be integer
read n
for integer i = 2 to n inclusive , read par [ i ]
integer cur equals n
while cur is not 1
push cur into v
cur equals par [ cur ]
push cur into v
for integer i = 0 to size of v exclusive
print v [ i ]
if i not equals i ! = ( int ) v . size ( ) - 1 , print space
print endline
n , m , g = integers
read n and m
arr = array of integers with length 105
for i = 0 to n exclusive , print arr [ i ]
for i = n
for j = 0 to n exclusive
if arr [ j ] > 0
decrement arr [ j ] by m
if arr [ j ] < = 0
set g to j
decrement i by 1
print g + 1
int function Plos with int arguments x , y and n
declare integer variable P1
if y is equal to 0
set P1 to 1
else if y = n
set P1 to 3
else if x = 0
set P1 to 4
else if x = n
set P1 to 2
return P1
create enum Position with values p1 = 1 , p2 , p3 and p4
integer function fun2 with int arguments x1 , y1 , x2 , y2 and n , Posution argument T1 and bool argument b1
declare int variable Md = 0
looping infinitely
if T1 is equal to p1
if y1 is equal to y2
add abs ( x1 - x2 ) to Md
stop the loop
if b1 = false
increase Md by n - x1
change x1 to n
change T1 to p2 casted to Posution
else
increase Md by x1
assign 0 to x1
change T1 to p4 casted to Posution
else if T1 = p2
if x1 = x2
increase Md by abs ( y1 - y2 )
stop the loop
if b1 is false
increase Md by n - y1
set y1 to n
assign p3 casted to Posution to T1
else
add y1 to Md
change y1 to 0
assign p1 casted to Posution to T1
else if T1 = p3
if y1 = y2
add abs ( x1 - x2 ) to Md
break the loop
if b1 = false
add x1 to Md
set T1 to p4 casted to Posution
set x1 to 0
else
add n - x1 to Md
change x1 to n
assign p2 casted to Posution to T1
else if T1 = p4
if x1 is equal to x2
increase Md by abs ( y1 - y2 )
break the loop
if b1 = false
change T1 to p1 casted to Posution
increase Md by y1
change y1 to 0
else
add n - y1 to Md
change y1 to n
change T1 to p3 casted to Posution
return Md
declare int variables n , x1 , y1 , x2 and y2
create input stream ff for " file . txt "
read n , x1 , y1 , x2 and y2
if x1 is equal to x2 and y1 = y2
print 0
create ints Mv and Md = 0
declare integer P1 = Plos ( x1 , y1 , n )
create Posution T1
assign P1 casted to Posution to T1
change Mv to the result of fun2 ( x1 , y1 , x2 , y2 , n , T1 , false )
set Md to the result of fun2 ( x1 , y1 , x2 , y2 , n , T1 , true )
print min of Mv and Md
n , a = int
read n , a
mina , maxa = a , mini , maxi = 0
for i = 1 to n exclusive
read a
if a > maxa
maxa = a
maxi = i
if a < = mina
mina = a
mini = i
print maxi + ( n - 1 - mini ) - ( 1 if mini < maxi else 0 )
create a long long integer mod = 1e9 + 9
into the function qm which takes two long long integers a and b and returns a long long int
let ans be long long int with ans = 1
while b > 0 do the following
if b & 1 then set ans = ans * a % mod
set b = b > > 1
set a = a * a % mod
return ( ans % mod + mod ) % mod
c = character array of size 1000005
n , a , b , k = long long ints
read n , a , b , k
read c
create long long int ans = 0
if n + 1 < = k
for i = 0 to n inclusive
if c [ i ] = -
then set ans = ans - qm ( a , n - i ) * qm ( b , i )
set ans = ( ans % mod + mod ) % mod
set ans = ans + qm ( a , n - i ) * qm ( b , i )
set ans = ( ans % mod + mod ) % mod
set ans = ( ans % mod + mod ) % mod
print ans
create long long t = ( n + 1 ) / k
creaye long long integer g = ( n + 1 ) % k
let x = 0 be a long long integer
if g is equal to 0
for i = 0 to k exclusive
if c [ i ] is equal to -
then set x = x - qm ( a , n - i ) * qm ( b , i )
set x = ( x % mod + mod ) % mod
set x = x + qm ( a , n - i ) * qm ( b , i )
assign ( x % mod + mod ) % mod to x
if qm ( a , k ) = qm ( b , k )
then set ans = t * t
assign ( ans % mod + mod ) % mod to ans
print ans
create long long integer jj = qm ( a , t * k ) - qm ( b , t * k )
set jj = x * jj % mod
set jj = jj * qm ( a , k ) % mod
do nothing
set jj = jj % mod
create long long integer nn = qm ( a , k ) - qm ( b , k )
set nn = nn % mod
assign nn * qm ( a , t * k ) to nn
set nn = nn % mod
set nn = qm ( nn , mod - 2 )
assign jj * nn to ans
set ans to ( ans % mod + mod ) % mod
print ans
for i = 0 to k exclusive
if c [ i ] is equal to -
set x = x - qm ( a , n - i ) * qm ( b , i )
set x = ( x % mod + mod ) % mod
set x to x + qm ( a , n - i ) * qm ( b , i )
assign ( x % mod + mod ) % mod to x
if qm ( a , k ) = = qm ( b , k )
then set ans = t * x
set ans = ( ans % mod + mod ) % mod
for hh = 0 to g exclusive
if c [ hh ] is equal to -
set ans = ans - qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) )
set ans = ( ans % mod + mod ) % mod
set ans = ans + qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) )
set ans = ( ans % mod + mod ) % mod
set ans = ( ans % mod + mod ) % mod
print ans
create long long integer jj = qm ( a , t * k ) - qm ( b , t * k )
set jj to x * jj % mod
set jj = jj * qm ( a , k ) % mod
do nothing
assign jj % mod to jj
create long long integer nn = ( qm ( a , k ) - qm ( b , k ) )
set nn = nn % mod
assign nn * qm ( a , t * k ) to nn
set nn = nn % mod
set nn = qm ( nn , mod - 2 )
set ans = jj * nn
set ans = ( ans % mod + mod ) % mod
for hh = 0 to g exclusive
if c [ hh ] is -
set ans = ans - qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) )
set ans = ( ans % mod + mod ) % mod
set ans = ans + qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) )
set ans = ( ans % mod + mod ) % mod
set ans = ( ans % mod + mod ) % mod
print ans
q is a queue of integers
declare ints n and x
read input to n
declare integer variable ancnt = 0
declare int variable cnt = 1
declare int len = 0
decrement n and loop further , while n ! = 0
read x
increment len by one
if x is less than 0 , increment ancnt by one
if ancnt is greater than 2
assign 1 to ancnt
push len - 1 into q
change len to 1
push len into q
print length of q
declare integer numsize = length of q
loop i from 0 to numsize exclusive
if i ! = 0 , print " "
print first element of q
remove first element of q
if i = numsize - 1 , print new line
let n , m , ans , cnt ints and father an empty int array of length 101 , with ans and cnt = 0
let f an empty 2d bool array of size 101 by 101
in function find that takes int x and returns an int
if father [ x ] is not x , set father [ x ] = find ( father [ x ] ) and return result
return x
in function check that takes ints x and y and returns a bool
set x to find ( x )
set y to find ( y )
if x equals y , return false
set father [ x ] to y
return true
let i , j , and k ints
read n and m
for i from 1 to n , set father [ i ] to i
for i from 1 to n
read j
while ( decrement j )
read k
set f [ i ] [ k ] to true
add f [ i ] [ k ] to cnt
for i from 1 to n
for j from i + 1 to n
for k from 1 to m
if f [ i ] [ k ] and f [ j ] [ k ] , add check ( i , j ) to ans
if not cnt
print n
otherwise
print n - ans - 1
create integer n
while read n is true
create string array a with size 101
create integer set b
create integer set c
for i = 0 to n exclusive
read a [ i ]
for j = 0 to n exclusive
if a [ i ] [ j ] is ' . '
insert i into b
insert j into c
if size of b is less than n and size of c is less than n
print " - 1 " print newline
else
if size of b is n
for i = 0 to n exclusive
for j = 0 to n exclusive
if a [ i ] [ j ] is ' . '
print i + 1 print " " print j + 1 print newline
break loop
else
for i = 0 to n exclusive
for j = 0 to n exclusive
if a [ j ] [ i ] is ' . '
print j + 1 print " " print i + 1 print newline
break loop
declare string variable s
read s
if length of s < = 2
print " No "
else
for i = 0 to length of s - 2 exclusive
if s [ i ] is equal to ' A ' and s [ i + 1 ] is equal to ' B ' and s [ i + 2 ] is equal to ' C '
print " Yes "
if s [ i ] is ' C ' and s [ i + 1 ] is ' A ' and s [ i + 2 ] is ' B '
print " Yes "
if s [ i ] = ' A ' and s [ i + 1 ] = ' C ' and s [ i + 2 ] = ' B '
print " Yes "
if s [ i ] = ' B ' and s [ i + 1 ] = ' A ' and s [ i + 2 ] = ' C '
print " Yes "
if s [ i ] = ' B ' and s [ i + 1 ] = ' C ' and s [ i + 2 ] = ' A '
print " Yes "
if s [ i ] = ' C ' and s [ i + 1 ] = ' B ' and s [ i + 2 ] = ' A '
print " Yes "
print " No "
s = string
check = boolean array of size 2
d = integer array of size 100001 , width of 2 , and depth of 2
in function go with argument integer x , integer y , and integer z and returns an integer
if x > = size of s
if y and z are nonzero , then return 1
if d [ x ] [ y ] [ z ] is not - 1 , then return d [ x ] [ y ] [ z ]
d [ x ] [ y ] [ z ] = the result of calling go with arguments x + 1 , y , z
return d [ x ] [ y ] [ z ]
read s
set all values of d to - 1
if the result of calling go with arguments 0 , 0 , 0 is 1
else
let a1 , b1 , a2 , b2 , k , sum = 0 be long long
read a1 , b1 , a2 , b2 , k
let x , y be long long with x = the max of a1 , a2 , and y = the min of b1 of b2
if x > y
print 0
else if k is between x and y both inclusive
print y - x
else
print y - + 1
n = integer
read n
C = boolean array of sizes 5 , 5 with C = { }
color = string = " RGBYW "
value = string = " 12345 "
for i = 0 to n exclusive
declare a string c
read c
for i = 0 to 5 exclusive
for j = 0 to 5 exclusive
if c [ 0 ] equals color [ i ] and c [ 1 ] equals value [ j ] , set C [ i ] [ j ] to true
ans = integer set to 25
for bc = 0 as long as bc is less than 1 shifted left 5 bits with increment bc + 1
for bv = 0 as long as bv is less than 1 shifted left 5 bits with increment bv + 1
ok = boolean = true
for c = 0 to 5 exclusive
if bc shifted left c bitwise and 1 bits
t = integer = 0
for v = 0 to 5 exclusive
if bv shifted right v bitwise and 1 bits is false , add integer value of C [ c ] [ v ] to t
if t is greater than 1 , set ok to false
for v = 0 to 5 exclusive
if bv shifted right v bitwise and 1 bits
t = integer = 0
for c = 0 to 5 exclusive
if bc shifted right c bitwise and 1 bits is false , add integer value of C [ c ] [ v ] to t
if t is greater than 1 , set ok to false
t = integer = 0
for c = 0 to 5 exclusive
for v = 0 to 5 exclusive
if not ( bc shifted right c bitwise and 1 bits ) and not ( bv shifted right v bitwise and 1 bits ) , add integer value of C [ c ] [ v ] to t
if t is greater than 1 , set ok to false
if ok
a = integer set to 0
for i = 0 to 5 exclusive , add ( bc shifted right i bitwise and 1 bits ) + ( bv shifted right i bitwise and 1 bits ) to a
set ans to call min with ans , a
display ans
declare integer array a size 1000050
declare n as integer
while read n is true
declare integer sum = 0
declare one = 0 as integer
set bytes from a to size of a to value 0
for i = 0 to n exclusive
read one
increment a [ one ]
let sum be a [ 0 ] % 2
for i = 1 to 1000050 exclusive
let a [ i ] be a [ i - 1 ] / 2 + a [ i ]
if a [ i ] % 2 is 1 , increment sum
print sum , newline
declare solve
make ints n and d
read n and d
create int array a of size n
for i = 0 to n exclusive , read a [ i ]
if n is equal to 1 or n is equal to 2
print 0
return
make long long integer cnt = 0
create int r = 0
let bool b = true
for i = 0 to n - 2 exclusive
make long long int k = r - i - 2
if k is less than 0 , set k to 0
set cnt to cnt + ( k * ( k + 1 ) / 2 )
for j = r to n exclusive
if a [ j ] is less than or equal to a [ i ] + d
add max ( 0 , j - i - 1 ) to cnt
else do
set r to j
set b to false
break loop
if b is truthy
set r to n - 1
else do
set b to true
display cnt
call solve ( )
declare integers i , j , n , x , integer arrays a size 105 , l size 105
set bytes from a to size of a to value 0
read n and x
for i = 0 to n exclusive
read l [ i ]
let j be l [ i ]
increment a [ j ]
declare integer sum = 0
declare integer array b size 105
declare integer k = 0
for i = 0 to 105 exclusive
if a [ i ] is greater than 0
increment sum
for q = 0 to n exclusive
if i is l [ q ]
let b [ k ] be q + 1
increment k
end loop
sort from b to b + k
if sum is greater than or equal to x
print " YES " and newline
print b [ 0 ]
for i = 1 to x exclusive , print " " , b [ i ]
print newline
else
print " NO " and newline
n , a , b , c , ans = long long
while read n , a , b , c
ans = n / a
if n > = b and a > b - c
t = 1
add ( n - b ) / ( b - c ) to t
subtract t * ( b - c ) from n
add max ( n ( a , n / b ) to t
ans = max ( ans , t )
print ans
lang = vector array of integer of size 103
emp = vector array of integer of size 103
ans , check , n , m , a , b = integers , markl , marke = integer array of size 102
function dfs1 takes integer x
function dfs2 takes integer y
markl [ y ] = 1
for i = 0 to lang [ y ] . size ( ) exclusive
if marke [ lang [ y ] [ i ] ] is 0 , dfs1 ( lang [ y ] [ i ] )
in the function dfs1 that take integer x
marke [ x ] = 1
for i = 0 to emp [ x ] . size ( ) exclusive
if markl [ emp [ x ] [ i ] ] is 0 , dfs2 ( emp [ x ] [ i ] )
read n , m
for i = 1 to n
read a
check = check + a
while decrement a
read b
append b in emp [ i ]
append i in lang [ b ]
for i = 1 to n
if marke [ i ] is 0
increment ans
dfs1 on i
if check , decrement ans
print ans
M = 1005
type = array of 5 string filled with " byte " , " short " , " int " , " long " , " BigInteger "
border = array of 4 string filled with " 127 " , " 32767 " , " 2147483647 " , " 9223372036854775807 "
digit = array of 4 int ( 3 , 5 , 10 , 19 )
s = string
read s
ans = 4
for i = 0 to 4 exclusive
if length of s < digit [ i ]
ans = i
break
if length of s is digit [ i ]
if s < = border [ i ]
ans = i
break
print type [ ans ]
create long long integers n , k
read n read k
create integer array a with size 100001
create long long integer set q
for i = 0 to n exclusive , read a [ i ]
sort elements from a to a + n
create integer ans with ans = 0
for i = 0 to n exclusive
if first index of a [ i ] in q is end of q
insert a [ i ] * k into q
increment ans
print ans print newline
declare integer array arr size 10000
declare integer veector v
declare integer array brr size 10000
declare integer n
read n
for i = 1 to n inclusive
declare integer m
read m
let arr [ i ] be m
add m to end of v
sort from beginning of v to end of v
declare integers idx = 1 , cur
for i = n - 1 to 0 inclusive , decrementing i
if i is n - 1
let cur be v [ i ]
let brr [ idx ] be v [ i ]
else
if cur is not v [ i ]
let brr [ idx ] be v [ i ]
let cur be v [ i ]
increment idx
for i = 1 to n inclusive
for j = 1 to n inclusive
if arr [ i ] is brr [ j ] and arr [ i ] is not 0 and brr [ j ] is not 0
if i is n
print j and newline
else
print j and " "
call the function find by passing the parameters int x , int father [ ]
if father [ x ] is equal to x , return the value of x
return the value of father [ x ] where father [ x ] = find ( father [ x ] , father )
let s be a string
read s
the integer value ans is equal to 0
let n be a integer with n = length of s - 2
for i = 0 to n exclusive
let tmp be a string with tmp = s . substr ( i , 3 )
sort the values tmp . begin ( ) and tmp . end ( )
if tmp is equal to ABC
the value of ans is equal to 1
stop
if ans is true
print Yes and newline
print No and newline
a , b , c , d = integers
function check takes two integers ; t1 and t2
if t1 < t2
return 1
else if t1 > t2
return - 1
read a , b , c , d
x , y = integers set to 0
t1 , t2 = integers with t1 set to b and t2 set to d
while true is true
if check of t1 and t2 is true
add a to t1
increment x by 1
if check of t1 and t2 is - 1
add c to t2
increment y by 1
if check of t1 and t2 is 0
print t1
break
if x > 1000 or y > 1000
print " - 1 "
pa = array of 10005 pair of int , int
maxn = 3f3f3f3f in exadecimal
n , m , k , count = int
read m , n
count , k = 0
for i = 0 to n exclusive read two pa [ i ] items
while k is not m
if m > first item of pa
if second item of pa is not 0 k = m
add second item of pa to m
first item of pa = maxn
increment count
else
break
if count is not n
else
create constant N = 1e5 + 1
let long long int array of size N
let int n
read n
let arr [ 0 ] = 0
for i = 1 to N exclusive , set arr [ i ] to arr [ i - 1 ] + i
for i = 1 to N exclusive
if binary_search ( arr + 1 , arr + N , n - arr [ i ] ) is truthy
print " YES "
print " NO "
mnx = 8000009
mod = 1000000007
dx = array of 4 long long filled with - 1 , 0 , 0 , 1
dy = array of 4 long long filled with 0 , - 1 , 1 , 0
n , m = long long
s = array of 111 by 111 char
u = array of 111 by 111 bool
function check ( get long long x and y , return bool )
return 0 < x and x < n + 1 and 0 < y and y < m + 1
function dfs ( get long long x and y , return nothing )
if u [ x ] [ y ] return
u [ x ] [ y ] = true
for i = 0 to 4 exclusive
read n , m
for i = 1 to n inclusive
for j = 1 to m inclusive read s [ i ] [ j ]
qwe = 0
for i = 1 to n inclusive
for j = 1 to m inclusive
if s [ i ] [ j ] is ' # ' increment qwe
res = 11111111111111
for i = 1 to n inclusive
for j = 1 to m inclusive
if s [ i ] [ j ] is ' # '
q = 0
for k = 0 to 4 exclusive
if q + 1 < qwe res = min ( res , q )
if qwe > 1
s [ i ] [ j ] = ' 0 '
for k = 1 to n inclusive
for l = 1 to m inclusive u [ k ] [ l ] = false
cnt = 0
for k = 1 to n inclusive
for l = 1 to m inclusive
if s [ k ] [ l ] is ' # ' and not u [ k ] [ l ]
dfs ( k , l )
increment cnt
if cnt > 1 res = min ( res , 1 )
s [ i ] [ j ] = ' # '
if res is 11111111111111 subtract 11111111111112 from res
create new integer constant INF = 2147483647
define integer constant mod = 1000000007
new constant integer tmod = 1000000009
let ma be a map from characters to integers
create new array of integers vis with size 25
declare vector of integers v
declare new array of integers sum with size 25
a1 is an array of integers with 5 elements
create new array of integers a2 with size 5
declare new integer called n
read variable n from the input
assign 0 to ma [ ' R ' ]
change ma [ ' G ' ] to 1
assign the new value = 2 to ma [ ' B ' ]
set ma [ ' Y ' ] to 3
assign the new value = 4 to ma [ ' W ' ]
start for loop from i = 0 to n exclusive
define string str
read input to str
declare new integer tmp = ma [ str [ 0 ] ] * 5 + str [ 1 ] - ' 1 '
change vis [ tmp ] to 1
start for loop from i = 0 to 25 exclusive incrementing i
if vis [ i ] is true , add i to v
define integer ans = 10
in a for loop , change s from 0 to 1 < < 10 exclusive
set the values of first sizeof ( a1 ) bytes at the pointer a1 to 0
set first sizeof ( a2 ) bytes at the pointer a2 to 0
change the values of first sizeof ( sum ) bytes at the pointer sum to 0
create integer pos with value 1
for integer i = 0 to 5 exclusive
if ( s > > i ) & 1 ! = 0 , change the value of a1 [ i ] to pos and increment pos
declare integer variable with name pos2 = 1
for i from 5 to 10 exclusive
if ( s > > i ) & 1 ! = 0 , set a2 [ i % 5 ] to pos2 and increase pos2 by 1
for integer i = 0 to ( ength of v exclusive
define integer tmp with value v [ i ]
define new integer called l with value = value of a1 [ tmp / 5 ]
new integer r = value of a2 [ tmp % 5 ]
increment sum [ l * 5 + r ] by one
create new boolean flag = true
in a for loop , change i from 0 to 25 exclusive incrementing i
if sum [ i ] is greater than 1
assign the new value = false to flag
stop the loop
if flag is false , skip the rest of the loop
change ans to min of ans and pos - 1 + pos2 - 1
print ans and ' \ n '
x = int
read x
if x is 1
print - 1
else
print x , space , x
create integers n and k , and an array of ints a with size 88
create stack of integers st
read input to n and k
for i = 0 to n exclusive , read a [ i ]
declare int variable num = 0
clear st
loop i from 0 to n exclusive
if there is no a [ i ] in st
if size of st = k
create new integer set iterator it
declare ints maxpos , j and val where maxpos = - 1
for j from i to n exclusive
if value at * it = a [ j ] , break the loop
if j is greater than maxpos , set maxpos to j and val = value at * it
remove val from st
insert a [ i ] into st
increment num by one
print num
create integers n , k
create string t
read n read k read t
create integer cnt with cnt = 1
create integer pos with pos = 1
create string ans with ans = t
while cnt is less than k
if pos is greater than or equal to integer casted size of ans
increment ans by t
increment cnt
else
create boolean ok with ok = true
create integer len with len = 0
for i = 0 to integer casted size of t exclusive
if pos + i is greater than or equal to integer casted size of ans , break loop
increment len
if ans [ pos + i ] is not t [ i ] , set ok to false
if ok is true
increment ans by substring of t starting at len
increment cnt
increment pos
print ans print newline
let n be a integer
chair = array of characters of length 10000
read n
read chair + 1
chair [ 0 ] is equal to 0
chair [ n + 1 ] is equal to 0
let ans be a integer with ans = 0
if n is equal to 1 and chair [ 1 ] is equal to 0
print No and newline
if n is equal to 1 and chair [ 1 ] is equal to 1
print Yes and newline
for i = 1 to n inclusive
if chair [ i ] is equal to 1 and ( chair [ i - 1 ] is equal to 1 or chair [ i + 1 ] is equal to 1 )
ans is equal to 1
stop
if chair [ i ] is equal to 0
if chair [ i - 1 ] is equal to 0 and chair [ i + 1 ] is equal to 0
ans is equal to 1
stop
if ans is equal to 1
print No and newline
print Yes and newline
let x , t , a , b , da , db be integers
read x , t , a , b , da , db
let sum be a integer
for i = 0 to t inclusive
if i equals t
sum is equal to 0
sum is equal to a - da * i
for j = 0 to t inclusive
if j is not equal to t , increment sum by b - db * j
if sum equals x
print YES and newline
if j is not equal to t , decrement sum by b - db * j
print NO and newline
create int arrays a and b , both of length 21
create vector < int > p
create int n and m
read n and m
for i = 1 to n inclusive , read a [ i ]
for i = 1 to m inclusive , read b [ i ]
for i = 1 to n inclusive
for j = 1 to m inclusive
if b [ j ] is equal to a [ i ]
push b [ j ] onto p
continue
if p empty
print newline
else
for i = 0 to p size - 1 exclusive , print p [ i ] " "
print last element of p
s = string
while read s
b = false
for i = 2 to length of s exclusive
if s [ i - 2 ] is ' A ' and s [ i - 1 ] is ' B ' and s [ i ] is ' C ' b = true
for i = 2 to length of s exclusive
if s [ i - 2 ] is ' A ' and s [ i - 1 ] is ' C ' and s [ i ] is ' B ' b = true
for i = 2 to length of s exclusive
if s [ i - 2 ] is ' B ' and s [ i - 1 ] is ' A ' and s [ i ] is ' C ' b = true
for i = 2 to length of s exclusive
if s [ i - 2 ] is ' B ' and s [ i - 1 ] is ' C ' and s [ i ] is ' A ' b = true
for i = 2 to length of s exclusive
if s [ i - 2 ] is ' C ' and s [ i - 1 ] is ' A ' and s [ i ] is ' B ' b = true
for i = 2 to length of s exclusive
if s [ i - 2 ] is ' C ' and s [ i - 1 ] is ' B ' and s [ i ] is ' A ' b = true
if b
print " Yes "
else
print " No "
create strings str1 and str2
declare an arrays of integers num1 and num2 with size 300
read str1 and str2 and keep looping
if length of str1 ! = length of str2
print " NO "
skip the rest of the loop
for k from 0 to 300 exclusive
assign 0 to num1 [ k ]
assign 0 to num2 [ k ]
for k = 0 to length of str1 exclusive
increment num1 [ str1 [ k ] ]
increment num2 [ str2 [ k ] ]
declare integer pan = 0
for i from 0 to 300 exclusive
if num1 [ i ] ! = num2 [ i ]
print " NO "
set pan to 1
stop the loop
if pan is not 0 , skip the rest of the loop
create integer count = 0
loop i from 0 to length of str1 exclusive
if str1 [ i ] ! = str2 [ i ] , increment count
if count ! = 2
print " NO "
else
print " YES "
declare integers a , b , c , d
read a , b , c , d
declare integer array Rick size 105
declare integer array Morty size 105
let Rick [ 0 ] be b
let Morty [ 0 ] be d
for i = 1 to 100 inclusive
let Rick [ i ] be b + ( i * a )
let Morty [ i ] be d + ( i * c )
for i = 0 to 100 inclusive
for j = 0 to 100 inclusive
if Rick [ i ] is Morty [ j ]
print Rick [ i ] , newline
print " - 1 " , newline
s = string
read s
ones = int with ones = 0
zeros = int with zeros = 0
ans = string with ans = " "
contains_0 = int with contains_0 = 0
for j = 0 to length of s
if s [ j ] is ' 0 '
set contains_0 to 1
break
i = int with i = 0
if contains_0 is 0 increment i
for i to length of s
if s [ i ] is ' 1 '
append ' 1 ' to ans
else if s [ i ] is ' 0 '
increment i
break
for i to length of s append s [ i ] to ans
print ans
MAXINT = const int with MAXINT = 2147483640
MAXLL = const long long with MAXLL = 9223372036854775800LL
MAXN = const long long with MAXN = 1e6
eps = const double with eps = 1e - 9
mod = const long long with mod = 998244353
dp = 3d array of long long of size [ 100006 ] [ 202 ] [ 2 ] , pref = 2d array of size [ 300 ] [ 2 ]
n = long long , a = integer array of size MAXN
call srand on time ( 0 )
read n
for i = 1 to n , read a [ i ]
if a [ 1 ] is - 1
for i = 1 to 200 dp [ 1 ] [ j ] [ 0 ] = 1
else
dp [ 1 ] [ a [ 1 ] ] [ 0 ] = 1
for i = 2 to n
for j = 1 to 200
if a [ i ] is - 1
for cur = 1 to 200
sum = long long with sum = 0
( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod
sum = pref [ cur - 1 ] [ 1 ] + pref [ cur - 1 ] [ 0 ]
else
sum = long long with sum = 0
cur = long long with cur = a [ i ]
( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod
sum = 0
ans = long long with ans = 0
create integers n , m , sum with sum = 0
read n
for i = 0 to n exclusive
read m
increment sum by m
if n - sum is minimum of 1 and n - 1
print " YES "
else
print " NO "
n , m = int
read n then m
s , t = string
read s then t
p = int with p = - 1
ans = int with ans = 0
for i = 0 to n
if s [ i ] is ' * '
set p to i
break
if p > - 1
if n > m + 1
set ans to 0
else
n1 , n2 , m1 , m2 = string
set n1 to substr of 0 , p on s
set n2 to substr of p + 1 , n on s
set m1 to substr of 0 , p on t
set m2 to substr of m - size of n2 , m on t
if n1 is m1 and n2 is m2
set ans to 1
else
set ans to 0
else
if s is t
set ans to 1
else
set ans to 0
if ans is 1
print " YES "
else
print " NO "
t = integer
read t
while t is true , decrement t and do the following
maze = character array of size 10 by 10
flag , sx , sy , gx , gy = integers with flag = 0
for i = 0 to 8 exclusive
for j = 0 to 8 exclusive
read maze [ i ] [ j ]
if maze [ i ] [ j ] is equal to K and flag is 0
then increment flag
set sx = i
assign j to sy
else if maze [ i ] [ j ] is K and flag is 1
increment flag
set gx to i
gy = j
create integer a and b
set a = absolute value of sx - gx
set b = abs ( gy - sy )
if a mod 4 is 0 and b mod 4 is 0
mod = 1000000007
dp0array of 5005 by 5005 int
a , b = string
read a , b
len1 = length of a
len2 = length of b
for i = 1 to len1 inclusive
for j = 1 to len2 inclusive
dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) modulo mod
ans = 0
for i = 1 to len1 inclusive ans = ( ans + dp [ i ] [ len2 ] ) modulo mod
print ans
students = integer
while ( read students )
i , j , k = integers
arr = integer array of size 1010
for i = 0 to students exclusive
count , temp = integers with count = 0
for j = 0 to 3
print temp
count = count + temp
arr [ i ] = count
roll = integer with roll = 1
for i = 1 to students exclusive
if ( arr [ i ] > arr [ 0 ] ) , increment roll
print roll
let l1 , s1 , r1 , p1 , l2 , s2 , r2 , p2 , l3 , s3 , r3 , p3 , l4 , s4 , r4 , p4 be integers
read l1 , s1 , r1 , and p1
read l2 , s2 , r2 , and p2
read l3 , s3 , r3 , and p3
read l1 , s4 , r4 , and p4
if ( l1 or s1 or r1 ) and p1
print YES
if ( l2 or s2 or r2 ) and p2
print YES
if ( l3 or s3 or r3 ) and p3
print YES
if ( l4 or s4 or r4 ) and p4
print YES
if l1 and p4
print YES
if s1 and p3
print YES
if r1 and p2
print YES
if l4 and p3
print YES
if s4 and p2
print YES
if r4 and p1
print YES
if l3 and p2
print YES
if s3 and p1
print YES
if r3 and p4
print YES
if l2 and p1
print YES
if s2 and p4
print YES
if r2 and p3
print YES
print NO
a , b , s = integers
read a , b , s
if ( abs ( a ) + abs ( b ) is s )
else if ( abs ( a ) + abs ( b ) > s )
else
if ( ( s - ( abs ( a ) + abs ( b ) ) ) modulo 2 is 0 )
else
long long integer as n , m , k , l
read n , m , k , l
if k + l is greater than n then do the following
output - 1
if n / m * m is less than l + k then do the following
output - 1
long long integer as ans = ( l + k ) / m
if l + k modulo m is not equal to 0 then add one to ans
if ans * m is greater than n then do the following
output - 1
else
output ans
create boolean z with z = false
create integers n , x , a
read n
set bytes from nega to size of nega to value 0
set bytes from posi to size of posi to value 0
for i = 0 to n exclusive
read x read a
if x is less than 0
set nega [ - x ] to a
increment ne
increment sumne by a
else
set posi [ x ] to a
increment sumpo by a
set po to n - ne
if po is ne
print sumne + sumpo print newline
if po is less than ne
set sumne to 0
create integer cont with cont = 0
for i = 0 to cont is less than po + 1 , incrementing i
if nega [ i ] is not 0
increment sumne by nega [ i ]
increment cont
if po is greater than ne
set sumpo to 0
create integer cont with cont = 0
for i = 0 to cont is less than ne + 1 exclusive
if posi [ i ] is not 0
increment sumpo by posi [ i ]
increment cont
print sumne + sumpo print newline
s = array of 10000010 char
num = array of 100010 int
n = int
i = int
flag = false
read n
getchar ( )
gets ( s )
for i = 0 to n exclusive
increment num [ s [ i ] - ' a ' ]
if num [ s [ i ] - ' a ' ] > 1 or n is 1 flag = true
if flag
print " Yes "
else
print " No "
create constant double with name PI = acos of - 1
declare new constant integer called MAX with value 2e9 + 7
MOD is a new constant integer with value 1000000007
create a map from integers to long longs with name m
define function solve
create new integer a
read user input to a
create new string called s
read s
declare long long n = length of s
total is a new long long with value 0
declare new array of integers p with n elements
start for loop from i = 0 to n exclusive
if i is false
change the value of p [ i ] to s [ i ] - ' 0 '
else
assign p [ i - 1 ] + ( s [ i ] - ' 0 ' to p [ i ] ) casted to int
for len = 1 to n inclusive incrementing len
for i = 0 to n exclusive
create new integer variable sum with value p [ i + len - 1 ]
if i is not 0 , change sum to sum - p [ i - 1 ]
increment m [ sum ]
increment total
if a = 0
print total * m [ 0 ] * 2 - m [ 0 ] * m [ 0 ]
return
create new long long called ans with value 0
for i from 1 to the square root of a inclusive incrementing i
if a % i is equal to 0
if i is equal to the square root of a
change ans to ans + ( ( m [ i ] * ( m [ i ] - 1 ) ) + m [ i ] )
else
increase ans by 2 * ( m [ i ] * m [ a / i ] )
print ans
call method solve ( )
create int n , i , t , e and answer , set n = 0 , i = 0 , t = 0 , e = 0
create string s
read s
for I = 0 to I different from length of s
if s [ I ] = n
increment n
else if s [ I ] = i
increment i
else if s [ I ] = e
add 1 to e
else if s [ I ] = t
t = t + 1
n = ( n - 1 ) / 2
set e = e / 3
set answer to min of ( n , min ( e , min ( i , t ) ) )
print answer
declare arr size 1300006 as integer array = { }
let arr [ 1 ] be 1
for i = 2 to square root of 1300006 inclusive
for j = i * i to 1300006 exclusive , incrementing j by i
if i % 2 is 0 and i is not 2 , end loop
let arr [ j ] be 1
declare long doubles c = 0 , c2 = 0
declare a , b as long longs
read a , b
declare unsigned long long maxi = 1
for i = 1 to 1300006 exclusive
if not arr [ i ] , increment c by b
declare stringstream x
declare string s
let x be x bitshift left i
let s be string version of x
declare string news = s
reverse sort from beginning of s to end of s
if news is s , increment c2 by a
if c2 is greater than or equal to c , let maxi be maximum of maxi and i
set cout flag fixed , set cout precision to 0 , print maxi and newline
declare integers a , b , , s
read a , b , s
declare integer dis = absolute value of a + absolute value of b
print " Yes " if dis is less than or equal to s and dis % 2 is s % 2 , else " No " , newline
create string time
read time
make integer vector t of size 4
set t [ 0 ] to time [ 0 ] - ' 0 '
set t [ 1 ] to time [ 1 ] - ' 0 '
set t [ 2 ] to time [ 3 ] - ' 0 '
set t [ 3 ] to time [ 4 ] - ' 0 '
create integer count = 0
loop indefinitely
if t [ 0 ] is equal to t [ 3 ] and t [ 1 ] is equal to t [ 2 ] , break loop
set t [ 3 ] to t [ 3 ] + 1
if t [ 3 ] is greater than 9
set t [ 2 ] to t [ 2 ] + 1
set t [ 3 ] to 0
if t [ 2 ] is greater than 5
add 1 to t [ 1 ]
set t [ 2 ] to 0
set t [ 3 ] to 0
if t [ 0 ] is not equal to 2 and t [ 1 ] is greater than 9
set t [ 0 ] to t [ 0 ] + 1
set t [ 1 ] to 0
set t [ 2 ] to 0
set t [ 3 ] to 0
if t [ 0 ] is equal to 2 and t [ 1 ] is greater than 3
set t [ 0 ] to 0
set t [ 1 ] to 0
set t [ 2 ] to 0
set t [ 3 ] to 0
increment count
the constant integer value of oo = 0x3f3f3f3f
the constant double value of PI = 2 * acos ( 0 . 0 )
let x , t , a , b , da , db be integers
in the boolean function solve
for i = 0 to t exclusive
for j = 0 to t exclusive
if a - i * da + b - j * db is equal to x or a - i * da is equal to x or b - j * db is equal to x , return 1
read x , t , a , b , da , db
if not x
print YES and newline
if solve ( ) , print YES and newline else print NO and newline
create int array win of size 300005 containing { 0 }
let ints n and m
read n and m
create integer set knight
for i = 1 to n , insert i into knight
for i = 0 to m exclusive
let ints a , b , and c
read a , b , and c
create int set iterators s , e , and p
set s to first value of knight comparing less
set e to first value of knight comparing greater
if the value of 3 is less than or equal to b , set e to the following value
for p = s to p ! = e
if the value of p is c
set p to the following value
otherwise
set win [ * p ] to c
erase the following value after p
for i = 1 to n
if i is not equal to 1 , print ' '
print win [ i ]
print new line
s , n , i = integers
dragon = multimap from int to int
temp = pair of int and int
r = pair of multimap < int , int > iterator and multimap < int , int > iterator
it1 , it2 = multimap from int to int iterator
print s , n
for i = 0 to n - 1
read temp . first , temp . second
insert temp in dragon
for it1 = dragon . begin ( ) to it1 is not dragon . lower_bound ( s )
r = dragon . equal_range ( first of it1 )
for it2 = r . first to it2 is not r . second , s = s + second in it2
decrement it1
if it1 is dragon . end ( )
print YES
else
print NO
n = integer
read n
mx , crr = integer array of size n
mxn = integer with mxn = INT_MIN
for i = 0 to cast to integer n exclusive
tmp , val , m = integer with tmp = INT_MIN
read m
crr [ i ] = m
for j = 0 to cast to integer m
read val
tmp = max of tmp and val
mx [ i ] = tmp
mxn = max of mxn and tmp
ans = long long integer with ans = 0
for i = 0 to cast to integer n , ans = ans + ( 1LL * ( mxn - mx [ i ] ) * crr [ i ] )
define function lcm which takes in long long integers , a , b , and c as arguments
let ans be a long long integer and set its value to a * b / __gcd ( a , b )
set ans to ( ans * c ) / __gcd ( ans , c )
return the value of ans
let n be a long long integer
read in n
let maxim be a long long integer and set its value to - 1
for i = 0 iterate until i is greater than or equal to the max of 1LL and n - 6
for j = n iterate until j is greater or equal to the max of 1LL and n - 6
for k = n iterate until k is greater than or equal to the max of 1LL and n - 6 , set maxim to the max of lcm ( i , j , k ) and maxim
print maxim
create integer n
declare is_x1 with integers a , b as arguments , returning integer
if b is 0 and a is greater than or equal to 0 and a is less than or equal to n , return 1 from function
declare is_x2 with integers a , b as arguments , returning integer
if b is n and a is greater than or equal to 0 and a is less than or equal to n , return 3 from function
declare is_y1 with integers b , a as arguments , returning integer
if b is 0 and a is greater than 0 or equal to 0 and a is less than or equal to n , return 4 from function
declare is_y2 with integers b , a as arguments , returning integer
if b is n and a is greater than or equal to 0 and a is less than or equal to n , return 2 from function
create integer t
create integers x1 , x2 , y1 , y2 , j
read n read x1 read y1 read x2 read y2
create integers value1 , value2 , val , a , b , set val to 0
for i = 0 to 2 exclusive
if i is 0
set a to x1 , set b to y1
else
set a to x2 , set b to y2
set j to 1
while not val
if j is 1
set val to result of run is_x1 with a , b as arguments
else if j is 2
set val to result of run is_y1 with a , b as arguments
else if j is 3
set val to result of run is_x2 with a , b as arguments
else if j is 4
set val to result of run is_y2 with a , b as arguments
increment j
if i is 0
set value1 to val
else
set value2 to val
set val to 0
if value1 is value2
if value1 is 1 or value1 is 3
print absolute value of ( x1 - x2 ) print " \ n "
else
print absolute value of ( y1 - y2 ) print " \ n "
else if ( value1 is 1 and value 2 is 2 ) or ( value1 is 2 and value 2 is 1 )
if value1 is 1
print ( n - x1 ) + y2 print " \ n "
else
print ( n - x2 ) + y1 print " \ n "
else if ( value1 is 1 and value2 is 4 ) or ( value1 is 4 and value2 is 1 )
if value1 is 1
print x1 + y2 print " \ n "
else
print x2 + y1 print " \ n "
else if ( value1 is 2 and value 2 is 3 ) or ( value1 is 3 and value2 is 2 )
if value1 is 2
print ( n - y1 ) + ( n - x2 ) print " \ n "
else
print ( n - y2 ) + ( n - x1 ) print " \ n "
else if ( value1 is 3 and value2 is 4 ) or ( value1 is 4 and value2 is 3 )
if value1 is 3
print x1 + n - y2 print " \ n "
else
print x2 + n - y1 print " \ n "
else if ( value1 is 1 and value2 is 3 ) or ( value1 is 3 and value2 is 1 )
print minimum of x1 + n + x2 and n - x1 + n + n - x2 print " \ n "
else if ( value1 is 2 and value2 is 4 ) or ( value1 is 4 and value2 is 2 )
print minimum of y1 + n + y2 and n - y1 + n + n - y2 print " \ n "
a = unsigned long long array of size 2000000
b = unsigned long long array of size 2000000
n = integer
in the function judge that takes integer n and returns bool
for i = 0 to n - 1 exclusive
if a [ i ] is a [ i + 1 ] , return true
return false
while read n
set all contents of a to 0
for i = 0 to n exclusive
read a [ i ]
increment b [ a [ i ] ]
sort a and a + n
ans = integer with ans = 0
for i = 1 to 2000000 exclusive
b [ i ] = b [ i ] + ( b [ i - 1 ] / 2 )
b [ i - 1 ] = b [ i - 1 ] modulo 2
ans = ans + b [ i - 1 ]
print ans
declare constant integer N = 1e5 + 10
declare long longs n , a , m , d
declare long long array t size N , long long da
declare nextDiv with long longs bound , div as arguments , returning long long
return ( bound if bound % div is 0 , else bound + div - bound % div )
declare nextDiv with long longs bound , num , div as arguments , returning long long
if ( bound % div is 0 ) return bound + num * div
return result of run nextDiv ( bound , div ) + ( num - 1 ) * div
declare prevDiv with long longs bound , div as arguments , returning long long
return bound if bound % div is 0 , else bound - bound % div
declare numDiv with long longs L , R , div as arguments , returning long long
return result of run prevDiv ( R , div ) / div - result of run prevDiv ( L - 1 , div ) / div
declare numOpen with long longs L , R as arguments , returning pair of long long , long long
declare long long realR = minimum of ( R and n * a )
declare long long xx = result of numDiv ( L , realR , a )
if xx is less than or equal to da , return { 1 , result of run nextDiv ( L , a ) + d }
declare long long noob = xx - da if xx % da is 0 , else xx - xx % da
declare long long nextt = result of run nextDiv ( L , noob , a )
if xx % da is 0 , return { xx / da , nextt + d }
return { 1 + xx / da , nextt + d } from function
declare special with long long bound as argument , returning long long
declare long long cur = result of run nextDiv ( bound + 1 , a )
if n is less than result of run numDiv ( a , bound , a ) , return 0 from function
declare long long numLeft = n - result of run numDiv ( a , bound , a )
if numLeft is greater than 0
return first element of result of run numOpen ( cur , result of run nextDiv ( cur , numLeft - 1 , a ) )
else
declare solve with no arguments , returning void
declare long long cur = minimum of ( a , t [ 1 ] )
declare long long pt = 1
declare long long ans = 0
while pt is less than or equal to m
if cur is not t [ pt ]
declare pair of long long , long long xop = result of run numOpen ( cur , t [ pt ] - 1 )
increment ans by first element xop
while pt is less than or equal to m and t [ pt ] is less than or equal to second element of xop , increment pt
if pt is m + 1
increment ans by result of run special ( second element of xop )
end loop
let cur be t [ pt ]
else
increment ans
declare long long neo = pt
while pt is less than m and t [ pt + 1 ] - t [ neo ] is less than or equal to d , increment pt
if pt is m
increment ans by result of run special ( t [ neo ] + d )
end loop
increment pt
let cur be t [ pt ]
print ans and ' \ n '
read n , m , a , d
for i = 1 to m inclusive , read t [ i ]
let da be result of run numDiv ( a , a + d , a )
run solve
declare long long array a size 1000 by 1000
declare long long q
declare fun with long long i as argument , returning long long
for j = 0 to 1000 exclusive
if a [ i ] [ j ] is not 0 , return minimum of ( result of run fun ( j ) and a [ i ] [ j ] )
let q be i
return INT_MAX from function
declare long long vector array vid size 3
end statement
declare n , p as long long
read n and p
declare x , y , z as long long
for i = 0 to p exclusive
read x , y , z
let a [ x - 1 ] [ y - 1 ] be z
for i = 0 to n exclusive
declare long long j
for j = 0 to n exclusive
if a [ j ] [ i ] is not 0 , end loop
if j is n
declare integer k = result of run fun with i as argument
if q is not i
add i to end of vid [ 0 ]
add k to end of vid [ 2 ]
add q to end of vid [ 1 ]
print size of vid [ 0 ] and newline
create ints i , j , k , m , n , and l and int array ans of size 20000
create char arrays a of size 20000 , b of size 20000 , c of size 20000 , and d of size 20000
for i = 0 to 20000 exclusive , set ans [ i ] to 0
read a
read d
set m to strlen ( d )
for i = 0 to m - 1 exclusive , set b [ i ] to ' '
append a to b
set n to strlen ( b )
for i = n to m + n - 1 exclusive , set b [ i ] to ' 0 '
set l to m
for i = 0 to n exclusive
for k = i to i + 1 exclusive , set c [ k - i ] to b [ k ]
for j = 0 to l exclusive
if d [ j ] is equal to c [ j ] , increment ans [ i ]
sort ans using argument ans + n + 1
print m - ans [ i ]
mp = long long , long long map
i , j , a , ans , cnt , n = long long with ans = 0
s = string
read a then s
set n to size of s as int
for i = 0 to n decrement s [ i ] by 48
for i = 0 to n
set cnt to 0
for j = i to n
increment cnt by s [ j ]
increment mp [ cnt ]
for i = 0 to n
set cnt to 0
for j = i to n
increment cnt by s [ j ]
if cnt and a are both 0
increment ans by ( n * ( n + 1 ) ) / 2
else if cnt is not 0 and a is a multiple if cnt and mp contains key a / cnt
increment ans by mp [ a / cnt ]
n = integer
read n
ans = bool with ans = false
sqr = integer with sqr = ceil ( sqrt ( 2 * n ) )
for i = 1 to sqr
for j = i to sqr
if i * ( i + 1 ) + j * ( j + 1 ) is 2 * n
ans = true
break loop
if ( ans ) break loop
if ans print YES , else NO
d = inta rray of size 30
t = int array of size 7
ne , me = int
n , m = int
in function check returning a bool
tn = int with tn = 0
b = int with b = 1
for i = 0 to ne
add t [ i ] * b to tn
set b to b * 7
set b to 1
tm = int with tm = 0
for i = ne to me
add t [ i ] * b to tm
set b to b * 7
return tn is less or equal to n and tm is less or equal to m
ans = int with ans = 0
in function dfs0 taking an int p
if p is greater or equal to me
add value of check to ans
return
for i = p to me
call swap on t [ p ] and t [ i ]
call dfs0 on p + 1
call swap on t [ p ] and t [ i ]
in function dfs1
for s = 1 bitshift left 7 - 1 decrement s while s is greater than 0
cnt = int with cnt = 0
for j = 0 to 7
if s bitshift right j bitwise - and 1 is true then set t [ cnt ] to j then increment cnt
if cnt equals me then call dfs0 of 0
read n then m
decrement n
decrement m
set ne to 0
dn , dm = int with dn = n and dm = m
if dn equals 0
increment ne
else
loop while dn is not 0
set d [ ne ] to dn mod 7 then increment ne
set dn to dn / 7
set me to ne
if dm equals 0
increment me
else
while dm is not 0
set d [ me ) to dm mod 7 then increment me
set dm to dm / 7
if me is greater than 7
print 0
else
call dfs1
print ans
s is a new array of characters with size 1005
n is a new integer
read n from the user input
read the value of s + 1 from the input
declare integers cnt , cnt0 , cnt1 = 0 and l = n / 2
if n is odd increment l by one
for i = 1 to n inclusive
change cnt to cnt + s [ i ] - ' 0 '
if s [ i ] = ' 0 ' , increment cnt0 and assign 0 to cnt1
if s [ i ] is equal to ' 1 ' , increment cnt1 and assign the new value = 0 to cnt0
if cnt0 = 3 or cnt1 is equal to 2
print " No "
if n = 1 and s [ 1 ] is equal to ' 0 '
print " No "
print " No "
else
print " Yes "
declare array of integers a of size 500010
create integer n
read n
read n values into array a
create integer ans = 0
let l and r be integers
let i be an int and for i = 0 to i = n exclusive
set l to i
assign i + 1 to r
while r is less than n and a [ l ] is not equal to [ r ]
increment l
r = r + 1
set l to i + 1
r = r - 2
create int num = 0
while l is less than or equal to r
set a [ l ] to a [ l - 1 ]
set a [ r ] to a [ r + 1 ]
increment l
decrement r
increment num
assign max of ans and num to ans
print ans
print n values of array a separated by a space
print a [ n - 1 ]
define function power which takes in long integers x and y as parameters
let temp be a long long integer
if y is equal to 0 , return 1
set temp to power ( x , y / 2 )
if y is even
return the value of temp * temp
or else
if y is greater than 0
return the value of x * temp * temp
or else
return the value of ( temp * temp ) / x
let prime be an array of booleans of size 10000000
define function sieve
set every value in prime to true
set prime [ 0 ] and prime [ 1 ] to false
for p = 2 to p * p < = 10000000
if prime [ p ] is true
for i = p * 2 to i < = 10000000
define function gcd which takes in long long integers a and b as arguments
if a is equal to 0 , return the value of b
return the greatest common denominator of b % a and a
let n , m , k , and l be integers
read in n , m , k and l
if m is greater than n or l is greater than n - k
print - 1 and a newline
let x be a long long integer
set x to ( k + l ) / m
if ( k + l ) % m is not equal to 0 , increment x
if m * x is greater than n
print - 1 and a newline
or else
print x and a newline
create integers a , b , c , and d
read a , b , c , and d
if b - a is equal to c - b and d - c is equal to c - b
print d + c - b
else do
create double m = 1 . 0 * b / a
if m * b is equal to c and m * c is equal to d
make double k = d * m
let integer kk = d * m
if kk is equal to k
print kk
print 42
s , t = strings with s = array of size 105
sl , tl = strings with sl = array of size 105
ok = array of 105 bool
n = integer
in the function getLower that takes string s and returns string
for i = 0 to s . size ( ) exclusive , s [ i ] = tolower ( s [ i ] )
return s
read n
i , j , k = integers
for i = 0 to n exclusive
read s [ i ]
sl [ i ] = getLower of s [ i ]
read t
tl = getLower of t
letterchar = character
read letter
len = integer with len = t . size ( )
for i = 0 to n exclusive
m = integer with m = s [ i ] . size ( )
for j = 0 to len - m
if ( tl . substr ( j , m ) is sl [ i ] )
for k = 0 to m exclusive , ok [ j + k ] = 1
for i = 0 to len exclusive
if ( ok [ i ] )
flag = bool with flag = isupper ( t [ i ] )
if ( tl [ i ] is letter )
if ( letter is a )
t [ i ] = b
else
t [ i ] = a
else
t [ i ] = letter
if ( flag ) , t [ i ] = toupper ( t [ i ] )
print t
declare constant integer N = 1e5 + 7
declare constant string array s = { " lios " , " liala " , " etr " , " etra " , " initis " , " inites " }
declare map from string to integer mp
declare string array h size N
declare integer a size N
declare inline get_s with string address s as argument , returning integer
if size of s is less than 3 , return 0 from function
for i = 3 to 6 inclusive
if i is greater than size of s , return 0 from function
declare integer cnt = 0
for i = 0 to 6 exclusive , let mp [ s [ i ] ] be i + 1
while ( read h [ cnt ] ) , increment cnt
declare booleans f1 = 0 , f2 = 0
for i = 0 to cnt exclusive
let a [ i ] be result of run get_s ( h [ i ] )
if not a [ i ] , return 0 * print " NO "
let f1 be f1 bitwise or ( bitwise and 1 ) , let f2 be f2 bitwise or ( bitwise not a [ i ] bitwise and 1 )
if cnt is 1 , return 0 * print " YES "
if f1 and f2 , return 0 * print " NO "
for i = 0 to cnt exclusive , increment a [ i ] by 1 , let a [ i ] be a [ i ] bitshift right 1
declare integer p = 0
while p is less than cnt - 1 and a [ p ] is a [ p + 1 ] and a [ p ] is 1 , increment p
if a [ p ] is 1
increment p
else if a [ p ] is 3
return 0 * print " NO "
if a [ p ] is not 2
return 0 * print " NO "
else
increment p
while p is less than cnt
if a [ increment p ] is not 3 , return 0 * print " NO "
if a [ increment p ] is not 3 , return 0 * print " NO "
declare char array a with size 1000000
read input to a
declare integer variable n = length of a
loop i from 0 to n - 2 exclusive
declare integers x , y and z = 0
set x to 1 if a [ i ] = ' A ' or a [ i + 1 ] = ' A ' or a [ i + 2 ] is equal to ' A '
set y to 1 if a [ i ] = ' B ' or a [ i + 1 ] is ' B ' or a [ i + 2 ] = ' B '
set z to 1 if a [ i ] is equal to ' C ' or a [ i + 1 ] = ' C ' or a [ i + 2 ] = ' C '
if x is true and y is true and z is true
print " Yes "
else
change x to 0
change y to 0
change z to 0
print " No "
n , s = integers
read n , s
arr = integer 2d array of size [ n ] [ 2 ]
for i = 0 to n exclusive , read arr [ i ] [ 0 ] , arr [ i ] [ 1 ]
m = integer with m = n
ff = bool with ff = false
while decrement m
j , mx = integer with mx = - 1
f = bool with f = false
for i = 0 to n exclusive
if s > arr [ i ] [ 0 ] and arr [ i ] [ 0 ] is not - 1
f = true
if arr [ i ] [ 1 ] > mx
mx = arr [ i ] [ 1 ]
j = i
if not f
ff = true
break loop
else
s = s + mx
arr [ j ] [ 0 ] = - 1
if ff
else
in the function gcd that takes integer a , b and returns integer
return if b , gcd ( b , a % b ) else a
in the function lcm that takes integer a , b and returns integer
return a / gcd ( a , b ) * b
in the function lcm that takes integer pointer arr and integer n and returns integer
r = integer with r = arr [ 0 ]
for i = 1 to n exclusive , r = lcm of r and arr [ i ]
return r
in = bool array of size 101 with in = { }
cycle = integer array of size 101
target = integer array of size 101
n = integer
read n
for i = 1 to n
read target [ i ]
if in [ target [ i ] ]
print - 1
in [ target [ i ] ] = true
for i = 1 to n
current = integer with current = i
cycle [ i ] = 0
do
current = target [ current ]
cycle [ i ] = cycle [ i ] + cycle [ i ] 1
while current is not i
if ( ( cycle [ i ] bitwise and 1 ) is 0 ) , cycle [ i ] = right shift cycle [ i ] 1 place
print lcm ( cycle + 1 , n )
declare new integer variable n
read n and keep looping
s is an array of characters with 1004 elements
read s + 1 from the input
declare new integer variable flag with value 1
start for loop from i = 1 to n inclusive
if s [ i ] is equal to ' 1 '
else
if flag is set
print " Yes " to the standard output
else
print " No "
let c be a character array of size 1000
let res be an integer array of size 1000
let l , mn , pl , n be integers with pl = 1
ch = character
input ch
while input ch
if ch is the character = , break
set c [ l ] to ch
if c [ l ] is the character +
increment pl
else
increment mn
increment l
input ch
input n
if n * pl - nm is less than n or pl - n * mn is greater than n
else
for i = 0 to 1 inclusive , set res [ i ] to 1
d is an integer with d = n - ( pl - mn )
for i = 0 to 1 inclusive
if ( i equals 0 or c [ i - 1 ] equals the character + ) and d is greater than 0
if d is less than n - res [ i ]
add d to res [ i ]
set d to 0
else
subtract n - res [ i ] from d
res [ i ] is assigned n
else if i isn ' t 0 and c [ i - 1 ] equals the character - and d is less than 0
if - d is less than n - res [ i ]
add - d to res [ i ]
set d to 0
else
add n - res [ i ] to d
set res [ i ] to n
output res [ 0 ]
for i = 0 to 1 exclusive , output the character space , c [ i ] the character space , and res [ i + 1 ]
output the string " = " and n
create integers a , b , c
while read a
create integer arrays r1 , r2 with r1 size 100 , r2 size 100 , create integer d
create integer vector v
for b = 1 to a inclusive , set r1 [ b ] to r2 [ b ] to 0
for b = 1 to a * a inclusive
read c read d
if r1 [ c ] is 0 and r2 [ d ] is 0
add element b to end of v
set r1 [ c ] to 1
set r2 [ d ] to 1
for c = 0 to size of v exclusive
if c is 0
print v [ c ]
else
print " " print v [ c ]
print newline
remove all elements from v
declare long longs i1 , r1 , i2 , r2 , k
declare long long time
while ( read i1 , r1 , i2 , r2 , k is true )
declare long long i = maximum of i1 and i2
declare long long r = minimum of r1 and r2
if i is less than or equal to r
if i is less than or equal to k and k is less than or equal to r
let time be r - i
else
let time be r - i + 1
else
let time be 0
print time and newline
create string s
create ints f1 and f2
read s
create int len = s length
create int st = - 1 and en = - 2
for i = 0 to len - 1 inclusive
if f1 is equal to 0 and s [ i ] is equal to ' a ' , continue
set f1 to 1
if f2 is equal to 0
set st to i
set f2 to 1
if s [ i ] is equal to ' a ' , break
set en to i
for i = st to en inclusive , subtract 1 from s [ i ]
if not f1 , set s [ len - 1 ] to ' z '
print s
function solve ( get long long n , return long long )
if n < = 9 return n + 1
dig = array of 20 int
c = 0
ret = 0
p10 = 1
while n
multiply p10 by 10
dig [ c ] = n modulo 10
divide n by 10
increment cnt
p100 = 100
for i = 2 to c exclusive
add 9 * ( p100 / 100 ) to ret
divide p100 by 10
add 10 to ret
h = 0
for i = c - 2 to 1 inclusive by - 1
multiply h by 10
add dig [ i ] to h
add ( dig [ c - 1 ] - 1 ) * p10 / 100 to ret
add h to ret
if dig [ c - 1 ] < = dig [ 0 ] increment ret
return ret
l , r = long long
function chk ( get int n , return bool )
dig = array of 20 int
c = 0
ret = 0
p10 = 1
while n
multiply p10 by 10
dig [ c ] = n modulo 10
divide n by 10
increment cnt
if dig [ c - 1 ] is dig [ 0 ] return true
return false
read l , r
print solve ( r ) - solve ( l - 1 )
let i , j , cnt be long long with cnt = 0x3f3f3f3f3f3f3f3f
in int function exgcd that takes args int a , b , & x , & y
if b is 0 then
set x to 1
set y to 0
return a
let g = int = exgcd of b , a mod b , y and x
decrement y by a / b * x
return g
let a , b , c , d , x , y , t be ints
read a , b , c and d
let g = int = exgcd of a , - c , x , y
if ( d - b ) mod g isn ' t 0 then print - 1 and new line , then exit 0
multiply y by ( d - b ) / g
multiply x by ( d - b ) / g
if b - d is positive or 0
set t to the max of x / g and - c / g
set x to ( x mod t + t ) mod t
set cnt to a * x + b
else
set t to the max between - a / g , a / g
set y to ( y modulo t + t ) mod t
set cnt = c * y + d
print cnt and new line
a = int array of size 277
s = string
read s
for i = 0 to size of s increment a [ s [ i ] ]
an = int with an = 0
set an to max of 0 , ( a [ ' n ' ] - 3 ) / 2 + ( a [ ' n ' ] > = 3 )
set an to min of an , a [ ' t ' ]
set an to min of an , a [ ' e ' ] / 3
set an to min of an , a [ ' i ' ]
print an
n , s , cur = int with cur = 101
read n then s
for i = 0 to n
x , y = int
read x then y
if x < s
if y is 0 set y to 100
set cur to min of cur , y
if x is s
if y is 0 set cur to min of cur , 100
print 100 - cur
declare integer arrays dx = { 1 , 0 , - 1 , 0 } , dy = { 0 , 1 , 0 , - 1 }
declare long longs n , d
read n and d
declare long long array a size n
for i = 0 to n exclusive , read a [ i ]
declare long long ans = 0
for i = 0 to n exclusive
declare integer u = ( first element between a and a + n comparing greater than a [ i ] + d ) - a
let u be u - i - 1
if u is greater than or equal to 2 , let ans be ans + ( long long casted u * ( u - 1 ) ) / 2
print ans and newline
a_i , b_i , n , temp , cont , p1 , p2 = integers with cont = 0
read n
v = vector of integer with v = n
for a_i = 0 to n exclusive , read v [ a_i ]
sort v . begin ( ) and v . end ( )
p1 = p2 = 0
while ( p2 < n )
while ( p2 < n )
if ( v [ p2 ] > v [ p1 ] )
increment cont
break loop
incremnet p2
increment p1
increment p2
print cont
mymap = map from string to integer
mymap [ " C " ] = 1
mymap [ " C # " ] = 2
mymap [ " D " ] = 3
let mymap [ " D # " ] = 4
let mymap [ " E " ] = 5
let mymap [ " F " ] = 6
let mymap [ " F # " ] = 7
let mymap [ " G " ] = 8
let mymap [ " G # " ] = 9
mymap [ " A " ] = 10
mymap [ " B " ] = 11
mymap [ " H " ] = 12
let s1 , s2 , s3 be strings
read n1 , n2 , n3
let n1 , n2 , n3 be integers
let n1 = mymap [ s1 ]
let n2 = mymap [ s2 ]
let n3 = mymap [ s3 ]
a1 , a2 be boolean values equals to 0
let k1 , k2 be integers
k1 = n2 - n1
if k1 is less than 0 , increase k1 by 12
k2 = n3 - n2
if k2 is less than 0 , increase k2 by 12
if k1 = 4 and k2 = 3 , a1 equals 1
if k1 = 3 and k2 = 4 , a2 equals 1
k1 = n3 - n1
if k1 is less than 0 , increase k1 by 12
k2 = n2 - n3
if k2 is less than 0 , increase k2 by 12
if k1 = 4 and k2 = 3 , a1 equals 1
if k1 = 3 and k2 = 4 , a2 equals 1
k1 = n1 - n2
if k1 is less than 0 , increase k1 by 12
k2 = n3 - n1
if k2 is less than 0 , increase k2 by 12
if k1 = 4 and k2 = 3 , a1 equals 1
if k1 = 3 and k2 = 4 , a2 equals 1
k1 = n3 - n2
if k1 is less than 0 , increase k1 by 12
k2 = n1 - n3
if k2 is less than 0 , increase k2 by 12
if k1 = 4 and k2 = 3 , a1 equals 1
if k1 = 3 and k2 = 4 , a2 equals 1
k1 = n1 - n3
if k1 is less than 0 , increase k1 by 12
k2 = n2 - n1
if k2 is less than 0 , increase k2 by 12
if k1 = 4 and k2 = 3 , a1 equals 1
if k1 = 3 and k2 = 4 , a2 equals 1
k1 = n2 - n3
if k1 is less than 0 , increase k1 by 12
k2 = n1 - n2
if k2 is less than 0 , increase k2 by 12
if k1 = 4 and k2 = 3 , a1 equals 1
if k1 = 3 and k2 = 4 , a2 equals 1
if a1 is true
print major and endline
else if a2 is true
print minor and endline
else
print strange and endline
n = int
read n
a = char array of size 500
read a
count_zero = int with count_zero = 0
for i = 0 to n
x = char with x = a [ i ]
if x is ' 0 ' increment count_zero
if a [ 0 ] is ' 0 '
print 0
print 1
for i = 0 to count_zero print 0
print newline
let a , b , c , d be double values
read a , b , c , d
if b - a is equal to c - b and c - b is equal to d - c
print d + ( d - c ) and newline
else if b / a is equal to c / b and c / b is equal to d / c
if d * ( d / c ) is equal to int ( d * ( d / c ) )
print d * ( d / c ) and newline
print 42 and newline
print 42 and newline
let a , b , c , d = integers
read a , b , c , d
if gcd of a and c is not equal to 1 and b modulo gcd of a and c is not equal to d modulo gcd of a and c
print - 1
while b is not equal to d do the following
if b is less than d
set b = b + a
else
set d = d + c
print b
create constant integer M = 50 + 5
x , t , a , b , da , db = integers
read x , t , a , b , da , db
create boolean ok = false
for i = 0 to t - 1 inclusive
for j = 0 to t - 1 inclusive
create integer tsum = a - da * i + b - db * j
if tsum is equal to x then assign true to ok
for i = 0 to t - 1 inclusive
create integer tsum = a - da * i
if tsum is equal to x then set ok to true
for i = 0 to t - 1 inclusive
create integer tsum = b - db * i
if tsum is equal to x then set ok to true
if x is equal to 0 then assign true to ok
create integer string = YES if ok is true else string = NO
print ans and new line
declare const long long MOD = 1000000007
create const long double EPS = 1e - 8
declare integer n
read n
create int vector mas with n elements
for i from 0 to n exclusive , read mas [ i ]
create int vector ans with 1 element = 0
declare int variable bad = 0
for i from 0 to n exclusive
if mas [ i ] is less than 0 , increment bad by one
if bad > = 3
push 1 into ans
assign 1 to bad
else
increment ans [ ans . size ( ) - 1 ]
print length of ans
for integer i = 0 to length of ans exclusive
if i is true , print ' '
print ans [ i ]
print new line
define function find which takes in integers x and array of strings father
return x if father [ x ] is equal to x
set father to find of father [ x ] and father and return father [ x ]
declare integers n and k
read k and k
create string s
read s
create integer pos set to n
for i = 1 to n exclusive
declare and set integers j to i and k to 0
iterate while s [ j ] = = s [ k ] and j < n
increment j
set k to k + 1
if j and n are equal
assign i to pos
terminate loop
print s
decrement k
for k iterations print s . substr ( n - pos )
print a newline
in int function quick that takes int a and int b
s = 1 = int
while b is positive
if b is odd then set s to s * a mod 10
set a to a mod 10
set b to bitwise right shift 1 mod 10
return s
n = int
read n
print the result of quick with args 8 and n
s , u are strings
read s , u
m is an integer set to length of u
for i = 0 to m exclusive , assign the character . + s + the character . to s
mini and cur are integers with mini set to m , cur set to 0
for i = 0 to ( length of s ) - ( length of u ) + 1 exclusive
assign 0 to cur
for j = 0 to length of u exclusive
if s [ i + j ] is unequal to u [ j ] , increment cur
set mini to call min with mini , cur
print mini
maxl is a constant integer set to 2e5 + 10
la , lb are integers
s and t are both character arrays both with size maxl
read la , lb , s , t
tar is an integer set to - 1
for i = 0 to la exclusive
if s [ i ] equals the character * , assign i to tar
if tar equals - 1
if la isn ' t lb
display NO
for i = 0 to la exclusive
if s [ i ] isn ' t t [ i ]
display NO
display YES
if la - 1 is greater than lb
display NO
for i = 0 to tar exclusive
if s [ i ] isn ' t t [ i ]
display NO
for i = 0 as long as la - i - 1 is greater than tar with increment i
if s [ la - i - 1 ] isn ' t t [ lb - i - 1 ]
display NO
display YES
define ints y , n , ans and maxi and arrays org and req with 26 elements each
function ansr with int arguments l and r that returns integer
if l > = r , return l
declare new integer mid with value l + ( r - l ) / 2
create new integer called o = 0
for i from 0 to 26 exclusive
if org [ i ] ! = 0
change o to o + org [ i ] / mid
if org [ i ] % mid is not 0 , change o to o + 1
if o is greater than n
return the result of ansr ( mid + 1 , r )
else
return the result of ansr ( l , mid )
s is a new array of characters with size 1003
read s
read standard input to n
start for loop from i = 0 to ' \ 0 ' exclusive , , adding 1 to org [ s [ i ] - 97 ] on each loop
for integer i = 0 to 26 exclusive incrementing i
if org [ i ] ! = 0
increment y
set req [ i ] to 1
if maxi is less than org [ i ] , change the value of maxi to org [ i ]
if y is greater than n
print " - 1 \ n "
else
change ans to ansr of 1 and maxi
create new ints o and suma = 0
start for loop from i = 0 to 26 exclusive
if org [ i ] ! = 0
set o to 0
increase o by org [ i ] / ans
if org [ i ] % ans ! = 0 , change o to o + 1
set the value of req [ i ] to o
change suma to suma + o
print ans
for i = 0 to 26 exclusive
while req [ i ] is not 0 , decrement it and print i + 97 converted to char
if suma is less than n
in a for loop , change i from 1 to n - suma inclusive , print ' a ' on each iteration
print new line to the standard output
declare new constant integer MAX_N with value 1000 + 10
declare 3d array of integers a with size MAX_N by 2 by 2 , and b with size 4 by 2 by 2
check is a new array of booleans with MAX_N elements
boolean function hast with int arguments i and s
change the value of b [ 0 ] [ 0 ] [ 0 ] to a [ i ] [ 0 ] [ 0 ]
assign a [ i ] [ 0 ] [ 1 ] to b [ 0 ] [ 0 ] [ 1 ]
change b [ 0 ] [ 1 ] [ 0 ] to a [ i ] [ 1 ] [ 0 ]
set the value of b [ 0 ] [ 1 ] [ 1 ] to a [ i ] [ 1 ] [ 1 ]
set the value of b [ 1 ] [ 0 ] [ 0 ] to a [ i ] [ 1 ] [ 0 ]
assign the new value = a [ i ] [ 0 ] [ 0 ] to b [ 1 ] [ 0 ] [ 1 ]
assign the new value = a [ i ] [ 1 ] [ 1 ] to b [ 1 ] [ 1 ] [ 0 ]
change the value of b [ 1 ] [ 1 ] [ 1 ] to a [ i ] [ 0 ] [ 1 ]
change b [ 2 ] [ 0 ] [ 0 ] to a [ i ] [ 1 ] [ 1 ]
set b [ 2 ] [ 0 ] [ 1 ] to a [ i ] [ 1 ] [ 0 ]
change the value of b [ 2 ] [ 1 ] [ 0 ] to a [ i ] [ 0 ] [ 1 ]
change the value of b [ 2 ] [ 1 ] [ 1 ] to a [ i ] [ 0 ] [ 0 ]
change b [ 3 ] [ 0 ] [ 0 ] to a [ i ] [ 0 ] [ 1 ]
change the value of b [ 3 ] [ 0 ] [ 1 ] to a [ i ] [ 1 ] [ 1 ]
assign the new value = a [ i ] [ 0 ] [ 0 ] to b [ 3 ] [ 1 ] [ 0 ]
set b [ 3 ] [ 1 ] [ 1 ] to a [ i ] [ 1 ] [ 0 ]
start for loop from i = 0 to 4 exclusive
declare integer variable x with value 0
start for loop from j = 0 to 2 exclusive incrementing j
start for loop from t = 0 to 2 exclusive
increment x if b [ i ] [ j ] [ t ] = a [ s ] [ j ] [ t ]
if x is equal to 4 , return true
return false
define integers n , aa , bb and ans where ans = 0
create new string called s
read variable n from the input
for i from 0 to n exclusive
read standard input to aa and bb
if i is less than n - 1 , read s
set a [ i ] [ 0 ] [ 0 ] to aa / 10
assign aa modulo 10 to a [ i ] [ 0 ] [ 1 ]
set the value of a [ i ] [ 1 ] [ 0 ] to bb / 10
set the value of a [ i ] [ 1 ] [ 1 ] to bb modulo 10
start for loop from i = 0 to n exclusive incrementing i
if check [ i ] is true , skip the rest of the loop
in a for loop , change j from i + 1 to n exclusive
if hast ( i , j ) returned true , change the value of check [ j ] to true
for i from 0 to n exclusive
if check [ i ] is false , increment ans
print ans
create constant integer N with N = 150005
create integer vector array g with size N
create integers n , m
create integer vector p
declare bfs with integer s as argument , returning pair of long long , long long
set p [ s ] to s
create integer queue q
add s to end of q
create long long ver with ver = 0
create long long cnted with cnted = 0
while q is not empty
create integer v with v = front of q
remove next element of q
increment ver
for i = 0 to size of g [ v ] exclusive
create integer to with to = g [ v ] [ i ]
increment cnted
if p [ to ] is - 1
set p [ to ] to v
add element to to end of q
return new pair created with ( ver , cnted / 2 )
read n read m
set p to vector integer initialized with ( n , - 1 )
for i = 0 to m exclusive
create integers x , y
read x read y
decrement x
decrement y
add element y to end of g [ x ]
add element x to end of g [ y ]
for i = 0 to n exclusive
if p [ i ] is - 1
create pair of long long , long long t with t = result of run bfs with i as argument
if ( first element of t * ( first element of t - 1 ) ) / 2 is not second element of t
print " NO " print newline
print " YES " print newline
